(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@sqlite.org/sqlite-wasm/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sqlite3Worker1Promiser: () => (/* binding */ sqlite3Worker1Promiser)
/* harmony export */ });
/* harmony import */ var _sqlite_wasm_jswasm_sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs */ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs");
/* harmony import */ var _sqlite_wasm_jswasm_sqlite3_worker1_promiser_bundler_friendly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sqlite-wasm/jswasm/sqlite3-worker1-promiser-bundler-friendly.js */ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser-bundler-friendly.js");



const sqlite3Worker1Promiser = self.sqlite3Worker1Promiser;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_sqlite_wasm_jswasm_sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 ** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.
 **
 ** This bundle (typically released as sqlite3.js or sqlite3.mjs)
 ** is an amalgamation of JavaScript source code from two projects:
 **
 ** 1) https://emscripten.org: the Emscripten "glue code" is covered by
 **    the terms of the MIT license and University of Illinois/NCSA
 **    Open Source License, as described at:
 **
 **    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html
 **
 ** 2) https://sqlite.org: all code and documentation labeled as being
 **    from this source are released under the same terms as the sqlite3
 **    C library:
 **
 ** 2022-10-16
 **
 ** The author disclaims copyright to this source code.  In place of a
 ** legal notice, here is a blessing:
 **
 ** *   May you do good and not evil.
 ** *   May you find forgiveness for yourself and forgive others.
 ** *   May you share freely, never taking more than you give.
 */
/*
 ** This code was built from sqlite3 version...
 **
 ** SQLITE_VERSION "3.45.3"
 ** SQLITE_VERSION_NUMBER 3045003
 ** SQLITE_SOURCE_ID "2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355"
 **
 ** Using the Emscripten SDK version 3.1.30.
 */

var sqlite3InitModule = (() => {
  var _scriptDir = "file:///home/runner/work/SQLite-Sample/SQLite-Sample/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs";

  return function (config) {
    var sqlite3InitModule = config || {};

    var Module =
      typeof sqlite3InitModule != 'undefined' ? sqlite3InitModule : {};

    var readyPromiseResolve, readyPromiseReject;
    Module['ready'] = new Promise(function (resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });

    const sqlite3InitModuleState =
      globalThis.sqlite3InitModuleState ||
      Object.assign(Object.create(null), {
        debugModule: () => {},
      });
    delete globalThis.sqlite3InitModuleState;
    sqlite3InitModuleState.debugModule(
      'globalThis.location =',
      globalThis.location,
    );

    const xNameOfInstantiateWasm =  false
      ? 0
      : 'emscripten-bug-17951';
    Module[xNameOfInstantiateWasm] = function callee(imports, onSuccess) {
      imports.env.foo = function () {};
      const uri = Module.locateFile(
        callee.uri,
        'undefined' === typeof scriptDirectory ? '' : scriptDirectory,
      );
      sqlite3InitModuleState.debugModule('instantiateWasm() uri =', uri);
      const wfetch = () => fetch(uri, { credentials: 'same-origin' });
      const loadWasm = WebAssembly.instantiateStreaming
        ? async () => {
            return WebAssembly.instantiateStreaming(wfetch(), imports).then(
              (arg) => onSuccess(arg.instance, arg.module),
            );
          }
        : async () => {
            return wfetch()
              .then((response) => response.arrayBuffer())
              .then((bytes) => WebAssembly.instantiate(bytes, imports))
              .then((arg) => onSuccess(arg.instance, arg.module));
          };
      loadWasm();
      return {};
    };

    Module[xNameOfInstantiateWasm].uri = 'sqlite3.wasm';

    var moduleOverrides = Object.assign({}, Module);

    var arguments_ = [];
    var thisProgram = './this.program';
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };

    var ENVIRONMENT_IS_WEB = typeof window == 'object';
    var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';

    var ENVIRONMENT_IS_NODE =
      typeof process == 'object' &&
      typeof process.versions == 'object' &&
      typeof process.versions.node == 'string';
    var ENVIRONMENT_IS_SHELL =
      !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

    var scriptDirectory = '';
    function locateFile(path) {
      if (Module['locateFile']) {
        return Module['locateFile'](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }

    var read_, readAsync, readBinary, setWindowTitle;

    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != 'undefined' && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }

      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }

      if (scriptDirectory.indexOf('blob:') !== 0) {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,
        );
      } else {
        scriptDirectory = '';
      }

      {
        read_ = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.send(null);
          return xhr.responseText;
        };

        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            xhr.responseType = 'arraybuffer';
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }

        readAsync = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = () => {
            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }

      setWindowTitle = (title) => (document.title = title);
    } else {
    }

    var out = Module['print'] || console.log.bind(console);
    var err = Module['printErr'] || console.warn.bind(console);

    Object.assign(Module, moduleOverrides);

    moduleOverrides = null;

    if (Module['arguments']) arguments_ = Module['arguments'];

    if (Module['thisProgram']) thisProgram = Module['thisProgram'];

    if (Module['quit']) quit_ = Module['quit'];

    var STACK_ALIGN = 16;
    var POINTER_SIZE = 4;

    function getNativeTypeSize(type) {
      switch (type) {
        case 'i1':
        case 'i8':
        case 'u8':
          return 1;
        case 'i16':
        case 'u16':
          return 2;
        case 'i32':
        case 'u32':
          return 4;
        case 'i64':
        case 'u64':
          return 8;
        case 'float':
          return 4;
        case 'double':
          return 8;
        default: {
          if (type[type.length - 1] === '*') {
            return POINTER_SIZE;
          }
          if (type[0] === 'i') {
            const bits = Number(type.substr(1));
            assert(
              bits % 8 === 0,
              'getNativeTypeSize invalid bits ' + bits + ', type ' + type,
            );
            return bits / 8;
          }
          return 0;
        }
      }
    }

    var wasmBinary;
    if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
    var noExitRuntime = Module['noExitRuntime'] || true;

    if (typeof WebAssembly != 'object') {
      abort('no native wasm support detected');
    }

    var wasmMemory;

    var ABORT = false;

    var EXITSTATUS;

    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }

    var UTF8Decoder =
      typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;

      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';

      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xe0) == 0xc0) {
          str += String.fromCharCode(((u0 & 31) << 6) | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xf0) == 0xe0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          u0 =
            ((u0 & 7) << 18) |
            (u1 << 12) |
            (u2 << 6) |
            (heapOrArray[idx++] & 63);
        }

        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(
            0xd800 | (ch >> 10),
            0xdc00 | (ch & 0x3ff),
          );
        }
      }
      return str;
    }

    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
    }

    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0)) return 0;

      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 0xd800 && u <= 0xdfff) {
          var u1 = str.charCodeAt(++i);
          u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);
        }
        if (u <= 0x7f) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7ff) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xc0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xffff) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xe0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 0xf0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        }
      }

      heap[outIdx] = 0;
      return outIdx - startIdx;
    }

    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }

    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 0x7f) {
          len++;
        } else if (c <= 0x7ff) {
          len += 2;
        } else if (c >= 0xd800 && c <= 0xdfff) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    }

    var HEAP,
      HEAP8,
      HEAPU8,
      HEAP16,
      HEAPU16,
      HEAP32,
      HEAPU32,
      HEAPF32,
      HEAP64,
      HEAPU64,
      HEAPF64;

    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module['HEAP8'] = HEAP8 = new Int8Array(b);
      Module['HEAP16'] = HEAP16 = new Int16Array(b);
      Module['HEAP32'] = HEAP32 = new Int32Array(b);
      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
      Module['HEAP64'] = HEAP64 = new BigInt64Array(b);
      Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);
    }

    var STACK_SIZE = 524288;

    var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;

    if (Module['wasmMemory']) {
      wasmMemory = Module['wasmMemory'];
    } else {
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_MEMORY / 65536,

        maximum: 2147483648 / 65536,
      });
    }

    updateMemoryViews();

    INITIAL_MEMORY = wasmMemory.buffer.byteLength;

    var wasmTable;

    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATEXIT__ = [];
    var __ATPOSTRUN__ = [];

    var runtimeInitialized = false;

    function keepRuntimeAlive() {
      return noExitRuntime;
    }

    function preRun() {
      if (Module['preRun']) {
        if (typeof Module['preRun'] == 'function')
          Module['preRun'] = [Module['preRun']];
        while (Module['preRun'].length) {
          addOnPreRun(Module['preRun'].shift());
        }
      }

      callRuntimeCallbacks(__ATPRERUN__);
    }

    function initRuntime() {
      runtimeInitialized = true;

      if (!Module['noFSInit'] && !FS.init.initialized) FS.init();
      FS.ignorePermissions = false;

      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }

    function postRun() {
      if (Module['postRun']) {
        if (typeof Module['postRun'] == 'function')
          Module['postRun'] = [Module['postRun']];
        while (Module['postRun'].length) {
          addOnPostRun(Module['postRun'].shift());
        }
      }

      callRuntimeCallbacks(__ATPOSTRUN__);
    }

    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }

    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }

    function addOnExit(cb) {}

    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }

    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;

    function getUniqueRunDependency(id) {
      return id;
    }

    function addRunDependency(id) {
      runDependencies++;

      if (Module['monitorRunDependencies']) {
        Module['monitorRunDependencies'](runDependencies);
      }
    }

    function removeRunDependency(id) {
      runDependencies--;

      if (Module['monitorRunDependencies']) {
        Module['monitorRunDependencies'](runDependencies);
      }

      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }

    function abort(what) {
      if (Module['onAbort']) {
        Module['onAbort'](what);
      }

      what = 'Aborted(' + what + ')';

      err(what);

      ABORT = true;
      EXITSTATUS = 1;

      what += '. Build with -sASSERTIONS for more info.';

      var e = new WebAssembly.RuntimeError(what);

      readyPromiseReject(e);

      throw e;
    }

    var dataURIPrefix = 'data:application/octet-stream;base64,';

    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }

    function isFileURI(filename) {
      return filename.startsWith('file://');
    }

    var wasmBinaryFile;
    if (Module['locateFile']) {
      wasmBinaryFile = 'sqlite3.wasm';
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
    } else {
      wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! sqlite3.wasm */ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm"), __webpack_require__.b).href;
    }

    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw 'both async and sync fetching of the wasm failed';
      } catch (err) {
        abort(err);
      }
    }

    function getBinaryPromise() {
      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
        if (typeof fetch == 'function') {
          return fetch(wasmBinaryFile, { credentials: 'same-origin' })
            .then(function (response) {
              if (!response['ok']) {
                throw (
                  "failed to load wasm binary file at '" + wasmBinaryFile + "'"
                );
              }
              return response['arrayBuffer']();
            })
            .catch(function () {
              return getBinary(wasmBinaryFile);
            });
        }
      }

      return Promise.resolve().then(function () {
        return getBinary(wasmBinaryFile);
      });
    }

    function createWasm() {
      var info = {
        env: asmLibraryArg,
        wasi_snapshot_preview1: asmLibraryArg,
      };

      function receiveInstance(instance, module) {
        var exports = instance.exports;

        Module['asm'] = exports;

        wasmTable = Module['asm']['__indirect_function_table'];

        addOnInit(Module['asm']['__wasm_call_ctors']);

        removeRunDependency('wasm-instantiate');
      }

      addRunDependency('wasm-instantiate');

      function receiveInstantiationResult(result) {
        receiveInstance(result['instance']);
      }

      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise()
          .then(function (binary) {
            return WebAssembly.instantiate(binary, info);
          })
          .then(function (instance) {
            return instance;
          })
          .then(receiver, function (reason) {
            err('failed to asynchronously prepare wasm: ' + reason);

            abort(reason);
          });
      }

      function instantiateAsync() {
        if (
          !wasmBinary &&
          typeof WebAssembly.instantiateStreaming == 'function' &&
          !isDataURI(wasmBinaryFile) &&
          typeof fetch == 'function'
        ) {
          return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(
            function (response) {
              var result = WebAssembly.instantiateStreaming(response, info);

              return result.then(receiveInstantiationResult, function (reason) {
                err('wasm streaming compile failed: ' + reason);
                err('falling back to ArrayBuffer instantiation');
                return instantiateArrayBuffer(receiveInstantiationResult);
              });
            },
          );
        } else {
          return instantiateArrayBuffer(receiveInstantiationResult);
        }
      }

      if (Module['instantiateWasm']) {
        try {
          var exports = Module['instantiateWasm'](info, receiveInstance);
          return exports;
        } catch (e) {
          err('Module.instantiateWasm callback failed with error: ' + e);

          readyPromiseReject(e);
        }
      }

      instantiateAsync().catch(readyPromiseReject);
      return {};
    }

    var tempDouble;
    var tempI64;

    var ASM_CONSTS = {};

    function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = 'Program terminated with exit(' + status + ')';
      this.status = status;
    }

    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }

    function getValue(ptr, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1':
          return HEAP8[ptr >> 0];
        case 'i8':
          return HEAP8[ptr >> 0];
        case 'i16':
          return HEAP16[ptr >> 1];
        case 'i32':
          return HEAP32[ptr >> 2];
        case 'i64':
          return HEAP64[ptr >> 3];
        case 'float':
          return HEAPF32[ptr >> 2];
        case 'double':
          return HEAPF64[ptr >> 3];
        case '*':
          return HEAPU32[ptr >> 2];
        default:
          abort('invalid type for getValue: ' + type);
      }
      return null;
    }

    function setValue(ptr, value, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1':
          HEAP8[ptr >> 0] = value;
          break;
        case 'i8':
          HEAP8[ptr >> 0] = value;
          break;
        case 'i16':
          HEAP16[ptr >> 1] = value;
          break;
        case 'i32':
          HEAP32[ptr >> 2] = value;
          break;
        case 'i64':
          (tempI64 = [
            value >>> 0,
            ((tempDouble = value),
            +Math.abs(tempDouble) >= 1.0
              ? tempDouble > 0.0
                ? (Math.min(
                    +Math.floor(tempDouble / 4294967296.0),
                    4294967295.0,
                  ) |
                    0) >>>
                  0
                : ~~+Math.ceil(
                    (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                  ) >>> 0
              : 0),
          ]),
            (HEAP32[ptr >> 2] = tempI64[0]),
            (HEAP32[(ptr + 4) >> 2] = tempI64[1]);
          break;
        case 'float':
          HEAPF32[ptr >> 2] = value;
          break;
        case 'double':
          HEAPF64[ptr >> 3] = value;
          break;
        case '*':
          HEAPU32[ptr >> 2] = value;
          break;
        default:
          abort('invalid type for setValue: ' + type);
      }
    }

    var PATH = {
      isAbs: (path) => path.charAt(0) === '/',
      splitPath: (filename) => {
        var splitPathRe =
          /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts, allowAboveRoot) => {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }

        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },
      normalize: (path) => {
        var isAbsolute = PATH.isAbs(path),
          trailingSlash = path.substr(-1) === '/';

        path = PATH.normalizeArray(
          path.split('/').filter((p) => !!p),
          !isAbsolute,
        ).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },
      dirname: (path) => {
        var result = PATH.splitPath(path),
          root = result[0],
          dir = result[1];
        if (!root && !dir) {
          return '.';
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path) => {
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, '');
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash + 1);
      },
      join: function () {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join('/'));
      },
      join2: (l, r) => {
        return PATH.normalize(l + '/' + r);
      },
    };

    function getRandomDevice() {
      if (
        typeof crypto == 'object' &&
        typeof crypto['getRandomValues'] == 'function'
      ) {
        var randomBuffer = new Uint8Array(1);
        return () => {
          crypto.getRandomValues(randomBuffer);
          return randomBuffer[0];
        };
      } else return () => abort('randomDevice');
    }

    var PATH_FS = {
      resolve: function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : FS.cwd();

          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return '';
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }

        resolvedPath = PATH.normalizeArray(
          resolvedPath.split('/').filter((p) => !!p),
          !resolvedAbsolute,
        ).join('/');
        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
      },
      relative: (from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      },
    };

    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(
        stringy,
        u8array,
        0,
        u8array.length,
      );
      if (dontAddNull) u8array.length = numBytesWritten;
      return u8array;
    }
    var TTY = {
      ttys: [],
      init: function () {},
      shutdown: function () {},
      register: function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close: function (stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        fsync: function (stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        read: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        },
      },
      default_tty_ops: {
        get_char: function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (
              typeof window != 'undefined' &&
              typeof window.prompt == 'function'
            ) {
              result = window.prompt('Input: ');
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        fsync: function (tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
      default_tty1_ops: {
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        fsync: function (tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
    };

    function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
      return address;
    }

    function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
    function mmapAlloc(size) {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      return zeroMemory(ptr, size);
    }
    var MEMFS = {
      ops_table: null,
      mount: function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511, 0);
      },
      createNode: function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink,
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
              },
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync,
              },
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink,
              },
              stream: {},
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
              },
              stream: FS.chrdev_stream_ops,
            },
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;

          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();

        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray: function (node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage: function (node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return;

        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(
          newCapacity,
          (prevCapacity *
            (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>>
            0,
        );
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage: function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(
              oldContents.subarray(0, Math.min(newSize, node.usedBytes)),
            );
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr: function (node) {
          var attr = {};

          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);

          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr: function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function (parent, name) {
          throw FS.genericErrors[44];
        },
        mknod: function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename: function (old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {}
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }

          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },
        unlink: function (parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        rmdir: function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        readdir: function (node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },
        symlink: function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink: function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        },
      },
      stream_ops: {
        read: function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer[offset + i] = contents[position + i];
          }
          return size;
        },
        write: function (stream, buffer, offset, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }

          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();

          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(
                buffer.subarray(offset, offset + length),
                position,
              );
              return length;
            }
          }

          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position,
            );
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek: function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate: function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(
            stream.node.usedBytes,
            offset + length,
          );
        },
        mmap: function (stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;

          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length,
                );
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },
        msync: function (stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);

          return 0;
        },
      },
    };

    function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(
        url,
        (arrayBuffer) => {
          assert(
            arrayBuffer,
            'Loading data file "' + url + '" failed (no arrayBuffer).',
          );
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency(dep);
        },
        (event) => {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        },
      );
      if (dep) addRunDependency(dep);
    }

    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: '/',
      initialized: false,
      ignorePermissions: true,
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      lookupPath: (path, opts = {}) => {
        path = PATH_FS.resolve(path);

        if (!path) return { path: '', node: null };

        var defaults = {
          follow_mount: true,
          recurse_count: 0,
        };
        opts = Object.assign(defaults, opts);

        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }

        var parts = path.split('/').filter((p) => !!p);

        var current = FS.root;
        var current_path = '/';

        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }

          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);

          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }

          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);

              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count + 1,
              });
              current = lookup.node;

              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }

        return { path: current_path, node: current };
      },
      getPath: (node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length - 1] !== '/'
              ? mount + '/' + path
              : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },
      hashName: (parentid, name) => {
        var hash = 0;

        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },
      hashAddNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode: (parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }

        return FS.lookup(parent, name);
      },
      createNode: (parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);

        FS.hashAddNode(node);

        return node;
      },
      destroyNode: (node) => {
        FS.hashRemoveNode(node);
      },
      isRoot: (node) => {
        return node === node.parent;
      },
      isMountpoint: (node) => {
        return !!node.mounted;
      },
      isFile: (mode) => {
        return (mode & 61440) === 32768;
      },
      isDir: (mode) => {
        return (mode & 61440) === 16384;
      },
      isLink: (mode) => {
        return (mode & 61440) === 40960;
      },
      isChrdev: (mode) => {
        return (mode & 61440) === 8192;
      },
      isBlkdev: (mode) => {
        return (mode & 61440) === 24576;
      },
      isFIFO: (mode) => {
        return (mode & 61440) === 4096;
      },
      isSocket: (mode) => {
        return (mode & 49152) === 49152;
      },
      flagModes: { r: 0, 'r+': 2, w: 577, 'w+': 578, a: 1089, 'a+': 1090 },
      modeStringToFlags: (str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },
      flagsToPermissionString: (flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if (flag & 512) {
          perms += 'w';
        }
        return perms;
      },
      nodePermissions: (node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }

        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup: (dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
      mayCreate: (dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {}
        return FS.nodePermissions(dir, 'wx');
      },
      mayDelete: (dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen: (node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStream: (fd) => FS.streams[fd],
      createStream: (stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = function () {
            this.shared = {};
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function () {
                return this.node;
              },

              set: function (val) {
                this.node = val;
              },
            },
            isRead: {
              get: function () {
                return (this.flags & 2097155) !== 1;
              },
            },
            isWrite: {
              get: function () {
                return (this.flags & 2097155) !== 0;
              },
            },
            isAppend: {
              get: function () {
                return this.flags & 1024;
              },
            },
            flags: {
              get: function () {
                return this.shared.flags;
              },

              set: function (val) {
                this.shared.flags = val;
              },
            },
            position: {
              get: function () {
                return this.shared.position;
              },

              set: function (val) {
                this.shared.position = val;
              },
            },
          });
        }

        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream: (fd) => {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: (stream) => {
          var device = FS.getDevice(stream.node.rdev);

          stream.stream_ops = device.stream_ops;

          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: () => {
          throw new FS.ErrnoError(70);
        },
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 0xff,
      makedev: (ma, mi) => (ma << 8) | mi,
      registerDevice: (dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts: (mount) => {
        var mounts = [];
        var check = [mount];

        while (check.length) {
          var m = check.pop();

          mounts.push(m);

          check.push.apply(check, m.mounts);
        }

        return mounts;
      },
      syncfs: (populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }

        FS.syncFSRequests++;

        if (FS.syncFSRequests > 1) {
          err(
            'warning: ' +
              FS.syncFSRequests +
              ' FS.syncfs operations in flight at once, probably just doing extra work',
          );
        }

        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;

        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }

        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }

        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: (type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;

        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

          mountpoint = lookup.path;
          node = lookup.node;

          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }

          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }

        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: [],
        };

        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;

        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;

          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }

        return mountRoot;
      },
      unmount: (mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }

        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);

        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];

          while (current) {
            var next = current.name_next;

            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }

            current = next;
          }
        });

        node.mounted = null;

        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: (parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },
      mknod: (path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create: (path, mode) => {
        mode = mode !== undefined ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
      mkdir: (path, mode) => {
        mode = mode !== undefined ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
      mkdirTree: (path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20) throw e;
          }
        }
      },
      mkdev: (path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
      symlink: (oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename: (old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);

        var lookup, old_dir, new_dir;

        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;

        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);

        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }

        var old_node = FS.lookupNode(old_dir, old_name);

        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }

        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }

        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {}

        if (old_node === new_node) {
          return;
        }

        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        errCode = new_node
          ? FS.mayDelete(new_dir, new_name, isdir)
          : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (
          FS.isMountpoint(old_node) ||
          (new_node && FS.isMountpoint(new_node))
        ) {
          throw new FS.ErrnoError(10);
        }

        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }

        FS.hashRemoveNode(old_node);

        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir: (path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
      readdir: (path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink: (path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
      readlink: (path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(
          FS.getPath(link.parent),
          link.node_ops.readlink(link),
        );
      },
      stat: (path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat: (path) => {
        return FS.stat(path, true);
      },
      chmod: (path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now(),
        });
      },
      lchmod: (path, mode) => {
        FS.chmod(path, mode, true);
      },
      fchmod: (fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },
      chown: (path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now(),
        });
      },
      lchown: (path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },
      fchown: (fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },
      truncate: (path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now(),
        });
      },
      ftruncate: (fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime: (path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime),
        });
      },
      open: (path, flags, mode) => {
        if (path === '') {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 : mode;
        if (flags & 64) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072),
            });
            node = lookup.node;
          } catch (e) {}
        }

        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }

        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }

        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }

        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }

        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }

        flags &= ~(128 | 512 | 131072);

        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,

          ungotten: [],
          error: false,
        });

        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
      close: (stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed: (stream) => {
        return stream.fd === null;
      },
      llseek: (stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read: (stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(
          stream,
          buffer,
          offset,
          length,
          position,
        );
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
      write: (stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(
          stream,
          buffer,
          offset,
          length,
          position,
          canOwn,
        );
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate: (stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap: (stream, length, position, prot, flags) => {
        if (
          (prot & 2) !== 0 &&
          (flags & 2) === 0 &&
          (stream.flags & 2097155) !== 2
        ) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(
          stream,
          buffer,
          offset,
          length,
          mmapFlags,
        );
      },
      munmap: (stream) => 0,
      ioctl: (stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile: (path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile: (path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },
      cwd: () => FS.currentPath,
      chdir: (path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: () => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },
      createDefaultDevices: () => {
        FS.mkdir('/dev');

        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));

        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));

        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);

        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },
      createSpecialDirectories: () => {
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount(
          {
            mount: () => {
              var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73);
              node.node_ops = {
                lookup: (parent, name) => {
                  var fd = +name;
                  var stream = FS.getStream(fd);
                  if (!stream) throw new FS.ErrnoError(8);
                  var ret = {
                    parent: null,
                    mount: { mountpoint: 'fake' },
                    node_ops: { readlink: () => stream.path },
                  };
                  ret.parent = ret;
                  return ret;
                },
              };
              return node;
            },
          },
          {},
          '/proc/self/fd',
        );
      },
      createStandardStreams: () => {
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }

        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },
      ensureErrnoError: () => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function (errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;

        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },
      staticInit: () => {
        FS.ensureErrnoError();

        FS.nameTable = new Array(4096);

        FS.mount(MEMFS, {}, '/');

        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();

        FS.filesystems = {
          MEMFS: MEMFS,
        };
      },
      init: (input, output, error) => {
        FS.init.initialized = true;

        FS.ensureErrnoError();

        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];

        FS.createStandardStreams();
      },
      quit: () => {
        FS.init.initialized = false;

        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      getMode: (canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },
      findObject: (path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath: (path, dontResolveLastLink) => {
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {}
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null,
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        }
        return ret;
      },
      createPath: (parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {}
          parent = current;
        }
        return current;
      },
      createFile: (parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(
          typeof parent == 'string' ? parent : FS.getPath(parent),
          name,
        );
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
      createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i)
              arr[i] = data.charCodeAt(i);
            data = arr;
          }

          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },
      createDevice: (parent, name, input, output) => {
        var path = PATH.join2(
          typeof parent == 'string' ? parent : FS.getPath(parent),
          name,
        );
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);

        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          },
        });
        return FS.mkdev(path, mode, dev);
      },
      forceLoadFile: (obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error(
            'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.',
          );
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },
      createLazyFile: (parent, name, url, canRead, canWrite) => {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize) | 0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter =
          function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
        LazyUint8Array.prototype.cacheLength =
          function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (
              !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
            )
              throw new Error(
                "Couldn't load " + url + '. Status: ' + xhr.status,
              );
            var datalength = Number(xhr.getResponseHeader('Content-length'));
            var header;
            var hasByteServing =
              (header = xhr.getResponseHeader('Accept-Ranges')) &&
              header === 'bytes';
            var usesGzip =
              (header = xhr.getResponseHeader('Content-Encoding')) &&
              header === 'gzip';

            var chunkSize = 1024 * 1024;

            if (!hasByteServing) chunkSize = datalength;

            var doXHR = (from, to) => {
              if (from > to)
                throw new Error(
                  'invalid range (' +
                    from +
                    ', ' +
                    to +
                    ') or no bytes requested!',
                );
              if (to > datalength - 1)
                throw new Error(
                  'only ' + datalength + ' bytes available! programmer error!',
                );

              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize)
                xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);

              xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }

              xhr.send(null);
              if (
                !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
              )
                throw new Error(
                  "Couldn't load " + url + '. Status: ' + xhr.status,
                );
              if (xhr.response !== undefined) {
                return new Uint8Array(xhr.response || []);
              }
              return intArrayFromString(xhr.responseText || '', true);
            };
            var lazyArray = this;
            lazyArray.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray.chunks[chunkNum] == 'undefined')
                throw new Error('doXHR failed!');
              return lazyArray.chunks[chunkNum];
            });

            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out(
                'LazyFiles on gzip forces download of the whole file when length is accessed',
              );
            }

            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER)
            throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              },
            },
            chunkSize: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              },
            },
          });

          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }

        var node = FS.createFile(parent, name, properties, canRead, canWrite);

        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }

        Object.defineProperties(node, {
          usedBytes: {
            get: function () {
              return this.contents.length;
            },
          },
        });

        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length) return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }

        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position);
        };

        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr: ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
      createPreloadedFile: (
        parent,
        name,
        url,
        canRead,
        canWrite,
        onload,
        onerror,
        dontCreateFile,
        canOwn,
        preFinish,
      ) => {
        var fullname = name
          ? PATH_FS.resolve(PATH.join2(parent, name))
          : parent;
        var dep = getUniqueRunDependency('cp ' + fullname);
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(
                parent,
                name,
                byteArray,
                canRead,
                canWrite,
                canOwn,
              );
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (
            Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
              if (onerror) onerror();
              removeRunDependency(dep);
            })
          ) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },
      indexedDB: () => {
        return (
          window.indexedDB ||
          window.mozIndexedDB ||
          window.webkitIndexedDB ||
          window.msIndexedDB
        );
      },
      DB_NAME: () => {
        return 'EM_FS_' + window.location.pathname;
      },
      DB_VERSION: 20,
      DB_STORE_NAME: 'FILE_DATA',
      saveFilesToDB: (paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(
              FS.analyzePath(path).object.contents,
              path,
            );
            putRequest.onsuccess = () => {
              ok++;
              if (ok + fail == total) finish();
            };
            putRequest.onerror = () => {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      loadFilesFromDB: (paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch (e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(
                PATH.dirname(path),
                PATH.basename(path),
                getRequest.result,
                true,
                true,
                true,
              );
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt: function (dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }

        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },
      doStat: function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (
            e &&
            e.node &&
            PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))
          ) {
            return -54;
          }
          throw e;
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[(buf + 8) >> 2] = stat.ino;
        HEAP32[(buf + 12) >> 2] = stat.mode;
        HEAPU32[(buf + 16) >> 2] = stat.nlink;
        HEAP32[(buf + 20) >> 2] = stat.uid;
        HEAP32[(buf + 24) >> 2] = stat.gid;
        HEAP32[(buf + 28) >> 2] = stat.rdev;
        (tempI64 = [
          stat.size >>> 0,
          ((tempDouble = stat.size),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 40) >> 2] = tempI64[0]),
          (HEAP32[(buf + 44) >> 2] = tempI64[1]);
        HEAP32[(buf + 48) >> 2] = 4096;
        HEAP32[(buf + 52) >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        (tempI64 = [
          Math.floor(atime / 1000) >>> 0,
          ((tempDouble = Math.floor(atime / 1000)),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 56) >> 2] = tempI64[0]),
          (HEAP32[(buf + 60) >> 2] = tempI64[1]);
        HEAPU32[(buf + 64) >> 2] = (atime % 1000) * 1000;
        (tempI64 = [
          Math.floor(mtime / 1000) >>> 0,
          ((tempDouble = Math.floor(mtime / 1000)),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 72) >> 2] = tempI64[0]),
          (HEAP32[(buf + 76) >> 2] = tempI64[1]);
        HEAPU32[(buf + 80) >> 2] = (mtime % 1000) * 1000;
        (tempI64 = [
          Math.floor(ctime / 1000) >>> 0,
          ((tempDouble = Math.floor(ctime / 1000)),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 88) >> 2] = tempI64[0]),
          (HEAP32[(buf + 92) >> 2] = tempI64[1]);
        HEAPU32[(buf + 96) >> 2] = (ctime % 1000) * 1000;
        (tempI64 = [
          stat.ino >>> 0,
          ((tempDouble = stat.ino),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 104) >> 2] = tempI64[0]),
          (HEAP32[(buf + 108) >> 2] = tempI64[1]);
        return 0;
      },
      doMsync: function (addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
      varargs: undefined,
      get: function () {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
        return ret;
      },
      getStr: function (ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
      getStreamFromFD: function (fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },
    };
    function ___syscall_chmod(path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        FS.chmod(path, mode);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_faccessat(dirfd, path, amode, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (amode & ~7) {
          return -28;
        }
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_fchmod(fd, mode) {
      try {
        FS.fchmod(fd, mode);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_fchown32(fd, owner, group) {
      try {
        FS.fchown(fd, owner, group);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function setErrNo(value) {
      HEAP32[___errno_location() >> 2] = value;
      return value;
    }

    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = SYSCALLS.get();
            if (arg < 0) {
              return -28;
            }
            var newStream;
            newStream = FS.createStream(stream, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = SYSCALLS.get();
            stream.flags |= arg;
            return 0;
          }
          case 5: {
            var arg = SYSCALLS.get();
            var offset = 0;

            HEAP16[(arg + offset) >> 1] = 2;
            return 0;
          }
          case 6:
          case 7:
            return 0;
          case 16:
          case 8:
            return -28;
          case 9:
            setErrNo(28);
            return -1;
          default: {
            return -28;
          }
        }
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    var MAX_INT53 = 9007199254740992;

    var MIN_INT53 = -9007199254740992;
    function bigintToI53Checked(num) {
      return num < MIN_INT53 || num > MAX_INT53 ? NaN : Number(num);
    }

    function ___syscall_ftruncate64(fd, length) {
      try {
        length = bigintToI53Checked(length);
        if (isNaN(length)) return -61;
        FS.ftruncate(fd, length);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_getcwd(buf, size) {
      try {
        if (size === 0) return -28;
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
        if (size < cwdLengthInBytes) return -68;
        stringToUTF8(cwd, buf, size);
        return cwdLengthInBytes;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509:
          case 21505: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21519: {
            if (!stream.tty) return -59;
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty) return -59;
            return -28;
          }
          case 21531: {
            var argp = SYSCALLS.get();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21524: {
            if (!stream.tty) return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_lstat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.lstat, path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_mkdirat(dirfd, path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);

        path = PATH.normalize(path);
        if (path[path.length - 1] === '/')
          path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_newfstatat(dirfd, path, buf, flags) {
      try {
        path = SYSCALLS.getStr(path);
        var nofollow = flags & 256;
        var allowEmpty = flags & 4096;
        flags = flags & ~6400;
        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_openat(dirfd, path, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        var mode = varargs ? SYSCALLS.get() : 0;
        return FS.open(path, flags, mode).fd;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);

        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);

        HEAP8[buf + len] = endChar;
        return len;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_rmdir(path) {
      try {
        path = SYSCALLS.getStr(path);
        FS.rmdir(path);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_stat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_unlinkat(dirfd, path, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (flags === 0) {
          FS.unlink(path);
        } else if (flags === 512) {
          FS.rmdir(path);
        } else {
          abort('Invalid flags passed to unlinkat');
        }
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function readI53FromI64(ptr) {
      return HEAPU32[ptr >> 2] + HEAP32[(ptr + 4) >> 2] * 4294967296;
    }

    function ___syscall_utimensat(dirfd, path, times, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path, true);
        if (!times) {
          var atime = Date.now();
          var mtime = atime;
        } else {
          var seconds = readI53FromI64(times);
          var nanoseconds = HEAP32[(times + 8) >> 2];
          atime = seconds * 1000 + nanoseconds / (1000 * 1000);
          times += 16;
          seconds = readI53FromI64(times);
          nanoseconds = HEAP32[(times + 8) >> 2];
          mtime = seconds * 1000 + nanoseconds / (1000 * 1000);
        }
        FS.utime(path, atime, mtime);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    var nowIsMonotonic = true;
    function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

    function __isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }

    var __MONTH_DAYS_LEAP_CUMULATIVE = [
      0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335,
    ];

    var __MONTH_DAYS_REGULAR_CUMULATIVE = [
      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
    ];
    function __yday_from_date(date) {
      var isLeapYear = __isLeapYear(date.getFullYear());
      var monthDaysCumulative = isLeapYear
        ? __MONTH_DAYS_LEAP_CUMULATIVE
        : __MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;

      return yday;
    }
    function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time) * 1000);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();
      HEAP32[(tmPtr + 8) >> 2] = date.getHours();
      HEAP32[(tmPtr + 12) >> 2] = date.getDate();
      HEAP32[(tmPtr + 16) >> 2] = date.getMonth();
      HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;
      HEAP32[(tmPtr + 24) >> 2] = date.getDay();

      var yday = __yday_from_date(date) | 0;
      HEAP32[(tmPtr + 28) >> 2] = yday;
      HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);

      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst =
        (summerOffset != winterOffset &&
          date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[(tmPtr + 32) >> 2] = dst;
    }

    function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream, len, off, prot, flags);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr >> 2] = ptr;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function __munmap_js(addr, len, prot, flags, fd, offset) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, flags, offset);
        }
        FS.munmap(stream);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }
    function __tzset_js(timezone, daylight, tzname) {
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();

      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);

      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;

      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);

      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : 'GMT';
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        HEAPU32[tzname >> 2] = winterNamePtr;
        HEAPU32[(tzname + 4) >> 2] = summerNamePtr;
      } else {
        HEAPU32[tzname >> 2] = summerNamePtr;
        HEAPU32[(tzname + 4) >> 2] = winterNamePtr;
      }
    }

    function _emscripten_date_now() {
      return Date.now();
    }

    var _emscripten_get_now;
    _emscripten_get_now = () => performance.now();
    function getHeapMax() {
      return 2147483648;
    }

    function emscripten_realloc_buffer(size) {
      var b = wasmMemory.buffer;
      try {
        wasmMemory.grow((size - b.byteLength + 65535) >>> 16);
        updateMemoryViews();
        return 1;
      } catch (e) {}
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;

      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }

      let alignUp = (x, multiple) =>
        x + ((multiple - (x % multiple)) % multiple);

      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);

        overGrownHeapSize = Math.min(
          overGrownHeapSize,
          requestedSize + 100663296,
        );

        var newSize = Math.min(
          maxHeapSize,
          alignUp(Math.max(requestedSize, overGrownHeapSize), 65536),
        );

        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }

    var ENV = {};

    function getExecutableName() {
      return thisProgram || './this.program';
    }
    function getEnvStrings() {
      if (!getEnvStrings.strings) {
        var lang =
          (
            (typeof navigator == 'object' &&
              navigator.languages &&
              navigator.languages[0]) ||
            'C'
          ).replace('-', '_') + '.UTF-8';
        var env = {
          USER: 'web_user',
          LOGNAME: 'web_user',
          PATH: '/',
          PWD: '/',
          HOME: '/home/web_user',
          LANG: lang,
          _: getExecutableName(),
        };

        for (var x in ENV) {
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }

    function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i);
      }

      if (!dontAddNull) HEAP8[buffer >> 0] = 0;
    }

    function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function (string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(__environ + i * 4) >> 2] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

    function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach(function (string) {
        bufSize += string.length + 1;
      });
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    }

    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function _fd_fdstat_get(fd, pbuf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);

        var type = stream.tty
          ? 2
          : FS.isDir(stream.mode)
            ? 3
            : FS.isLink(stream.mode)
              ? 7
              : 4;
        HEAP8[pbuf >> 0] = type;

        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[(iov + 4) >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }

    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function _fd_seek(fd, offset, whence, newOffset) {
      try {
        offset = bigintToI53Checked(offset);
        if (isNaN(offset)) return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset, whence);
        (tempI64 = [
          stream.position >>> 0,
          ((tempDouble = stream.position),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[newOffset >> 2] = tempI64[0]),
          (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function _fd_sync(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (stream.stream_ops && stream.stream_ops.fsync) {
          return stream.stream_ops.fsync(stream);
        }
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[(iov + 4) >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }

    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    var FSNode = function (parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, {
      read: {
        get: function () {
          return (this.mode & readMode) === readMode;
        },
        set: function (val) {
          val ? (this.mode |= readMode) : (this.mode &= ~readMode);
        },
      },
      write: {
        get: function () {
          return (this.mode & writeMode) === writeMode;
        },
        set: function (val) {
          val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
        },
      },
      isFolder: {
        get: function () {
          return FS.isDir(this.mode);
        },
      },
      isDevice: {
        get: function () {
          return FS.isChrdev(this.mode);
        },
      },
    });
    FS.FSNode = FSNode;
    FS.staticInit();
    var ASSERTIONS = false;

    var asmLibraryArg = {
      __syscall_chmod: ___syscall_chmod,
      __syscall_faccessat: ___syscall_faccessat,
      __syscall_fchmod: ___syscall_fchmod,
      __syscall_fchown32: ___syscall_fchown32,
      __syscall_fcntl64: ___syscall_fcntl64,
      __syscall_fstat64: ___syscall_fstat64,
      __syscall_ftruncate64: ___syscall_ftruncate64,
      __syscall_getcwd: ___syscall_getcwd,
      __syscall_ioctl: ___syscall_ioctl,
      __syscall_lstat64: ___syscall_lstat64,
      __syscall_mkdirat: ___syscall_mkdirat,
      __syscall_newfstatat: ___syscall_newfstatat,
      __syscall_openat: ___syscall_openat,
      __syscall_readlinkat: ___syscall_readlinkat,
      __syscall_rmdir: ___syscall_rmdir,
      __syscall_stat64: ___syscall_stat64,
      __syscall_unlinkat: ___syscall_unlinkat,
      __syscall_utimensat: ___syscall_utimensat,
      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
      _localtime_js: __localtime_js,
      _mmap_js: __mmap_js,
      _munmap_js: __munmap_js,
      _tzset_js: __tzset_js,
      emscripten_date_now: _emscripten_date_now,
      emscripten_get_now: _emscripten_get_now,
      emscripten_resize_heap: _emscripten_resize_heap,
      environ_get: _environ_get,
      environ_sizes_get: _environ_sizes_get,
      fd_close: _fd_close,
      fd_fdstat_get: _fd_fdstat_get,
      fd_read: _fd_read,
      fd_seek: _fd_seek,
      fd_sync: _fd_sync,
      fd_write: _fd_write,
      memory: wasmMemory,
    };
    var asm = createWasm();

    var ___wasm_call_ctors = (Module['___wasm_call_ctors'] = function () {
      return (___wasm_call_ctors = Module['___wasm_call_ctors'] =
        Module['asm']['__wasm_call_ctors']).apply(null, arguments);
    });

    var _sqlite3_status64 = (Module['_sqlite3_status64'] = function () {
      return (_sqlite3_status64 = Module['_sqlite3_status64'] =
        Module['asm']['sqlite3_status64']).apply(null, arguments);
    });

    var _sqlite3_status = (Module['_sqlite3_status'] = function () {
      return (_sqlite3_status = Module['_sqlite3_status'] =
        Module['asm']['sqlite3_status']).apply(null, arguments);
    });

    var _sqlite3_db_status = (Module['_sqlite3_db_status'] = function () {
      return (_sqlite3_db_status = Module['_sqlite3_db_status'] =
        Module['asm']['sqlite3_db_status']).apply(null, arguments);
    });

    var _sqlite3_msize = (Module['_sqlite3_msize'] = function () {
      return (_sqlite3_msize = Module['_sqlite3_msize'] =
        Module['asm']['sqlite3_msize']).apply(null, arguments);
    });

    var _sqlite3_vfs_find = (Module['_sqlite3_vfs_find'] = function () {
      return (_sqlite3_vfs_find = Module['_sqlite3_vfs_find'] =
        Module['asm']['sqlite3_vfs_find']).apply(null, arguments);
    });

    var _sqlite3_initialize = (Module['_sqlite3_initialize'] = function () {
      return (_sqlite3_initialize = Module['_sqlite3_initialize'] =
        Module['asm']['sqlite3_initialize']).apply(null, arguments);
    });

    var _sqlite3_malloc = (Module['_sqlite3_malloc'] = function () {
      return (_sqlite3_malloc = Module['_sqlite3_malloc'] =
        Module['asm']['sqlite3_malloc']).apply(null, arguments);
    });

    var _sqlite3_free = (Module['_sqlite3_free'] = function () {
      return (_sqlite3_free = Module['_sqlite3_free'] =
        Module['asm']['sqlite3_free']).apply(null, arguments);
    });

    var _sqlite3_vfs_register = (Module['_sqlite3_vfs_register'] = function () {
      return (_sqlite3_vfs_register = Module['_sqlite3_vfs_register'] =
        Module['asm']['sqlite3_vfs_register']).apply(null, arguments);
    });

    var _sqlite3_vfs_unregister = (Module['_sqlite3_vfs_unregister'] =
      function () {
        return (_sqlite3_vfs_unregister = Module['_sqlite3_vfs_unregister'] =
          Module['asm']['sqlite3_vfs_unregister']).apply(null, arguments);
      });

    var _sqlite3_malloc64 = (Module['_sqlite3_malloc64'] = function () {
      return (_sqlite3_malloc64 = Module['_sqlite3_malloc64'] =
        Module['asm']['sqlite3_malloc64']).apply(null, arguments);
    });

    var _sqlite3_realloc = (Module['_sqlite3_realloc'] = function () {
      return (_sqlite3_realloc = Module['_sqlite3_realloc'] =
        Module['asm']['sqlite3_realloc']).apply(null, arguments);
    });

    var _sqlite3_realloc64 = (Module['_sqlite3_realloc64'] = function () {
      return (_sqlite3_realloc64 = Module['_sqlite3_realloc64'] =
        Module['asm']['sqlite3_realloc64']).apply(null, arguments);
    });

    var _sqlite3_value_text = (Module['_sqlite3_value_text'] = function () {
      return (_sqlite3_value_text = Module['_sqlite3_value_text'] =
        Module['asm']['sqlite3_value_text']).apply(null, arguments);
    });

    var _sqlite3_randomness = (Module['_sqlite3_randomness'] = function () {
      return (_sqlite3_randomness = Module['_sqlite3_randomness'] =
        Module['asm']['sqlite3_randomness']).apply(null, arguments);
    });

    var _sqlite3_stricmp = (Module['_sqlite3_stricmp'] = function () {
      return (_sqlite3_stricmp = Module['_sqlite3_stricmp'] =
        Module['asm']['sqlite3_stricmp']).apply(null, arguments);
    });

    var _sqlite3_strnicmp = (Module['_sqlite3_strnicmp'] = function () {
      return (_sqlite3_strnicmp = Module['_sqlite3_strnicmp'] =
        Module['asm']['sqlite3_strnicmp']).apply(null, arguments);
    });

    var _sqlite3_uri_parameter = (Module['_sqlite3_uri_parameter'] =
      function () {
        return (_sqlite3_uri_parameter = Module['_sqlite3_uri_parameter'] =
          Module['asm']['sqlite3_uri_parameter']).apply(null, arguments);
      });

    var ___errno_location = (Module['___errno_location'] = function () {
      return (___errno_location = Module['___errno_location'] =
        Module['asm']['__errno_location']).apply(null, arguments);
    });

    var _sqlite3_uri_boolean = (Module['_sqlite3_uri_boolean'] = function () {
      return (_sqlite3_uri_boolean = Module['_sqlite3_uri_boolean'] =
        Module['asm']['sqlite3_uri_boolean']).apply(null, arguments);
    });

    var _sqlite3_serialize = (Module['_sqlite3_serialize'] = function () {
      return (_sqlite3_serialize = Module['_sqlite3_serialize'] =
        Module['asm']['sqlite3_serialize']).apply(null, arguments);
    });

    var _sqlite3_prepare_v2 = (Module['_sqlite3_prepare_v2'] = function () {
      return (_sqlite3_prepare_v2 = Module['_sqlite3_prepare_v2'] =
        Module['asm']['sqlite3_prepare_v2']).apply(null, arguments);
    });

    var _sqlite3_step = (Module['_sqlite3_step'] = function () {
      return (_sqlite3_step = Module['_sqlite3_step'] =
        Module['asm']['sqlite3_step']).apply(null, arguments);
    });

    var _sqlite3_column_int64 = (Module['_sqlite3_column_int64'] = function () {
      return (_sqlite3_column_int64 = Module['_sqlite3_column_int64'] =
        Module['asm']['sqlite3_column_int64']).apply(null, arguments);
    });

    var _sqlite3_reset = (Module['_sqlite3_reset'] = function () {
      return (_sqlite3_reset = Module['_sqlite3_reset'] =
        Module['asm']['sqlite3_reset']).apply(null, arguments);
    });

    var _sqlite3_exec = (Module['_sqlite3_exec'] = function () {
      return (_sqlite3_exec = Module['_sqlite3_exec'] =
        Module['asm']['sqlite3_exec']).apply(null, arguments);
    });

    var _sqlite3_column_int = (Module['_sqlite3_column_int'] = function () {
      return (_sqlite3_column_int = Module['_sqlite3_column_int'] =
        Module['asm']['sqlite3_column_int']).apply(null, arguments);
    });

    var _sqlite3_finalize = (Module['_sqlite3_finalize'] = function () {
      return (_sqlite3_finalize = Module['_sqlite3_finalize'] =
        Module['asm']['sqlite3_finalize']).apply(null, arguments);
    });

    var _sqlite3_file_control = (Module['_sqlite3_file_control'] = function () {
      return (_sqlite3_file_control = Module['_sqlite3_file_control'] =
        Module['asm']['sqlite3_file_control']).apply(null, arguments);
    });

    var _sqlite3_column_name = (Module['_sqlite3_column_name'] = function () {
      return (_sqlite3_column_name = Module['_sqlite3_column_name'] =
        Module['asm']['sqlite3_column_name']).apply(null, arguments);
    });

    var _sqlite3_column_text = (Module['_sqlite3_column_text'] = function () {
      return (_sqlite3_column_text = Module['_sqlite3_column_text'] =
        Module['asm']['sqlite3_column_text']).apply(null, arguments);
    });

    var _sqlite3_column_type = (Module['_sqlite3_column_type'] = function () {
      return (_sqlite3_column_type = Module['_sqlite3_column_type'] =
        Module['asm']['sqlite3_column_type']).apply(null, arguments);
    });

    var _sqlite3_errmsg = (Module['_sqlite3_errmsg'] = function () {
      return (_sqlite3_errmsg = Module['_sqlite3_errmsg'] =
        Module['asm']['sqlite3_errmsg']).apply(null, arguments);
    });

    var _sqlite3_deserialize = (Module['_sqlite3_deserialize'] = function () {
      return (_sqlite3_deserialize = Module['_sqlite3_deserialize'] =
        Module['asm']['sqlite3_deserialize']).apply(null, arguments);
    });

    var _sqlite3_clear_bindings = (Module['_sqlite3_clear_bindings'] =
      function () {
        return (_sqlite3_clear_bindings = Module['_sqlite3_clear_bindings'] =
          Module['asm']['sqlite3_clear_bindings']).apply(null, arguments);
      });

    var _sqlite3_value_blob = (Module['_sqlite3_value_blob'] = function () {
      return (_sqlite3_value_blob = Module['_sqlite3_value_blob'] =
        Module['asm']['sqlite3_value_blob']).apply(null, arguments);
    });

    var _sqlite3_value_bytes = (Module['_sqlite3_value_bytes'] = function () {
      return (_sqlite3_value_bytes = Module['_sqlite3_value_bytes'] =
        Module['asm']['sqlite3_value_bytes']).apply(null, arguments);
    });

    var _sqlite3_value_double = (Module['_sqlite3_value_double'] = function () {
      return (_sqlite3_value_double = Module['_sqlite3_value_double'] =
        Module['asm']['sqlite3_value_double']).apply(null, arguments);
    });

    var _sqlite3_value_int = (Module['_sqlite3_value_int'] = function () {
      return (_sqlite3_value_int = Module['_sqlite3_value_int'] =
        Module['asm']['sqlite3_value_int']).apply(null, arguments);
    });

    var _sqlite3_value_int64 = (Module['_sqlite3_value_int64'] = function () {
      return (_sqlite3_value_int64 = Module['_sqlite3_value_int64'] =
        Module['asm']['sqlite3_value_int64']).apply(null, arguments);
    });

    var _sqlite3_value_subtype = (Module['_sqlite3_value_subtype'] =
      function () {
        return (_sqlite3_value_subtype = Module['_sqlite3_value_subtype'] =
          Module['asm']['sqlite3_value_subtype']).apply(null, arguments);
      });

    var _sqlite3_value_pointer = (Module['_sqlite3_value_pointer'] =
      function () {
        return (_sqlite3_value_pointer = Module['_sqlite3_value_pointer'] =
          Module['asm']['sqlite3_value_pointer']).apply(null, arguments);
      });

    var _sqlite3_value_type = (Module['_sqlite3_value_type'] = function () {
      return (_sqlite3_value_type = Module['_sqlite3_value_type'] =
        Module['asm']['sqlite3_value_type']).apply(null, arguments);
    });

    var _sqlite3_value_nochange = (Module['_sqlite3_value_nochange'] =
      function () {
        return (_sqlite3_value_nochange = Module['_sqlite3_value_nochange'] =
          Module['asm']['sqlite3_value_nochange']).apply(null, arguments);
      });

    var _sqlite3_value_frombind = (Module['_sqlite3_value_frombind'] =
      function () {
        return (_sqlite3_value_frombind = Module['_sqlite3_value_frombind'] =
          Module['asm']['sqlite3_value_frombind']).apply(null, arguments);
      });

    var _sqlite3_value_dup = (Module['_sqlite3_value_dup'] = function () {
      return (_sqlite3_value_dup = Module['_sqlite3_value_dup'] =
        Module['asm']['sqlite3_value_dup']).apply(null, arguments);
    });

    var _sqlite3_value_free = (Module['_sqlite3_value_free'] = function () {
      return (_sqlite3_value_free = Module['_sqlite3_value_free'] =
        Module['asm']['sqlite3_value_free']).apply(null, arguments);
    });

    var _sqlite3_result_blob = (Module['_sqlite3_result_blob'] = function () {
      return (_sqlite3_result_blob = Module['_sqlite3_result_blob'] =
        Module['asm']['sqlite3_result_blob']).apply(null, arguments);
    });

    var _sqlite3_result_error_toobig = (Module['_sqlite3_result_error_toobig'] =
      function () {
        return (_sqlite3_result_error_toobig = Module[
          '_sqlite3_result_error_toobig'
        ] =
          Module['asm']['sqlite3_result_error_toobig']).apply(null, arguments);
      });

    var _sqlite3_result_error_nomem = (Module['_sqlite3_result_error_nomem'] =
      function () {
        return (_sqlite3_result_error_nomem = Module[
          '_sqlite3_result_error_nomem'
        ] =
          Module['asm']['sqlite3_result_error_nomem']).apply(null, arguments);
      });

    var _sqlite3_result_double = (Module['_sqlite3_result_double'] =
      function () {
        return (_sqlite3_result_double = Module['_sqlite3_result_double'] =
          Module['asm']['sqlite3_result_double']).apply(null, arguments);
      });

    var _sqlite3_result_error = (Module['_sqlite3_result_error'] = function () {
      return (_sqlite3_result_error = Module['_sqlite3_result_error'] =
        Module['asm']['sqlite3_result_error']).apply(null, arguments);
    });

    var _sqlite3_result_int = (Module['_sqlite3_result_int'] = function () {
      return (_sqlite3_result_int = Module['_sqlite3_result_int'] =
        Module['asm']['sqlite3_result_int']).apply(null, arguments);
    });

    var _sqlite3_result_int64 = (Module['_sqlite3_result_int64'] = function () {
      return (_sqlite3_result_int64 = Module['_sqlite3_result_int64'] =
        Module['asm']['sqlite3_result_int64']).apply(null, arguments);
    });

    var _sqlite3_result_null = (Module['_sqlite3_result_null'] = function () {
      return (_sqlite3_result_null = Module['_sqlite3_result_null'] =
        Module['asm']['sqlite3_result_null']).apply(null, arguments);
    });

    var _sqlite3_result_pointer = (Module['_sqlite3_result_pointer'] =
      function () {
        return (_sqlite3_result_pointer = Module['_sqlite3_result_pointer'] =
          Module['asm']['sqlite3_result_pointer']).apply(null, arguments);
      });

    var _sqlite3_result_subtype = (Module['_sqlite3_result_subtype'] =
      function () {
        return (_sqlite3_result_subtype = Module['_sqlite3_result_subtype'] =
          Module['asm']['sqlite3_result_subtype']).apply(null, arguments);
      });

    var _sqlite3_result_text = (Module['_sqlite3_result_text'] = function () {
      return (_sqlite3_result_text = Module['_sqlite3_result_text'] =
        Module['asm']['sqlite3_result_text']).apply(null, arguments);
    });

    var _sqlite3_result_zeroblob = (Module['_sqlite3_result_zeroblob'] =
      function () {
        return (_sqlite3_result_zeroblob = Module['_sqlite3_result_zeroblob'] =
          Module['asm']['sqlite3_result_zeroblob']).apply(null, arguments);
      });

    var _sqlite3_result_zeroblob64 = (Module['_sqlite3_result_zeroblob64'] =
      function () {
        return (_sqlite3_result_zeroblob64 = Module[
          '_sqlite3_result_zeroblob64'
        ] =
          Module['asm']['sqlite3_result_zeroblob64']).apply(null, arguments);
      });

    var _sqlite3_result_error_code = (Module['_sqlite3_result_error_code'] =
      function () {
        return (_sqlite3_result_error_code = Module[
          '_sqlite3_result_error_code'
        ] =
          Module['asm']['sqlite3_result_error_code']).apply(null, arguments);
      });

    var _sqlite3_user_data = (Module['_sqlite3_user_data'] = function () {
      return (_sqlite3_user_data = Module['_sqlite3_user_data'] =
        Module['asm']['sqlite3_user_data']).apply(null, arguments);
    });

    var _sqlite3_context_db_handle = (Module['_sqlite3_context_db_handle'] =
      function () {
        return (_sqlite3_context_db_handle = Module[
          '_sqlite3_context_db_handle'
        ] =
          Module['asm']['sqlite3_context_db_handle']).apply(null, arguments);
      });

    var _sqlite3_vtab_nochange = (Module['_sqlite3_vtab_nochange'] =
      function () {
        return (_sqlite3_vtab_nochange = Module['_sqlite3_vtab_nochange'] =
          Module['asm']['sqlite3_vtab_nochange']).apply(null, arguments);
      });

    var _sqlite3_vtab_in_first = (Module['_sqlite3_vtab_in_first'] =
      function () {
        return (_sqlite3_vtab_in_first = Module['_sqlite3_vtab_in_first'] =
          Module['asm']['sqlite3_vtab_in_first']).apply(null, arguments);
      });

    var _sqlite3_vtab_in_next = (Module['_sqlite3_vtab_in_next'] = function () {
      return (_sqlite3_vtab_in_next = Module['_sqlite3_vtab_in_next'] =
        Module['asm']['sqlite3_vtab_in_next']).apply(null, arguments);
    });

    var _sqlite3_aggregate_context = (Module['_sqlite3_aggregate_context'] =
      function () {
        return (_sqlite3_aggregate_context = Module[
          '_sqlite3_aggregate_context'
        ] =
          Module['asm']['sqlite3_aggregate_context']).apply(null, arguments);
      });

    var _sqlite3_get_auxdata = (Module['_sqlite3_get_auxdata'] = function () {
      return (_sqlite3_get_auxdata = Module['_sqlite3_get_auxdata'] =
        Module['asm']['sqlite3_get_auxdata']).apply(null, arguments);
    });

    var _sqlite3_set_auxdata = (Module['_sqlite3_set_auxdata'] = function () {
      return (_sqlite3_set_auxdata = Module['_sqlite3_set_auxdata'] =
        Module['asm']['sqlite3_set_auxdata']).apply(null, arguments);
    });

    var _sqlite3_column_count = (Module['_sqlite3_column_count'] = function () {
      return (_sqlite3_column_count = Module['_sqlite3_column_count'] =
        Module['asm']['sqlite3_column_count']).apply(null, arguments);
    });

    var _sqlite3_data_count = (Module['_sqlite3_data_count'] = function () {
      return (_sqlite3_data_count = Module['_sqlite3_data_count'] =
        Module['asm']['sqlite3_data_count']).apply(null, arguments);
    });

    var _sqlite3_column_blob = (Module['_sqlite3_column_blob'] = function () {
      return (_sqlite3_column_blob = Module['_sqlite3_column_blob'] =
        Module['asm']['sqlite3_column_blob']).apply(null, arguments);
    });

    var _sqlite3_column_bytes = (Module['_sqlite3_column_bytes'] = function () {
      return (_sqlite3_column_bytes = Module['_sqlite3_column_bytes'] =
        Module['asm']['sqlite3_column_bytes']).apply(null, arguments);
    });

    var _sqlite3_column_double = (Module['_sqlite3_column_double'] =
      function () {
        return (_sqlite3_column_double = Module['_sqlite3_column_double'] =
          Module['asm']['sqlite3_column_double']).apply(null, arguments);
      });

    var _sqlite3_column_value = (Module['_sqlite3_column_value'] = function () {
      return (_sqlite3_column_value = Module['_sqlite3_column_value'] =
        Module['asm']['sqlite3_column_value']).apply(null, arguments);
    });

    var _sqlite3_bind_blob = (Module['_sqlite3_bind_blob'] = function () {
      return (_sqlite3_bind_blob = Module['_sqlite3_bind_blob'] =
        Module['asm']['sqlite3_bind_blob']).apply(null, arguments);
    });

    var _sqlite3_bind_double = (Module['_sqlite3_bind_double'] = function () {
      return (_sqlite3_bind_double = Module['_sqlite3_bind_double'] =
        Module['asm']['sqlite3_bind_double']).apply(null, arguments);
    });

    var _sqlite3_bind_int = (Module['_sqlite3_bind_int'] = function () {
      return (_sqlite3_bind_int = Module['_sqlite3_bind_int'] =
        Module['asm']['sqlite3_bind_int']).apply(null, arguments);
    });

    var _sqlite3_bind_int64 = (Module['_sqlite3_bind_int64'] = function () {
      return (_sqlite3_bind_int64 = Module['_sqlite3_bind_int64'] =
        Module['asm']['sqlite3_bind_int64']).apply(null, arguments);
    });

    var _sqlite3_bind_null = (Module['_sqlite3_bind_null'] = function () {
      return (_sqlite3_bind_null = Module['_sqlite3_bind_null'] =
        Module['asm']['sqlite3_bind_null']).apply(null, arguments);
    });

    var _sqlite3_bind_pointer = (Module['_sqlite3_bind_pointer'] = function () {
      return (_sqlite3_bind_pointer = Module['_sqlite3_bind_pointer'] =
        Module['asm']['sqlite3_bind_pointer']).apply(null, arguments);
    });

    var _sqlite3_bind_text = (Module['_sqlite3_bind_text'] = function () {
      return (_sqlite3_bind_text = Module['_sqlite3_bind_text'] =
        Module['asm']['sqlite3_bind_text']).apply(null, arguments);
    });

    var _sqlite3_bind_parameter_count = (Module[
      '_sqlite3_bind_parameter_count'
    ] = function () {
      return (_sqlite3_bind_parameter_count = Module[
        '_sqlite3_bind_parameter_count'
      ] =
        Module['asm']['sqlite3_bind_parameter_count']).apply(null, arguments);
    });

    var _sqlite3_bind_parameter_index = (Module[
      '_sqlite3_bind_parameter_index'
    ] = function () {
      return (_sqlite3_bind_parameter_index = Module[
        '_sqlite3_bind_parameter_index'
      ] =
        Module['asm']['sqlite3_bind_parameter_index']).apply(null, arguments);
    });

    var _sqlite3_db_handle = (Module['_sqlite3_db_handle'] = function () {
      return (_sqlite3_db_handle = Module['_sqlite3_db_handle'] =
        Module['asm']['sqlite3_db_handle']).apply(null, arguments);
    });

    var _sqlite3_stmt_readonly = (Module['_sqlite3_stmt_readonly'] =
      function () {
        return (_sqlite3_stmt_readonly = Module['_sqlite3_stmt_readonly'] =
          Module['asm']['sqlite3_stmt_readonly']).apply(null, arguments);
      });

    var _sqlite3_stmt_isexplain = (Module['_sqlite3_stmt_isexplain'] =
      function () {
        return (_sqlite3_stmt_isexplain = Module['_sqlite3_stmt_isexplain'] =
          Module['asm']['sqlite3_stmt_isexplain']).apply(null, arguments);
      });

    var _sqlite3_stmt_status = (Module['_sqlite3_stmt_status'] = function () {
      return (_sqlite3_stmt_status = Module['_sqlite3_stmt_status'] =
        Module['asm']['sqlite3_stmt_status']).apply(null, arguments);
    });

    var _sqlite3_sql = (Module['_sqlite3_sql'] = function () {
      return (_sqlite3_sql = Module['_sqlite3_sql'] =
        Module['asm']['sqlite3_sql']).apply(null, arguments);
    });

    var _sqlite3_expanded_sql = (Module['_sqlite3_expanded_sql'] = function () {
      return (_sqlite3_expanded_sql = Module['_sqlite3_expanded_sql'] =
        Module['asm']['sqlite3_expanded_sql']).apply(null, arguments);
    });

    var _sqlite3_preupdate_old = (Module['_sqlite3_preupdate_old'] =
      function () {
        return (_sqlite3_preupdate_old = Module['_sqlite3_preupdate_old'] =
          Module['asm']['sqlite3_preupdate_old']).apply(null, arguments);
      });

    var _sqlite3_preupdate_count = (Module['_sqlite3_preupdate_count'] =
      function () {
        return (_sqlite3_preupdate_count = Module['_sqlite3_preupdate_count'] =
          Module['asm']['sqlite3_preupdate_count']).apply(null, arguments);
      });

    var _sqlite3_preupdate_depth = (Module['_sqlite3_preupdate_depth'] =
      function () {
        return (_sqlite3_preupdate_depth = Module['_sqlite3_preupdate_depth'] =
          Module['asm']['sqlite3_preupdate_depth']).apply(null, arguments);
      });

    var _sqlite3_preupdate_blobwrite = (Module['_sqlite3_preupdate_blobwrite'] =
      function () {
        return (_sqlite3_preupdate_blobwrite = Module[
          '_sqlite3_preupdate_blobwrite'
        ] =
          Module['asm']['sqlite3_preupdate_blobwrite']).apply(null, arguments);
      });

    var _sqlite3_preupdate_new = (Module['_sqlite3_preupdate_new'] =
      function () {
        return (_sqlite3_preupdate_new = Module['_sqlite3_preupdate_new'] =
          Module['asm']['sqlite3_preupdate_new']).apply(null, arguments);
      });

    var _sqlite3_value_numeric_type = (Module['_sqlite3_value_numeric_type'] =
      function () {
        return (_sqlite3_value_numeric_type = Module[
          '_sqlite3_value_numeric_type'
        ] =
          Module['asm']['sqlite3_value_numeric_type']).apply(null, arguments);
      });

    var _sqlite3_set_authorizer = (Module['_sqlite3_set_authorizer'] =
      function () {
        return (_sqlite3_set_authorizer = Module['_sqlite3_set_authorizer'] =
          Module['asm']['sqlite3_set_authorizer']).apply(null, arguments);
      });

    var _sqlite3_strglob = (Module['_sqlite3_strglob'] = function () {
      return (_sqlite3_strglob = Module['_sqlite3_strglob'] =
        Module['asm']['sqlite3_strglob']).apply(null, arguments);
    });

    var _sqlite3_strlike = (Module['_sqlite3_strlike'] = function () {
      return (_sqlite3_strlike = Module['_sqlite3_strlike'] =
        Module['asm']['sqlite3_strlike']).apply(null, arguments);
    });

    var _sqlite3_auto_extension = (Module['_sqlite3_auto_extension'] =
      function () {
        return (_sqlite3_auto_extension = Module['_sqlite3_auto_extension'] =
          Module['asm']['sqlite3_auto_extension']).apply(null, arguments);
      });

    var _sqlite3_cancel_auto_extension = (Module[
      '_sqlite3_cancel_auto_extension'
    ] = function () {
      return (_sqlite3_cancel_auto_extension = Module[
        '_sqlite3_cancel_auto_extension'
      ] =
        Module['asm']['sqlite3_cancel_auto_extension']).apply(null, arguments);
    });

    var _sqlite3_reset_auto_extension = (Module[
      '_sqlite3_reset_auto_extension'
    ] = function () {
      return (_sqlite3_reset_auto_extension = Module[
        '_sqlite3_reset_auto_extension'
      ] =
        Module['asm']['sqlite3_reset_auto_extension']).apply(null, arguments);
    });

    var _sqlite3_prepare_v3 = (Module['_sqlite3_prepare_v3'] = function () {
      return (_sqlite3_prepare_v3 = Module['_sqlite3_prepare_v3'] =
        Module['asm']['sqlite3_prepare_v3']).apply(null, arguments);
    });

    var _sqlite3_create_module = (Module['_sqlite3_create_module'] =
      function () {
        return (_sqlite3_create_module = Module['_sqlite3_create_module'] =
          Module['asm']['sqlite3_create_module']).apply(null, arguments);
      });

    var _sqlite3_create_module_v2 = (Module['_sqlite3_create_module_v2'] =
      function () {
        return (_sqlite3_create_module_v2 = Module[
          '_sqlite3_create_module_v2'
        ] =
          Module['asm']['sqlite3_create_module_v2']).apply(null, arguments);
      });

    var _sqlite3_drop_modules = (Module['_sqlite3_drop_modules'] = function () {
      return (_sqlite3_drop_modules = Module['_sqlite3_drop_modules'] =
        Module['asm']['sqlite3_drop_modules']).apply(null, arguments);
    });

    var _sqlite3_declare_vtab = (Module['_sqlite3_declare_vtab'] = function () {
      return (_sqlite3_declare_vtab = Module['_sqlite3_declare_vtab'] =
        Module['asm']['sqlite3_declare_vtab']).apply(null, arguments);
    });

    var _sqlite3_vtab_on_conflict = (Module['_sqlite3_vtab_on_conflict'] =
      function () {
        return (_sqlite3_vtab_on_conflict = Module[
          '_sqlite3_vtab_on_conflict'
        ] =
          Module['asm']['sqlite3_vtab_on_conflict']).apply(null, arguments);
      });

    var _sqlite3_vtab_collation = (Module['_sqlite3_vtab_collation'] =
      function () {
        return (_sqlite3_vtab_collation = Module['_sqlite3_vtab_collation'] =
          Module['asm']['sqlite3_vtab_collation']).apply(null, arguments);
      });

    var _sqlite3_vtab_in = (Module['_sqlite3_vtab_in'] = function () {
      return (_sqlite3_vtab_in = Module['_sqlite3_vtab_in'] =
        Module['asm']['sqlite3_vtab_in']).apply(null, arguments);
    });

    var _sqlite3_vtab_rhs_value = (Module['_sqlite3_vtab_rhs_value'] =
      function () {
        return (_sqlite3_vtab_rhs_value = Module['_sqlite3_vtab_rhs_value'] =
          Module['asm']['sqlite3_vtab_rhs_value']).apply(null, arguments);
      });

    var _sqlite3_vtab_distinct = (Module['_sqlite3_vtab_distinct'] =
      function () {
        return (_sqlite3_vtab_distinct = Module['_sqlite3_vtab_distinct'] =
          Module['asm']['sqlite3_vtab_distinct']).apply(null, arguments);
      });

    var _sqlite3_keyword_name = (Module['_sqlite3_keyword_name'] = function () {
      return (_sqlite3_keyword_name = Module['_sqlite3_keyword_name'] =
        Module['asm']['sqlite3_keyword_name']).apply(null, arguments);
    });

    var _sqlite3_keyword_count = (Module['_sqlite3_keyword_count'] =
      function () {
        return (_sqlite3_keyword_count = Module['_sqlite3_keyword_count'] =
          Module['asm']['sqlite3_keyword_count']).apply(null, arguments);
      });

    var _sqlite3_keyword_check = (Module['_sqlite3_keyword_check'] =
      function () {
        return (_sqlite3_keyword_check = Module['_sqlite3_keyword_check'] =
          Module['asm']['sqlite3_keyword_check']).apply(null, arguments);
      });

    var _sqlite3_complete = (Module['_sqlite3_complete'] = function () {
      return (_sqlite3_complete = Module['_sqlite3_complete'] =
        Module['asm']['sqlite3_complete']).apply(null, arguments);
    });

    var _sqlite3_libversion = (Module['_sqlite3_libversion'] = function () {
      return (_sqlite3_libversion = Module['_sqlite3_libversion'] =
        Module['asm']['sqlite3_libversion']).apply(null, arguments);
    });

    var _sqlite3_libversion_number = (Module['_sqlite3_libversion_number'] =
      function () {
        return (_sqlite3_libversion_number = Module[
          '_sqlite3_libversion_number'
        ] =
          Module['asm']['sqlite3_libversion_number']).apply(null, arguments);
      });

    var _sqlite3_shutdown = (Module['_sqlite3_shutdown'] = function () {
      return (_sqlite3_shutdown = Module['_sqlite3_shutdown'] =
        Module['asm']['sqlite3_shutdown']).apply(null, arguments);
    });

    var _sqlite3_last_insert_rowid = (Module['_sqlite3_last_insert_rowid'] =
      function () {
        return (_sqlite3_last_insert_rowid = Module[
          '_sqlite3_last_insert_rowid'
        ] =
          Module['asm']['sqlite3_last_insert_rowid']).apply(null, arguments);
      });

    var _sqlite3_set_last_insert_rowid = (Module[
      '_sqlite3_set_last_insert_rowid'
    ] = function () {
      return (_sqlite3_set_last_insert_rowid = Module[
        '_sqlite3_set_last_insert_rowid'
      ] =
        Module['asm']['sqlite3_set_last_insert_rowid']).apply(null, arguments);
    });

    var _sqlite3_changes64 = (Module['_sqlite3_changes64'] = function () {
      return (_sqlite3_changes64 = Module['_sqlite3_changes64'] =
        Module['asm']['sqlite3_changes64']).apply(null, arguments);
    });

    var _sqlite3_changes = (Module['_sqlite3_changes'] = function () {
      return (_sqlite3_changes = Module['_sqlite3_changes'] =
        Module['asm']['sqlite3_changes']).apply(null, arguments);
    });

    var _sqlite3_total_changes64 = (Module['_sqlite3_total_changes64'] =
      function () {
        return (_sqlite3_total_changes64 = Module['_sqlite3_total_changes64'] =
          Module['asm']['sqlite3_total_changes64']).apply(null, arguments);
      });

    var _sqlite3_total_changes = (Module['_sqlite3_total_changes'] =
      function () {
        return (_sqlite3_total_changes = Module['_sqlite3_total_changes'] =
          Module['asm']['sqlite3_total_changes']).apply(null, arguments);
      });

    var _sqlite3_txn_state = (Module['_sqlite3_txn_state'] = function () {
      return (_sqlite3_txn_state = Module['_sqlite3_txn_state'] =
        Module['asm']['sqlite3_txn_state']).apply(null, arguments);
    });

    var _sqlite3_close_v2 = (Module['_sqlite3_close_v2'] = function () {
      return (_sqlite3_close_v2 = Module['_sqlite3_close_v2'] =
        Module['asm']['sqlite3_close_v2']).apply(null, arguments);
    });

    var _sqlite3_busy_handler = (Module['_sqlite3_busy_handler'] = function () {
      return (_sqlite3_busy_handler = Module['_sqlite3_busy_handler'] =
        Module['asm']['sqlite3_busy_handler']).apply(null, arguments);
    });

    var _sqlite3_progress_handler = (Module['_sqlite3_progress_handler'] =
      function () {
        return (_sqlite3_progress_handler = Module[
          '_sqlite3_progress_handler'
        ] =
          Module['asm']['sqlite3_progress_handler']).apply(null, arguments);
      });

    var _sqlite3_busy_timeout = (Module['_sqlite3_busy_timeout'] = function () {
      return (_sqlite3_busy_timeout = Module['_sqlite3_busy_timeout'] =
        Module['asm']['sqlite3_busy_timeout']).apply(null, arguments);
    });

    var _sqlite3_create_function = (Module['_sqlite3_create_function'] =
      function () {
        return (_sqlite3_create_function = Module['_sqlite3_create_function'] =
          Module['asm']['sqlite3_create_function']).apply(null, arguments);
      });

    var _sqlite3_create_function_v2 = (Module['_sqlite3_create_function_v2'] =
      function () {
        return (_sqlite3_create_function_v2 = Module[
          '_sqlite3_create_function_v2'
        ] =
          Module['asm']['sqlite3_create_function_v2']).apply(null, arguments);
      });

    var _sqlite3_create_window_function = (Module[
      '_sqlite3_create_window_function'
    ] = function () {
      return (_sqlite3_create_window_function = Module[
        '_sqlite3_create_window_function'
      ] =
        Module['asm']['sqlite3_create_window_function']).apply(null, arguments);
    });

    var _sqlite3_overload_function = (Module['_sqlite3_overload_function'] =
      function () {
        return (_sqlite3_overload_function = Module[
          '_sqlite3_overload_function'
        ] =
          Module['asm']['sqlite3_overload_function']).apply(null, arguments);
      });

    var _sqlite3_trace_v2 = (Module['_sqlite3_trace_v2'] = function () {
      return (_sqlite3_trace_v2 = Module['_sqlite3_trace_v2'] =
        Module['asm']['sqlite3_trace_v2']).apply(null, arguments);
    });

    var _sqlite3_commit_hook = (Module['_sqlite3_commit_hook'] = function () {
      return (_sqlite3_commit_hook = Module['_sqlite3_commit_hook'] =
        Module['asm']['sqlite3_commit_hook']).apply(null, arguments);
    });

    var _sqlite3_update_hook = (Module['_sqlite3_update_hook'] = function () {
      return (_sqlite3_update_hook = Module['_sqlite3_update_hook'] =
        Module['asm']['sqlite3_update_hook']).apply(null, arguments);
    });

    var _sqlite3_rollback_hook = (Module['_sqlite3_rollback_hook'] =
      function () {
        return (_sqlite3_rollback_hook = Module['_sqlite3_rollback_hook'] =
          Module['asm']['sqlite3_rollback_hook']).apply(null, arguments);
      });

    var _sqlite3_preupdate_hook = (Module['_sqlite3_preupdate_hook'] =
      function () {
        return (_sqlite3_preupdate_hook = Module['_sqlite3_preupdate_hook'] =
          Module['asm']['sqlite3_preupdate_hook']).apply(null, arguments);
      });

    var _sqlite3_error_offset = (Module['_sqlite3_error_offset'] = function () {
      return (_sqlite3_error_offset = Module['_sqlite3_error_offset'] =
        Module['asm']['sqlite3_error_offset']).apply(null, arguments);
    });

    var _sqlite3_errcode = (Module['_sqlite3_errcode'] = function () {
      return (_sqlite3_errcode = Module['_sqlite3_errcode'] =
        Module['asm']['sqlite3_errcode']).apply(null, arguments);
    });

    var _sqlite3_extended_errcode = (Module['_sqlite3_extended_errcode'] =
      function () {
        return (_sqlite3_extended_errcode = Module[
          '_sqlite3_extended_errcode'
        ] =
          Module['asm']['sqlite3_extended_errcode']).apply(null, arguments);
      });

    var _sqlite3_errstr = (Module['_sqlite3_errstr'] = function () {
      return (_sqlite3_errstr = Module['_sqlite3_errstr'] =
        Module['asm']['sqlite3_errstr']).apply(null, arguments);
    });

    var _sqlite3_limit = (Module['_sqlite3_limit'] = function () {
      return (_sqlite3_limit = Module['_sqlite3_limit'] =
        Module['asm']['sqlite3_limit']).apply(null, arguments);
    });

    var _sqlite3_open = (Module['_sqlite3_open'] = function () {
      return (_sqlite3_open = Module['_sqlite3_open'] =
        Module['asm']['sqlite3_open']).apply(null, arguments);
    });

    var _sqlite3_open_v2 = (Module['_sqlite3_open_v2'] = function () {
      return (_sqlite3_open_v2 = Module['_sqlite3_open_v2'] =
        Module['asm']['sqlite3_open_v2']).apply(null, arguments);
    });

    var _sqlite3_create_collation = (Module['_sqlite3_create_collation'] =
      function () {
        return (_sqlite3_create_collation = Module[
          '_sqlite3_create_collation'
        ] =
          Module['asm']['sqlite3_create_collation']).apply(null, arguments);
      });

    var _sqlite3_create_collation_v2 = (Module['_sqlite3_create_collation_v2'] =
      function () {
        return (_sqlite3_create_collation_v2 = Module[
          '_sqlite3_create_collation_v2'
        ] =
          Module['asm']['sqlite3_create_collation_v2']).apply(null, arguments);
      });

    var _sqlite3_collation_needed = (Module['_sqlite3_collation_needed'] =
      function () {
        return (_sqlite3_collation_needed = Module[
          '_sqlite3_collation_needed'
        ] =
          Module['asm']['sqlite3_collation_needed']).apply(null, arguments);
      });

    var _sqlite3_get_autocommit = (Module['_sqlite3_get_autocommit'] =
      function () {
        return (_sqlite3_get_autocommit = Module['_sqlite3_get_autocommit'] =
          Module['asm']['sqlite3_get_autocommit']).apply(null, arguments);
      });

    var _sqlite3_table_column_metadata = (Module[
      '_sqlite3_table_column_metadata'
    ] = function () {
      return (_sqlite3_table_column_metadata = Module[
        '_sqlite3_table_column_metadata'
      ] =
        Module['asm']['sqlite3_table_column_metadata']).apply(null, arguments);
    });

    var _sqlite3_extended_result_codes = (Module[
      '_sqlite3_extended_result_codes'
    ] = function () {
      return (_sqlite3_extended_result_codes = Module[
        '_sqlite3_extended_result_codes'
      ] =
        Module['asm']['sqlite3_extended_result_codes']).apply(null, arguments);
    });

    var _sqlite3_uri_key = (Module['_sqlite3_uri_key'] = function () {
      return (_sqlite3_uri_key = Module['_sqlite3_uri_key'] =
        Module['asm']['sqlite3_uri_key']).apply(null, arguments);
    });

    var _sqlite3_uri_int64 = (Module['_sqlite3_uri_int64'] = function () {
      return (_sqlite3_uri_int64 = Module['_sqlite3_uri_int64'] =
        Module['asm']['sqlite3_uri_int64']).apply(null, arguments);
    });

    var _sqlite3_db_name = (Module['_sqlite3_db_name'] = function () {
      return (_sqlite3_db_name = Module['_sqlite3_db_name'] =
        Module['asm']['sqlite3_db_name']).apply(null, arguments);
    });

    var _sqlite3_db_filename = (Module['_sqlite3_db_filename'] = function () {
      return (_sqlite3_db_filename = Module['_sqlite3_db_filename'] =
        Module['asm']['sqlite3_db_filename']).apply(null, arguments);
    });

    var _sqlite3_compileoption_used = (Module['_sqlite3_compileoption_used'] =
      function () {
        return (_sqlite3_compileoption_used = Module[
          '_sqlite3_compileoption_used'
        ] =
          Module['asm']['sqlite3_compileoption_used']).apply(null, arguments);
      });

    var _sqlite3_compileoption_get = (Module['_sqlite3_compileoption_get'] =
      function () {
        return (_sqlite3_compileoption_get = Module[
          '_sqlite3_compileoption_get'
        ] =
          Module['asm']['sqlite3_compileoption_get']).apply(null, arguments);
      });

    var _sqlite3session_diff = (Module['_sqlite3session_diff'] = function () {
      return (_sqlite3session_diff = Module['_sqlite3session_diff'] =
        Module['asm']['sqlite3session_diff']).apply(null, arguments);
    });

    var _sqlite3session_attach = (Module['_sqlite3session_attach'] =
      function () {
        return (_sqlite3session_attach = Module['_sqlite3session_attach'] =
          Module['asm']['sqlite3session_attach']).apply(null, arguments);
      });

    var _sqlite3session_create = (Module['_sqlite3session_create'] =
      function () {
        return (_sqlite3session_create = Module['_sqlite3session_create'] =
          Module['asm']['sqlite3session_create']).apply(null, arguments);
      });

    var _sqlite3session_delete = (Module['_sqlite3session_delete'] =
      function () {
        return (_sqlite3session_delete = Module['_sqlite3session_delete'] =
          Module['asm']['sqlite3session_delete']).apply(null, arguments);
      });

    var _sqlite3session_table_filter = (Module['_sqlite3session_table_filter'] =
      function () {
        return (_sqlite3session_table_filter = Module[
          '_sqlite3session_table_filter'
        ] =
          Module['asm']['sqlite3session_table_filter']).apply(null, arguments);
      });

    var _sqlite3session_changeset = (Module['_sqlite3session_changeset'] =
      function () {
        return (_sqlite3session_changeset = Module[
          '_sqlite3session_changeset'
        ] =
          Module['asm']['sqlite3session_changeset']).apply(null, arguments);
      });

    var _sqlite3session_changeset_strm = (Module[
      '_sqlite3session_changeset_strm'
    ] = function () {
      return (_sqlite3session_changeset_strm = Module[
        '_sqlite3session_changeset_strm'
      ] =
        Module['asm']['sqlite3session_changeset_strm']).apply(null, arguments);
    });

    var _sqlite3session_patchset_strm = (Module[
      '_sqlite3session_patchset_strm'
    ] = function () {
      return (_sqlite3session_patchset_strm = Module[
        '_sqlite3session_patchset_strm'
      ] =
        Module['asm']['sqlite3session_patchset_strm']).apply(null, arguments);
    });

    var _sqlite3session_patchset = (Module['_sqlite3session_patchset'] =
      function () {
        return (_sqlite3session_patchset = Module['_sqlite3session_patchset'] =
          Module['asm']['sqlite3session_patchset']).apply(null, arguments);
      });

    var _sqlite3session_enable = (Module['_sqlite3session_enable'] =
      function () {
        return (_sqlite3session_enable = Module['_sqlite3session_enable'] =
          Module['asm']['sqlite3session_enable']).apply(null, arguments);
      });

    var _sqlite3session_indirect = (Module['_sqlite3session_indirect'] =
      function () {
        return (_sqlite3session_indirect = Module['_sqlite3session_indirect'] =
          Module['asm']['sqlite3session_indirect']).apply(null, arguments);
      });

    var _sqlite3session_isempty = (Module['_sqlite3session_isempty'] =
      function () {
        return (_sqlite3session_isempty = Module['_sqlite3session_isempty'] =
          Module['asm']['sqlite3session_isempty']).apply(null, arguments);
      });

    var _sqlite3session_memory_used = (Module['_sqlite3session_memory_used'] =
      function () {
        return (_sqlite3session_memory_used = Module[
          '_sqlite3session_memory_used'
        ] =
          Module['asm']['sqlite3session_memory_used']).apply(null, arguments);
      });

    var _sqlite3session_object_config = (Module[
      '_sqlite3session_object_config'
    ] = function () {
      return (_sqlite3session_object_config = Module[
        '_sqlite3session_object_config'
      ] =
        Module['asm']['sqlite3session_object_config']).apply(null, arguments);
    });

    var _sqlite3session_changeset_size = (Module[
      '_sqlite3session_changeset_size'
    ] = function () {
      return (_sqlite3session_changeset_size = Module[
        '_sqlite3session_changeset_size'
      ] =
        Module['asm']['sqlite3session_changeset_size']).apply(null, arguments);
    });

    var _sqlite3changeset_start = (Module['_sqlite3changeset_start'] =
      function () {
        return (_sqlite3changeset_start = Module['_sqlite3changeset_start'] =
          Module['asm']['sqlite3changeset_start']).apply(null, arguments);
      });

    var _sqlite3changeset_start_v2 = (Module['_sqlite3changeset_start_v2'] =
      function () {
        return (_sqlite3changeset_start_v2 = Module[
          '_sqlite3changeset_start_v2'
        ] =
          Module['asm']['sqlite3changeset_start_v2']).apply(null, arguments);
      });

    var _sqlite3changeset_start_strm = (Module['_sqlite3changeset_start_strm'] =
      function () {
        return (_sqlite3changeset_start_strm = Module[
          '_sqlite3changeset_start_strm'
        ] =
          Module['asm']['sqlite3changeset_start_strm']).apply(null, arguments);
      });

    var _sqlite3changeset_start_v2_strm = (Module[
      '_sqlite3changeset_start_v2_strm'
    ] = function () {
      return (_sqlite3changeset_start_v2_strm = Module[
        '_sqlite3changeset_start_v2_strm'
      ] =
        Module['asm']['sqlite3changeset_start_v2_strm']).apply(null, arguments);
    });

    var _sqlite3changeset_next = (Module['_sqlite3changeset_next'] =
      function () {
        return (_sqlite3changeset_next = Module['_sqlite3changeset_next'] =
          Module['asm']['sqlite3changeset_next']).apply(null, arguments);
      });

    var _sqlite3changeset_op = (Module['_sqlite3changeset_op'] = function () {
      return (_sqlite3changeset_op = Module['_sqlite3changeset_op'] =
        Module['asm']['sqlite3changeset_op']).apply(null, arguments);
    });

    var _sqlite3changeset_pk = (Module['_sqlite3changeset_pk'] = function () {
      return (_sqlite3changeset_pk = Module['_sqlite3changeset_pk'] =
        Module['asm']['sqlite3changeset_pk']).apply(null, arguments);
    });

    var _sqlite3changeset_old = (Module['_sqlite3changeset_old'] = function () {
      return (_sqlite3changeset_old = Module['_sqlite3changeset_old'] =
        Module['asm']['sqlite3changeset_old']).apply(null, arguments);
    });

    var _sqlite3changeset_new = (Module['_sqlite3changeset_new'] = function () {
      return (_sqlite3changeset_new = Module['_sqlite3changeset_new'] =
        Module['asm']['sqlite3changeset_new']).apply(null, arguments);
    });

    var _sqlite3changeset_conflict = (Module['_sqlite3changeset_conflict'] =
      function () {
        return (_sqlite3changeset_conflict = Module[
          '_sqlite3changeset_conflict'
        ] =
          Module['asm']['sqlite3changeset_conflict']).apply(null, arguments);
      });

    var _sqlite3changeset_fk_conflicts = (Module[
      '_sqlite3changeset_fk_conflicts'
    ] = function () {
      return (_sqlite3changeset_fk_conflicts = Module[
        '_sqlite3changeset_fk_conflicts'
      ] =
        Module['asm']['sqlite3changeset_fk_conflicts']).apply(null, arguments);
    });

    var _sqlite3changeset_finalize = (Module['_sqlite3changeset_finalize'] =
      function () {
        return (_sqlite3changeset_finalize = Module[
          '_sqlite3changeset_finalize'
        ] =
          Module['asm']['sqlite3changeset_finalize']).apply(null, arguments);
      });

    var _sqlite3changeset_invert = (Module['_sqlite3changeset_invert'] =
      function () {
        return (_sqlite3changeset_invert = Module['_sqlite3changeset_invert'] =
          Module['asm']['sqlite3changeset_invert']).apply(null, arguments);
      });

    var _sqlite3changeset_invert_strm = (Module[
      '_sqlite3changeset_invert_strm'
    ] = function () {
      return (_sqlite3changeset_invert_strm = Module[
        '_sqlite3changeset_invert_strm'
      ] =
        Module['asm']['sqlite3changeset_invert_strm']).apply(null, arguments);
    });

    var _sqlite3changeset_apply_v2 = (Module['_sqlite3changeset_apply_v2'] =
      function () {
        return (_sqlite3changeset_apply_v2 = Module[
          '_sqlite3changeset_apply_v2'
        ] =
          Module['asm']['sqlite3changeset_apply_v2']).apply(null, arguments);
      });

    var _sqlite3changeset_apply = (Module['_sqlite3changeset_apply'] =
      function () {
        return (_sqlite3changeset_apply = Module['_sqlite3changeset_apply'] =
          Module['asm']['sqlite3changeset_apply']).apply(null, arguments);
      });

    var _sqlite3changeset_apply_v2_strm = (Module[
      '_sqlite3changeset_apply_v2_strm'
    ] = function () {
      return (_sqlite3changeset_apply_v2_strm = Module[
        '_sqlite3changeset_apply_v2_strm'
      ] =
        Module['asm']['sqlite3changeset_apply_v2_strm']).apply(null, arguments);
    });

    var _sqlite3changeset_apply_strm = (Module['_sqlite3changeset_apply_strm'] =
      function () {
        return (_sqlite3changeset_apply_strm = Module[
          '_sqlite3changeset_apply_strm'
        ] =
          Module['asm']['sqlite3changeset_apply_strm']).apply(null, arguments);
      });

    var _sqlite3changegroup_new = (Module['_sqlite3changegroup_new'] =
      function () {
        return (_sqlite3changegroup_new = Module['_sqlite3changegroup_new'] =
          Module['asm']['sqlite3changegroup_new']).apply(null, arguments);
      });

    var _sqlite3changegroup_add = (Module['_sqlite3changegroup_add'] =
      function () {
        return (_sqlite3changegroup_add = Module['_sqlite3changegroup_add'] =
          Module['asm']['sqlite3changegroup_add']).apply(null, arguments);
      });

    var _sqlite3changegroup_output = (Module['_sqlite3changegroup_output'] =
      function () {
        return (_sqlite3changegroup_output = Module[
          '_sqlite3changegroup_output'
        ] =
          Module['asm']['sqlite3changegroup_output']).apply(null, arguments);
      });

    var _sqlite3changegroup_add_strm = (Module['_sqlite3changegroup_add_strm'] =
      function () {
        return (_sqlite3changegroup_add_strm = Module[
          '_sqlite3changegroup_add_strm'
        ] =
          Module['asm']['sqlite3changegroup_add_strm']).apply(null, arguments);
      });

    var _sqlite3changegroup_output_strm = (Module[
      '_sqlite3changegroup_output_strm'
    ] = function () {
      return (_sqlite3changegroup_output_strm = Module[
        '_sqlite3changegroup_output_strm'
      ] =
        Module['asm']['sqlite3changegroup_output_strm']).apply(null, arguments);
    });

    var _sqlite3changegroup_delete = (Module['_sqlite3changegroup_delete'] =
      function () {
        return (_sqlite3changegroup_delete = Module[
          '_sqlite3changegroup_delete'
        ] =
          Module['asm']['sqlite3changegroup_delete']).apply(null, arguments);
      });

    var _sqlite3changeset_concat = (Module['_sqlite3changeset_concat'] =
      function () {
        return (_sqlite3changeset_concat = Module['_sqlite3changeset_concat'] =
          Module['asm']['sqlite3changeset_concat']).apply(null, arguments);
      });

    var _sqlite3changeset_concat_strm = (Module[
      '_sqlite3changeset_concat_strm'
    ] = function () {
      return (_sqlite3changeset_concat_strm = Module[
        '_sqlite3changeset_concat_strm'
      ] =
        Module['asm']['sqlite3changeset_concat_strm']).apply(null, arguments);
    });

    var _sqlite3session_config = (Module['_sqlite3session_config'] =
      function () {
        return (_sqlite3session_config = Module['_sqlite3session_config'] =
          Module['asm']['sqlite3session_config']).apply(null, arguments);
      });

    var _sqlite3_sourceid = (Module['_sqlite3_sourceid'] = function () {
      return (_sqlite3_sourceid = Module['_sqlite3_sourceid'] =
        Module['asm']['sqlite3_sourceid']).apply(null, arguments);
    });

    var _sqlite3_wasm_pstack_ptr = (Module['_sqlite3_wasm_pstack_ptr'] =
      function () {
        return (_sqlite3_wasm_pstack_ptr = Module['_sqlite3_wasm_pstack_ptr'] =
          Module['asm']['sqlite3_wasm_pstack_ptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_pstack_restore = (Module['_sqlite3_wasm_pstack_restore'] =
      function () {
        return (_sqlite3_wasm_pstack_restore = Module[
          '_sqlite3_wasm_pstack_restore'
        ] =
          Module['asm']['sqlite3_wasm_pstack_restore']).apply(null, arguments);
      });

    var _sqlite3_wasm_pstack_alloc = (Module['_sqlite3_wasm_pstack_alloc'] =
      function () {
        return (_sqlite3_wasm_pstack_alloc = Module[
          '_sqlite3_wasm_pstack_alloc'
        ] =
          Module['asm']['sqlite3_wasm_pstack_alloc']).apply(null, arguments);
      });

    var _sqlite3_wasm_pstack_remaining = (Module[
      '_sqlite3_wasm_pstack_remaining'
    ] = function () {
      return (_sqlite3_wasm_pstack_remaining = Module[
        '_sqlite3_wasm_pstack_remaining'
      ] =
        Module['asm']['sqlite3_wasm_pstack_remaining']).apply(null, arguments);
    });

    var _sqlite3_wasm_pstack_quota = (Module['_sqlite3_wasm_pstack_quota'] =
      function () {
        return (_sqlite3_wasm_pstack_quota = Module[
          '_sqlite3_wasm_pstack_quota'
        ] =
          Module['asm']['sqlite3_wasm_pstack_quota']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_error = (Module['_sqlite3_wasm_db_error'] =
      function () {
        return (_sqlite3_wasm_db_error = Module['_sqlite3_wasm_db_error'] =
          Module['asm']['sqlite3_wasm_db_error']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_struct = (Module['_sqlite3_wasm_test_struct'] =
      function () {
        return (_sqlite3_wasm_test_struct = Module[
          '_sqlite3_wasm_test_struct'
        ] =
          Module['asm']['sqlite3_wasm_test_struct']).apply(null, arguments);
      });

    var _sqlite3_wasm_enum_json = (Module['_sqlite3_wasm_enum_json'] =
      function () {
        return (_sqlite3_wasm_enum_json = Module['_sqlite3_wasm_enum_json'] =
          Module['asm']['sqlite3_wasm_enum_json']).apply(null, arguments);
      });

    var _sqlite3_wasm_vfs_unlink = (Module['_sqlite3_wasm_vfs_unlink'] =
      function () {
        return (_sqlite3_wasm_vfs_unlink = Module['_sqlite3_wasm_vfs_unlink'] =
          Module['asm']['sqlite3_wasm_vfs_unlink']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_vfs = (Module['_sqlite3_wasm_db_vfs'] = function () {
      return (_sqlite3_wasm_db_vfs = Module['_sqlite3_wasm_db_vfs'] =
        Module['asm']['sqlite3_wasm_db_vfs']).apply(null, arguments);
    });

    var _sqlite3_wasm_db_reset = (Module['_sqlite3_wasm_db_reset'] =
      function () {
        return (_sqlite3_wasm_db_reset = Module['_sqlite3_wasm_db_reset'] =
          Module['asm']['sqlite3_wasm_db_reset']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_export_chunked = (Module[
      '_sqlite3_wasm_db_export_chunked'
    ] = function () {
      return (_sqlite3_wasm_db_export_chunked = Module[
        '_sqlite3_wasm_db_export_chunked'
      ] =
        Module['asm']['sqlite3_wasm_db_export_chunked']).apply(null, arguments);
    });

    var _sqlite3_wasm_db_serialize = (Module['_sqlite3_wasm_db_serialize'] =
      function () {
        return (_sqlite3_wasm_db_serialize = Module[
          '_sqlite3_wasm_db_serialize'
        ] =
          Module['asm']['sqlite3_wasm_db_serialize']).apply(null, arguments);
      });

    var _sqlite3_wasm_vfs_create_file = (Module[
      '_sqlite3_wasm_vfs_create_file'
    ] = function () {
      return (_sqlite3_wasm_vfs_create_file = Module[
        '_sqlite3_wasm_vfs_create_file'
      ] =
        Module['asm']['sqlite3_wasm_vfs_create_file']).apply(null, arguments);
    });

    var _sqlite3_wasm_posix_create_file = (Module[
      '_sqlite3_wasm_posix_create_file'
    ] = function () {
      return (_sqlite3_wasm_posix_create_file = Module[
        '_sqlite3_wasm_posix_create_file'
      ] =
        Module['asm']['sqlite3_wasm_posix_create_file']).apply(null, arguments);
    });

    var _sqlite3_wasm_kvvfsMakeKeyOnPstack = (Module[
      '_sqlite3_wasm_kvvfsMakeKeyOnPstack'
    ] = function () {
      return (_sqlite3_wasm_kvvfsMakeKeyOnPstack = Module[
        '_sqlite3_wasm_kvvfsMakeKeyOnPstack'
      ] =
        Module['asm']['sqlite3_wasm_kvvfsMakeKeyOnPstack']).apply(
        null,
        arguments,
      );
    });

    var _sqlite3_wasm_kvvfs_methods = (Module['_sqlite3_wasm_kvvfs_methods'] =
      function () {
        return (_sqlite3_wasm_kvvfs_methods = Module[
          '_sqlite3_wasm_kvvfs_methods'
        ] =
          Module['asm']['sqlite3_wasm_kvvfs_methods']).apply(null, arguments);
      });

    var _sqlite3_wasm_vtab_config = (Module['_sqlite3_wasm_vtab_config'] =
      function () {
        return (_sqlite3_wasm_vtab_config = Module[
          '_sqlite3_wasm_vtab_config'
        ] =
          Module['asm']['sqlite3_wasm_vtab_config']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_config_ip = (Module['_sqlite3_wasm_db_config_ip'] =
      function () {
        return (_sqlite3_wasm_db_config_ip = Module[
          '_sqlite3_wasm_db_config_ip'
        ] =
          Module['asm']['sqlite3_wasm_db_config_ip']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_config_pii = (Module['_sqlite3_wasm_db_config_pii'] =
      function () {
        return (_sqlite3_wasm_db_config_pii = Module[
          '_sqlite3_wasm_db_config_pii'
        ] =
          Module['asm']['sqlite3_wasm_db_config_pii']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_config_s = (Module['_sqlite3_wasm_db_config_s'] =
      function () {
        return (_sqlite3_wasm_db_config_s = Module[
          '_sqlite3_wasm_db_config_s'
        ] =
          Module['asm']['sqlite3_wasm_db_config_s']).apply(null, arguments);
      });

    var _sqlite3_wasm_config_i = (Module['_sqlite3_wasm_config_i'] =
      function () {
        return (_sqlite3_wasm_config_i = Module['_sqlite3_wasm_config_i'] =
          Module['asm']['sqlite3_wasm_config_i']).apply(null, arguments);
      });

    var _sqlite3_wasm_config_ii = (Module['_sqlite3_wasm_config_ii'] =
      function () {
        return (_sqlite3_wasm_config_ii = Module['_sqlite3_wasm_config_ii'] =
          Module['asm']['sqlite3_wasm_config_ii']).apply(null, arguments);
      });

    var _sqlite3_wasm_config_j = (Module['_sqlite3_wasm_config_j'] =
      function () {
        return (_sqlite3_wasm_config_j = Module['_sqlite3_wasm_config_j'] =
          Module['asm']['sqlite3_wasm_config_j']).apply(null, arguments);
      });

    var _sqlite3_wasm_init_wasmfs = (Module['_sqlite3_wasm_init_wasmfs'] =
      function () {
        return (_sqlite3_wasm_init_wasmfs = Module[
          '_sqlite3_wasm_init_wasmfs'
        ] =
          Module['asm']['sqlite3_wasm_init_wasmfs']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_intptr = (Module['_sqlite3_wasm_test_intptr'] =
      function () {
        return (_sqlite3_wasm_test_intptr = Module[
          '_sqlite3_wasm_test_intptr'
        ] =
          Module['asm']['sqlite3_wasm_test_intptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_voidptr = (Module['_sqlite3_wasm_test_voidptr'] =
      function () {
        return (_sqlite3_wasm_test_voidptr = Module[
          '_sqlite3_wasm_test_voidptr'
        ] =
          Module['asm']['sqlite3_wasm_test_voidptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_int64_max = (Module['_sqlite3_wasm_test_int64_max'] =
      function () {
        return (_sqlite3_wasm_test_int64_max = Module[
          '_sqlite3_wasm_test_int64_max'
        ] =
          Module['asm']['sqlite3_wasm_test_int64_max']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_int64_min = (Module['_sqlite3_wasm_test_int64_min'] =
      function () {
        return (_sqlite3_wasm_test_int64_min = Module[
          '_sqlite3_wasm_test_int64_min'
        ] =
          Module['asm']['sqlite3_wasm_test_int64_min']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_int64_times2 = (Module[
      '_sqlite3_wasm_test_int64_times2'
    ] = function () {
      return (_sqlite3_wasm_test_int64_times2 = Module[
        '_sqlite3_wasm_test_int64_times2'
      ] =
        Module['asm']['sqlite3_wasm_test_int64_times2']).apply(null, arguments);
    });

    var _sqlite3_wasm_test_int64_minmax = (Module[
      '_sqlite3_wasm_test_int64_minmax'
    ] = function () {
      return (_sqlite3_wasm_test_int64_minmax = Module[
        '_sqlite3_wasm_test_int64_minmax'
      ] =
        Module['asm']['sqlite3_wasm_test_int64_minmax']).apply(null, arguments);
    });

    var _sqlite3_wasm_test_int64ptr = (Module['_sqlite3_wasm_test_int64ptr'] =
      function () {
        return (_sqlite3_wasm_test_int64ptr = Module[
          '_sqlite3_wasm_test_int64ptr'
        ] =
          Module['asm']['sqlite3_wasm_test_int64ptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_stack_overflow = (Module[
      '_sqlite3_wasm_test_stack_overflow'
    ] = function () {
      return (_sqlite3_wasm_test_stack_overflow = Module[
        '_sqlite3_wasm_test_stack_overflow'
      ] =
        Module['asm']['sqlite3_wasm_test_stack_overflow']).apply(
        null,
        arguments,
      );
    });

    var _sqlite3_wasm_test_str_hello = (Module['_sqlite3_wasm_test_str_hello'] =
      function () {
        return (_sqlite3_wasm_test_str_hello = Module[
          '_sqlite3_wasm_test_str_hello'
        ] =
          Module['asm']['sqlite3_wasm_test_str_hello']).apply(null, arguments);
      });

    var _sqlite3_wasm_SQLTester_strglob = (Module[
      '_sqlite3_wasm_SQLTester_strglob'
    ] = function () {
      return (_sqlite3_wasm_SQLTester_strglob = Module[
        '_sqlite3_wasm_SQLTester_strglob'
      ] =
        Module['asm']['sqlite3_wasm_SQLTester_strglob']).apply(null, arguments);
    });

    var _malloc = (Module['_malloc'] = function () {
      return (_malloc = Module['_malloc'] = Module['asm']['malloc']).apply(
        null,
        arguments,
      );
    });

    var _free = (Module['_free'] = function () {
      return (_free = Module['_free'] = Module['asm']['free']).apply(
        null,
        arguments,
      );
    });

    var _realloc = (Module['_realloc'] = function () {
      return (_realloc = Module['_realloc'] = Module['asm']['realloc']).apply(
        null,
        arguments,
      );
    });

    var _emscripten_builtin_memalign = (Module['_emscripten_builtin_memalign'] =
      function () {
        return (_emscripten_builtin_memalign = Module[
          '_emscripten_builtin_memalign'
        ] =
          Module['asm']['emscripten_builtin_memalign']).apply(null, arguments);
      });

    var stackSave = (Module['stackSave'] = function () {
      return (stackSave = Module['stackSave'] =
        Module['asm']['stackSave']).apply(null, arguments);
    });

    var stackRestore = (Module['stackRestore'] = function () {
      return (stackRestore = Module['stackRestore'] =
        Module['asm']['stackRestore']).apply(null, arguments);
    });

    var stackAlloc = (Module['stackAlloc'] = function () {
      return (stackAlloc = Module['stackAlloc'] =
        Module['asm']['stackAlloc']).apply(null, arguments);
    });

    Module['wasmMemory'] = wasmMemory;

    var calledRun;

    dependenciesFulfilled = function runCaller() {
      if (!calledRun) run();
      if (!calledRun) dependenciesFulfilled = runCaller;
    };

    function run(args) {
      args = args || arguments_;

      if (runDependencies > 0) {
        return;
      }

      preRun();

      if (runDependencies > 0) {
        return;
      }

      function doRun() {
        if (calledRun) return;
        calledRun = true;
        Module['calledRun'] = true;

        if (ABORT) return;

        initRuntime();

        readyPromiseResolve(Module);
        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

        postRun();
      }

      if (Module['setStatus']) {
        Module['setStatus']('Running...');
        setTimeout(function () {
          setTimeout(function () {
            Module['setStatus']('');
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }

    if (Module['preInit']) {
      if (typeof Module['preInit'] == 'function')
        Module['preInit'] = [Module['preInit']];
      while (Module['preInit'].length > 0) {
        Module['preInit'].pop()();
      }
    }

    run();

    if (!Module.postRun) Module.postRun = [];
    Module.postRun.push(function (Module) {
      'use strict';

      'use strict';
      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(
        apiConfig = globalThis.sqlite3ApiConfig ||
          sqlite3ApiBootstrap.defaultConfig,
      ) {
        if (sqlite3ApiBootstrap.sqlite3) {
          console.warn(
            'sqlite3ApiBootstrap() called multiple times.',
            'Config and external initializers are ignored on calls after the first.',
          );
          return sqlite3ApiBootstrap.sqlite3;
        }
        const config = Object.assign(
          Object.create(null),
          {
            exports: undefined,
            memory: undefined,
            bigIntEnabled: (() => {
              if ('undefined' !== typeof Module) {
                return !!Module.HEAPU64;
              }
              return !!globalThis.BigInt64Array;
            })(),
            debug: console.debug.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console),
            log: console.log.bind(console),
            wasmfsOpfsDir: '/opfs',

            useStdAlloc: false,
          },
          apiConfig || {},
        );

        Object.assign(
          config,
          {
            allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',
            deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',
            reallocExportName: config.useStdAlloc
              ? 'realloc'
              : 'sqlite3_realloc',
          },
          config,
        );

        ['exports', 'memory', 'wasmfsOpfsDir'].forEach((k) => {
          if ('function' === typeof config[k]) {
            config[k] = config[k]();
          }
        });

        const capi = Object.create(null);

        const wasm = Object.create(null);

        const __rcStr = (rc) => {
          return (
            (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc)) ||
            'Unknown result code #' + rc
          );
        };

        const __isInt = (n) => 'number' === typeof n && n === (n | 0);

        class SQLite3Error extends Error {
          constructor(...args) {
            let rc;
            if (args.length) {
              if (__isInt(args[0])) {
                rc = args[0];
                if (1 === args.length) {
                  super(__rcStr(args[0]));
                } else {
                  const rcStr = __rcStr(rc);
                  if ('object' === typeof args[1]) {
                    super(rcStr, args[1]);
                  } else {
                    args[0] = rcStr + ':';
                    super(args.join(' '));
                  }
                }
              } else {
                if (2 === args.length && 'object' === typeof args[1]) {
                  super(...args);
                } else {
                  super(args.join(' '));
                }
              }
            }
            this.resultCode = rc || capi.SQLITE_ERROR;
            this.name = 'SQLite3Error';
          }
        }

        SQLite3Error.toss = (...args) => {
          throw new SQLite3Error(...args);
        };
        const toss3 = SQLite3Error.toss;

        if (config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)) {
          toss3(
            "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.",
          );
        }

        const isInt32 = (n) => {
          return (
            'bigint' !== typeof n &&
            !!(n === (n | 0) && n <= 2147483647 && n >= -2147483648)
          );
        };

        const bigIntFits64 = function f(b) {
          if (!f._max) {
            f._max = BigInt('0x7fffffffffffffff');
            f._min = ~f._max;
          }
          return b >= f._min && b <= f._max;
        };

        const bigIntFits32 = (b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn;

        const bigIntFitsDouble = function f(b) {
          if (!f._min) {
            f._min = Number.MIN_SAFE_INTEGER;
            f._max = Number.MAX_SAFE_INTEGER;
          }
          return b >= f._min && b <= f._max;
        };

        const isTypedArray = (v) => {
          return v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)
            ? v
            : false;
        };

        const __SAB =
          'undefined' === typeof SharedArrayBuffer
            ? function () {}
            : SharedArrayBuffer;

        const isSharedTypedArray = (aTypedArray) =>
          aTypedArray.buffer instanceof __SAB;

        const typedArrayPart = (aTypedArray, begin, end) => {
          return isSharedTypedArray(aTypedArray)
            ? aTypedArray.slice(begin, end)
            : aTypedArray.subarray(begin, end);
        };

        const isBindableTypedArray = (v) => {
          return (
            v &&
            (v instanceof Uint8Array ||
              v instanceof Int8Array ||
              v instanceof ArrayBuffer)
          );
        };

        const isSQLableTypedArray = (v) => {
          return (
            v &&
            (v instanceof Uint8Array ||
              v instanceof Int8Array ||
              v instanceof ArrayBuffer)
          );
        };

        const affirmBindableTypedArray = (v) => {
          return (
            isBindableTypedArray(v) ||
            toss3('Value is not of a supported TypedArray type.')
          );
        };

        const utf8Decoder = new TextDecoder('utf-8');

        const typedArrayToString = function (typedArray, begin, end) {
          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
        };

        const flexibleString = function (v) {
          if (isSQLableTypedArray(v)) {
            return typedArrayToString(
              v instanceof ArrayBuffer ? new Uint8Array(v) : v,
            );
          } else if (Array.isArray(v)) return v.join('');
          else if (wasm.isPtr(v)) v = wasm.cstrToJs(v);
          return v;
        };

        class WasmAllocError extends Error {
          constructor(...args) {
            if (2 === args.length && 'object' === typeof args[1]) {
              super(...args);
            } else if (args.length) {
              super(args.join(' '));
            } else {
              super('Allocation failed.');
            }
            this.resultCode = capi.SQLITE_NOMEM;
            this.name = 'WasmAllocError';
          }
        }

        WasmAllocError.toss = (...args) => {
          throw new WasmAllocError(...args);
        };

        Object.assign(capi, {
          sqlite3_bind_blob: undefined,

          sqlite3_bind_text: undefined,

          sqlite3_create_function_v2: (
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
            xDestroy,
          ) => {},

          sqlite3_create_function: (
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
          ) => {},

          sqlite3_create_window_function: (
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xStep,
            xFinal,
            xValue,
            xInverse,
            xDestroy,
          ) => {},

          sqlite3_prepare_v3: (
            dbPtr,
            sql,
            sqlByteLen,
            prepFlags,
            stmtPtrPtr,
            strPtrPtr,
          ) => {},

          sqlite3_prepare_v2: (
            dbPtr,
            sql,
            sqlByteLen,
            stmtPtrPtr,
            strPtrPtr,
          ) => {},

          sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg) => {},

          sqlite3_randomness: (n, outPtr) => {},
        });

        const util = {
          affirmBindableTypedArray,
          flexibleString,
          bigIntFits32,
          bigIntFits64,
          bigIntFitsDouble,
          isBindableTypedArray,
          isInt32,
          isSQLableTypedArray,
          isTypedArray,
          typedArrayToString,
          isUIThread: () =>
            globalThis.window === globalThis && !!globalThis.document,

          isSharedTypedArray,
          toss: function (...args) {
            throw new Error(args.join(' '));
          },
          toss3,
          typedArrayPart,

          affirmDbHeader: function (bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            const header = 'SQLite format 3';
            if (header.length > bytes.byteLength) {
              toss3('Input does not contain an SQLite3 database header.');
            }
            for (let i = 0; i < header.length; ++i) {
              if (header.charCodeAt(i) !== bytes[i]) {
                toss3('Input does not contain an SQLite3 database header.');
              }
            }
          },

          affirmIsDb: function (bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            const n = bytes.byteLength;
            if (n < 512 || n % 512 !== 0) {
              toss3('Byte array size', n, 'is invalid for an SQLite3 db.');
            }
            util.affirmDbHeader(bytes);
          },
        };

        Object.assign(wasm, {
          ptrSizeof: config.wasmPtrSizeof || 4,

          ptrIR: config.wasmPtrIR || 'i32',

          bigIntEnabled: !!config.bigIntEnabled,

          exports:
            config.exports ||
            toss3('Missing API config.exports (WASM module exports).'),

          memory:
            config.memory ||
            config.exports['memory'] ||
            toss3(
              'API config object requires a WebAssembly.Memory object',
              'in either config.exports.memory (exported)',
              'or config.memory (imported).',
            ),

          alloc: undefined,

          realloc: undefined,

          dealloc: undefined,
        });

        wasm.allocFromTypedArray = function (srcTypedArray) {
          if (srcTypedArray instanceof ArrayBuffer) {
            srcTypedArray = new Uint8Array(srcTypedArray);
          }
          affirmBindableTypedArray(srcTypedArray);
          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
          wasm
            .heapForSize(srcTypedArray.constructor)
            .set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
          return pRet;
        };

        {
          const keyAlloc = config.allocExportName,
            keyDealloc = config.deallocExportName,
            keyRealloc = config.reallocExportName;
          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {
            const f = wasm.exports[key];
            if (!(f instanceof Function))
              toss3('Missing required exports[', key, '] function.');
          }

          wasm.alloc = function f(n) {
            return (
              f.impl(n) ||
              WasmAllocError.toss('Failed to allocate', n, ' bytes.')
            );
          };
          wasm.alloc.impl = wasm.exports[keyAlloc];
          wasm.realloc = function f(m, n) {
            const m2 = f.impl(m, n);
            return n
              ? m2 || WasmAllocError.toss('Failed to reallocate', n, ' bytes.')
              : 0;
          };
          wasm.realloc.impl = wasm.exports[keyRealloc];
          wasm.dealloc = wasm.exports[keyDealloc];
        }

        wasm.compileOptionUsed = function f(optName) {
          if (!arguments.length) {
            if (f._result) return f._result;
            else if (!f._opt) {
              f._rx = /^([^=]+)=(.+)/;
              f._rxInt = /^-?\d+$/;
              f._opt = function (opt, rv) {
                const m = f._rx.exec(opt);
                rv[0] = m ? m[1] : opt;
                rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;
              };
            }
            const rc = {},
              ov = [0, 0];
            let i = 0,
              k;
            while ((k = capi.sqlite3_compileoption_get(i++))) {
              f._opt(k, ov);
              rc[ov[0]] = ov[1];
            }
            return (f._result = rc);
          } else if (Array.isArray(optName)) {
            const rc = {};
            optName.forEach((v) => {
              rc[v] = capi.sqlite3_compileoption_used(v);
            });
            return rc;
          } else if ('object' === typeof optName) {
            Object.keys(optName).forEach((k) => {
              optName[k] = capi.sqlite3_compileoption_used(k);
            });
            return optName;
          }
          return 'string' === typeof optName
            ? !!capi.sqlite3_compileoption_used(optName)
            : false;
        };

        wasm.pstack = Object.assign(Object.create(null), {
          restore: wasm.exports.sqlite3_wasm_pstack_restore,

          alloc: function (n) {
            if ('string' === typeof n && !(n = wasm.sizeofIR(n))) {
              WasmAllocError.toss(
                'Invalid value for pstack.alloc(',
                arguments[0],
                ')',
              );
            }
            return (
              wasm.exports.sqlite3_wasm_pstack_alloc(n) ||
              WasmAllocError.toss(
                'Could not allocate',
                n,
                'bytes from the pstack.',
              )
            );
          },

          allocChunks: function (n, sz) {
            if ('string' === typeof sz && !(sz = wasm.sizeofIR(sz))) {
              WasmAllocError.toss(
                'Invalid size value for allocChunks(',
                arguments[1],
                ')',
              );
            }
            const mem = wasm.pstack.alloc(n * sz);
            const rc = [];
            let i = 0,
              offset = 0;
            for (; i < n; ++i, offset += sz) rc.push(mem + offset);
            return rc;
          },

          allocPtr: (n = 1, safePtrSize = true) => {
            return 1 === n
              ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)
              : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);
          },

          call: function (f) {
            const stackPos = wasm.pstack.pointer;
            try {
              return f(sqlite3);
            } finally {
              wasm.pstack.restore(stackPos);
            }
          },
        });
        Object.defineProperties(wasm.pstack, {
          pointer: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3_wasm_pstack_ptr,
          },

          quota: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3_wasm_pstack_quota,
          },

          remaining: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3_wasm_pstack_remaining,
          },
        });

        capi.sqlite3_randomness = (...args) => {
          if (
            1 === args.length &&
            util.isTypedArray(args[0]) &&
            1 === args[0].BYTES_PER_ELEMENT
          ) {
            const ta = args[0];
            if (0 === ta.byteLength) {
              wasm.exports.sqlite3_randomness(0, 0);
              return ta;
            }
            const stack = wasm.pstack.pointer;
            try {
              let n = ta.byteLength,
                offset = 0;
              const r = wasm.exports.sqlite3_randomness;
              const heap = wasm.heap8u();
              const nAlloc = n < 512 ? n : 512;
              const ptr = wasm.pstack.alloc(nAlloc);
              do {
                const j = n > nAlloc ? nAlloc : n;
                r(j, ptr);
                ta.set(typedArrayPart(heap, ptr, ptr + j), offset);
                n -= j;
                offset += j;
              } while (n > 0);
            } catch (e) {
              console.error(
                'Highly unexpected (and ignored!) ' +
                  'exception in sqlite3_randomness():',
                e,
              );
            } finally {
              wasm.pstack.restore(stack);
            }
            return ta;
          }
          wasm.exports.sqlite3_randomness(...args);
        };

        let __wasmfsOpfsDir = undefined;

        capi.sqlite3_wasmfs_opfs_dir = function () {
          if (undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;

          const pdir = config.wasmfsOpfsDir;
          if (
            !pdir ||
            !globalThis.FileSystemHandle ||
            !globalThis.FileSystemDirectoryHandle ||
            !globalThis.FileSystemFileHandle
          ) {
            return (__wasmfsOpfsDir = '');
          }
          try {
            if (
              pdir &&
              0 ===
                wasm.xCallWrapped(
                  'sqlite3_wasm_init_wasmfs',
                  'i32',
                  ['string'],
                  pdir,
                )
            ) {
              return (__wasmfsOpfsDir = pdir);
            } else {
              return (__wasmfsOpfsDir = '');
            }
          } catch (e) {
            return (__wasmfsOpfsDir = '');
          }
        };

        capi.sqlite3_wasmfs_filename_is_persistent = function (name) {
          const p = capi.sqlite3_wasmfs_opfs_dir();
          return p && name ? name.startsWith(p + '/') : false;
        };

        capi.sqlite3_js_db_uses_vfs = function (pDb, vfsName, dbName = 0) {
          try {
            const pK = capi.sqlite3_vfs_find(vfsName);
            if (!pK) return false;
            else if (!pDb) {
              return pK === capi.sqlite3_vfs_find(0) ? pK : false;
            } else {
              return pK === capi.sqlite3_js_db_vfs(pDb, dbName) ? pK : false;
            }
          } catch (e) {
            return false;
          }
        };

        capi.sqlite3_js_vfs_list = function () {
          const rc = [];
          let pVfs = capi.sqlite3_vfs_find(0);
          while (pVfs) {
            const oVfs = new capi.sqlite3_vfs(pVfs);
            rc.push(wasm.cstrToJs(oVfs.$zName));
            pVfs = oVfs.$pNext;
            oVfs.dispose();
          }
          return rc;
        };

        capi.sqlite3_js_db_export = function (pDb, schema = 0) {
          pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);
          if (!pDb) toss3('Invalid sqlite3* argument.');
          if (!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');
          const scope = wasm.scopedAllocPush();
          let pOut;
          try {
            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
            const ppOut = pSize + 8;

            const zSchema = schema
              ? wasm.isPtr(schema)
                ? schema
                : wasm.scopedAllocCString('' + schema)
              : 0;
            let rc = wasm.exports.sqlite3_wasm_db_serialize(
              pDb,
              zSchema,
              ppOut,
              pSize,
              0,
            );
            if (rc) {
              toss3(
                'Database serialization failed with code',
                sqlite3.capi.sqlite3_js_rc_str(rc),
              );
            }
            pOut = wasm.peekPtr(ppOut);
            const nOut = wasm.peek(pSize, 'i64');
            rc = nOut
              ? wasm.heap8u().slice(pOut, pOut + Number(nOut))
              : new Uint8Array();
            return rc;
          } finally {
            if (pOut) wasm.exports.sqlite3_free(pOut);
            wasm.scopedAllocPop(scope);
          }
        };

        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) =>
          wasm.sqlite3_wasm_db_vfs(dbPointer, dbName);

        capi.sqlite3_js_aggregate_context = (pCtx, n) => {
          return (
            capi.sqlite3_aggregate_context(pCtx, n) ||
            (n
              ? WasmAllocError.toss(
                  'Cannot allocate',
                  n,
                  'bytes for sqlite3_aggregate_context()',
                )
              : 0)
          );
        };

        capi.sqlite3_js_posix_create_file = function (filename, data, dataLen) {
          let pData;
          if (data && wasm.isPtr(data)) {
            pData = data;
          } else if (
            data instanceof ArrayBuffer ||
            data instanceof Uint8Array
          ) {
            pData = wasm.allocFromTypedArray(data);
            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
              dataLen = data.byteLength;
            }
          } else {
            SQLite3Error.toss(
              'Invalid 2nd argument for sqlite3_js_posix_create_file().',
            );
          }
          try {
            if (!util.isInt32(dataLen) || dataLen < 0) {
              SQLite3Error.toss(
                'Invalid 3rd argument for sqlite3_js_posix_create_file().',
              );
            }
            const rc = wasm.sqlite3_wasm_posix_create_file(
              filename,
              pData,
              dataLen,
            );
            if (rc)
              SQLite3Error.toss(
                'Creation of file failed with sqlite3 result code',
                capi.sqlite3_js_rc_str(rc),
              );
          } finally {
            wasm.dealloc(pData);
          }
        };

        capi.sqlite3_js_vfs_create_file = function (
          vfs,
          filename,
          data,
          dataLen,
        ) {
          config.warn(
            'sqlite3_js_vfs_create_file() is deprecated and',
            'should be avoided because it can lead to C-level crashes.',
            'See its documentation for alternative options.',
          );
          let pData;
          if (data) {
            if (wasm.isPtr(data)) {
              pData = data;
            } else if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            if (data instanceof Uint8Array) {
              pData = wasm.allocFromTypedArray(data);
              if (
                arguments.length < 4 ||
                !util.isInt32(dataLen) ||
                dataLen < 0
              ) {
                dataLen = data.byteLength;
              }
            } else {
              SQLite3Error.toss(
                'Invalid 3rd argument type for sqlite3_js_vfs_create_file().',
              );
            }
          } else {
            pData = 0;
          }
          if (!util.isInt32(dataLen) || dataLen < 0) {
            wasm.dealloc(pData);
            SQLite3Error.toss(
              'Invalid 4th argument for sqlite3_js_vfs_create_file().',
            );
          }
          try {
            const rc = wasm.sqlite3_wasm_vfs_create_file(
              vfs,
              filename,
              pData,
              dataLen,
            );
            if (rc)
              SQLite3Error.toss(
                'Creation of file failed with sqlite3 result code',
                capi.sqlite3_js_rc_str(rc),
              );
          } finally {
            wasm.dealloc(pData);
          }
        };

        capi.sqlite3_js_sql_to_string = (sql) => {
          if ('string' === typeof sql) {
            return sql;
          }
          const x = flexibleString(v);
          return x === v ? undefined : x;
        };

        if (util.isUIThread()) {
          const __kvvfsInfo = function (which) {
            const rc = Object.create(null);
            rc.prefix = 'kvvfs-' + which;
            rc.stores = [];
            if ('session' === which || '' === which)
              rc.stores.push(globalThis.sessionStorage);
            if ('local' === which || '' === which)
              rc.stores.push(globalThis.localStorage);
            return rc;
          };

          capi.sqlite3_js_kvvfs_clear = function (which = '') {
            let rc = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s) => {
              const toRm = [];
              let i;
              for (i = 0; i < s.length; ++i) {
                const k = s.key(i);
                if (k.startsWith(kvinfo.prefix)) toRm.push(k);
              }
              toRm.forEach((kk) => s.removeItem(kk));
              rc += toRm.length;
            });
            return rc;
          };

          capi.sqlite3_js_kvvfs_size = function (which = '') {
            let sz = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s) => {
              let i;
              for (i = 0; i < s.length; ++i) {
                const k = s.key(i);
                if (k.startsWith(kvinfo.prefix)) {
                  sz += k.length;
                  sz += s.getItem(k).length;
                }
              }
            });
            return sz * 2;
          };
        }

        capi.sqlite3_db_config = function (pDb, op, ...args) {
          if (!this.s) {
            this.s = wasm.xWrap('sqlite3_wasm_db_config_s', 'int', [
              'sqlite3*',
              'int',
              'string:static',
            ]);
            this.pii = wasm.xWrap('sqlite3_wasm_db_config_pii', 'int', [
              'sqlite3*',
              'int',
              '*',
              'int',
              'int',
            ]);
            this.ip = wasm.xWrap('sqlite3_wasm_db_config_ip', 'int', [
              'sqlite3*',
              'int',
              'int',
              '*',
            ]);
          }
          switch (op) {
            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
            case capi.SQLITE_DBCONFIG_RESET_DATABASE:
            case capi.SQLITE_DBCONFIG_DEFENSIVE:
            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
            case capi.SQLITE_DBCONFIG_DQS_DML:
            case capi.SQLITE_DBCONFIG_DQS_DDL:
            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
              return this.ip(pDb, op, args[0], args[1] || 0);
            case capi.SQLITE_DBCONFIG_LOOKASIDE:
              return this.pii(pDb, op, args[0], args[1], args[2]);
            case capi.SQLITE_DBCONFIG_MAINDBNAME:
              return this.s(pDb, op, args[0]);
            default:
              return capi.SQLITE_MISUSE;
          }
        }.bind(Object.create(null));

        capi.sqlite3_value_to_js = function (
          pVal,
          throwIfCannotConvert = true,
        ) {
          let arg;
          const valType = capi.sqlite3_value_type(pVal);
          switch (valType) {
            case capi.SQLITE_INTEGER:
              if (wasm.bigIntEnabled) {
                arg = capi.sqlite3_value_int64(pVal);
                if (util.bigIntFitsDouble(arg)) arg = Number(arg);
              } else arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_FLOAT:
              arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_TEXT:
              arg = capi.sqlite3_value_text(pVal);
              break;
            case capi.SQLITE_BLOB: {
              const n = capi.sqlite3_value_bytes(pVal);
              const pBlob = capi.sqlite3_value_blob(pVal);
              if (n && !pBlob)
                sqlite3.WasmAllocError.toss(
                  'Cannot allocate memory for blob argument of',
                  n,
                  'byte(s)',
                );
              arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;
              break;
            }
            case capi.SQLITE_NULL:
              arg = null;
              break;
            default:
              if (throwIfCannotConvert) {
                toss3(
                  capi.SQLITE_MISMATCH,
                  'Unhandled sqlite3_value_type():',
                  valType,
                );
              }
              arg = undefined;
          }
          return arg;
        };

        capi.sqlite3_values_to_js = function (
          argc,
          pArgv,
          throwIfCannotConvert = true,
        ) {
          let i;
          const tgt = [];
          for (i = 0; i < argc; ++i) {
            tgt.push(
              capi.sqlite3_value_to_js(
                wasm.peekPtr(pArgv + wasm.ptrSizeof * i),
                throwIfCannotConvert,
              ),
            );
          }
          return tgt;
        };

        capi.sqlite3_result_error_js = function (pCtx, e) {
          if (e instanceof WasmAllocError) {
            capi.sqlite3_result_error_nomem(pCtx);
          } else {
            capi.sqlite3_result_error(pCtx, '' + e, -1);
          }
        };

        capi.sqlite3_result_js = function (pCtx, val) {
          if (val instanceof Error) {
            capi.sqlite3_result_error_js(pCtx, val);
            return;
          }
          try {
            switch (typeof val) {
              case 'undefined':
                break;
              case 'boolean':
                capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                break;
              case 'bigint':
                if (util.bigIntFits32(val)) {
                  capi.sqlite3_result_int(pCtx, Number(val));
                } else if (util.bigIntFitsDouble(val)) {
                  capi.sqlite3_result_double(pCtx, Number(val));
                } else if (wasm.bigIntEnabled) {
                  if (util.bigIntFits64(val))
                    capi.sqlite3_result_int64(pCtx, val);
                  else
                    toss3(
                      'BigInt value',
                      val.toString(),
                      'is too BigInt for int64.',
                    );
                } else {
                  toss3('BigInt value', val.toString(), 'is too BigInt.');
                }
                break;
              case 'number': {
                let f;
                if (util.isInt32(val)) {
                  f = capi.sqlite3_result_int;
                } else if (
                  wasm.bigIntEnabled &&
                  Number.isInteger(val) &&
                  util.bigIntFits64(BigInt(val))
                ) {
                  f = capi.sqlite3_result_int64;
                } else {
                  f = capi.sqlite3_result_double;
                }
                f(pCtx, val);
                break;
              }
              case 'string': {
                const [p, n] = wasm.allocCString(val, true);
                capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);
                break;
              }
              case 'object':
                if (null === val) {
                  capi.sqlite3_result_null(pCtx);
                  break;
                } else if (util.isBindableTypedArray(val)) {
                  const pBlob = wasm.allocFromTypedArray(val);
                  capi.sqlite3_result_blob(
                    pCtx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC,
                  );
                  break;
                }

              default:
                toss3(
                  "Don't not how to handle this UDF result value:",
                  typeof val,
                  val,
                );
            }
          } catch (e) {
            capi.sqlite3_result_error_js(pCtx, e);
          }
        };

        capi.sqlite3_column_js = function (
          pStmt,
          iCol,
          throwIfCannotConvert = true,
        ) {
          const v = capi.sqlite3_column_value(pStmt, iCol);
          return 0 === v
            ? undefined
            : capi.sqlite3_value_to_js(v, throwIfCannotConvert);
        };

        const __newOldValue = function (pObj, iCol, impl) {
          impl = capi[impl];
          if (!this.ptr) this.ptr = wasm.allocPtr();
          else wasm.pokePtr(this.ptr, 0);
          const rc = impl(pObj, iCol, this.ptr);
          if (rc)
            return SQLite3Error.toss(
              rc,
              arguments[2] + '() failed with code ' + rc,
            );
          const pv = wasm.peekPtr(this.ptr);
          return pv ? capi.sqlite3_value_to_js(pv, true) : undefined;
        }.bind(Object.create(null));

        capi.sqlite3_preupdate_new_js = (pDb, iCol) =>
          __newOldValue(pDb, iCol, 'sqlite3_preupdate_new');

        capi.sqlite3_preupdate_old_js = (pDb, iCol) =>
          __newOldValue(pDb, iCol, 'sqlite3_preupdate_old');

        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) =>
          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_new');

        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) =>
          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_old');

        const sqlite3 = {
          WasmAllocError: WasmAllocError,
          SQLite3Error: SQLite3Error,
          capi,
          util,
          wasm,
          config,

          version: Object.create(null),

          client: undefined,

          asyncPostInit: async function ff() {
            if (ff.isReady instanceof Promise) return ff.isReady;
            let lia = sqlite3ApiBootstrap.initializersAsync;
            delete sqlite3ApiBootstrap.initializersAsync;
            const postInit = async () => {
              if (!sqlite3.__isUnderTest) {
                delete sqlite3.util;

                delete sqlite3.StructBinder;
              }
              return sqlite3;
            };
            const catcher = (e) => {
              config.error('an async sqlite3 initializer failed:', e);
              throw e;
            };
            if (!lia || !lia.length) {
              return (ff.isReady = postInit().catch(catcher));
            }
            lia = lia.map((f) => {
              return f instanceof Function ? async (x) => f(sqlite3) : f;
            });
            lia.push(postInit);
            let p = Promise.resolve(sqlite3);
            while (lia.length) p = p.then(lia.shift());
            return (ff.isReady = p.catch(catcher));
          },

          scriptInfo: undefined,
        };
        try {
          sqlite3ApiBootstrap.initializers.forEach((f) => {
            f(sqlite3);
          });
        } catch (e) {
          console.error('sqlite3 bootstrap initializer threw:', e);
          throw e;
        }
        delete sqlite3ApiBootstrap.initializers;
        sqlite3ApiBootstrap.sqlite3 = sqlite3;
        return sqlite3;
      };

      globalThis.sqlite3ApiBootstrap.initializers = [];

      globalThis.sqlite3ApiBootstrap.initializersAsync = [];

      globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);

      globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;

      globalThis.WhWasmUtilInstaller = function (target) {
        'use strict';
        if (undefined === target.bigIntEnabled) {
          target.bigIntEnabled = !!globalThis['BigInt64Array'];
        }

        const toss = (...args) => {
          throw new Error(args.join(' '));
        };

        if (!target.exports) {
          Object.defineProperty(target, 'exports', {
            enumerable: true,
            configurable: true,
            get: () => target.instance && target.instance.exports,
          });
        }

        const ptrIR = target.pointerIR || 'i32';
        const ptrSizeof = (target.ptrSizeof =
          'i32' === ptrIR
            ? 4
            : 'i64' === ptrIR
              ? 8
              : toss('Unhandled ptrSizeof:', ptrIR));

        const cache = Object.create(null);

        cache.heapSize = 0;

        cache.memory = null;

        cache.freeFuncIndexes = [];

        cache.scopedAlloc = [];

        cache.utf8Decoder = new TextDecoder();
        cache.utf8Encoder = new TextEncoder('utf-8');

        target.sizeofIR = (n) => {
          switch (n) {
            case 'i8':
              return 1;
            case 'i16':
              return 2;
            case 'i32':
            case 'f32':
            case 'float':
              return 4;
            case 'i64':
            case 'f64':
            case 'double':
              return 8;
            case '*':
              return ptrSizeof;
            default:
              return ('' + n).endsWith('*') ? ptrSizeof : undefined;
          }
        };

        const heapWrappers = function () {
          if (!cache.memory) {
            cache.memory =
              target.memory instanceof WebAssembly.Memory
                ? target.memory
                : target.exports.memory;
          } else if (cache.heapSize === cache.memory.buffer.byteLength) {
            return cache;
          }

          const b = cache.memory.buffer;
          cache.HEAP8 = new Int8Array(b);
          cache.HEAP8U = new Uint8Array(b);
          cache.HEAP16 = new Int16Array(b);
          cache.HEAP16U = new Uint16Array(b);
          cache.HEAP32 = new Int32Array(b);
          cache.HEAP32U = new Uint32Array(b);
          if (target.bigIntEnabled) {
            cache.HEAP64 = new BigInt64Array(b);
            cache.HEAP64U = new BigUint64Array(b);
          }
          cache.HEAP32F = new Float32Array(b);
          cache.HEAP64F = new Float64Array(b);
          cache.heapSize = b.byteLength;
          return cache;
        };

        target.heap8 = () => heapWrappers().HEAP8;

        target.heap8u = () => heapWrappers().HEAP8U;

        target.heap16 = () => heapWrappers().HEAP16;

        target.heap16u = () => heapWrappers().HEAP16U;

        target.heap32 = () => heapWrappers().HEAP32;

        target.heap32u = () => heapWrappers().HEAP32U;

        target.heapForSize = function (n, unsigned = true) {
          let ctor;
          const c =
            cache.memory && cache.heapSize === cache.memory.buffer.byteLength
              ? cache
              : heapWrappers();
          switch (n) {
            case Int8Array:
              return c.HEAP8;
            case Uint8Array:
              return c.HEAP8U;
            case Int16Array:
              return c.HEAP16;
            case Uint16Array:
              return c.HEAP16U;
            case Int32Array:
              return c.HEAP32;
            case Uint32Array:
              return c.HEAP32U;
            case 8:
              return unsigned ? c.HEAP8U : c.HEAP8;
            case 16:
              return unsigned ? c.HEAP16U : c.HEAP16;
            case 32:
              return unsigned ? c.HEAP32U : c.HEAP32;
            case 64:
              if (c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;
              break;
            default:
              if (target.bigIntEnabled) {
                if (n === globalThis['BigUint64Array']) return c.HEAP64U;
                else if (n === globalThis['BigInt64Array']) return c.HEAP64;
                break;
              }
          }
          toss(
            'Invalid heapForSize() size: expecting 8, 16, 32,',
            'or (if BigInt is enabled) 64.',
          );
        };

        target.functionTable = function () {
          return target.exports.__indirect_function_table;
        };

        target.functionEntry = function (fptr) {
          const ft = target.functionTable();
          return fptr < ft.length ? ft.get(fptr) : undefined;
        };

        target.jsFuncToWasm = function f(func, sig) {
          if (!f._) {
            f._ = {
              sigTypes: Object.assign(Object.create(null), {
                i: 'i32',
                p: 'i32',
                P: 'i32',
                s: 'i32',
                j: 'i64',
                f: 'f32',
                d: 'f64',
              }),

              typeCodes: Object.assign(Object.create(null), {
                f64: 0x7c,
                f32: 0x7d,
                i64: 0x7e,
                i32: 0x7f,
              }),

              uleb128Encode: function (tgt, method, n) {
                if (n < 128) tgt[method](n);
                else tgt[method](n % 128 | 128, n >> 7);
              },

              rxJSig: /^(\w)\((\w*)\)$/,

              sigParams: function (sig) {
                const m = f._.rxJSig.exec(sig);
                return m ? m[2] : sig.substr(1);
              },

              letterType: (x) =>
                f._.sigTypes[x] || toss('Invalid signature letter:', x),

              pushSigType: (dest, letter) =>
                dest.push(f._.typeCodes[f._.letterType(letter)]),
            };
          }
          if ('string' === typeof func) {
            const x = sig;
            sig = func;
            func = x;
          }
          const sigParams = f._.sigParams(sig);
          const wasmCode = [0x01, 0x60];
          f._.uleb128Encode(wasmCode, 'push', sigParams.length);
          for (const x of sigParams) f._.pushSigType(wasmCode, x);
          if ('v' === sig[0]) wasmCode.push(0);
          else {
            wasmCode.push(1);
            f._.pushSigType(wasmCode, sig[0]);
          }
          f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);
          wasmCode.unshift(
            0x00,
            0x61,
            0x73,
            0x6d,
            0x01,
            0x00,
            0x00,
            0x00,
            0x01,
          );
          wasmCode.push(
            0x02,
            0x07,

            0x01,
            0x01,
            0x65,
            0x01,
            0x66,
            0x00,
            0x00,
            0x07,
            0x05,

            0x01,
            0x01,
            0x66,
            0x00,
            0x00,
          );
          return new WebAssembly.Instance(
            new WebAssembly.Module(new Uint8Array(wasmCode)),
            {
              e: { f: func },
            },
          ).exports['f'];
        };

        const __installFunction = function f(func, sig, scoped) {
          if (scoped && !cache.scopedAlloc.length) {
            toss('No scopedAllocPush() scope is active.');
          }
          if ('string' === typeof func) {
            const x = sig;
            sig = func;
            func = x;
          }
          if ('string' !== typeof sig || !(func instanceof Function)) {
            toss(
              'Invalid arguments: expecting (function,signature) ' +
                'or (signature,function).',
            );
          }
          const ft = target.functionTable();
          const oldLen = ft.length;
          let ptr;
          while (cache.freeFuncIndexes.length) {
            ptr = cache.freeFuncIndexes.pop();
            if (ft.get(ptr)) {
              ptr = null;
              continue;
            } else {
              break;
            }
          }
          if (!ptr) {
            ptr = oldLen;
            ft.grow(1);
          }
          try {
            ft.set(ptr, func);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
            return ptr;
          } catch (e) {
            if (!(e instanceof TypeError)) {
              if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
              throw e;
            }
          }

          try {
            const fptr = target.jsFuncToWasm(func, sig);
            ft.set(ptr, fptr);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
          } catch (e) {
            if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
            throw e;
          }
          return ptr;
        };

        target.installFunction = (func, sig) =>
          __installFunction(func, sig, false);

        target.scopedInstallFunction = (func, sig) =>
          __installFunction(func, sig, true);

        target.uninstallFunction = function (ptr) {
          if (!ptr && 0 !== ptr) return undefined;
          const fi = cache.freeFuncIndexes;
          const ft = target.functionTable();
          fi.push(ptr);
          const rc = ft.get(ptr);
          ft.set(ptr, null);
          return rc;
        };

        target.peek = function f(ptr, type = 'i8') {
          if (type.endsWith('*')) type = ptrIR;
          const c =
            cache.memory && cache.heapSize === cache.memory.buffer.byteLength
              ? cache
              : heapWrappers();
          const list = Array.isArray(ptr) ? [] : undefined;
          let rc;
          do {
            if (list) ptr = arguments[0].shift();
            switch (type) {
              case 'i1':
              case 'i8':
                rc = c.HEAP8[ptr >> 0];
                break;
              case 'i16':
                rc = c.HEAP16[ptr >> 1];
                break;
              case 'i32':
                rc = c.HEAP32[ptr >> 2];
                break;
              case 'float':
              case 'f32':
                rc = c.HEAP32F[ptr >> 2];
                break;
              case 'double':
              case 'f64':
                rc = Number(c.HEAP64F[ptr >> 3]);
                break;
              case 'i64':
                if (target.bigIntEnabled) {
                  rc = BigInt(c.HEAP64[ptr >> 3]);
                  break;
                }

              default:
                toss('Invalid type for peek():', type);
            }
            if (list) list.push(rc);
          } while (list && arguments[0].length);
          return list || rc;
        };

        target.poke = function (ptr, value, type = 'i8') {
          if (type.endsWith('*')) type = ptrIR;
          const c =
            cache.memory && cache.heapSize === cache.memory.buffer.byteLength
              ? cache
              : heapWrappers();
          for (const p of Array.isArray(ptr) ? ptr : [ptr]) {
            switch (type) {
              case 'i1':
              case 'i8':
                c.HEAP8[p >> 0] = value;
                continue;
              case 'i16':
                c.HEAP16[p >> 1] = value;
                continue;
              case 'i32':
                c.HEAP32[p >> 2] = value;
                continue;
              case 'float':
              case 'f32':
                c.HEAP32F[p >> 2] = value;
                continue;
              case 'double':
              case 'f64':
                c.HEAP64F[p >> 3] = value;
                continue;
              case 'i64':
                if (c.HEAP64) {
                  c.HEAP64[p >> 3] = BigInt(value);
                  continue;
                }

              default:
                toss('Invalid type for poke(): ' + type);
            }
          }
          return this;
        };

        target.peekPtr = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);

        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);

        target.peek8 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i8');

        target.poke8 = (ptr, value) => target.poke(ptr, value, 'i8');

        target.peek16 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i16');

        target.poke16 = (ptr, value) => target.poke(ptr, value, 'i16');

        target.peek32 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i32');

        target.poke32 = (ptr, value) => target.poke(ptr, value, 'i32');

        target.peek64 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i64');

        target.poke64 = (ptr, value) => target.poke(ptr, value, 'i64');

        target.peek32f = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f32');

        target.poke32f = (ptr, value) => target.poke(ptr, value, 'f32');

        target.peek64f = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f64');

        target.poke64f = (ptr, value) => target.poke(ptr, value, 'f64');

        target.getMemValue = target.peek;

        target.getPtrValue = target.peekPtr;

        target.setMemValue = target.poke;

        target.setPtrValue = target.pokePtr;

        target.isPtr32 = (ptr) =>
          'number' === typeof ptr && ptr === (ptr | 0) && ptr >= 0;

        target.isPtr = target.isPtr32;

        target.cstrlen = function (ptr) {
          if (!ptr || !target.isPtr(ptr)) return null;
          const h = heapWrappers().HEAP8U;
          let pos = ptr;
          for (; h[pos] !== 0; ++pos) {}
          return pos - ptr;
        };

        const __SAB =
          'undefined' === typeof SharedArrayBuffer
            ? function () {}
            : SharedArrayBuffer;
        const __utf8Decode = function (arrayBuffer, begin, end) {
          return cache.utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB
              ? arrayBuffer.slice(begin, end)
              : arrayBuffer.subarray(begin, end),
          );
        };

        target.cstrToJs = function (ptr) {
          const n = target.cstrlen(ptr);
          return n
            ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n)
            : null === n
              ? n
              : '';
        };

        target.jstrlen = function (str) {
          if ('string' !== typeof str) return null;
          const n = str.length;
          let len = 0;
          for (let i = 0; i < n; ++i) {
            let u = str.charCodeAt(i);
            if (u >= 0xd800 && u <= 0xdfff) {
              u =
                (0x10000 + ((u & 0x3ff) << 10)) | (str.charCodeAt(++i) & 0x3ff);
            }
            if (u <= 0x7f) ++len;
            else if (u <= 0x7ff) len += 2;
            else if (u <= 0xffff) len += 3;
            else len += 4;
          }
          return len;
        };

        target.jstrcpy = function (
          jstr,
          tgt,
          offset = 0,
          maxBytes = -1,
          addNul = true,
        ) {
          if (
            !tgt ||
            (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))
          ) {
            toss('jstrcpy() target must be an Int8Array or Uint8Array.');
          }
          if (maxBytes < 0) maxBytes = tgt.length - offset;
          if (!(maxBytes > 0) || !(offset >= 0)) return 0;
          let i = 0,
            max = jstr.length;
          const begin = offset,
            end = offset + maxBytes - (addNul ? 1 : 0);
          for (; i < max && offset < end; ++i) {
            let u = jstr.charCodeAt(i);
            if (u >= 0xd800 && u <= 0xdfff) {
              u =
                (0x10000 + ((u & 0x3ff) << 10)) |
                (jstr.charCodeAt(++i) & 0x3ff);
            }
            if (u <= 0x7f) {
              if (offset >= end) break;
              tgt[offset++] = u;
            } else if (u <= 0x7ff) {
              if (offset + 1 >= end) break;
              tgt[offset++] = 0xc0 | (u >> 6);
              tgt[offset++] = 0x80 | (u & 0x3f);
            } else if (u <= 0xffff) {
              if (offset + 2 >= end) break;
              tgt[offset++] = 0xe0 | (u >> 12);
              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
              tgt[offset++] = 0x80 | (u & 0x3f);
            } else {
              if (offset + 3 >= end) break;
              tgt[offset++] = 0xf0 | (u >> 18);
              tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);
              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
              tgt[offset++] = 0x80 | (u & 0x3f);
            }
          }
          if (addNul) tgt[offset++] = 0;
          return offset - begin;
        };

        target.cstrncpy = function (tgtPtr, srcPtr, n) {
          if (!tgtPtr || !srcPtr)
            toss('cstrncpy() does not accept NULL strings.');
          if (n < 0) n = target.cstrlen(strPtr) + 1;
          else if (!(n > 0)) return 0;
          const heap = target.heap8u();
          let i = 0,
            ch;
          for (; i < n && (ch = heap[srcPtr + i]); ++i) {
            heap[tgtPtr + i] = ch;
          }
          if (i < n) heap[tgtPtr + i++] = 0;
          return i;
        };

        target.jstrToUintArray = (str, addNul = false) => {
          return cache.utf8Encoder.encode(addNul ? str + '\0' : str);
        };

        const __affirmAlloc = (obj, funcName) => {
          if (
            !(obj.alloc instanceof Function) ||
            !(obj.dealloc instanceof Function)
          ) {
            toss(
              'Object is missing alloc() and/or dealloc() function(s)',
              'required by',
              funcName + '().',
            );
          }
        };

        const __allocCStr = function (
          jstr,
          returnWithLength,
          allocator,
          funcName,
        ) {
          __affirmAlloc(target, funcName);
          if ('string' !== typeof jstr) return null;
          if (false) {} else {
            const u = cache.utf8Encoder.encode(jstr),
              ptr = allocator(u.length + 1),
              heap = heapWrappers().HEAP8U;
            heap.set(u, ptr);
            heap[ptr + u.length] = 0;
            return returnWithLength ? [ptr, u.length] : ptr;
          }
        };

        target.allocCString = (jstr, returnWithLength = false) =>
          __allocCStr(jstr, returnWithLength, target.alloc, 'allocCString()');

        target.scopedAllocPush = function () {
          __affirmAlloc(target, 'scopedAllocPush');
          const a = [];
          cache.scopedAlloc.push(a);
          return a;
        };

        target.scopedAllocPop = function (state) {
          __affirmAlloc(target, 'scopedAllocPop');
          const n = arguments.length
            ? cache.scopedAlloc.indexOf(state)
            : cache.scopedAlloc.length - 1;
          if (n < 0) toss('Invalid state object for scopedAllocPop().');
          if (0 === arguments.length) state = cache.scopedAlloc[n];
          cache.scopedAlloc.splice(n, 1);
          for (let p; (p = state.pop()); ) {
            if (target.functionEntry(p)) {
              target.uninstallFunction(p);
            } else target.dealloc(p);
          }
        };

        target.scopedAlloc = function (n) {
          if (!cache.scopedAlloc.length) {
            toss('No scopedAllocPush() scope is active.');
          }
          const p = target.alloc(n);
          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p);
          return p;
        };

        Object.defineProperty(target.scopedAlloc, 'level', {
          configurable: false,
          enumerable: false,
          get: () => cache.scopedAlloc.length,
          set: () => toss("The 'active' property is read-only."),
        });

        target.scopedAllocCString = (jstr, returnWithLength = false) =>
          __allocCStr(
            jstr,
            returnWithLength,
            target.scopedAlloc,
            'scopedAllocCString()',
          );

        const __allocMainArgv = function (isScoped, list) {
          const pList = target[isScoped ? 'scopedAlloc' : 'alloc'](
            (list.length + 1) * target.ptrSizeof,
          );
          let i = 0;
          list.forEach((e) => {
            target.pokePtr(
              pList + target.ptrSizeof * i++,
              target[isScoped ? 'scopedAllocCString' : 'allocCString']('' + e),
            );
          });
          target.pokePtr(pList + target.ptrSizeof * i, 0);
          return pList;
        };

        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);

        target.allocMainArgv = (list) => __allocMainArgv(false, list);

        target.cArgvToJs = (argc, pArgv) => {
          const list = [];
          for (let i = 0; i < argc; ++i) {
            const arg = target.peekPtr(pArgv + target.ptrSizeof * i);
            list.push(arg ? target.cstrToJs(arg) : null);
          }
          return list;
        };

        target.scopedAllocCall = function (func) {
          target.scopedAllocPush();
          try {
            return func();
          } finally {
            target.scopedAllocPop();
          }
        };

        const __allocPtr = function (howMany, safePtrSize, method) {
          __affirmAlloc(target, method);
          const pIr = safePtrSize ? 'i64' : ptrIR;
          let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
          target.poke(m, 0, pIr);
          if (1 === howMany) {
            return m;
          }
          const a = [m];
          for (let i = 1; i < howMany; ++i) {
            m += safePtrSize ? 8 : ptrSizeof;
            a[i] = m;
            target.poke(m, 0, pIr);
          }
          return a;
        };

        target.allocPtr = (howMany = 1, safePtrSize = true) =>
          __allocPtr(howMany, safePtrSize, 'alloc');

        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) =>
          __allocPtr(howMany, safePtrSize, 'scopedAlloc');

        target.xGet = function (name) {
          return (
            target.exports[name] || toss('Cannot find exported symbol:', name)
          );
        };

        const __argcMismatch = (f, n) =>
          toss(f + '() requires', n, 'argument(s).');

        target.xCall = function (fname, ...args) {
          const f = target.xGet(fname);
          if (!(f instanceof Function))
            toss('Exported symbol', fname, 'is not a function.');
          if (f.length !== args.length) __argcMismatch(fname, f.length);
          return 2 === arguments.length && Array.isArray(arguments[1])
            ? f.apply(null, arguments[1])
            : f.apply(null, args);
        };

        cache.xWrap = Object.create(null);
        cache.xWrap.convert = Object.create(null);

        cache.xWrap.convert.arg = new Map();

        cache.xWrap.convert.result = new Map();
        const xArg = cache.xWrap.convert.arg,
          xResult = cache.xWrap.convert.result;

        if (target.bigIntEnabled) {
          xArg.set('i64', (i) => BigInt(i));
        }
        const __xArgPtr =
          'i32' === ptrIR ? (i) => i | 0 : (i) => BigInt(i) | BigInt(0);
        xArg
          .set('i32', __xArgPtr)
          .set('i16', (i) => (i | 0) & 0xffff)
          .set('i8', (i) => (i | 0) & 0xff)
          .set('f32', (i) => Number(i).valueOf())
          .set('float', xArg.get('f32'))
          .set('f64', xArg.get('f32'))
          .set('double', xArg.get('f64'))
          .set('int', xArg.get('i32'))
          .set('null', (i) => i)
          .set(null, xArg.get('null'))
          .set('**', __xArgPtr)
          .set('*', __xArgPtr);
        xResult
          .set('*', __xArgPtr)
          .set('pointer', __xArgPtr)
          .set('number', (v) => Number(v))
          .set('void', (v) => undefined)
          .set('null', (v) => v)
          .set(null, xResult.get('null'));

        {
          const copyToResult = [
            'i8',
            'i16',
            'i32',
            'int',
            'f32',
            'float',
            'f64',
            'double',
          ];
          if (target.bigIntEnabled) copyToResult.push('i64');
          const adaptPtr = xArg.get(ptrIR);
          for (const t of copyToResult) {
            xArg.set(t + '*', adaptPtr);
            xResult.set(t + '*', adaptPtr);
            xResult.set(t, xArg.get(t) || toss('Missing arg converter:', t));
          }
        }

        const __xArgString = function (v) {
          if ('string' === typeof v) return target.scopedAllocCString(v);
          return v ? __xArgPtr(v) : null;
        };
        xArg
          .set('string', __xArgString)
          .set('utf8', __xArgString)
          .set('pointer', __xArgString);

        xResult
          .set('string', (i) => target.cstrToJs(i))
          .set('utf8', xResult.get('string'))
          .set('string:dealloc', (i) => {
            try {
              return i ? target.cstrToJs(i) : null;
            } finally {
              target.dealloc(i);
            }
          })
          .set('utf8:dealloc', xResult.get('string:dealloc'))
          .set('json', (i) => JSON.parse(target.cstrToJs(i)))
          .set('json:dealloc', (i) => {
            try {
              return i ? JSON.parse(target.cstrToJs(i)) : null;
            } finally {
              target.dealloc(i);
            }
          });

        const AbstractArgAdapter = class {
          constructor(opt) {
            this.name = opt.name || 'unnamed adapter';
          }

          convertArg(v, argv, argIndex) {
            toss('AbstractArgAdapter must be subclassed.');
          }
        };

        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
          constructor(opt) {
            super(opt);
            if (xArg.FuncPtrAdapter.warnOnUse) {
              console.warn(
                'xArg.FuncPtrAdapter is an internal-only API',
                'and is not intended to be invoked from',
                'client-level code. Invoked with:',
                opt,
              );
            }
            this.name = opt.name || 'unnamed';
            this.signature = opt.signature;
            if (opt.contextKey instanceof Function) {
              this.contextKey = opt.contextKey;
              if (!opt.bindScope) opt.bindScope = 'context';
            }
            this.bindScope =
              opt.bindScope ||
              toss(
                'FuncPtrAdapter options requires a bindScope (explicit or implied).',
              );
            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
              toss(
                'Invalid options.bindScope (' +
                  opt.bindMod +
                  ') for FuncPtrAdapter. ' +
                  'Expecting one of: (' +
                  FuncPtrAdapter.bindScopes.join(', ') +
                  ')',
              );
            }
            this.isTransient = 'transient' === this.bindScope;
            this.isContext = 'context' === this.bindScope;
            this.isPermanent = 'permanent' === this.bindScope;
            this.singleton = 'singleton' === this.bindScope ? [] : undefined;

            this.callProxy =
              opt.callProxy instanceof Function ? opt.callProxy : undefined;
          }

          contextKey(argv, argIndex) {
            return this;
          }

          contextMap(key) {
            const cm = this.__cmap || (this.__cmap = new Map());
            let rc = cm.get(key);
            if (undefined === rc) cm.set(key, (rc = []));
            return rc;
          }

          convertArg(v, argv, argIndex) {
            let pair = this.singleton;
            if (!pair && this.isContext) {
              pair = this.contextMap(this.contextKey(argv, argIndex));
            }
            if (pair && pair[0] === v) return pair[1];
            if (v instanceof Function) {
              if (this.callProxy) v = this.callProxy(v);
              const fp = __installFunction(v, this.signature, this.isTransient);
              if (FuncPtrAdapter.debugFuncInstall) {
                FuncPtrAdapter.debugOut(
                  'FuncPtrAdapter installed',
                  this,
                  this.contextKey(argv, argIndex),
                  '@' + fp,
                  v,
                );
              }
              if (pair) {
                if (pair[1]) {
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      'FuncPtrAdapter uninstalling',
                      this,
                      this.contextKey(argv, argIndex),
                      '@' + pair[1],
                      v,
                    );
                  }
                  try {
                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                      pair[1],
                    );
                  } catch (e) {}
                }
                pair[0] = v;
                pair[1] = fp;
              }
              return fp;
            } else if (target.isPtr(v) || null === v || undefined === v) {
              if (pair && pair[1] && pair[1] !== v) {
                if (FuncPtrAdapter.debugFuncInstall) {
                  FuncPtrAdapter.debugOut(
                    'FuncPtrAdapter uninstalling',
                    this,
                    this.contextKey(argv, argIndex),
                    '@' + pair[1],
                    v,
                  );
                }
                try {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                } catch (e) {}
                pair[0] = pair[1] = v | 0;
              }
              return v || 0;
            } else {
              throw new TypeError(
                'Invalid FuncPtrAdapter argument type. ' +
                  'Expecting a function pointer or a ' +
                  (this.name ? this.name + ' ' : '') +
                  'function matching signature ' +
                  this.signature +
                  '.',
              );
            }
          }
        };

        xArg.FuncPtrAdapter.warnOnUse = false;

        xArg.FuncPtrAdapter.debugFuncInstall = false;

        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);

        xArg.FuncPtrAdapter.bindScopes = [
          'transient',
          'context',
          'singleton',
          'permanent',
        ];

        const __xArgAdapterCheck = (t) =>
          xArg.get(t) || toss('Argument adapter not found:', t);

        const __xResultAdapterCheck = (t) =>
          xResult.get(t) || toss('Result adapter not found:', t);

        cache.xWrap.convertArg = (t, ...args) => __xArgAdapterCheck(t)(...args);
        cache.xWrap.convertArgNoCheck = (t, ...args) => xArg.get(t)(...args);

        cache.xWrap.convertResult = (t, v) =>
          null === t ? v : t ? __xResultAdapterCheck(t)(v) : undefined;
        cache.xWrap.convertResultNoCheck = (t, v) =>
          null === t ? v : t ? xResult.get(t)(v) : undefined;

        target.xWrap = function (fArg, resultType, ...argTypes) {
          if (3 === arguments.length && Array.isArray(arguments[2])) {
            argTypes = arguments[2];
          }
          if (target.isPtr(fArg)) {
            fArg =
              target.functionEntry(fArg) ||
              toss('Function pointer not found in WASM function table.');
          }
          const fIsFunc = fArg instanceof Function;
          const xf = fIsFunc ? fArg : target.xGet(fArg);
          if (fIsFunc) fArg = xf.name || 'unnamed function';
          if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);
          if (null === resultType && 0 === xf.length) {
            return xf;
          }
          if (undefined !== resultType && null !== resultType)
            __xResultAdapterCheck(resultType);
          for (const t of argTypes) {
            if (t instanceof AbstractArgAdapter)
              xArg.set(t, (...args) => t.convertArg(...args));
            else __xArgAdapterCheck(t);
          }
          const cxw = cache.xWrap;
          if (0 === xf.length) {
            return (...args) =>
              args.length
                ? __argcMismatch(fArg, xf.length)
                : cxw.convertResult(resultType, xf.call(null));
          }
          return function (...args) {
            if (args.length !== xf.length) __argcMismatch(fArg, xf.length);
            const scope = target.scopedAllocPush();
            try {
              for (const i in args)
                args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);
              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
            } finally {
              target.scopedAllocPop(scope);
            }
          };
        };

        const __xAdapter = function (
          func,
          argc,
          typeName,
          adapter,
          modeName,
          xcvPart,
        ) {
          if ('string' === typeof typeName) {
            if (1 === argc) return xcvPart.get(typeName);
            else if (2 === argc) {
              if (!adapter) {
                delete xcvPart.get(typeName);
                return func;
              } else if (!(adapter instanceof Function)) {
                toss(modeName, 'requires a function argument.');
              }
              xcvPart.set(typeName, adapter);
              return func;
            }
          }
          toss('Invalid arguments to', modeName);
        };

        target.xWrap.resultAdapter = function f(typeName, adapter) {
          return __xAdapter(
            f,
            arguments.length,
            typeName,
            adapter,
            'resultAdapter()',
            xResult,
          );
        };

        target.xWrap.argAdapter = function f(typeName, adapter) {
          return __xAdapter(
            f,
            arguments.length,
            typeName,
            adapter,
            'argAdapter()',
            xArg,
          );
        };

        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;

        target.xCallWrapped = function (fArg, resultType, argTypes, ...args) {
          if (Array.isArray(arguments[3])) args = arguments[3];
          return target
            .xWrap(fArg, resultType, argTypes || [])
            .apply(null, args || []);
        };

        target.xWrap.testConvertArg = cache.xWrap.convertArg;

        target.xWrap.testConvertResult = cache.xWrap.convertResult;

        return target;
      };

      globalThis.WhWasmUtilInstaller.yawl = function (config) {
        const wfetch = () => fetch(config.uri, { credentials: 'same-origin' });
        const wui = this;
        const finalThen = function (arg) {
          if (config.wasmUtilTarget) {
            const toss = (...args) => {
              throw new Error(args.join(' '));
            };
            const tgt = config.wasmUtilTarget;
            tgt.module = arg.module;
            tgt.instance = arg.instance;

            if (!tgt.instance.exports.memory) {
              tgt.memory =
                (config.imports &&
                  config.imports.env &&
                  config.imports.env.memory) ||
                toss("Missing 'memory' object!");
            }
            if (!tgt.alloc && arg.instance.exports.malloc) {
              const exports = arg.instance.exports;
              tgt.alloc = function (n) {
                return (
                  exports.malloc(n) || toss('Allocation of', n, 'bytes failed.')
                );
              };
              tgt.dealloc = function (m) {
                exports.free(m);
              };
            }
            wui(tgt);
          }
          if (config.onload) config.onload(arg, config);
          return arg;
        };
        const loadWasm = WebAssembly.instantiateStreaming
          ? function loadWasmStreaming() {
              return WebAssembly.instantiateStreaming(
                wfetch(),
                config.imports || {},
              ).then(finalThen);
            }
          : function loadWasmOldSchool() {
              return wfetch()
                .then((response) => response.arrayBuffer())
                .then((bytes) =>
                  WebAssembly.instantiate(bytes, config.imports || {}),
                )
                .then(finalThen);
            };
        return loadWasm;
      }.bind(globalThis.WhWasmUtilInstaller);

      ('use strict');
      globalThis.Jaccwabyt = function StructBinderFactory(config) {
        const toss = (...args) => {
          throw new Error(args.join(' '));
        };

        if (
          !(config.heap instanceof WebAssembly.Memory) &&
          !(config.heap instanceof Function)
        ) {
          toss(
            'config.heap must be WebAssembly.Memory instance or a function.',
          );
        }
        ['alloc', 'dealloc'].forEach(function (k) {
          config[k] instanceof Function ||
            toss("Config option '" + k + "' must be a function.");
        });
        const SBF = StructBinderFactory;
        const heap =
            config.heap instanceof Function
              ? config.heap
              : () => new Uint8Array(config.heap.buffer),
          alloc = config.alloc,
          dealloc = config.dealloc,
          log = config.log || console.log.bind(console),
          memberPrefix = config.memberPrefix || '',
          memberSuffix = config.memberSuffix || '',
          bigIntEnabled =
            undefined === config.bigIntEnabled
              ? !!globalThis['BigInt64Array']
              : !!config.bigIntEnabled,
          BigInt = globalThis['BigInt'],
          BigInt64Array = globalThis['BigInt64Array'],
          ptrSizeof = config.ptrSizeof || 4,
          ptrIR = config.ptrIR || 'i32';
        if (!SBF.debugFlags) {
          SBF.__makeDebugFlags = function (deriveFrom = null) {
            if (deriveFrom && deriveFrom.__flags)
              deriveFrom = deriveFrom.__flags;
            const f = function f(flags) {
              if (0 === arguments.length) {
                return f.__flags;
              }
              if (flags < 0) {
                delete f.__flags.getter;
                delete f.__flags.setter;
                delete f.__flags.alloc;
                delete f.__flags.dealloc;
              } else {
                f.__flags.getter = 0 !== (0x01 & flags);
                f.__flags.setter = 0 !== (0x02 & flags);
                f.__flags.alloc = 0 !== (0x04 & flags);
                f.__flags.dealloc = 0 !== (0x08 & flags);
              }
              return f._flags;
            };
            Object.defineProperty(f, '__flags', {
              iterable: false,
              writable: false,
              value: Object.create(deriveFrom),
            });
            if (!deriveFrom) f(0);
            return f;
          };
          SBF.debugFlags = SBF.__makeDebugFlags();
        }

        const isLittleEndian = (function () {
          const buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);

          return new Int16Array(buffer)[0] === 256;
        })();

        const isFuncSig = (s) => '(' === s[1];

        const isPtrSig = (s) => 'p' === s || 'P' === s;
        const isAutoPtrSig = (s) => 'P' === s;
        const sigLetter = (s) => (isFuncSig(s) ? 'p' : s[0]);

        const sigIR = function (s) {
          switch (sigLetter(s)) {
            case 'c':
            case 'C':
              return 'i8';
            case 'i':
              return 'i32';
            case 'p':
            case 'P':
            case 's':
              return ptrIR;
            case 'j':
              return 'i64';
            case 'f':
              return 'float';
            case 'd':
              return 'double';
          }
          toss('Unhandled signature IR:', s);
        };

        const affirmBigIntArray = BigInt64Array
          ? () => true
          : () => toss('BigInt64Array is not available.');

        const sigDVGetter = function (s) {
          switch (sigLetter(s)) {
            case 'p':
            case 'P':
            case 's': {
              switch (ptrSizeof) {
                case 4:
                  return 'getInt32';
                case 8:
                  return affirmBigIntArray() && 'getBigInt64';
              }
              break;
            }
            case 'i':
              return 'getInt32';
            case 'c':
              return 'getInt8';
            case 'C':
              return 'getUint8';
            case 'j':
              return affirmBigIntArray() && 'getBigInt64';
            case 'f':
              return 'getFloat32';
            case 'd':
              return 'getFloat64';
          }
          toss('Unhandled DataView getter for signature:', s);
        };

        const sigDVSetter = function (s) {
          switch (sigLetter(s)) {
            case 'p':
            case 'P':
            case 's': {
              switch (ptrSizeof) {
                case 4:
                  return 'setInt32';
                case 8:
                  return affirmBigIntArray() && 'setBigInt64';
              }
              break;
            }
            case 'i':
              return 'setInt32';
            case 'c':
              return 'setInt8';
            case 'C':
              return 'setUint8';
            case 'j':
              return affirmBigIntArray() && 'setBigInt64';
            case 'f':
              return 'setFloat32';
            case 'd':
              return 'setFloat64';
          }
          toss('Unhandled DataView setter for signature:', s);
        };

        const sigDVSetWrapper = function (s) {
          switch (sigLetter(s)) {
            case 'i':
            case 'f':
            case 'c':
            case 'C':
            case 'd':
              return Number;
            case 'j':
              return affirmBigIntArray() && BigInt;
            case 'p':
            case 'P':
            case 's':
              switch (ptrSizeof) {
                case 4:
                  return Number;
                case 8:
                  return affirmBigIntArray() && BigInt;
              }
              break;
          }
          toss('Unhandled DataView set wrapper for signature:', s);
        };

        const sPropName = (s, k) => s + '::' + k;

        const __propThrowOnSet = function (structName, propName) {
          return () => toss(sPropName(structName, propName), 'is read-only.');
        };

        const __instancePointerMap = new WeakMap();

        const xPtrPropName = '(pointer-is-external)';

        const __freeStruct = function (ctor, obj, m) {
          if (!m) m = __instancePointerMap.get(obj);
          if (m) {
            __instancePointerMap.delete(obj);
            if (Array.isArray(obj.ondispose)) {
              let x;
              while ((x = obj.ondispose.shift())) {
                try {
                  if (x instanceof Function) x.call(obj);
                  else if (x instanceof StructType) x.dispose();
                  else if ('number' === typeof x) dealloc(x);
                } catch (e) {
                  console.warn(
                    'ondispose() for',
                    ctor.structName,
                    '@',
                    m,
                    'threw. NOT propagating it.',
                    e,
                  );
                }
              }
            } else if (obj.ondispose instanceof Function) {
              try {
                obj.ondispose();
              } catch (e) {
                console.warn(
                  'ondispose() for',
                  ctor.structName,
                  '@',
                  m,
                  'threw. NOT propagating it.',
                  e,
                );
              }
            }
            delete obj.ondispose;
            if (ctor.debugFlags.__flags.dealloc) {
              log(
                'debug.dealloc:',
                obj[xPtrPropName] ? 'EXTERNAL' : '',
                ctor.structName,
                'instance:',
                ctor.structInfo.sizeof,
                'bytes @' + m,
              );
            }
            if (!obj[xPtrPropName]) dealloc(m);
          }
        };

        const rop = (v) => {
          return {
            configurable: false,
            writable: false,
            iterable: false,
            value: v,
          };
        };

        const __allocStruct = function (ctor, obj, m) {
          let fill = !m;
          if (m) Object.defineProperty(obj, xPtrPropName, rop(m));
          else {
            m = alloc(ctor.structInfo.sizeof);
            if (!m) toss('Allocation of', ctor.structName, 'structure failed.');
          }
          try {
            if (ctor.debugFlags.__flags.alloc) {
              log(
                'debug.alloc:',
                fill ? '' : 'EXTERNAL',
                ctor.structName,
                'instance:',
                ctor.structInfo.sizeof,
                'bytes @' + m,
              );
            }
            if (fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
            __instancePointerMap.set(obj, m);
          } catch (e) {
            __freeStruct(ctor, obj, m);
            throw e;
          }
        };

        const __memoryDump = function () {
          const p = this.pointer;
          return p
            ? new Uint8Array(heap().slice(p, p + this.structInfo.sizeof))
            : null;
        };

        const __memberKey = (k) => memberPrefix + k + memberSuffix;
        const __memberKeyProp = rop(__memberKey);

        const __lookupMember = function (
          structInfo,
          memberName,
          tossIfNotFound = true,
        ) {
          let m = structInfo.members[memberName];
          if (!m && (memberPrefix || memberSuffix)) {
            for (const v of Object.values(structInfo.members)) {
              if (v.key === memberName) {
                m = v;
                break;
              }
            }
            if (!m && tossIfNotFound) {
              toss(
                sPropName(structInfo.name, memberName),
                'is not a mapped struct member.',
              );
            }
          }
          return m;
        };

        const __memberSignature = function f(
          obj,
          memberName,
          emscriptenFormat = false,
        ) {
          if (!f._)
            f._ = (x) =>
              x.replace(/[^vipPsjrdcC]/g, '').replace(/[pPscC]/g, 'i');
          const m = __lookupMember(obj.structInfo, memberName, true);
          return emscriptenFormat ? f._(m.signature) : m.signature;
        };

        const __ptrPropDescriptor = {
          configurable: false,
          enumerable: false,
          get: function () {
            return __instancePointerMap.get(this);
          },
          set: () => toss("Cannot assign the 'pointer' property of a struct."),
        };

        const __structMemberKeys = rop(function () {
          const a = [];
          for (const k of Object.keys(this.structInfo.members)) {
            a.push(this.memberKey(k));
          }
          return a;
        });

        const __utf8Decoder = new TextDecoder('utf-8');
        const __utf8Encoder = new TextEncoder();

        const __SAB =
          'undefined' === typeof SharedArrayBuffer
            ? function () {}
            : SharedArrayBuffer;
        const __utf8Decode = function (arrayBuffer, begin, end) {
          return __utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB
              ? arrayBuffer.slice(begin, end)
              : arrayBuffer.subarray(begin, end),
          );
        };

        const __memberIsString = function (
          obj,
          memberName,
          tossIfNotFound = false,
        ) {
          const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
          return m && 1 === m.signature.length && 's' === m.signature[0]
            ? m
            : false;
        };

        const __affirmCStringSignature = function (member) {
          if ('s' === member.signature) return;
          toss(
            'Invalid member type signature for C-string value:',
            JSON.stringify(member),
          );
        };

        const __memberToJsString = function f(obj, memberName) {
          const m = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m);
          const addr = obj[m.key];

          if (!addr) return null;
          let pos = addr;
          const mem = heap();
          for (; mem[pos] !== 0; ++pos) {}

          return addr === pos ? '' : __utf8Decode(mem, addr, pos);
        };

        const __addOnDispose = function (obj, ...v) {
          if (obj.ondispose) {
            if (!Array.isArray(obj.ondispose)) {
              obj.ondispose = [obj.ondispose];
            }
          } else {
            obj.ondispose = [];
          }
          obj.ondispose.push(...v);
        };

        const __allocCString = function (str) {
          const u = __utf8Encoder.encode(str);
          const mem = alloc(u.length + 1);
          if (!mem) toss('Allocation error while duplicating string:', str);
          const h = heap();

          h.set(u, mem);
          h[mem + u.length] = 0;

          return mem;
        };

        const __setMemberCString = function (obj, memberName, str) {
          const m = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m);

          const mem = __allocCString(str);
          obj[m.key] = mem;
          __addOnDispose(obj, mem);
          return obj;
        };

        const StructType = function ctor(structName, structInfo) {
          if (arguments[2] !== rop) {
            toss(
              'Do not call the StructType constructor',
              'from client-level code.',
            );
          }
          Object.defineProperties(this, {
            structName: rop(structName),
            structInfo: rop(structInfo),
          });
        };

        StructType.prototype = Object.create(null, {
          dispose: rop(function () {
            __freeStruct(this.constructor, this);
          }),
          lookupMember: rop(function (memberName, tossIfNotFound = true) {
            return __lookupMember(this.structInfo, memberName, tossIfNotFound);
          }),
          memberToJsString: rop(function (memberName) {
            return __memberToJsString(this, memberName);
          }),
          memberIsString: rop(function (memberName, tossIfNotFound = true) {
            return __memberIsString(this, memberName, tossIfNotFound);
          }),
          memberKey: __memberKeyProp,
          memberKeys: __structMemberKeys,
          memberSignature: rop(function (memberName, emscriptenFormat = false) {
            return __memberSignature(this, memberName, emscriptenFormat);
          }),
          memoryDump: rop(__memoryDump),
          pointer: __ptrPropDescriptor,
          setMemberCString: rop(function (memberName, str) {
            return __setMemberCString(this, memberName, str);
          }),
        });

        Object.assign(StructType.prototype, {
          addOnDispose: function (...v) {
            __addOnDispose(this, ...v);
            return this;
          },
        });

        Object.defineProperties(StructType, {
          allocCString: rop(__allocCString),
          isA: rop((v) => v instanceof StructType),
          hasExternalPointer: rop(
            (v) => v instanceof StructType && !!v[xPtrPropName],
          ),
          memberKey: __memberKeyProp,
        });

        const isNumericValue = (v) =>
          Number.isFinite(v) || v instanceof (BigInt || Number);

        const makeMemberWrapper = function f(ctor, name, descr) {
          if (!f._) {
            f._ = { getters: {}, setters: {}, sw: {} };
            const a = ['i', 'c', 'C', 'p', 'P', 's', 'f', 'd', 'v()'];
            if (bigIntEnabled) a.push('j');
            a.forEach(function (v) {
              f._.getters[v] = sigDVGetter(v);
              f._.setters[v] = sigDVSetter(v);
              f._.sw[v] = sigDVSetWrapper(v);
            });
            const rxSig1 = /^[ipPsjfdcC]$/,
              rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
            f.sigCheck = function (obj, name, key, sig) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                toss(obj.structName, 'already has a property named', key + '.');
              }
              rxSig1.test(sig) ||
                rxSig2.test(sig) ||
                toss(
                  'Malformed signature for',
                  sPropName(obj.structName, name) + ':',
                  sig,
                );
            };
          }
          const key = ctor.memberKey(name);
          f.sigCheck(ctor.prototype, name, key, descr.signature);
          descr.key = key;
          descr.name = name;
          const sigGlyph = sigLetter(descr.signature);
          const xPropName = sPropName(ctor.prototype.structName, key);
          const dbg = ctor.prototype.debugFlags.__flags;

          const prop = Object.create(null);
          prop.configurable = false;
          prop.enumerable = false;
          prop.get = function () {
            if (dbg.getter) {
              log(
                'debug.getter:',
                f._.getters[sigGlyph],
                'for',
                sigIR(sigGlyph),
                xPropName,
                '@',
                this.pointer,
                '+',
                descr.offset,
                'sz',
                descr.sizeof,
              );
            }
            let rc = new DataView(
              heap().buffer,
              this.pointer + descr.offset,
              descr.sizeof,
            )[f._.getters[sigGlyph]](0, isLittleEndian);
            if (dbg.getter) log('debug.getter:', xPropName, 'result =', rc);
            return rc;
          };
          if (descr.readOnly) {
            prop.set = __propThrowOnSet(ctor.prototype.structName, key);
          } else {
            prop.set = function (v) {
              if (dbg.setter) {
                log(
                  'debug.setter:',
                  f._.setters[sigGlyph],
                  'for',
                  sigIR(sigGlyph),
                  xPropName,
                  '@',
                  this.pointer,
                  '+',
                  descr.offset,
                  'sz',
                  descr.sizeof,
                  v,
                );
              }
              if (!this.pointer) {
                toss('Cannot set struct property on disposed instance.');
              }
              if (null === v) v = 0;
              else
                while (!isNumericValue(v)) {
                  if (
                    isAutoPtrSig(descr.signature) &&
                    v instanceof StructType
                  ) {
                    v = v.pointer || 0;
                    if (dbg.setter)
                      log('debug.setter:', xPropName, 'resolved to', v);
                    break;
                  }
                  toss('Invalid value for pointer-type', xPropName + '.');
                }
              new DataView(
                heap().buffer,
                this.pointer + descr.offset,
                descr.sizeof,
              )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);
            };
          }
          Object.defineProperty(ctor.prototype, key, prop);
        };

        const StructBinder = function StructBinder(structName, structInfo) {
          if (1 === arguments.length) {
            structInfo = structName;
            structName = structInfo.name;
          } else if (!structInfo.name) {
            structInfo.name = structName;
          }
          if (!structName) toss('Struct name is required.');
          let lastMember = false;
          Object.keys(structInfo.members).forEach((k) => {
            const m = structInfo.members[k];
            if (!m.sizeof) toss(structName, 'member', k, 'is missing sizeof.');
            else if (m.sizeof === 1) {
              m.signature === 'c' ||
                m.signature === 'C' ||
                toss(
                  'Unexpected sizeof==1 member',
                  sPropName(structInfo.name, k),
                  'with signature',
                  m.signature,
                );
            } else {
              if (0 !== m.sizeof % 4) {
                console.warn(
                  'Invalid struct member description =',
                  m,
                  'from',
                  structInfo,
                );
                toss(
                  structName,
                  'member',
                  k,
                  'sizeof is not aligned. sizeof=' + m.sizeof,
                );
              }
              if (0 !== m.offset % 4) {
                console.warn(
                  'Invalid struct member description =',
                  m,
                  'from',
                  structInfo,
                );
                toss(
                  structName,
                  'member',
                  k,
                  'offset is not aligned. offset=' + m.offset,
                );
              }
            }
            if (!lastMember || lastMember.offset < m.offset) lastMember = m;
          });
          if (!lastMember) toss('No member property descriptions found.');
          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
            toss(
              'Invalid struct config:',
              structName,
              'max member offset (' + lastMember.offset + ') ',
              'extends past end of struct (sizeof=' + structInfo.sizeof + ').',
            );
          }
          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));

          const StructCtor = function StructCtor(externalMemory) {
            if (!(this instanceof StructCtor)) {
              toss(
                'The',
                structName,
                "constructor may only be called via 'new'.",
              );
            } else if (arguments.length) {
              if (
                externalMemory !== (externalMemory | 0) ||
                externalMemory <= 0
              ) {
                toss('Invalid pointer value for', structName, 'constructor.');
              }
              __allocStruct(StructCtor, this, externalMemory);
            } else {
              __allocStruct(StructCtor, this);
            }
          };
          Object.defineProperties(StructCtor, {
            debugFlags: debugFlags,
            isA: rop((v) => v instanceof StructCtor),
            memberKey: __memberKeyProp,
            memberKeys: __structMemberKeys,
            methodInfoForKey: rop(function (mKey) {}),
            structInfo: rop(structInfo),
            structName: rop(structName),
          });
          StructCtor.prototype = new StructType(structName, structInfo, rop);
          Object.defineProperties(StructCtor.prototype, {
            debugFlags: debugFlags,
            constructor: rop(StructCtor),
          });
          Object.keys(structInfo.members).forEach((name) =>
            makeMemberWrapper(StructCtor, name, structInfo.members[name]),
          );
          return StructCtor;
        };
        StructBinder.StructType = StructType;
        StructBinder.config = config;
        StructBinder.allocCString = __allocCString;
        if (!StructBinder.debugFlags) {
          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
        }
        return StructBinder;
      };

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        'use strict';
        const toss = (...args) => {
          throw new Error(args.join(' '));
        };
        const toss3 = sqlite3.SQLite3Error.toss;
        const capi = sqlite3.capi,
          wasm = sqlite3.wasm,
          util = sqlite3.util;
        globalThis.WhWasmUtilInstaller(wasm);
        delete globalThis.WhWasmUtilInstaller;

        if (false) {}

        wasm.bindingSignatures = [
          ['sqlite3_aggregate_context', 'void*', 'sqlite3_context*', 'int'],

          ['sqlite3_bind_double', 'int', 'sqlite3_stmt*', 'int', 'f64'],
          ['sqlite3_bind_int', 'int', 'sqlite3_stmt*', 'int', 'int'],
          ['sqlite3_bind_null', undefined, 'sqlite3_stmt*', 'int'],
          ['sqlite3_bind_parameter_count', 'int', 'sqlite3_stmt*'],
          ['sqlite3_bind_parameter_index', 'int', 'sqlite3_stmt*', 'string'],
          [
            'sqlite3_bind_pointer',
            'int',
            'sqlite3_stmt*',
            'int',
            '*',
            'string:static',
            '*',
          ],
          [
            'sqlite3_busy_handler',
            'int',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                signature: 'i(pi)',
                contextKey: (argv, argIndex) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_busy_timeout', 'int', 'sqlite3*', 'int'],

          ['sqlite3_changes', 'int', 'sqlite3*'],
          ['sqlite3_clear_bindings', 'int', 'sqlite3_stmt*'],
          ['sqlite3_collation_needed', 'int', 'sqlite3*', '*', '*'],
          ['sqlite3_column_blob', '*', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_bytes', 'int', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_count', 'int', 'sqlite3_stmt*'],
          ['sqlite3_column_double', 'f64', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_int', 'int', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_name', 'string', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_text', 'string', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_type', 'int', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_value', 'sqlite3_value*', 'sqlite3_stmt*', 'int'],
          [
            'sqlite3_commit_hook',
            'void*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_commit_hook',
                signature: 'i(p)',
                contextKey: (argv) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_compileoption_get', 'string', 'int'],
          ['sqlite3_compileoption_used', 'int', 'string'],
          ['sqlite3_complete', 'int', 'string:flexible'],
          ['sqlite3_context_db_handle', 'sqlite3*', 'sqlite3_context*'],

          ['sqlite3_data_count', 'int', 'sqlite3_stmt*'],
          ['sqlite3_db_filename', 'string', 'sqlite3*', 'string'],
          ['sqlite3_db_handle', 'sqlite3*', 'sqlite3_stmt*'],
          ['sqlite3_db_name', 'string', 'sqlite3*', 'int'],
          ['sqlite3_db_status', 'int', 'sqlite3*', 'int', '*', '*', 'int'],
          ['sqlite3_errcode', 'int', 'sqlite3*'],
          ['sqlite3_errmsg', 'string', 'sqlite3*'],
          ['sqlite3_error_offset', 'int', 'sqlite3*'],
          ['sqlite3_errstr', 'string', 'int'],
          [
            'sqlite3_exec',
            'int',
            [
              'sqlite3*',
              'string:flexible',
              new wasm.xWrap.FuncPtrAdapter({
                signature: 'i(pipp)',
                bindScope: 'transient',
                callProxy: (callback) => {
                  let aNames;
                  return (pVoid, nCols, pColVals, pColNames) => {
                    try {
                      const aVals = wasm.cArgvToJs(nCols, pColVals);
                      if (!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);
                      return callback(aVals, aNames) | 0;
                    } catch (e) {
                      return e.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                },
              }),
              '*',
              '**',
            ],
          ],
          ['sqlite3_expanded_sql', 'string', 'sqlite3_stmt*'],
          ['sqlite3_extended_errcode', 'int', 'sqlite3*'],
          ['sqlite3_extended_result_codes', 'int', 'sqlite3*', 'int'],
          ['sqlite3_file_control', 'int', 'sqlite3*', 'string', 'int', '*'],
          ['sqlite3_finalize', 'int', 'sqlite3_stmt*'],
          ['sqlite3_free', undefined, '*'],
          ['sqlite3_get_autocommit', 'int', 'sqlite3*'],
          ['sqlite3_get_auxdata', '*', 'sqlite3_context*', 'int'],
          ['sqlite3_initialize', undefined],

          ['sqlite3_keyword_count', 'int'],
          ['sqlite3_keyword_name', 'int', ['int', '**', '*']],
          ['sqlite3_keyword_check', 'int', ['string', 'int']],
          ['sqlite3_libversion', 'string'],
          ['sqlite3_libversion_number', 'int'],
          ['sqlite3_limit', 'int', ['sqlite3*', 'int', 'int']],
          ['sqlite3_malloc', '*', 'int'],
          ['sqlite3_open', 'int', 'string', '*'],
          ['sqlite3_open_v2', 'int', 'string', '*', 'int', 'string'],

          [
            'sqlite3_progress_handler',
            undefined,
            [
              'sqlite3*',
              'int',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xProgressHandler',
                signature: 'i(p)',
                bindScope: 'context',
                contextKey: (argv, argIndex) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_realloc', '*', '*', 'int'],
          ['sqlite3_reset', 'int', 'sqlite3_stmt*'],

          [
            'sqlite3_result_blob',
            undefined,
            'sqlite3_context*',
            '*',
            'int',
            '*',
          ],
          ['sqlite3_result_double', undefined, 'sqlite3_context*', 'f64'],
          [
            'sqlite3_result_error',
            undefined,
            'sqlite3_context*',
            'string',
            'int',
          ],
          ['sqlite3_result_error_code', undefined, 'sqlite3_context*', 'int'],
          ['sqlite3_result_error_nomem', undefined, 'sqlite3_context*'],
          ['sqlite3_result_error_toobig', undefined, 'sqlite3_context*'],
          ['sqlite3_result_int', undefined, 'sqlite3_context*', 'int'],
          ['sqlite3_result_null', undefined, 'sqlite3_context*'],
          [
            'sqlite3_result_pointer',
            undefined,
            'sqlite3_context*',
            '*',
            'string:static',
            '*',
          ],
          ['sqlite3_result_subtype', undefined, 'sqlite3_value*', 'int'],
          [
            'sqlite3_result_text',
            undefined,
            'sqlite3_context*',
            'string',
            'int',
            '*',
          ],
          ['sqlite3_result_zeroblob', undefined, 'sqlite3_context*', 'int'],
          [
            'sqlite3_rollback_hook',
            'void*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_rollback_hook',
                signature: 'v(p)',
                contextKey: (argv) => argv[0],
              }),
              '*',
            ],
          ],
          [
            'sqlite3_set_authorizer',
            'int',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_set_authorizer::xAuth',
                signature: 'i(pi' + 'ssss)',
                contextKey: (argv, argIndex) => argv[0],
                callProxy: (callback) => {
                  return (pV, iCode, s0, s1, s2, s3) => {
                    try {
                      s0 = s0 && wasm.cstrToJs(s0);
                      s1 = s1 && wasm.cstrToJs(s1);
                      s2 = s2 && wasm.cstrToJs(s2);
                      s3 = s3 && wasm.cstrToJs(s3);
                      return callback(pV, iCode, s0, s1, s2, s3) || 0;
                    } catch (e) {
                      return e.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                },
              }),
              '*',
            ],
          ],
          [
            'sqlite3_set_auxdata',
            undefined,
            [
              'sqlite3_context*',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroyAuxData',
                signature: 'v(*)',
                contextKey: (argv, argIndex) => argv[0],
              }),
            ],
          ],
          ['sqlite3_shutdown', undefined],
          ['sqlite3_sourceid', 'string'],
          ['sqlite3_sql', 'string', 'sqlite3_stmt*'],
          ['sqlite3_status', 'int', 'int', '*', '*', 'int'],
          ['sqlite3_step', 'int', 'sqlite3_stmt*'],
          ['sqlite3_stmt_isexplain', 'int', ['sqlite3_stmt*']],
          ['sqlite3_stmt_readonly', 'int', ['sqlite3_stmt*']],
          ['sqlite3_stmt_status', 'int', 'sqlite3_stmt*', 'int', 'int'],
          ['sqlite3_strglob', 'int', 'string', 'string'],
          ['sqlite3_stricmp', 'int', 'string', 'string'],
          ['sqlite3_strlike', 'int', 'string', 'string', 'int'],
          ['sqlite3_strnicmp', 'int', 'string', 'string', 'int'],
          [
            'sqlite3_table_column_metadata',
            'int',
            'sqlite3*',
            'string',
            'string',
            'string',
            '**',
            '**',
            '*',
            '*',
            '*',
          ],
          ['sqlite3_total_changes', 'int', 'sqlite3*'],
          [
            'sqlite3_trace_v2',
            'int',
            [
              'sqlite3*',
              'int',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_trace_v2::callback',
                signature: 'i(ippp)',
                contextKey: (argv, argIndex) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_txn_state', 'int', ['sqlite3*', 'string']],

          ['sqlite3_uri_boolean', 'int', 'sqlite3_filename', 'string', 'int'],
          ['sqlite3_uri_key', 'string', 'sqlite3_filename', 'int'],
          ['sqlite3_uri_parameter', 'string', 'sqlite3_filename', 'string'],
          ['sqlite3_user_data', 'void*', 'sqlite3_context*'],
          ['sqlite3_value_blob', '*', 'sqlite3_value*'],
          ['sqlite3_value_bytes', 'int', 'sqlite3_value*'],
          ['sqlite3_value_double', 'f64', 'sqlite3_value*'],
          ['sqlite3_value_dup', 'sqlite3_value*', 'sqlite3_value*'],
          ['sqlite3_value_free', undefined, 'sqlite3_value*'],
          ['sqlite3_value_frombind', 'int', 'sqlite3_value*'],
          ['sqlite3_value_int', 'int', 'sqlite3_value*'],
          ['sqlite3_value_nochange', 'int', 'sqlite3_value*'],
          ['sqlite3_value_numeric_type', 'int', 'sqlite3_value*'],
          ['sqlite3_value_pointer', '*', 'sqlite3_value*', 'string:static'],
          ['sqlite3_value_subtype', 'int', 'sqlite3_value*'],
          ['sqlite3_value_text', 'string', 'sqlite3_value*'],
          ['sqlite3_value_type', 'int', 'sqlite3_value*'],
          ['sqlite3_vfs_find', '*', 'string'],
          ['sqlite3_vfs_register', 'int', 'sqlite3_vfs*', 'int'],
          ['sqlite3_vfs_unregister', 'int', 'sqlite3_vfs*'],
        ];

        if (false) {}

        if (wasm.exports.sqlite3_activate_see instanceof Function) {
          wasm.bindingSignatures.push(
            ['sqlite3_key', 'int', 'sqlite3*', 'string', 'int'],
            ['sqlite3_key_v2', 'int', 'sqlite3*', 'string', '*', 'int'],
            ['sqlite3_rekey', 'int', 'sqlite3*', 'string', 'int'],
            ['sqlite3_rekey_v2', 'int', 'sqlite3*', 'string', '*', 'int'],
            ['sqlite3_activate_see', undefined, 'string'],
          );
        }

        wasm.bindingSignatures.int64 = [
          ['sqlite3_bind_int64', 'int', ['sqlite3_stmt*', 'int', 'i64']],
          ['sqlite3_changes64', 'i64', ['sqlite3*']],
          ['sqlite3_column_int64', 'i64', ['sqlite3_stmt*', 'int']],
          [
            'sqlite3_create_module',
            'int',
            ['sqlite3*', 'string', 'sqlite3_module*', '*'],
          ],
          [
            'sqlite3_create_module_v2',
            'int',
            ['sqlite3*', 'string', 'sqlite3_module*', '*', '*'],
          ],
          ['sqlite3_declare_vtab', 'int', ['sqlite3*', 'string:flexible']],
          [
            'sqlite3_deserialize',
            'int',
            'sqlite3*',
            'string',
            '*',
            'i64',
            'i64',
            'int',
          ],
          ['sqlite3_drop_modules', 'int', ['sqlite3*', '**']],
          ['sqlite3_last_insert_rowid', 'i64', ['sqlite3*']],
          ['sqlite3_malloc64', '*', 'i64'],
          ['sqlite3_msize', 'i64', '*'],
          ['sqlite3_overload_function', 'int', ['sqlite3*', 'string', 'int']],
          ['sqlite3_preupdate_blobwrite', 'int', 'sqlite3*'],
          ['sqlite3_preupdate_count', 'int', 'sqlite3*'],
          ['sqlite3_preupdate_depth', 'int', 'sqlite3*'],
          [
            'sqlite3_preupdate_hook',
            '*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_preupdate_hook',
                signature: 'v(ppippjj)',
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p, db, op, zDb, zTbl, iKey1, iKey2) => {
                    callback(
                      p,
                      db,
                      op,
                      wasm.cstrToJs(zDb),
                      wasm.cstrToJs(zTbl),
                      iKey1,
                      iKey2,
                    );
                  };
                },
              }),
              '*',
            ],
          ],
          ['sqlite3_preupdate_new', 'int', ['sqlite3*', 'int', '**']],
          ['sqlite3_preupdate_old', 'int', ['sqlite3*', 'int', '**']],
          ['sqlite3_realloc64', '*', '*', 'i64'],
          ['sqlite3_result_int64', undefined, '*', 'i64'],
          ['sqlite3_result_zeroblob64', 'int', '*', 'i64'],
          ['sqlite3_serialize', '*', 'sqlite3*', 'string', '*', 'int'],
          ['sqlite3_set_last_insert_rowid', undefined, ['sqlite3*', 'i64']],
          ['sqlite3_status64', 'int', 'int', '*', '*', 'int'],
          ['sqlite3_total_changes64', 'i64', ['sqlite3*']],
          [
            'sqlite3_update_hook',
            '*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_update_hook',
                signature: 'v(iippj)',
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p, op, z0, z1, rowid) => {
                    callback(
                      p,
                      op,
                      wasm.cstrToJs(z0),
                      wasm.cstrToJs(z1),
                      rowid,
                    );
                  };
                },
              }),
              '*',
            ],
          ],
          ['sqlite3_uri_int64', 'i64', ['sqlite3_filename', 'string', 'i64']],
          ['sqlite3_value_int64', 'i64', 'sqlite3_value*'],
          ['sqlite3_vtab_collation', 'string', 'sqlite3_index_info*', 'int'],
          ['sqlite3_vtab_distinct', 'int', 'sqlite3_index_info*'],
          ['sqlite3_vtab_in', 'int', 'sqlite3_index_info*', 'int', 'int'],
          ['sqlite3_vtab_in_first', 'int', 'sqlite3_value*', '**'],
          ['sqlite3_vtab_in_next', 'int', 'sqlite3_value*', '**'],

          ['sqlite3_vtab_nochange', 'int', 'sqlite3_context*'],
          ['sqlite3_vtab_on_conflict', 'int', 'sqlite3*'],
          ['sqlite3_vtab_rhs_value', 'int', 'sqlite3_index_info*', 'int', '**'],
        ];

        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add) {
          const __ipsProxy = {
            signature: 'i(ps)',
            callProxy: (callback) => {
              return (p, s) => {
                try {
                  return callback(p, wasm.cstrToJs(s)) | 0;
                } catch (e) {
                  return e.resultCode || capi.SQLITE_ERROR;
                }
              };
            },
          };

          wasm.bindingSignatures.int64.push(
            ...[
              [
                'sqlite3changegroup_add',
                'int',
                ['sqlite3_changegroup*', 'int', 'void*'],
              ],
              [
                'sqlite3changegroup_add_strm',
                'int',
                [
                  'sqlite3_changegroup*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changegroup_delete',
                undefined,
                ['sqlite3_changegroup*'],
              ],
              ['sqlite3changegroup_new', 'int', ['**']],
              [
                'sqlite3changegroup_output',
                'int',
                ['sqlite3_changegroup*', 'int*', '**'],
              ],
              [
                'sqlite3changegroup_output_strm',
                'int',
                [
                  'sqlite3_changegroup*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppi)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_apply',
                'int',
                [
                  'sqlite3*',
                  'int',
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_apply_strm',
                'int',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_apply_v2',
                'int',
                [
                  'sqlite3*',
                  'int',
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  '**',
                  'int*',
                  'int',
                ],
              ],
              [
                'sqlite3changeset_apply_v2_strm',
                'int',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  '**',
                  'int*',
                  'int',
                ],
              ],
              [
                'sqlite3changeset_concat',
                'int',
                ['int', 'void*', 'int', 'void*', 'int*', '**'],
              ],
              [
                'sqlite3changeset_concat_strm',
                'int',
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInputA',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInputB',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppi)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_conflict',
                'int',
                ['sqlite3_changeset_iter*', 'int', '**'],
              ],
              ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],
              [
                'sqlite3changeset_fk_conflicts',
                'int',
                ['sqlite3_changeset_iter*', 'int*'],
              ],
              [
                'sqlite3changeset_invert',
                'int',
                ['int', 'void*', 'int*', '**'],
              ],
              [
                'sqlite3changeset_invert_strm',
                'int',
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppi)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_new',
                'int',
                ['sqlite3_changeset_iter*', 'int', '**'],
              ],
              ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],
              [
                'sqlite3changeset_old',
                'int',
                ['sqlite3_changeset_iter*', 'int', '**'],
              ],
              [
                'sqlite3changeset_op',
                'int',
                ['sqlite3_changeset_iter*', '**', 'int*', 'int*', 'int*'],
              ],
              [
                'sqlite3changeset_pk',
                'int',
                ['sqlite3_changeset_iter*', '**', 'int*'],
              ],
              ['sqlite3changeset_start', 'int', ['**', 'int', '*']],
              [
                'sqlite3changeset_start_strm',
                'int',
                [
                  '**',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],
              [
                'sqlite3changeset_start_v2_strm',
                'int',
                [
                  '**',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  'int',
                ],
              ],
              ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],
              [
                'sqlite3session_changeset',
                'int',
                ['sqlite3_session*', 'int*', '**'],
              ],
              ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],
              [
                'sqlite3session_changeset_strm',
                'int',
                [
                  'sqlite3_session*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              ['sqlite3session_config', 'int', ['int', 'void*']],
              ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],

              [
                'sqlite3session_diff',
                'int',
                ['sqlite3_session*', 'string', 'string', '**'],
              ],
              ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],
              ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],
              ['sqlite3session_isempty', 'int', ['sqlite3_session*']],
              ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],
              [
                'sqlite3session_object_config',
                'int',
                ['sqlite3_session*', 'int', 'void*'],
              ],
              [
                'sqlite3session_patchset',
                'int',
                ['sqlite3_session*', '*', '**'],
              ],
              [
                'sqlite3session_patchset_strm',
                'int',
                [
                  'sqlite3_session*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3session_table_filter',
                undefined,
                [
                  'sqlite3_session*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    ...__ipsProxy,
                    contextKey: (argv, argIndex) => argv[0],
                  }),
                  '*',
                ],
              ],
            ],
          );
        }

        wasm.bindingSignatures.wasm = [
          ['sqlite3_wasm_db_reset', 'int', 'sqlite3*'],
          ['sqlite3_wasm_db_vfs', 'sqlite3_vfs*', 'sqlite3*', 'string'],
          [
            'sqlite3_wasm_vfs_create_file',
            'int',
            'sqlite3_vfs*',
            'string',
            '*',
            'int',
          ],
          ['sqlite3_wasm_posix_create_file', 'int', 'string', '*', 'int'],
          ['sqlite3_wasm_vfs_unlink', 'int', 'sqlite3_vfs*', 'string'],
        ];

        sqlite3.StructBinder = globalThis.Jaccwabyt({
          heap:  false ? 0 : wasm.heap8u,
          alloc: wasm.alloc,
          dealloc: wasm.dealloc,
          bigIntEnabled: wasm.bigIntEnabled,
          memberPrefix: '$',
        });
        delete globalThis.Jaccwabyt;

        {
          const __xString = wasm.xWrap.argAdapter('string');
          wasm.xWrap.argAdapter('string:flexible', (v) =>
            __xString(util.flexibleString(v)),
          );

          wasm.xWrap.argAdapter(
            'string:static',
            function (v) {
              if (wasm.isPtr(v)) return v;
              v = '' + v;
              let rc = this[v];
              return rc || (this[v] = wasm.allocCString(v));
            }.bind(Object.create(null)),
          );

          const __xArgPtr = wasm.xWrap.argAdapter('*');
          const nilType = function () {};
          wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)(
            'sqlite3_context*',
            __xArgPtr,
          )('sqlite3_value*', __xArgPtr)('void*', __xArgPtr)(
            'sqlite3_changegroup*',
            __xArgPtr,
          )('sqlite3_changeset_iter*', __xArgPtr)(
            'sqlite3_session*',
            __xArgPtr,
          )('sqlite3_stmt*', (v) =>
            __xArgPtr(
              v instanceof (sqlite3?.oo1?.Stmt || nilType) ? v.pointer : v,
            ),
          )('sqlite3*', (v) =>
            __xArgPtr(
              v instanceof (sqlite3?.oo1?.DB || nilType) ? v.pointer : v,
            ),
          )('sqlite3_index_info*', (v) =>
            __xArgPtr(
              v instanceof (capi.sqlite3_index_info || nilType) ? v.pointer : v,
            ),
          )('sqlite3_module*', (v) =>
            __xArgPtr(
              v instanceof (capi.sqlite3_module || nilType) ? v.pointer : v,
            ),
          )('sqlite3_vfs*', (v) => {
            if ('string' === typeof v) {
              return (
                capi.sqlite3_vfs_find(v) ||
                sqlite3.SQLite3Error.toss(
                  capi.SQLITE_NOTFOUND,
                  'Unknown sqlite3_vfs name:',
                  v,
                )
              );
            }
            return __xArgPtr(
              v instanceof (capi.sqlite3_vfs || nilType) ? v.pointer : v,
            );
          });

          const __xRcPtr = wasm.xWrap.resultAdapter('*');
          wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)(
            'sqlite3_context*',
            __xRcPtr,
          )('sqlite3_stmt*', __xRcPtr)('sqlite3_value*', __xRcPtr)(
            'sqlite3_vfs*',
            __xRcPtr,
          )('void*', __xRcPtr);

          if (0 === wasm.exports.sqlite3_step.length) {
            wasm.xWrap.doArgcCheck = false;
            sqlite3.config.warn(
              'Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks.',
            );
          }
          for (const e of wasm.bindingSignatures) {
            capi[e[0]] = wasm.xWrap.apply(null, e);
          }
          for (const e of wasm.bindingSignatures.wasm) {
            wasm[e[0]] = wasm.xWrap.apply(null, e);
          }

          const fI64Disabled = function (fname) {
            return () =>
              toss(
                fname + '() is unavailable due to lack',
                'of BigInt support in this build.',
              );
          };
          for (const e of wasm.bindingSignatures.int64) {
            capi[e[0]] = wasm.bigIntEnabled
              ? wasm.xWrap.apply(null, e)
              : fI64Disabled(e[0]);
          }

          delete wasm.bindingSignatures;

          if (wasm.exports.sqlite3_wasm_db_error) {
            const __db_err = wasm.xWrap(
              'sqlite3_wasm_db_error',
              'int',
              'sqlite3*',
              'int',
              'string',
            );

            util.sqlite3_wasm_db_error = function (pDb, resultCode, message) {
              if (resultCode instanceof sqlite3.WasmAllocError) {
                resultCode = capi.SQLITE_NOMEM;
                message = 0;
              } else if (resultCode instanceof Error) {
                message = message || '' + resultCode;
                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
              }
              return pDb ? __db_err(pDb, resultCode, message) : resultCode;
            };
          } else {
            util.sqlite3_wasm_db_error = function (pDb, errCode, msg) {
              console.warn(
                'sqlite3_wasm_db_error() is not exported.',
                arguments,
              );
              return errCode;
            };
          }
        }

        {
          const cJson = wasm.xCall('sqlite3_wasm_enum_json');
          if (!cJson) {
            toss(
              "Maintenance required: increase sqlite3_wasm_enum_json()'s",
              'static buffer size!',
            );
          }

          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));

          const defineGroups = [
            'access',
            'authorizer',
            'blobFinalizers',
            'changeset',
            'config',
            'dataTypes',
            'dbConfig',
            'dbStatus',
            'encodings',
            'fcntl',
            'flock',
            'ioCap',
            'limits',
            'openFlags',
            'prepareFlags',
            'resultCodes',
            'sqlite3Status',
            'stmtStatus',
            'syncFlags',
            'trace',
            'txnState',
            'udfFlags',
            'version',
          ];
          if (wasm.bigIntEnabled) {
            defineGroups.push('serialize', 'session', 'vtab');
          }
          for (const t of defineGroups) {
            for (const e of Object.entries(wasm.ctype[t])) {
              capi[e[0]] = e[1];
            }
          }
          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              'Internal error: cannot resolve exported function',
              'entry SQLITE_WASM_DEALLOC (==' + capi.SQLITE_WASM_DEALLOC + ').',
            );
          }
          const __rcMap = Object.create(null);
          for (const t of ['resultCodes']) {
            for (const e of Object.entries(wasm.ctype[t])) {
              __rcMap[e[1]] = e[0];
            }
          }

          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];

          const notThese = Object.assign(Object.create(null), {
            WasmTestStruct: true,

            sqlite3_kvvfs_methods: !util.isUIThread(),

            sqlite3_index_info: !wasm.bigIntEnabled,
            sqlite3_index_constraint: !wasm.bigIntEnabled,
            sqlite3_index_orderby: !wasm.bigIntEnabled,
            sqlite3_index_constraint_usage: !wasm.bigIntEnabled,
          });
          for (const s of wasm.ctype.structs) {
            if (!notThese[s.name]) {
              capi[s.name] = sqlite3.StructBinder(s);
            }
          }
          if (capi.sqlite3_index_info) {
            for (const k of [
              'sqlite3_index_constraint',
              'sqlite3_index_orderby',
              'sqlite3_index_constraint_usage',
            ]) {
              capi.sqlite3_index_info[k] = capi[k];
              delete capi[k];
            }
            capi.sqlite3_vtab_config = wasm.xWrap(
              'sqlite3_wasm_vtab_config',
              'int',
              ['sqlite3*', 'int', 'int'],
            );
          }
        }

        const __dbArgcMismatch = (pDb, f, n) => {
          return util.sqlite3_wasm_db_error(
            pDb,
            capi.SQLITE_MISUSE,
            f + '() requires ' + n + ' argument' + (1 === n ? '' : 's') + '.',
          );
        };

        const __errEncoding = (pDb) => {
          return util.sqlite3_wasm_db_error(
            pDb,
            capi.SQLITE_FORMAT,
            'SQLITE_UTF8 is the only supported encoding.',
          );
        };

        const __argPDb = (pDb) => wasm.xWrap.argAdapter('sqlite3*')(pDb);
        const __argStr = (str) => (wasm.isPtr(str) ? wasm.cstrToJs(str) : str);
        const __dbCleanupMap = function (pDb, mode) {
          pDb = __argPDb(pDb);
          let m = this.dbMap.get(pDb);
          if (!mode) {
            this.dbMap.delete(pDb);
            return m;
          } else if (!m && mode > 0) {
            this.dbMap.set(pDb, (m = Object.create(null)));
          }
          return m;
        }.bind(
          Object.assign(Object.create(null), {
            dbMap: new Map(),
          }),
        );

        __dbCleanupMap.addCollation = function (pDb, name) {
          const m = __dbCleanupMap(pDb, 1);
          if (!m.collation) m.collation = new Set();
          m.collation.add(__argStr(name).toLowerCase());
        };

        __dbCleanupMap._addUDF = function (pDb, name, arity, map) {
          name = __argStr(name).toLowerCase();
          let u = map.get(name);
          if (!u) map.set(name, (u = new Set()));
          u.add(arity < 0 ? -1 : arity);
        };

        __dbCleanupMap.addFunction = function (pDb, name, arity) {
          const m = __dbCleanupMap(pDb, 1);
          if (!m.udf) m.udf = new Map();
          this._addUDF(pDb, name, arity, m.udf);
        };

        __dbCleanupMap.addWindowFunc = function (pDb, name, arity) {
          const m = __dbCleanupMap(pDb, 1);
          if (!m.wudf) m.wudf = new Map();
          this._addUDF(pDb, name, arity, m.wudf);
        };

        __dbCleanupMap.cleanup = function (pDb) {
          pDb = __argPDb(pDb);

          const closeArgs = [pDb];
          for (const name of [
            'sqlite3_busy_handler',
            'sqlite3_commit_hook',
            'sqlite3_preupdate_hook',
            'sqlite3_progress_handler',
            'sqlite3_rollback_hook',
            'sqlite3_set_authorizer',
            'sqlite3_trace_v2',
            'sqlite3_update_hook',
          ]) {
            const x = wasm.exports[name];
            closeArgs.length = x.length;
            try {
              capi[name](...closeArgs);
            } catch (e) {
              console.warn(
                'close-time call of',
                name + '(',
                closeArgs,
                ') threw:',
                e,
              );
            }
          }
          const m = __dbCleanupMap(pDb, 0);
          if (!m) return;
          if (m.collation) {
            for (const name of m.collation) {
              try {
                capi.sqlite3_create_collation_v2(
                  pDb,
                  name,
                  capi.SQLITE_UTF8,
                  0,
                  0,
                  0,
                );
              } catch (e) {}
            }
            delete m.collation;
          }
          let i;
          for (i = 0; i < 2; ++i) {
            const fmap = i ? m.wudf : m.udf;
            if (!fmap) continue;
            const func = i
              ? capi.sqlite3_create_window_function
              : capi.sqlite3_create_function_v2;
            for (const e of fmap) {
              const name = e[0],
                arities = e[1];
              const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
              if (i) fargs.push(0);
              for (const arity of arities) {
                try {
                  fargs[2] = arity;
                  func.apply(null, fargs);
                } catch (e) {}
              }
              arities.clear();
            }
            fmap.clear();
          }
          delete m.udf;
          delete m.wudf;
        };

        {
          const __sqlite3CloseV2 = wasm.xWrap(
            'sqlite3_close_v2',
            'int',
            'sqlite3*',
          );
          capi.sqlite3_close_v2 = function (pDb) {
            if (1 !== arguments.length)
              return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);
            if (pDb) {
              try {
                __dbCleanupMap.cleanup(pDb);
              } catch (e) {}
            }
            return __sqlite3CloseV2(pDb);
          };
        }

        if (capi.sqlite3session_table_filter) {
          const __sqlite3SessionDelete = wasm.xWrap(
            'sqlite3session_delete',
            undefined,
            ['sqlite3_session*'],
          );
          capi.sqlite3session_delete = function (pSession) {
            if (1 !== arguments.length) {
              return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);
            } else if (pSession) {
              capi.sqlite3session_table_filter(pSession, 0, 0);
            }
            __sqlite3SessionDelete(pSession);
          };
        }

        {
          const contextKey = (argv, argIndex) => {
            return (
              'argv[' +
              argIndex +
              ']:' +
              argv[0] +
              ':' +
              wasm.cstrToJs(argv[1]).toLowerCase()
            );
          };
          const __sqlite3CreateCollationV2 = wasm.xWrap(
            'sqlite3_create_collation_v2',
            'int',
            [
              'sqlite3*',
              'string',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xCompare',
                signature: 'i(pipip)',
                contextKey,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroy',
                signature: 'v(p)',
                contextKey,
              }),
            ],
          );

          capi.sqlite3_create_collation_v2 = function (
            pDb,
            zName,
            eTextRep,
            pArg,
            xCompare,
            xDestroy,
          ) {
            if (6 !== arguments.length)
              return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);
            else if (0 === (eTextRep & 0xf)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
              return __errEncoding(pDb);
            }
            try {
              const rc = __sqlite3CreateCollationV2(
                pDb,
                zName,
                eTextRep,
                pArg,
                xCompare,
                xDestroy,
              );
              if (0 === rc && xCompare instanceof Function) {
                __dbCleanupMap.addCollation(pDb, zName);
              }
              return rc;
            } catch (e) {
              return util.sqlite3_wasm_db_error(pDb, e);
            }
          };

          capi.sqlite3_create_collation = (
            pDb,
            zName,
            eTextRep,
            pArg,
            xCompare,
          ) => {
            return 5 === arguments.length
              ? capi.sqlite3_create_collation_v2(
                  pDb,
                  zName,
                  eTextRep,
                  pArg,
                  xCompare,
                  0,
                )
              : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);
          };
        }

        {
          const contextKey = function (argv, argIndex) {
            return (
              argv[0] +
              ':' +
              (argv[2] < 0 ? -1 : argv[2]) +
              ':' +
              argIndex +
              ':' +
              wasm.cstrToJs(argv[1]).toLowerCase()
            );
          };

          const __cfProxy = Object.assign(Object.create(null), {
            xInverseAndStep: {
              signature: 'v(pip)',
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              },
            },
            xFinalAndValue: {
              signature: 'v(p)',
              contextKey,
              callProxy: (callback) => {
                return (pCtx) => {
                  try {
                    capi.sqlite3_result_js(pCtx, callback(pCtx));
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              },
            },
            xFunc: {
              signature: 'v(pip)',
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    capi.sqlite3_result_js(
                      pCtx,
                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)),
                    );
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              },
            },
            xDestroy: {
              signature: 'v(p)',
              contextKey,

              callProxy: (callback) => {
                return (pVoid) => {
                  try {
                    callback(pVoid);
                  } catch (e) {
                    console.error('UDF xDestroy method threw:', e);
                  }
                };
              },
            },
          });

          const __sqlite3CreateFunction = wasm.xWrap(
            'sqlite3_create_function_v2',
            'int',
            [
              'sqlite3*',
              'string',
              'int',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xFunc',
                ...__cfProxy.xFunc,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xStep',
                ...__cfProxy.xInverseAndStep,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xFinal',
                ...__cfProxy.xFinalAndValue,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroy',
                ...__cfProxy.xDestroy,
              }),
            ],
          );

          const __sqlite3CreateWindowFunction = wasm.xWrap(
            'sqlite3_create_window_function',
            'int',
            [
              'sqlite3*',
              'string',
              'int',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xStep',
                ...__cfProxy.xInverseAndStep,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xFinal',
                ...__cfProxy.xFinalAndValue,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xValue',
                ...__cfProxy.xFinalAndValue,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xInverse',
                ...__cfProxy.xInverseAndStep,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroy',
                ...__cfProxy.xDestroy,
              }),
            ],
          );

          capi.sqlite3_create_function_v2 = function f(
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb,
                'sqlite3_create_function_v2',
                f.length,
              );
            } else if (0 === (eTextRep & 0xf)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
              return __errEncoding(pDb);
            }
            try {
              const rc = __sqlite3CreateFunction(
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy,
              );
              if (
                0 === rc &&
                (xFunc instanceof Function ||
                  xStep instanceof Function ||
                  xFinal instanceof Function ||
                  xDestroy instanceof Function)
              ) {
                __dbCleanupMap.addFunction(pDb, funcName, nArg);
              }
              return rc;
            } catch (e) {
              console.error('sqlite3_create_function_v2() setup threw:', e);
              return util.sqlite3_wasm_db_error(
                pDb,
                e,
                'Creation of UDF threw: ' + e,
              );
            }
          };

          capi.sqlite3_create_function = function f(
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
          ) {
            return f.length === arguments.length
              ? capi.sqlite3_create_function_v2(
                  pDb,
                  funcName,
                  nArg,
                  eTextRep,
                  pApp,
                  xFunc,
                  xStep,
                  xFinal,
                  0,
                )
              : __dbArgcMismatch(pDb, 'sqlite3_create_function', f.length);
          };

          capi.sqlite3_create_window_function = function f(
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xStep,
            xFinal,
            xValue,
            xInverse,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb,
                'sqlite3_create_window_function',
                f.length,
              );
            } else if (0 === (eTextRep & 0xf)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
              return __errEncoding(pDb);
            }
            try {
              const rc = __sqlite3CreateWindowFunction(
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy,
              );
              if (
                0 === rc &&
                (xStep instanceof Function ||
                  xFinal instanceof Function ||
                  xValue instanceof Function ||
                  xInverse instanceof Function ||
                  xDestroy instanceof Function)
              ) {
                __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);
              }
              return rc;
            } catch (e) {
              console.error('sqlite3_create_window_function() setup threw:', e);
              return util.sqlite3_wasm_db_error(
                pDb,
                e,
                'Creation of UDF threw: ' + e,
              );
            }
          };

          capi.sqlite3_create_function_v2.udfSetResult =
            capi.sqlite3_create_function.udfSetResult =
            capi.sqlite3_create_window_function.udfSetResult =
              capi.sqlite3_result_js;

          capi.sqlite3_create_function_v2.udfConvertArgs =
            capi.sqlite3_create_function.udfConvertArgs =
            capi.sqlite3_create_window_function.udfConvertArgs =
              capi.sqlite3_values_to_js;

          capi.sqlite3_create_function_v2.udfSetError =
            capi.sqlite3_create_function.udfSetError =
            capi.sqlite3_create_window_function.udfSetError =
              capi.sqlite3_result_error_js;
        }

        {
          const __flexiString = (v, n) => {
            if ('string' === typeof v) {
              n = -1;
            } else if (util.isSQLableTypedArray(v)) {
              n = v.byteLength;
              v = util.typedArrayToString(
                v instanceof ArrayBuffer ? new Uint8Array(v) : v,
              );
            } else if (Array.isArray(v)) {
              v = v.join('');
              n = -1;
            }
            return [v, n];
          };

          const __prepare = {
            basic: wasm.xWrap('sqlite3_prepare_v3', 'int', [
              'sqlite3*',
              'string',
              'int',
              'int',
              '**',
              '**',
            ]),

            full: wasm.xWrap('sqlite3_prepare_v3', 'int', [
              'sqlite3*',
              '*',
              'int',
              'int',
              '**',
              '**',
            ]),
          };

          capi.sqlite3_prepare_v3 = function f(
            pDb,
            sql,
            sqlLen,
            prepFlags,
            ppStmt,
            pzTail,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(pDb, 'sqlite3_prepare_v3', f.length);
            }
            const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
            switch (typeof xSql) {
              case 'string':
                return __prepare.basic(
                  pDb,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  null,
                );
              case 'number':
                return __prepare.full(
                  pDb,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  pzTail,
                );
              default:
                return util.sqlite3_wasm_db_error(
                  pDb,
                  capi.SQLITE_MISUSE,
                  'Invalid SQL argument type for sqlite3_prepare_v2/v3().',
                );
            }
          };

          capi.sqlite3_prepare_v2 = function f(
            pDb,
            sql,
            sqlLen,
            ppStmt,
            pzTail,
          ) {
            return f.length === arguments.length
              ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)
              : __dbArgcMismatch(pDb, 'sqlite3_prepare_v2', f.length);
          };
        }

        {
          const __bindText = wasm.xWrap('sqlite3_bind_text', 'int', [
            'sqlite3_stmt*',
            'int',
            'string',
            'int',
            '*',
          ]);
          const __bindBlob = wasm.xWrap('sqlite3_bind_blob', 'int', [
            'sqlite3_stmt*',
            'int',
            '*',
            'int',
            '*',
          ]);

          capi.sqlite3_bind_text = function f(
            pStmt,
            iCol,
            text,
            nText,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                'sqlite3_bind_text',
                f.length,
              );
            } else if (wasm.isPtr(text) || null === text) {
              return __bindText(pStmt, iCol, text, nText, xDestroy);
            } else if (text instanceof ArrayBuffer) {
              text = new Uint8Array(text);
            } else if (Array.isArray(pMem)) {
              text = pMem.join('');
            }
            let p, n;
            try {
              if (util.isSQLableTypedArray(text)) {
                p = wasm.allocFromTypedArray(text);
                n = text.byteLength;
              } else if ('string' === typeof text) {
                [p, n] = wasm.allocCString(text);
              } else {
                return util.sqlite3_wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  'Invalid 3rd argument type for sqlite3_bind_text().',
                );
              }
              return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
            } catch (e) {
              wasm.dealloc(p);
              return util.sqlite3_wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e,
              );
            }
          };

          capi.sqlite3_bind_blob = function f(
            pStmt,
            iCol,
            pMem,
            nMem,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                'sqlite3_bind_blob',
                f.length,
              );
            } else if (wasm.isPtr(pMem) || null === pMem) {
              return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);
            } else if (pMem instanceof ArrayBuffer) {
              pMem = new Uint8Array(pMem);
            } else if (Array.isArray(pMem)) {
              pMem = pMem.join('');
            }
            let p, n;
            try {
              if (util.isBindableTypedArray(pMem)) {
                p = wasm.allocFromTypedArray(pMem);
                n = nMem >= 0 ? nMem : pMem.byteLength;
              } else if ('string' === typeof pMem) {
                [p, n] = wasm.allocCString(pMem);
              } else {
                return util.sqlite3_wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  'Invalid 3rd argument type for sqlite3_bind_blob().',
                );
              }
              return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
            } catch (e) {
              wasm.dealloc(p);
              return util.sqlite3_wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e,
              );
            }
          };
        }

        {
          capi.sqlite3_config = function (op, ...args) {
            if (arguments.length < 2) return capi.SQLITE_MISUSE;
            switch (op) {
              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
              case capi.SQLITE_CONFIG_MEMSTATUS:
              case capi.SQLITE_CONFIG_SMALL_MALLOC:
              case capi.SQLITE_CONFIG_SORTERREF_SIZE:
              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
              case capi.SQLITE_CONFIG_URI:
                return wasm.exports.sqlite3_wasm_config_i(op, args[0]);
              case capi.SQLITE_CONFIG_LOOKASIDE:
                return wasm.exports.sqlite3_wasm_config_ii(
                  op,
                  args[0],
                  args[1],
                );
              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                return wasm.exports.sqlite3_wasm_config_j(op, args[0]);
              case capi.SQLITE_CONFIG_GETMALLOC:
              case capi.SQLITE_CONFIG_GETMUTEX:
              case capi.SQLITE_CONFIG_GETPCACHE2:
              case capi.SQLITE_CONFIG_GETPCACHE:
              case capi.SQLITE_CONFIG_HEAP:
              case capi.SQLITE_CONFIG_LOG:
              case capi.SQLITE_CONFIG_MALLOC:
              case capi.SQLITE_CONFIG_MMAP_SIZE:
              case capi.SQLITE_CONFIG_MULTITHREAD:
              case capi.SQLITE_CONFIG_MUTEX:
              case capi.SQLITE_CONFIG_PAGECACHE:
              case capi.SQLITE_CONFIG_PCACHE2:
              case capi.SQLITE_CONFIG_PCACHE:
              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
              case capi.SQLITE_CONFIG_PMASZ:
              case capi.SQLITE_CONFIG_SERIALIZED:
              case capi.SQLITE_CONFIG_SINGLETHREAD:
              case capi.SQLITE_CONFIG_SQLLOG:
              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
              default:
                return capi.SQLITE_NOTFOUND;
            }
          };
        }

        {
          const __autoExtFptr = new Set();

          capi.sqlite3_auto_extension = function (fPtr) {
            if (fPtr instanceof Function) {
              fPtr = wasm.installFunction('i(ppp)', fPtr);
            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {
              return capi.SQLITE_MISUSE;
            }
            const rc = wasm.exports.sqlite3_auto_extension(fPtr);
            if (fPtr !== arguments[0]) {
              if (0 === rc) __autoExtFptr.add(fPtr);
              else wasm.uninstallFunction(fPtr);
            }
            return rc;
          };

          capi.sqlite3_cancel_auto_extension = function (fPtr) {
            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr)) return 0;
            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
          };

          capi.sqlite3_reset_auto_extension = function () {
            wasm.exports.sqlite3_reset_auto_extension();
            for (const fp of __autoExtFptr) wasm.uninstallFunction(fp);
            __autoExtFptr.clear();
          };
        }

        const pKvvfs = capi.sqlite3_vfs_find('kvvfs');
        if (pKvvfs) {
          if (util.isUIThread()) {
            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
              wasm.exports.sqlite3_wasm_kvvfs_methods(),
            );
            delete capi.sqlite3_kvvfs_methods;

            const kvvfsMakeKey = wasm.exports.sqlite3_wasm_kvvfsMakeKeyOnPstack,
              pstack = wasm.pstack;

            const kvvfsStorage = (zClass) =>
              115 === wasm.peek(zClass) ? sessionStorage : localStorage;

            const kvvfsImpls = {
              xRead: (zClass, zKey, zBuf, nBuf) => {
                const stack = pstack.pointer,
                  astack = wasm.scopedAllocPush();
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return -3;
                  const jKey = wasm.cstrToJs(zXKey);
                  const jV = kvvfsStorage(zClass).getItem(jKey);
                  if (!jV) return -1;
                  const nV = jV.length;
                  if (nBuf <= 0) return nV;
                  else if (1 === nBuf) {
                    wasm.poke(zBuf, 0);
                    return nV;
                  }
                  const zV = wasm.scopedAllocCString(jV);
                  if (nBuf > nV + 1) nBuf = nV + 1;
                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                  wasm.poke(zBuf + nBuf - 1, 0);
                  return nBuf - 1;
                } catch (e) {
                  console.error('kvstorageRead()', e);
                  return -2;
                } finally {
                  pstack.restore(stack);
                  wasm.scopedAllocPop(astack);
                }
              },
              xWrite: (zClass, zKey, zData) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return 1;
                  const jKey = wasm.cstrToJs(zXKey);
                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
                  return 0;
                } catch (e) {
                  console.error('kvstorageWrite()', e);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
              xDelete: (zClass, zKey) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return 1;
                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
                  return 0;
                } catch (e) {
                  console.error('kvstorageDelete()', e);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
            };
            for (const k of Object.keys(kvvfsImpls)) {
              kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm.installFunction(
                kvvfsMethods.memberSignature(k),
                kvvfsImpls[k],
              );
            }
          } else {
            capi.sqlite3_vfs_unregister(pKvvfs);
          }
        }

        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        sqlite3.version = {
          libVersion: '3.45.3',
          libVersionNumber: 3045003,
          sourceId:
            '2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355',
          downloadVersion: 3450300,
        };
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        const toss = (...args) => {
          throw new Error(args.join(' '));
        };
        const toss3 = (...args) => {
          throw new sqlite3.SQLite3Error(...args);
        };

        const capi = sqlite3.capi,
          wasm = sqlite3.wasm,
          util = sqlite3.util;

        const __ptrMap = new WeakMap();

        const __stmtMap = new WeakMap();

        const getOwnOption = (opts, p, dflt) => {
          const d = Object.getOwnPropertyDescriptor(opts, p);
          return d ? d.value : dflt;
        };

        const checkSqlite3Rc = function (dbPtr, sqliteResultCode) {
          if (sqliteResultCode) {
            if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;
            toss3(
              sqliteResultCode,
              'sqlite3 result code',
              sqliteResultCode + ':',
              dbPtr
                ? capi.sqlite3_errmsg(dbPtr)
                : capi.sqlite3_errstr(sqliteResultCode),
            );
          }
          return arguments[0];
        };

        const __dbTraceToConsole = wasm.installFunction(
          'i(ippp)',
          function (t, c, p, x) {
            if (capi.SQLITE_TRACE_STMT === t) {
              console.log(
                'SQL TRACE #' + ++this.counter + ' via sqlite3@' + c + ':',
                wasm.cstrToJs(x),
              );
            }
          }.bind({ counter: 0 }),
        );

        const __vfsPostOpenSql = Object.create(null);

        const dbCtorHelper = function ctor(...args) {
          if (!ctor._name2vfs) {
            ctor._name2vfs = Object.create(null);
            const isWorkerThread =
              'function' === typeof importScripts
                ? (n) =>
                    toss3(
                      'The VFS for',
                      n,
                      'is only available in the main window thread.',
                    )
                : false;
            ctor._name2vfs[':localStorage:'] = {
              vfs: 'kvvfs',
              filename: isWorkerThread || (() => 'local'),
            };
            ctor._name2vfs[':sessionStorage:'] = {
              vfs: 'kvvfs',
              filename: isWorkerThread || (() => 'session'),
            };
          }
          const opt = ctor.normalizeArgs(...args);
          let fn = opt.filename,
            vfsName = opt.vfs,
            flagsStr = opt.flags;
          if (
            ('string' !== typeof fn && 'number' !== typeof fn) ||
            'string' !== typeof flagsStr ||
            (vfsName &&
              'string' !== typeof vfsName &&
              'number' !== typeof vfsName)
          ) {
            sqlite3.config.error('Invalid DB ctor args', opt, arguments);
            toss3('Invalid arguments for DB constructor.');
          }
          let fnJs = 'number' === typeof fn ? wasm.cstrToJs(fn) : fn;
          const vfsCheck = ctor._name2vfs[fnJs];
          if (vfsCheck) {
            vfsName = vfsCheck.vfs;
            fn = fnJs = vfsCheck.filename(fnJs);
          }
          let pDb,
            oflags = 0;
          if (flagsStr.indexOf('c') >= 0) {
            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
          }
          if (flagsStr.indexOf('w') >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;
          if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;
          oflags |= capi.SQLITE_OPEN_EXRESCODE;
          const stack = wasm.pstack.pointer;
          try {
            const pPtr = wasm.pstack.allocPtr();
            let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
            pDb = wasm.peekPtr(pPtr);
            checkSqlite3Rc(pDb, rc);
            capi.sqlite3_extended_result_codes(pDb, 1);
            if (flagsStr.indexOf('t') >= 0) {
              capi.sqlite3_trace_v2(
                pDb,
                capi.SQLITE_TRACE_STMT,
                __dbTraceToConsole,
                pDb,
              );
            }
          } catch (e) {
            if (pDb) capi.sqlite3_close_v2(pDb);
            throw e;
          } finally {
            wasm.pstack.restore(stack);
          }
          this.filename = fnJs;
          __ptrMap.set(this, pDb);
          __stmtMap.set(this, Object.create(null));
          try {
            const pVfs = capi.sqlite3_js_db_vfs(pDb);
            if (!pVfs)
              toss3('Internal error: cannot get VFS for new db handle.');
            const postInitSql = __vfsPostOpenSql[pVfs];
            if (postInitSql instanceof Function) {
              postInitSql(this, sqlite3);
            } else if (postInitSql) {
              checkSqlite3Rc(pDb, capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0));
            }
          } catch (e) {
            this.close();
            throw e;
          }
        };

        dbCtorHelper.setVfsPostOpenSql = function (pVfs, sql) {
          __vfsPostOpenSql[pVfs] = sql;
        };

        dbCtorHelper.normalizeArgs = function (
          filename = ':memory:',
          flags = 'c',
          vfs = null,
        ) {
          const arg = {};
          if (
            1 === arguments.length &&
            arguments[0] &&
            'object' === typeof arguments[0]
          ) {
            Object.assign(arg, arguments[0]);
            if (undefined === arg.flags) arg.flags = 'c';
            if (undefined === arg.vfs) arg.vfs = null;
            if (undefined === arg.filename) arg.filename = ':memory:';
          } else {
            arg.filename = filename;
            arg.flags = flags;
            arg.vfs = vfs;
          }
          return arg;
        };

        const DB = function (...args) {
          dbCtorHelper.apply(this, args);
        };
        DB.dbCtorHelper = dbCtorHelper;

        const BindTypes = {
          null: 1,
          number: 2,
          string: 3,
          boolean: 4,
          blob: 5,
        };
        BindTypes['undefined'] == BindTypes.null;
        if (wasm.bigIntEnabled) {
          BindTypes.bigint = BindTypes.number;
        }

        const Stmt = function () {
          if (BindTypes !== arguments[2]) {
            toss3(
              capi.SQLITE_MISUSE,
              'Do not call the Stmt constructor directly. Use DB.prepare().',
            );
          }
          this.db = arguments[0];
          __ptrMap.set(this, arguments[1]);
          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
        };

        const affirmDbOpen = function (db) {
          if (!db.pointer) toss3('DB has been closed.');
          return db;
        };

        const affirmColIndex = function (stmt, ndx) {
          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
            toss3('Column index', ndx, 'is out of range.');
          }
          return stmt;
        };

        const parseExecArgs = function (db, args) {
          const out = Object.create(null);
          out.opt = Object.create(null);
          switch (args.length) {
            case 1:
              if (
                'string' === typeof args[0] ||
                util.isSQLableTypedArray(args[0])
              ) {
                out.sql = args[0];
              } else if (Array.isArray(args[0])) {
                out.sql = args[0];
              } else if (args[0] && 'object' === typeof args[0]) {
                out.opt = args[0];
                out.sql = out.opt.sql;
              }
              break;
            case 2:
              out.sql = args[0];
              out.opt = args[1];
              break;
            default:
              toss3('Invalid argument count for exec().');
          }
          out.sql = util.flexibleString(out.sql);
          if ('string' !== typeof out.sql) {
            toss3('Missing SQL argument or unsupported SQL value type.');
          }
          const opt = out.opt;
          switch (opt.returnValue) {
            case 'resultRows':
              if (!opt.resultRows) opt.resultRows = [];
              out.returnVal = () => opt.resultRows;
              break;
            case 'saveSql':
              if (!opt.saveSql) opt.saveSql = [];
              out.returnVal = () => opt.saveSql;
              break;
            case undefined:
            case 'this':
              out.returnVal = () => db;
              break;
            default:
              toss3('Invalid returnValue value:', opt.returnValue);
          }
          if (!opt.callback && !opt.returnValue && undefined !== opt.rowMode) {
            if (!opt.resultRows) opt.resultRows = [];
            out.returnVal = () => opt.resultRows;
          }
          if (opt.callback || opt.resultRows) {
            switch (undefined === opt.rowMode ? 'array' : opt.rowMode) {
              case 'object':
                out.cbArg = (stmt) => stmt.get(Object.create(null));
                break;
              case 'array':
                out.cbArg = (stmt) => stmt.get([]);
                break;
              case 'stmt':
                if (Array.isArray(opt.resultRows)) {
                  toss3(
                    'exec(): invalid rowMode for a resultRows array: must',
                    "be one of 'array', 'object',",
                    'a result column number, or column name reference.',
                  );
                }
                out.cbArg = (stmt) => stmt;
                break;
              default:
                if (util.isInt32(opt.rowMode)) {
                  out.cbArg = (stmt) => stmt.get(opt.rowMode);
                  break;
                } else if (
                  'string' === typeof opt.rowMode &&
                  opt.rowMode.length > 1 &&
                  '$' === opt.rowMode[0]
                ) {
                  const $colName = opt.rowMode.substr(1);
                  out.cbArg = (stmt) => {
                    const rc = stmt.get(Object.create(null))[$colName];
                    return undefined === rc
                      ? toss3(
                          capi.SQLITE_NOTFOUND,
                          'exec(): unknown result column:',
                          $colName,
                        )
                      : rc;
                  };
                  break;
                }
                toss3('Invalid rowMode:', opt.rowMode);
            }
          }
          return out;
        };

        const __selectFirstRow = (db, sql, bind, ...getArgs) => {
          const stmt = db.prepare(sql);
          try {
            const rc = stmt.bind(bind).step()
              ? stmt.get(...getArgs)
              : undefined;
            stmt.reset();
            return rc;
          } finally {
            stmt.finalize();
          }
        };

        const __selectAll = (db, sql, bind, rowMode) =>
          db.exec({
            sql,
            bind,
            rowMode,
            returnValue: 'resultRows',
          });

        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);

        DB.prototype = {
          isOpen: function () {
            return !!this.pointer;
          },

          affirmOpen: function () {
            return affirmDbOpen(this);
          },

          close: function () {
            if (this.pointer) {
              if (this.onclose && this.onclose.before instanceof Function) {
                try {
                  this.onclose.before(this);
                } catch (e) {}
              }
              const pDb = this.pointer;
              Object.keys(__stmtMap.get(this)).forEach((k, s) => {
                if (s && s.pointer) {
                  try {
                    s.finalize();
                  } catch (e) {}
                }
              });
              __ptrMap.delete(this);
              __stmtMap.delete(this);
              capi.sqlite3_close_v2(pDb);
              if (this.onclose && this.onclose.after instanceof Function) {
                try {
                  this.onclose.after(this);
                } catch (e) {}
              }
              delete this.filename;
            }
          },

          changes: function (total = false, sixtyFour = false) {
            const p = affirmDbOpen(this).pointer;
            if (total) {
              return sixtyFour
                ? capi.sqlite3_total_changes64(p)
                : capi.sqlite3_total_changes(p);
            } else {
              return sixtyFour
                ? capi.sqlite3_changes64(p)
                : capi.sqlite3_changes(p);
            }
          },

          dbFilename: function (dbName = 'main') {
            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
          },

          dbName: function (dbNumber = 0) {
            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
          },

          dbVfsName: function (dbName = 0) {
            let rc;
            const pVfs = capi.sqlite3_js_db_vfs(
              affirmDbOpen(this).pointer,
              dbName,
            );
            if (pVfs) {
              const v = new capi.sqlite3_vfs(pVfs);
              try {
                rc = wasm.cstrToJs(v.$zName);
              } finally {
                v.dispose();
              }
            }
            return rc;
          },

          prepare: function (sql) {
            affirmDbOpen(this);
            const stack = wasm.pstack.pointer;
            let ppStmt, pStmt;
            try {
              ppStmt = wasm.pstack.alloc(8);
              DB.checkRc(
                this,
                capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null),
              );
              pStmt = wasm.peekPtr(ppStmt);
            } finally {
              wasm.pstack.restore(stack);
            }
            if (!pStmt) toss3('Cannot prepare empty SQL.');
            const stmt = new Stmt(this, pStmt, BindTypes);
            __stmtMap.get(this)[pStmt] = stmt;
            return stmt;
          },

          exec: function () {
            affirmDbOpen(this);
            const arg = parseExecArgs(this, arguments);
            if (!arg.sql) {
              return toss3('exec() requires an SQL string.');
            }
            const opt = arg.opt;
            const callback = opt.callback;
            const resultRows = Array.isArray(opt.resultRows)
              ? opt.resultRows
              : undefined;
            let stmt;
            let bind = opt.bind;
            let evalFirstResult = !!(
              arg.cbArg ||
              opt.columnNames ||
              resultRows
            );
            const stack = wasm.scopedAllocPush();
            const saveSql = Array.isArray(opt.saveSql)
              ? opt.saveSql
              : undefined;
            try {
              const isTA = util.isSQLableTypedArray(arg.sql);
              let sqlByteLen = isTA
                ? arg.sql.byteLength
                : wasm.jstrlen(arg.sql);
              const ppStmt = wasm.scopedAlloc(
                2 * wasm.ptrSizeof + (sqlByteLen + 1),
              );
              const pzTail = ppStmt + wasm.ptrSizeof;
              let pSql = pzTail + wasm.ptrSizeof;
              const pSqlEnd = pSql + sqlByteLen;
              if (isTA) wasm.heap8().set(arg.sql, pSql);
              else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
              wasm.poke(pSql + sqlByteLen, 0);
              while (pSql && wasm.peek(pSql, 'i8')) {
                wasm.pokePtr([ppStmt, pzTail], 0);
                DB.checkRc(
                  this,
                  capi.sqlite3_prepare_v3(
                    this.pointer,
                    pSql,
                    sqlByteLen,
                    0,
                    ppStmt,
                    pzTail,
                  ),
                );
                const pStmt = wasm.peekPtr(ppStmt);
                pSql = wasm.peekPtr(pzTail);
                sqlByteLen = pSqlEnd - pSql;
                if (!pStmt) continue;
                if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
                stmt = new Stmt(this, pStmt, BindTypes);
                if (bind && stmt.parameterCount) {
                  stmt.bind(bind);
                  bind = null;
                }
                if (evalFirstResult && stmt.columnCount) {
                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                  evalFirstResult = false;
                  if (arg.cbArg || resultRows) {
                    for (; stmt.step(); stmt._lockedByExec = false) {
                      if (0 === gotColNames++)
                        stmt.getColumnNames(opt.columnNames);
                      stmt._lockedByExec = true;
                      const row = arg.cbArg(stmt);
                      if (resultRows) resultRows.push(row);
                      if (callback && false === callback.call(opt, row, stmt)) {
                        break;
                      }
                    }
                    stmt._lockedByExec = false;
                  }
                  if (0 === gotColNames) {
                    stmt.getColumnNames(opt.columnNames);
                  }
                } else {
                  stmt.step();
                }
                stmt.reset().finalize();
                stmt = null;
              }
            } finally {
              wasm.scopedAllocPop(stack);
              if (stmt) {
                delete stmt._lockedByExec;
                stmt.finalize();
              }
            }
            return arg.returnVal();
          },

          createFunction: function f(name, xFunc, opt) {
            const isFunc = (f) => f instanceof Function;
            switch (arguments.length) {
              case 1:
                opt = name;
                name = opt.name;
                xFunc = opt.xFunc || 0;
                break;
              case 2:
                if (!isFunc(xFunc)) {
                  opt = xFunc;
                  xFunc = opt.xFunc || 0;
                }
                break;
              case 3:
                break;
              default:
                break;
            }
            if (!opt) opt = {};
            if ('string' !== typeof name) {
              toss3('Invalid arguments: missing function name.');
            }
            let xStep = opt.xStep || 0;
            let xFinal = opt.xFinal || 0;
            const xValue = opt.xValue || 0;
            const xInverse = opt.xInverse || 0;
            let isWindow = undefined;
            if (isFunc(xFunc)) {
              isWindow = false;
              if (isFunc(xStep) || isFunc(xFinal)) {
                toss3('Ambiguous arguments: scalar or aggregate?');
              }
              xStep = xFinal = null;
            } else if (isFunc(xStep)) {
              if (!isFunc(xFinal)) {
                toss3('Missing xFinal() callback for aggregate or window UDF.');
              }
              xFunc = null;
            } else if (isFunc(xFinal)) {
              toss3('Missing xStep() callback for aggregate or window UDF.');
            } else {
              toss3('Missing function-type properties.');
            }
            if (false === isWindow) {
              if (isFunc(xValue) || isFunc(xInverse)) {
                toss3(
                  'xValue and xInverse are not permitted for non-window UDFs.',
                );
              }
            } else if (isFunc(xValue)) {
              if (!isFunc(xInverse)) {
                toss3('xInverse must be provided if xValue is.');
              }
              isWindow = true;
            } else if (isFunc(xInverse)) {
              toss3('xValue must be provided if xInverse is.');
            }
            const pApp = opt.pApp;
            if (
              undefined !== pApp &&
              null !== pApp &&
              ('number' !== typeof pApp || !util.isInt32(pApp))
            ) {
              toss3(
                'Invalid value for pApp property. Must be a legal WASM pointer value.',
              );
            }
            const xDestroy = opt.xDestroy || 0;
            if (xDestroy && !isFunc(xDestroy)) {
              toss3('xDestroy property must be a function.');
            }
            let fFlags = 0;
            if (getOwnOption(opt, 'deterministic'))
              fFlags |= capi.SQLITE_DETERMINISTIC;
            if (getOwnOption(opt, 'directOnly'))
              fFlags |= capi.SQLITE_DIRECTONLY;
            if (getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;
            name = name.toLowerCase();
            const xArity = xFunc || xStep;
            const arity = getOwnOption(opt, 'arity');
            const arityArg =
              'number' === typeof arity
                ? arity
                : xArity.length
                  ? xArity.length - 1
                  : 0;
            let rc;
            if (isWindow) {
              rc = capi.sqlite3_create_window_function(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy,
              );
            } else {
              rc = capi.sqlite3_create_function_v2(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xFunc,
                xStep,
                xFinal,
                xDestroy,
              );
            }
            DB.checkRc(this, rc);
            return this;
          },

          selectValue: function (sql, bind, asType) {
            return __selectFirstRow(this, sql, bind, 0, asType);
          },

          selectValues: function (sql, bind, asType) {
            const stmt = this.prepare(sql),
              rc = [];
            try {
              stmt.bind(bind);
              while (stmt.step()) rc.push(stmt.get(0, asType));
              stmt.reset();
            } finally {
              stmt.finalize();
            }
            return rc;
          },

          selectArray: function (sql, bind) {
            return __selectFirstRow(this, sql, bind, []);
          },

          selectObject: function (sql, bind) {
            return __selectFirstRow(this, sql, bind, {});
          },

          selectArrays: function (sql, bind) {
            return __selectAll(this, sql, bind, 'array');
          },

          selectObjects: function (sql, bind) {
            return __selectAll(this, sql, bind, 'object');
          },

          openStatementCount: function () {
            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
          },

          transaction: function (callback) {
            let opener = 'BEGIN';
            if (arguments.length > 1) {
              if (/[^a-zA-Z]/.test(arguments[0])) {
                toss3(
                  capi.SQLITE_MISUSE,
                  'Invalid argument for BEGIN qualifier.',
                );
              }
              opener += ' ' + arguments[0];
              callback = arguments[1];
            }
            affirmDbOpen(this).exec(opener);
            try {
              const rc = callback(this);
              this.exec('COMMIT');
              return rc;
            } catch (e) {
              this.exec('ROLLBACK');
              throw e;
            }
          },

          savepoint: function (callback) {
            affirmDbOpen(this).exec('SAVEPOINT oo1');
            try {
              const rc = callback(this);
              this.exec('RELEASE oo1');
              return rc;
            } catch (e) {
              this.exec('ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1');
              throw e;
            }
          },

          checkRc: function (resultCode) {
            return checkSqlite3Rc(this, resultCode);
          },
        };

        const affirmStmtOpen = function (stmt) {
          if (!stmt.pointer) toss3('Stmt has been closed.');
          return stmt;
        };

        const isSupportedBindType = function (v) {
          let t = BindTypes[null === v || undefined === v ? 'null' : typeof v];
          switch (t) {
            case BindTypes.boolean:
            case BindTypes.null:
            case BindTypes.number:
            case BindTypes.string:
              return t;
            case BindTypes.bigint:
              if (wasm.bigIntEnabled) return t;

            default:
              return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;
          }
        };

        const affirmSupportedBindType = function (v) {
          return (
            isSupportedBindType(v) ||
            toss3('Unsupported bind() argument type:', typeof v)
          );
        };

        const affirmParamIndex = function (stmt, key) {
          const n =
            'number' === typeof key
              ? key
              : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
          if (0 === n || !util.isInt32(n)) {
            toss3('Invalid bind() parameter name: ' + key);
          } else if (n < 1 || n > stmt.parameterCount)
            toss3('Bind index', key, 'is out of range.');
          return n;
        };

        const affirmNotLockedByExec = function (stmt, currentOpName) {
          if (stmt._lockedByExec) {
            toss3(
              'Operation is illegal when statement is locked:',
              currentOpName,
            );
          }
          return stmt;
        };

        const bindOne = function f(stmt, ndx, bindType, val) {
          affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');
          if (!f._) {
            f._tooBigInt = (v) =>
              toss3(
                'BigInt value is too big to store without precision loss:',
                v,
              );
            f._ = {
              string: function (stmt, ndx, val, asBlob) {
                const [pStr, n] = wasm.allocCString(val, true);
                const f = asBlob
                  ? capi.sqlite3_bind_blob
                  : capi.sqlite3_bind_text;
                return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);
              },
            };
          }
          affirmSupportedBindType(val);
          ndx = affirmParamIndex(stmt, ndx);
          let rc = 0;
          switch (
            null === val || undefined === val ? BindTypes.null : bindType
          ) {
            case BindTypes.null:
              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
              break;
            case BindTypes.string:
              rc = f._.string(stmt, ndx, val, false);
              break;
            case BindTypes.number: {
              let m;
              if (util.isInt32(val)) m = capi.sqlite3_bind_int;
              else if ('bigint' === typeof val) {
                if (!util.bigIntFits64(val)) {
                  f._tooBigInt(val);
                } else if (wasm.bigIntEnabled) {
                  m = capi.sqlite3_bind_int64;
                } else if (util.bigIntFitsDouble(val)) {
                  val = Number(val);
                  m = capi.sqlite3_bind_double;
                } else {
                  f._tooBigInt(val);
                }
              } else {
                val = Number(val);
                if (wasm.bigIntEnabled && Number.isInteger(val)) {
                  m = capi.sqlite3_bind_int64;
                } else {
                  m = capi.sqlite3_bind_double;
                }
              }
              rc = m(stmt.pointer, ndx, val);
              break;
            }
            case BindTypes.boolean:
              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
              break;
            case BindTypes.blob: {
              if ('string' === typeof val) {
                rc = f._.string(stmt, ndx, val, true);
                break;
              } else if (val instanceof ArrayBuffer) {
                val = new Uint8Array(val);
              } else if (!util.isBindableTypedArray(val)) {
                toss3(
                  'Binding a value as a blob requires',
                  'that it be a string, Uint8Array, Int8Array, or ArrayBuffer.',
                );
              }
              const pBlob = wasm.alloc(val.byteLength || 1);
              wasm.heap8().set(val.byteLength ? val : [0], pBlob);
              rc = capi.sqlite3_bind_blob(
                stmt.pointer,
                ndx,
                pBlob,
                val.byteLength,
                capi.SQLITE_WASM_DEALLOC,
              );
              break;
            }
            default:
              sqlite3.config.warn('Unsupported bind() argument type:', val);
              toss3('Unsupported bind() argument type: ' + typeof val);
          }
          if (rc) DB.checkRc(stmt.db.pointer, rc);
          stmt._mayGet = false;
          return stmt;
        };

        Stmt.prototype = {
          finalize: function () {
            if (this.pointer) {
              affirmNotLockedByExec(this, 'finalize()');
              const rc = capi.sqlite3_finalize(this.pointer);
              delete __stmtMap.get(this.db)[this.pointer];
              __ptrMap.delete(this);
              delete this._mayGet;
              delete this.parameterCount;
              delete this._lockedByExec;
              delete this.db;
              return rc;
            }
          },

          clearBindings: function () {
            affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()');
            capi.sqlite3_clear_bindings(this.pointer);
            this._mayGet = false;
            return this;
          },

          reset: function (alsoClearBinds) {
            affirmNotLockedByExec(this, 'reset()');
            if (alsoClearBinds) this.clearBindings();
            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
            this._mayGet = false;
            checkSqlite3Rc(this.db, rc);
            return this;
          },

          bind: function () {
            affirmStmtOpen(this);
            let ndx, arg;
            switch (arguments.length) {
              case 1:
                ndx = 1;
                arg = arguments[0];
                break;
              case 2:
                ndx = arguments[0];
                arg = arguments[1];
                break;
              default:
                toss3('Invalid bind() arguments.');
            }
            if (undefined === arg) {
              return this;
            } else if (!this.parameterCount) {
              toss3('This statement has no bindable parameters.');
            }
            this._mayGet = false;
            if (null === arg) {
              return bindOne(this, ndx, BindTypes.null, arg);
            } else if (Array.isArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  'When binding an array, an index argument is not permitted.',
                );
              }
              arg.forEach((v, i) =>
                bindOne(this, i + 1, affirmSupportedBindType(v), v),
              );
              return this;
            } else if (arg instanceof ArrayBuffer) {
              arg = new Uint8Array(arg);
            }
            if ('object' === typeof arg && !util.isBindableTypedArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  'When binding an object, an index argument is not permitted.',
                );
              }
              Object.keys(arg).forEach((k) =>
                bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k]),
              );
              return this;
            } else {
              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
            }
            toss3('Should not reach this point.');
          },

          bindAsBlob: function (ndx, arg) {
            affirmStmtOpen(this);
            if (1 === arguments.length) {
              arg = ndx;
              ndx = 1;
            }
            const t = affirmSupportedBindType(arg);
            if (
              BindTypes.string !== t &&
              BindTypes.blob !== t &&
              BindTypes.null !== t
            ) {
              toss3('Invalid value type for bindAsBlob()');
            }
            return bindOne(this, ndx, BindTypes.blob, arg);
          },

          step: function () {
            affirmNotLockedByExec(this, 'step()');
            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
            switch (rc) {
              case capi.SQLITE_DONE:
                return (this._mayGet = false);
              case capi.SQLITE_ROW:
                return (this._mayGet = true);
              default:
                this._mayGet = false;
                sqlite3.config.warn(
                  'sqlite3_step() rc=',
                  rc,
                  capi.sqlite3_js_rc_str(rc),
                  'SQL =',
                  capi.sqlite3_sql(this.pointer),
                );
                DB.checkRc(this.db.pointer, rc);
            }
          },

          stepReset: function () {
            this.step();
            return this.reset();
          },

          stepFinalize: function () {
            try {
              const rc = this.step();
              this.reset();
              return rc;
            } finally {
              try {
                this.finalize();
              } catch (e) {}
            }
          },

          get: function (ndx, asType) {
            if (!affirmStmtOpen(this)._mayGet) {
              toss3('Stmt.step() has not (recently) returned true.');
            }
            if (Array.isArray(ndx)) {
              let i = 0;
              const n = this.columnCount;
              while (i < n) {
                ndx[i] = this.get(i++);
              }
              return ndx;
            } else if (ndx && 'object' === typeof ndx) {
              let i = 0;
              const n = this.columnCount;
              while (i < n) {
                ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);
              }
              return ndx;
            }
            affirmColIndex(this, ndx);
            switch (
              undefined === asType
                ? capi.sqlite3_column_type(this.pointer, ndx)
                : asType
            ) {
              case capi.SQLITE_NULL:
                return null;
              case capi.SQLITE_INTEGER: {
                if (wasm.bigIntEnabled) {
                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                  if (
                    rc >= Number.MIN_SAFE_INTEGER &&
                    rc <= Number.MAX_SAFE_INTEGER
                  ) {
                    return Number(rc).valueOf();
                  }
                  return rc;
                } else {
                  const rc = capi.sqlite3_column_double(this.pointer, ndx);
                  if (
                    rc > Number.MAX_SAFE_INTEGER ||
                    rc < Number.MIN_SAFE_INTEGER
                  ) {
                    toss3(
                      'Integer is out of range for JS integer range: ' + rc,
                    );
                  }

                  return util.isInt32(rc) ? rc | 0 : rc;
                }
              }
              case capi.SQLITE_FLOAT:
                return capi.sqlite3_column_double(this.pointer, ndx);
              case capi.SQLITE_TEXT:
                return capi.sqlite3_column_text(this.pointer, ndx);
              case capi.SQLITE_BLOB: {
                const n = capi.sqlite3_column_bytes(this.pointer, ndx),
                  ptr = capi.sqlite3_column_blob(this.pointer, ndx),
                  rc = new Uint8Array(n);

                if (n) rc.set(wasm.heap8u().slice(ptr, ptr + n), 0);

                if (n && this.db._blobXfer instanceof Array) {
                  this.db._blobXfer.push(rc.buffer);
                }
                return rc;
              }
              default:
                toss3(
                  "Don't know how to translate",
                  'type of result column #' + ndx + '.',
                );
            }
            toss3('Not reached.');
          },

          getInt: function (ndx) {
            return this.get(ndx, capi.SQLITE_INTEGER);
          },

          getFloat: function (ndx) {
            return this.get(ndx, capi.SQLITE_FLOAT);
          },

          getString: function (ndx) {
            return this.get(ndx, capi.SQLITE_TEXT);
          },

          getBlob: function (ndx) {
            return this.get(ndx, capi.SQLITE_BLOB);
          },

          getJSON: function (ndx) {
            const s = this.get(ndx, capi.SQLITE_STRING);
            return null === s ? s : JSON.parse(s);
          },

          getColumnName: function (ndx) {
            return capi.sqlite3_column_name(
              affirmColIndex(affirmStmtOpen(this), ndx).pointer,
              ndx,
            );
          },

          getColumnNames: function (tgt = []) {
            affirmColIndex(affirmStmtOpen(this), 0);
            const n = this.columnCount;
            for (let i = 0; i < n; ++i) {
              tgt.push(capi.sqlite3_column_name(this.pointer, i));
            }
            return tgt;
          },

          getParamIndex: function (name) {
            return affirmStmtOpen(this).parameterCount
              ? capi.sqlite3_bind_parameter_index(this.pointer, name)
              : undefined;
          },
        };

        {
          const prop = {
            enumerable: true,
            get: function () {
              return __ptrMap.get(this);
            },
            set: () => toss3('The pointer property is read-only.'),
          };
          Object.defineProperty(Stmt.prototype, 'pointer', prop);
          Object.defineProperty(DB.prototype, 'pointer', prop);
        }

        Object.defineProperty(Stmt.prototype, 'columnCount', {
          enumerable: false,
          get: function () {
            return capi.sqlite3_column_count(this.pointer);
          },
          set: () => toss3('The columnCount property is read-only.'),
        });

        sqlite3.oo1 = {
          DB,
          Stmt,
        };

        if (util.isUIThread()) {
          sqlite3.oo1.JsStorageDb = function (storageName = 'session') {
            if ('session' !== storageName && 'local' !== storageName) {
              toss3("JsStorageDb db name must be one of 'session' or 'local'.");
            }
            dbCtorHelper.call(this, {
              filename: storageName,
              flags: 'c',
              vfs: 'kvvfs',
            });
          };
          const jdb = sqlite3.oo1.JsStorageDb;
          jdb.prototype = Object.create(DB.prototype);

          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;

          jdb.prototype.clearStorage = function () {
            return jdb.clearStorage(affirmDbOpen(this).filename);
          };

          jdb.storageSize = capi.sqlite3_js_kvvfs_size;

          jdb.prototype.storageSize = function () {
            return jdb.storageSize(affirmDbOpen(this).filename);
          };
        }
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        sqlite3.initWorker1API = function () {
          'use strict';
          const toss = (...args) => {
            throw new Error(args.join(' '));
          };
          if (!(globalThis.WorkerGlobalScope instanceof Function)) {
            toss('initWorker1API() must be run from a Worker thread.');
          }
          const sqlite3 = this.sqlite3 || toss('Missing this.sqlite3 object.');
          const DB = sqlite3.oo1.DB;

          const getDbId = function (db) {
            let id = wState.idMap.get(db);
            if (id) return id;
            id = 'db#' + ++wState.idSeq + '@' + db.pointer;

            wState.idMap.set(db, id);
            return id;
          };

          const wState = {
            dbList: [],

            idSeq: 0,

            idMap: new WeakMap(),

            xfer: [],
            open: function (opt) {
              const db = new DB(opt);
              this.dbs[getDbId(db)] = db;
              if (this.dbList.indexOf(db) < 0) this.dbList.push(db);
              return db;
            },
            close: function (db, alsoUnlink) {
              if (db) {
                delete this.dbs[getDbId(db)];
                const filename = db.filename;
                const pVfs = sqlite3.wasm.sqlite3_wasm_db_vfs(db.pointer, 0);
                db.close();
                const ddNdx = this.dbList.indexOf(db);
                if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);
                if (alsoUnlink && filename && pVfs) {
                  sqlite3.wasm.sqlite3_wasm_vfs_unlink(pVfs, filename);
                }
              }
            },

            post: function (msg, xferList) {
              if (xferList && xferList.length) {
                globalThis.postMessage(msg, Array.from(xferList));
                xferList.length = 0;
              } else {
                globalThis.postMessage(msg);
              }
            },

            dbs: Object.create(null),

            getDb: function (id, require = true) {
              return (
                this.dbs[id] ||
                (require ? toss('Unknown (or closed) DB ID:', id) : undefined)
              );
            },
          };

          const affirmDbOpen = function (db = wState.dbList[0]) {
            return db && db.pointer ? db : toss('DB is not opened.');
          };

          const getMsgDb = function (msgData, affirmExists = true) {
            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
            return affirmExists ? affirmDbOpen(db) : db;
          };

          const getDefaultDbId = function () {
            return wState.dbList[0] && getDbId(wState.dbList[0]);
          };

          const guessVfs = function (filename) {
            const m = /^file:.+(vfs=(\w+))/.exec(filename);
            return sqlite3.capi.sqlite3_vfs_find(m ? m[2] : 0);
          };

          const isSpecialDbFilename = (n) => {
            return '' === n || ':' === n[0];
          };

          const wMsgHandler = {
            open: function (ev) {
              const oargs = Object.create(null),
                args = ev.args || Object.create(null);
              if (args.simulateError) {
                toss('Throwing because of simulateError flag.');
              }
              const rc = Object.create(null);
              let byteArray, pVfs;
              oargs.vfs = args.vfs;
              if (isSpecialDbFilename(args.filename)) {
                oargs.filename = args.filename || '';
              } else {
                oargs.filename = args.filename;
                byteArray = args.byteArray;
                if (byteArray) pVfs = guessVfs(args.filename);
              }
              if (pVfs) {
                let pMem;
                try {
                  pMem = sqlite3.wasm.allocFromTypedArray(byteArray);
                  const rc = sqlite3.wasm.sqlite3_wasm_vfs_create_file(
                    pVfs,
                    oargs.filename,
                    pMem,
                    byteArray.byteLength,
                  );
                  if (rc) sqlite3.SQLite3Error.toss(rc);
                } catch (e) {
                  throw new sqlite3.SQLite3Error(
                    e.name + ' creating ' + args.filename + ': ' + e.message,
                    {
                      cause: e,
                    },
                  );
                } finally {
                  if (pMem) sqlite3.wasm.dealloc(pMem);
                }
              }
              const db = wState.open(oargs);
              rc.filename = db.filename;
              rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(
                db.pointer,
                'opfs',
              );
              rc.dbId = getDbId(db);
              rc.vfs = db.dbVfsName();
              return rc;
            },

            close: function (ev) {
              const db = getMsgDb(ev, false);
              const response = {
                filename: db && db.filename,
              };
              if (db) {
                const doUnlink =
                  ev.args && 'object' === typeof ev.args
                    ? !!ev.args.unlink
                    : false;
                wState.close(db, doUnlink);
              }
              return response;
            },

            exec: function (ev) {
              const rc =
                'string' === typeof ev.args
                  ? { sql: ev.args }
                  : ev.args || Object.create(null);
              if ('stmt' === rc.rowMode) {
                toss(
                  "Invalid rowMode for 'exec': stmt mode",
                  'does not work in the Worker API.',
                );
              } else if (!rc.sql) {
                toss("'exec' requires input SQL.");
              }
              const db = getMsgDb(ev);
              if (rc.callback || Array.isArray(rc.resultRows)) {
                db._blobXfer = wState.xfer;
              }
              const theCallback = rc.callback;
              let rowNumber = 0;
              const hadColNames = !!rc.columnNames;
              if ('string' === typeof theCallback) {
                if (!hadColNames) rc.columnNames = [];

                rc.callback = function (row, stmt) {
                  wState.post(
                    {
                      type: theCallback,
                      columnNames: rc.columnNames,
                      rowNumber: ++rowNumber,
                      row: row,
                    },
                    wState.xfer,
                  );
                };
              }
              try {
                const changeCount = !!rc.countChanges
                  ? db.changes(true, 64 === rc.countChanges)
                  : undefined;
                db.exec(rc);
                if (undefined !== changeCount) {
                  rc.changeCount =
                    db.changes(true, 64 === rc.countChanges) - changeCount;
                }
                if (rc.callback instanceof Function) {
                  rc.callback = theCallback;

                  wState.post({
                    type: theCallback,
                    columnNames: rc.columnNames,
                    rowNumber: null,
                    row: undefined,
                  });
                }
              } finally {
                delete db._blobXfer;
                if (rc.callback) rc.callback = theCallback;
              }
              return rc;
            },

            'config-get': function () {
              const rc = Object.create(null),
                src = sqlite3.config;
              ['bigIntEnabled'].forEach(function (k) {
                if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
              });
              rc.version = sqlite3.version;
              rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();
              rc.opfsEnabled = !!sqlite3.opfs;
              return rc;
            },

            export: function (ev) {
              const db = getMsgDb(ev);
              const response = {
                byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),
                filename: db.filename,
                mimetype: 'application/x-sqlite3',
              };
              wState.xfer.push(response.byteArray.buffer);
              return response;
            },

            toss: function (ev) {
              toss('Testing worker exception');
            },

            'opfs-tree': async function (ev) {
              if (!sqlite3.opfs) toss('OPFS support is unavailable.');
              const response = await sqlite3.opfs.treeList();
              return response;
            },
          };

          globalThis.onmessage = async function (ev) {
            ev = ev.data;
            let result,
              dbId = ev.dbId,
              evType = ev.type;
            const arrivalTime = performance.now();
            try {
              if (
                wMsgHandler.hasOwnProperty(evType) &&
                wMsgHandler[evType] instanceof Function
              ) {
                result = await wMsgHandler[evType](ev);
              } else {
                toss('Unknown db worker message type:', ev.type);
              }
            } catch (err) {
              evType = 'error';
              result = {
                operation: ev.type,
                message: err.message,
                errorClass: err.name,
                input: ev,
              };
              if (err.stack) {
                result.stack =
                  'string' === typeof err.stack
                    ? err.stack.split(/\n\s*/)
                    : err.stack;
              }
              if (false)
                {}
            }
            if (!dbId) {
              dbId = result.dbId || getDefaultDbId();
            }

            wState.post(
              {
                type: evType,
                dbId: dbId,
                messageId: ev.messageId,
                workerReceivedTime: arrivalTime,
                workerRespondTime: performance.now(),
                departureTime: ev.departureTime,

                result: result,
              },
              wState.xfer,
            );
          };
          globalThis.postMessage({
            type: 'sqlite3-api',
            result: 'worker1-ready',
          });
        }.bind({ sqlite3 });
      });

      ('use strict');
      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        const wasm = sqlite3.wasm,
          capi = sqlite3.capi,
          toss = sqlite3.util.toss3;
        const vfs = Object.create(null),
          vtab = Object.create(null);

        const StructBinder = sqlite3.StructBinder;
        sqlite3.vfs = vfs;
        sqlite3.vtab = vtab;

        const sii = capi.sqlite3_index_info;

        sii.prototype.nthConstraint = function (n, asPtr = false) {
          if (n < 0 || n >= this.$nConstraint) return false;
          const ptr =
            this.$aConstraint +
            sii.sqlite3_index_constraint.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
        };

        sii.prototype.nthConstraintUsage = function (n, asPtr = false) {
          if (n < 0 || n >= this.$nConstraint) return false;
          const ptr =
            this.$aConstraintUsage +
            sii.sqlite3_index_constraint_usage.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
        };

        sii.prototype.nthOrderBy = function (n, asPtr = false) {
          if (n < 0 || n >= this.$nOrderBy) return false;
          const ptr =
            this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
        };

        const installMethod = function callee(
          tgt,
          name,
          func,
          applyArgcCheck = callee.installMethodArgcCheck,
        ) {
          if (!(tgt instanceof StructBinder.StructType)) {
            toss('Usage error: target object is-not-a StructType.');
          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {
            toss('Usage errror: expecting a Function or WASM pointer to one.');
          }
          if (1 === arguments.length) {
            return (n, f) => callee(tgt, n, f, applyArgcCheck);
          }
          if (!callee.argcProxy) {
            callee.argcProxy = function (tgt, funcName, func, sig) {
              return function (...args) {
                if (func.length !== arguments.length) {
                  toss(
                    'Argument mismatch for',
                    tgt.structInfo.name +
                      '::' +
                      funcName +
                      ': Native signature is:',
                    sig,
                  );
                }
                return func.apply(this, args);
              };
            };

            callee.removeFuncList = function () {
              if (this.ondispose.__removeFuncList) {
                this.ondispose.__removeFuncList.forEach((v, ndx) => {
                  if ('number' === typeof v) {
                    try {
                      wasm.uninstallFunction(v);
                    } catch (e) {}
                  }
                });
                delete this.ondispose.__removeFuncList;
              }
            };
          }
          const sigN = tgt.memberSignature(name);
          if (sigN.length < 2) {
            toss(
              'Member',
              name,
              'does not have a function pointer signature:',
              sigN,
            );
          }
          const memKey = tgt.memberKey(name);
          const fProxy =
            applyArgcCheck && !wasm.isPtr(func)
              ? callee.argcProxy(tgt, memKey, func, sigN)
              : func;
          if (wasm.isPtr(fProxy)) {
            if (fProxy && !wasm.functionEntry(fProxy)) {
              toss('Pointer', fProxy, 'is not a WASM function table entry.');
            }
            tgt[memKey] = fProxy;
          } else {
            const pFunc = wasm.installFunction(
              fProxy,
              tgt.memberSignature(name, true),
            );
            tgt[memKey] = pFunc;
            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
              tgt.addOnDispose(
                'ondispose.__removeFuncList handler',
                callee.removeFuncList,
              );
              tgt.ondispose.__removeFuncList = [];
            }
            tgt.ondispose.__removeFuncList.push(memKey, pFunc);
          }
          return (n, f) => callee(tgt, n, f, applyArgcCheck);
        };
        installMethod.installMethodArgcCheck = false;

        const installMethods = function (
          structInstance,
          methods,
          applyArgcCheck = installMethod.installMethodArgcCheck,
        ) {
          const seen = new Map();
          for (const k of Object.keys(methods)) {
            const m = methods[k];
            const prior = seen.get(m);
            if (prior) {
              const mkey = structInstance.memberKey(k);
              structInstance[mkey] =
                structInstance[structInstance.memberKey(prior)];
            } else {
              installMethod(structInstance, k, m, applyArgcCheck);
              seen.set(m, k);
            }
          }
          return structInstance;
        };

        StructBinder.StructType.prototype.installMethod = function callee(
          name,
          func,
          applyArgcCheck = installMethod.installMethodArgcCheck,
        ) {
          return arguments.length < 3 && name && 'object' === typeof name
            ? installMethods(this, ...arguments)
            : installMethod(this, ...arguments);
        };

        StructBinder.StructType.prototype.installMethods = function (
          methods,
          applyArgcCheck = installMethod.installMethodArgcCheck,
        ) {
          return installMethods(this, methods, applyArgcCheck);
        };

        capi.sqlite3_vfs.prototype.registerVfs = function (asDefault = false) {
          if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {
            toss('Expecting a sqlite3_vfs-type argument.');
          }
          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
          if (rc) {
            toss('sqlite3_vfs_register(', this, ') failed with rc', rc);
          }
          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
            toss(
              'BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS',
              this,
            );
          }
          return this;
        };

        vfs.installVfs = function (opt) {
          let count = 0;
          const propList = ['io', 'vfs'];
          for (const key of propList) {
            const o = opt[key];
            if (o) {
              ++count;
              installMethods(o.struct, o.methods, !!o.applyArgcCheck);
              if ('vfs' === key) {
                if (!o.struct.$zName && 'string' === typeof o.name) {
                  o.struct.addOnDispose(
                    (o.struct.$zName = wasm.allocCString(o.name)),
                  );
                }
                o.struct.registerVfs(!!o.asDefault);
              }
            }
          }
          if (!count)
            toss(
              'Misuse: installVfs() options object requires at least',
              'one of:',
              propList,
            );
          return this;
        };

        const __xWrapFactory = function (methodName, StructType) {
          return function (ptr, removeMapping = false) {
            if (0 === arguments.length) ptr = new StructType();
            if (ptr instanceof StructType) {
              this.set(ptr.pointer, ptr);
              return ptr;
            } else if (!wasm.isPtr(ptr)) {
              sqlite3.SQLite3Error.toss(
                'Invalid argument to',
                methodName + '()',
              );
            }
            let rc = this.get(ptr);
            if (removeMapping) this.delete(ptr);
            return rc;
          }.bind(new Map());
        };

        const StructPtrMapper = function (name, StructType) {
          const __xWrap = __xWrapFactory(name, StructType);

          return Object.assign(Object.create(null), {
            StructType,

            create: (ppOut) => {
              const rc = __xWrap();
              wasm.pokePtr(ppOut, rc.pointer);
              return rc;
            },

            get: (pCObj) => __xWrap(pCObj),

            unget: (pCObj) => __xWrap(pCObj, true),

            dispose: (pCObj) => {
              const o = __xWrap(pCObj, true);
              if (o) o.dispose();
            },
          });
        };

        vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);

        vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);

        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);

        vtab.xError = function f(methodName, err, defaultRc) {
          if (f.errorReporter instanceof Function) {
            try {
              f.errorReporter(
                'sqlite3_module::' + methodName + '(): ' + err.message,
              );
            } catch (e) {}
          }
          let rc;
          if (err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;
          else if (arguments.length > 2) rc = defaultRc;
          else if (err instanceof sqlite3.SQLite3Error) rc = err.resultCode;
          return rc || capi.SQLITE_ERROR;
        };
        vtab.xError.errorReporter =  true ? console.error.bind(console) : 0;

        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, 'i64');

        vtab.setupModule = function (opt) {
          let createdMod = false;
          const mod =
            this instanceof capi.sqlite3_module
              ? this
              : opt.struct || (createdMod = new capi.sqlite3_module());
          try {
            const methods = opt.methods || toss("Missing 'methods' object.");
            for (const e of Object.entries({
              xConnect: 'xCreate',
              xDisconnect: 'xDestroy',
            })) {
              const k = e[0],
                v = e[1];
              if (true === methods[k]) methods[k] = methods[v];
              else if (true === methods[v]) methods[v] = methods[k];
            }
            if (opt.catchExceptions) {
              const fwrap = function (methodName, func) {
                if (['xConnect', 'xCreate'].indexOf(methodName) >= 0) {
                  return function (pDb, pAux, argc, argv, ppVtab, pzErr) {
                    try {
                      return func(...arguments) || 0;
                    } catch (e) {
                      if (!(e instanceof sqlite3.WasmAllocError)) {
                        wasm.dealloc(wasm.peekPtr(pzErr));
                        wasm.pokePtr(pzErr, wasm.allocCString(e.message));
                      }
                      return vtab.xError(methodName, e);
                    }
                  };
                } else {
                  return function (...args) {
                    try {
                      return func(...args) || 0;
                    } catch (e) {
                      return vtab.xError(methodName, e);
                    }
                  };
                }
              };
              const mnames = [
                'xCreate',
                'xConnect',
                'xBestIndex',
                'xDisconnect',
                'xDestroy',
                'xOpen',
                'xClose',
                'xFilter',
                'xNext',
                'xEof',
                'xColumn',
                'xRowid',
                'xUpdate',
                'xBegin',
                'xSync',
                'xCommit',
                'xRollback',
                'xFindFunction',
                'xRename',
                'xSavepoint',
                'xRelease',
                'xRollbackTo',
                'xShadowName',
              ];
              const remethods = Object.create(null);
              for (const k of mnames) {
                const m = methods[k];
                if (!(m instanceof Function)) continue;
                else if ('xConnect' === k && methods.xCreate === m) {
                  remethods[k] = methods.xCreate;
                } else if ('xCreate' === k && methods.xConnect === m) {
                  remethods[k] = methods.xConnect;
                } else {
                  remethods[k] = fwrap(k, m);
                }
              }
              installMethods(mod, remethods, false);
            } else {
              installMethods(mod, methods, !!opt.applyArgcCheck);
            }
            if (0 === mod.$iVersion) {
              let v;
              if ('number' === typeof opt.iVersion) v = opt.iVersion;
              else if (mod.$xShadowName) v = 3;
              else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)
                v = 2;
              else v = 1;
              mod.$iVersion = v;
            }
          } catch (e) {
            if (createdMod) createdMod.dispose();
            throw e;
          }
          return mod;
        };

        capi.sqlite3_module.prototype.setupModule = function (opt) {
          return vtab.setupModule.call(this, opt);
        };
      });

      ('use strict');
      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        const installOpfsVfs = function callee(options) {
          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
            return Promise.reject(
              new Error(
                'Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. ' +
                  'The server must emit the COOP/COEP response headers to enable those. ' +
                  'See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep',
              ),
            );
          } else if ('undefined' === typeof WorkerGlobalScope) {
            return Promise.reject(
              new Error(
                'The OPFS sqlite3_vfs cannot run in the main thread ' +
                  'because it requires Atomics.wait().',
              ),
            );
          } else if (
            !globalThis.FileSystemHandle ||
            !globalThis.FileSystemDirectoryHandle ||
            !globalThis.FileSystemFileHandle ||
            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
            !navigator?.storage?.getDirectory
          ) {
            return Promise.reject(new Error('Missing required OPFS APIs.'));
          }
          if (!options || 'object' !== typeof options) {
            options = Object.create(null);
          }
          const urlParams = new URL(globalThis.location.href).searchParams;
          if (urlParams.has('opfs-disable')) {
            return Promise.resolve(sqlite3);
          }
          if (undefined === options.verbose) {
            options.verbose = urlParams.has('opfs-verbose')
              ? +urlParams.get('opfs-verbose') || 2
              : 1;
          }
          if (undefined === options.sanityChecks) {
            options.sanityChecks = urlParams.has('opfs-sanity-check');
          }
          if (undefined === options.proxyUri) {
            options.proxyUri = callee.defaultProxyUri;
          }

          if ('function' === typeof options.proxyUri) {
            options.proxyUri = options.proxyUri();
          }
          const thePromise = new Promise(function (
            promiseResolve_,
            promiseReject_,
          ) {
            const loggers = [
              sqlite3.config.error,
              sqlite3.config.warn,
              sqlite3.config.log,
            ];
            const logImpl = (level, ...args) => {
              if (options.verbose > level)
                loggers[level]('OPFS syncer:', ...args);
            };
            const log = (...args) => logImpl(2, ...args);
            const warn = (...args) => logImpl(1, ...args);
            const error = (...args) => logImpl(0, ...args);
            const toss = sqlite3.util.toss;
            const capi = sqlite3.capi;
            const util = sqlite3.util;
            const wasm = sqlite3.wasm;
            const sqlite3_vfs = capi.sqlite3_vfs;
            const sqlite3_file = capi.sqlite3_file;
            const sqlite3_io_methods = capi.sqlite3_io_methods;

            const opfsUtil = Object.create(null);

            const thisThreadHasOPFS = () => {
              return (
                globalThis.FileSystemHandle &&
                globalThis.FileSystemDirectoryHandle &&
                globalThis.FileSystemFileHandle &&
                globalThis.FileSystemFileHandle.prototype
                  .createSyncAccessHandle &&
                navigator?.storage?.getDirectory
              );
            };

            opfsUtil.metrics = {
              dump: function () {
                let k,
                  n = 0,
                  t = 0,
                  w = 0;
                for (k in state.opIds) {
                  const m = metrics[k];
                  n += m.count;
                  t += m.time;
                  w += m.wait;
                  m.avgTime = m.count && m.time ? m.time / m.count : 0;
                  m.avgWait = m.count && m.wait ? m.wait / m.count : 0;
                }
                sqlite3.config.log(
                  globalThis.location.href,
                  'metrics for',
                  globalThis.location.href,
                  ':',
                  metrics,
                  '\nTotal of',
                  n,
                  'op(s) for',
                  t,
                  'ms (incl. ' + w + ' ms of waiting on the async side)',
                );
                sqlite3.config.log('Serialization metrics:', metrics.s11n);
                W.postMessage({ type: 'opfs-async-metrics' });
              },
              reset: function () {
                let k;
                const r = (m) => (m.count = m.time = m.wait = 0);
                for (k in state.opIds) {
                  r((metrics[k] = Object.create(null)));
                }
                let s = (metrics.s11n = Object.create(null));
                s = s.serialize = Object.create(null);
                s.count = s.time = 0;
                s = metrics.s11n.deserialize = Object.create(null);
                s.count = s.time = 0;
              },
            };
            const opfsIoMethods = new sqlite3_io_methods();
            const opfsVfs = new sqlite3_vfs().addOnDispose(() =>
              opfsIoMethods.dispose(),
            );
            let promiseWasRejected = undefined;
            const promiseReject = (err) => {
              promiseWasRejected = true;
              opfsVfs.dispose();
              return promiseReject_(err);
            };
            const promiseResolve = () => {
              promiseWasRejected = false;
              return promiseResolve_(sqlite3);
            };
            const W = new Worker(
              new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("vendors-node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-opfs-async-proxy_js"), __webpack_require__.b),
            );
            setTimeout(() => {
              if (undefined === promiseWasRejected) {
                promiseReject(
                  new Error(
                    'Timeout while waiting for OPFS async proxy worker.',
                  ),
                );
              }
            }, 4000);
            W._originalOnError = W.onerror;
            W.onerror = function (err) {
              error('Error initializing OPFS asyncer:', err);
              promiseReject(
                new Error(
                  'Loading OPFS async Worker failed for unknown reasons.',
                ),
              );
            };
            const pDVfs = capi.sqlite3_vfs_find(null);
            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
            opfsIoMethods.$iVersion = 1;
            opfsVfs.$iVersion = 2;
            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
            opfsVfs.$mxPathname = 1024;
            opfsVfs.$zName = wasm.allocCString('opfs');

            opfsVfs.$xDlOpen =
              opfsVfs.$xDlError =
              opfsVfs.$xDlSym =
              opfsVfs.$xDlClose =
                null;
            opfsVfs.addOnDispose(
              '$zName',
              opfsVfs.$zName,
              'cleanup default VFS wrapper',
              () => (dVfs ? dVfs.dispose() : null),
            );

            const state = Object.create(null);
            state.verbose = options.verbose;
            state.littleEndian = (() => {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);

              return new Int16Array(buffer)[0] === 256;
            })();

            state.asyncIdleWaitTime = 150;

            state.asyncS11nExceptions = 1;

            state.fileBufferSize = 1024 * 64;
            state.sabS11nOffset = state.fileBufferSize;

            state.sabS11nSize = opfsVfs.$mxPathname * 2;

            state.sabIO = new SharedArrayBuffer(
              state.fileBufferSize + state.sabS11nSize,
            );
            state.opIds = Object.create(null);
            const metrics = Object.create(null);
            {
              let i = 0;

              state.opIds.whichOp = i++;

              state.opIds.rc = i++;

              state.opIds.xAccess = i++;
              state.opIds.xClose = i++;
              state.opIds.xDelete = i++;
              state.opIds.xDeleteNoWait = i++;
              state.opIds.xFileSize = i++;
              state.opIds.xLock = i++;
              state.opIds.xOpen = i++;
              state.opIds.xRead = i++;
              state.opIds.xSleep = i++;
              state.opIds.xSync = i++;
              state.opIds.xTruncate = i++;
              state.opIds.xUnlock = i++;
              state.opIds.xWrite = i++;
              state.opIds.mkdir = i++;
              state.opIds['opfs-async-metrics'] = i++;
              state.opIds['opfs-async-shutdown'] = i++;

              state.opIds.retry = i++;
              state.sabOP = new SharedArrayBuffer(i * 4);
              opfsUtil.metrics.reset();
            }

            state.sq3Codes = Object.create(null);
            [
              'SQLITE_ACCESS_EXISTS',
              'SQLITE_ACCESS_READWRITE',
              'SQLITE_BUSY',
              'SQLITE_ERROR',
              'SQLITE_IOERR',
              'SQLITE_IOERR_ACCESS',
              'SQLITE_IOERR_CLOSE',
              'SQLITE_IOERR_DELETE',
              'SQLITE_IOERR_FSYNC',
              'SQLITE_IOERR_LOCK',
              'SQLITE_IOERR_READ',
              'SQLITE_IOERR_SHORT_READ',
              'SQLITE_IOERR_TRUNCATE',
              'SQLITE_IOERR_UNLOCK',
              'SQLITE_IOERR_WRITE',
              'SQLITE_LOCK_EXCLUSIVE',
              'SQLITE_LOCK_NONE',
              'SQLITE_LOCK_PENDING',
              'SQLITE_LOCK_RESERVED',
              'SQLITE_LOCK_SHARED',
              'SQLITE_LOCKED',
              'SQLITE_MISUSE',
              'SQLITE_NOTFOUND',
              'SQLITE_OPEN_CREATE',
              'SQLITE_OPEN_DELETEONCLOSE',
              'SQLITE_OPEN_MAIN_DB',
              'SQLITE_OPEN_READONLY',
            ].forEach((k) => {
              if (undefined === (state.sq3Codes[k] = capi[k])) {
                toss('Maintenance required: not found:', k);
              }
            });
            state.opfsFlags = Object.assign(Object.create(null), {
              OPFS_UNLOCK_ASAP: 0x01,

              defaultUnlockAsap: false,
            });

            const opRun = (op, ...args) => {
              const opNdx = state.opIds[op] || toss('Invalid op ID:', op);
              state.s11n.serialize(...args);
              Atomics.store(state.sabOPView, state.opIds.rc, -1);
              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
              Atomics.notify(state.sabOPView, state.opIds.whichOp);
              const t = performance.now();
              Atomics.wait(state.sabOPView, state.opIds.rc, -1);
              const rc = Atomics.load(state.sabOPView, state.opIds.rc);
              metrics[op].wait += performance.now() - t;
              if (rc && state.asyncS11nExceptions) {
                const err = state.s11n.deserialize();
                if (err) error(op + '() async error:', ...err);
              }
              return rc;
            };

            opfsUtil.debug = {
              asyncShutdown: () => {
                warn(
                  'Shutting down OPFS async listener. The OPFS VFS will no longer work.',
                );
                opRun('opfs-async-shutdown');
              },
              asyncRestart: () => {
                warn(
                  'Attempting to restart OPFS VFS async listener. Might work, might not.',
                );
                W.postMessage({ type: 'opfs-async-restart' });
              },
            };

            const initS11n = () => {
              if (state.s11n) return state.s11n;
              const textDecoder = new TextDecoder(),
                textEncoder = new TextEncoder('utf-8'),
                viewU8 = new Uint8Array(
                  state.sabIO,
                  state.sabS11nOffset,
                  state.sabS11nSize,
                ),
                viewDV = new DataView(
                  state.sabIO,
                  state.sabS11nOffset,
                  state.sabS11nSize,
                );
              state.s11n = Object.create(null);

              const TypeIds = Object.create(null);
              TypeIds.number = {
                id: 1,
                size: 8,
                getter: 'getFloat64',
                setter: 'setFloat64',
              };
              TypeIds.bigint = {
                id: 2,
                size: 8,
                getter: 'getBigInt64',
                setter: 'setBigInt64',
              };
              TypeIds.boolean = {
                id: 3,
                size: 4,
                getter: 'getInt32',
                setter: 'setInt32',
              };
              TypeIds.string = { id: 4 };

              const getTypeId = (v) =>
                TypeIds[typeof v] ||
                toss(
                  'Maintenance required: this value type cannot be serialized.',
                  v,
                );
              const getTypeIdById = (tid) => {
                switch (tid) {
                  case TypeIds.number.id:
                    return TypeIds.number;
                  case TypeIds.bigint.id:
                    return TypeIds.bigint;
                  case TypeIds.boolean.id:
                    return TypeIds.boolean;
                  case TypeIds.string.id:
                    return TypeIds.string;
                  default:
                    toss('Invalid type ID:', tid);
                }
              };

              state.s11n.deserialize = function (clear = false) {
                ++metrics.s11n.deserialize.count;
                const t = performance.now();
                const argc = viewU8[0];
                const rc = argc ? [] : null;
                if (argc) {
                  const typeIds = [];
                  let offset = 1,
                    i,
                    n,
                    v;
                  for (i = 0; i < argc; ++i, ++offset) {
                    typeIds.push(getTypeIdById(viewU8[offset]));
                  }
                  for (i = 0; i < argc; ++i) {
                    const t = typeIds[i];
                    if (t.getter) {
                      v = viewDV[t.getter](offset, state.littleEndian);
                      offset += t.size;
                    } else {
                      n = viewDV.getInt32(offset, state.littleEndian);
                      offset += 4;
                      v = textDecoder.decode(viewU8.slice(offset, offset + n));
                      offset += n;
                    }
                    rc.push(v);
                  }
                }
                if (clear) viewU8[0] = 0;

                metrics.s11n.deserialize.time += performance.now() - t;
                return rc;
              };

              state.s11n.serialize = function (...args) {
                const t = performance.now();
                ++metrics.s11n.serialize.count;
                if (args.length) {
                  const typeIds = [];
                  let i = 0,
                    offset = 1;
                  viewU8[0] = args.length & 0xff;
                  for (; i < args.length; ++i, ++offset) {
                    typeIds.push(getTypeId(args[i]));
                    viewU8[offset] = typeIds[i].id;
                  }
                  for (i = 0; i < args.length; ++i) {
                    const t = typeIds[i];
                    if (t.setter) {
                      viewDV[t.setter](offset, args[i], state.littleEndian);
                      offset += t.size;
                    } else {
                      const s = textEncoder.encode(args[i]);
                      viewDV.setInt32(offset, s.byteLength, state.littleEndian);
                      offset += 4;
                      viewU8.set(s, offset);
                      offset += s.byteLength;
                    }
                  }
                } else {
                  viewU8[0] = 0;
                }
                metrics.s11n.serialize.time += performance.now() - t;
              };
              return state.s11n;
            };

            const randomFilename = function f(len = 16) {
              if (!f._chars) {
                f._chars =
                  'abcdefghijklmnopqrstuvwxyz' +
                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
                  '012346789';
                f._n = f._chars.length;
              }
              const a = [];
              let i = 0;
              for (; i < len; ++i) {
                const ndx = (Math.random() * (f._n * 64)) % f._n | 0;
                a[i] = f._chars[ndx];
              }
              return a.join('');
            };

            const __openFiles = Object.create(null);

            const opTimer = Object.create(null);
            opTimer.op = undefined;
            opTimer.start = undefined;
            const mTimeStart = (op) => {
              opTimer.start = performance.now();
              opTimer.op = op;
              ++metrics[op].count;
            };
            const mTimeEnd = () =>
              (metrics[opTimer.op].time += performance.now() - opTimer.start);

            const ioSyncWrappers = {
              xCheckReservedLock: function (pFile, pOut) {
                const f = __openFiles[pFile];
                wasm.poke(pOut, f.lockType ? 1 : 0, 'i32');
                return 0;
              },
              xClose: function (pFile) {
                mTimeStart('xClose');
                let rc = 0;
                const f = __openFiles[pFile];
                if (f) {
                  delete __openFiles[pFile];
                  rc = opRun('xClose', pFile);
                  if (f.sq3File) f.sq3File.dispose();
                }
                mTimeEnd();
                return rc;
              },
              xDeviceCharacteristics: function (pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              },
              xFileControl: function (pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              },
              xFileSize: function (pFile, pSz64) {
                mTimeStart('xFileSize');
                let rc = opRun('xFileSize', pFile);
                if (0 == rc) {
                  try {
                    const sz = state.s11n.deserialize()[0];
                    wasm.poke(pSz64, sz, 'i64');
                  } catch (e) {
                    error('Unexpected error reading xFileSize() result:', e);
                    rc = state.sq3Codes.SQLITE_IOERR;
                  }
                }
                mTimeEnd();
                return rc;
              },
              xLock: function (pFile, lockType) {
                mTimeStart('xLock');
                const f = __openFiles[pFile];
                let rc = 0;

                if (!f.lockType) {
                  rc = opRun('xLock', pFile, lockType);
                  if (0 === rc) f.lockType = lockType;
                } else {
                  f.lockType = lockType;
                }
                mTimeEnd();
                return rc;
              },
              xRead: function (pFile, pDest, n, offset64) {
                mTimeStart('xRead');
                const f = __openFiles[pFile];
                let rc;
                try {
                  rc = opRun('xRead', pFile, n, Number(offset64));
                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                    wasm.heap8u().set(f.sabView.subarray(0, n), pDest);
                  }
                } catch (e) {
                  error('xRead(', arguments, ') failed:', e, f);
                  rc = capi.SQLITE_IOERR_READ;
                }
                mTimeEnd();
                return rc;
              },
              xSync: function (pFile, flags) {
                mTimeStart('xSync');
                ++metrics.xSync.count;
                const rc = opRun('xSync', pFile, flags);
                mTimeEnd();
                return rc;
              },
              xTruncate: function (pFile, sz64) {
                mTimeStart('xTruncate');
                const rc = opRun('xTruncate', pFile, Number(sz64));
                mTimeEnd();
                return rc;
              },
              xUnlock: function (pFile, lockType) {
                mTimeStart('xUnlock');
                const f = __openFiles[pFile];
                let rc = 0;
                if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {
                  rc = opRun('xUnlock', pFile, lockType);
                }
                if (0 === rc) f.lockType = lockType;
                mTimeEnd();
                return rc;
              },
              xWrite: function (pFile, pSrc, n, offset64) {
                mTimeStart('xWrite');
                const f = __openFiles[pFile];
                let rc;
                try {
                  f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n));
                  rc = opRun('xWrite', pFile, n, Number(offset64));
                } catch (e) {
                  error('xWrite(', arguments, ') failed:', e, f);
                  rc = capi.SQLITE_IOERR_WRITE;
                }
                mTimeEnd();
                return rc;
              },
            };

            const vfsSyncWrappers = {
              xAccess: function (pVfs, zName, flags, pOut) {
                mTimeStart('xAccess');
                const rc = opRun('xAccess', wasm.cstrToJs(zName));
                wasm.poke(pOut, rc ? 0 : 1, 'i32');
                mTimeEnd();
                return 0;
              },
              xCurrentTime: function (pVfs, pOut) {
                wasm.poke(
                  pOut,
                  2440587.5 + new Date().getTime() / 86400000,
                  'double',
                );
                return 0;
              },
              xCurrentTimeInt64: function (pVfs, pOut) {
                wasm.poke(
                  pOut,
                  2440587.5 * 86400000 + new Date().getTime(),
                  'i64',
                );
                return 0;
              },
              xDelete: function (pVfs, zName, doSyncDir) {
                mTimeStart('xDelete');
                const rc = opRun(
                  'xDelete',
                  wasm.cstrToJs(zName),
                  doSyncDir,
                  false,
                );
                mTimeEnd();
                return rc;
              },
              xFullPathname: function (pVfs, zName, nOut, pOut) {
                const i = wasm.cstrncpy(pOut, zName, nOut);
                return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
              },
              xGetLastError: function (pVfs, nOut, pOut) {
                warn('OPFS xGetLastError() has nothing sensible to return.');
                return 0;
              },

              xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
                mTimeStart('xOpen');
                let opfsFlags = 0;
                if (0 === zName) {
                  zName = randomFilename();
                } else if ('number' === typeof zName) {
                  if (capi.sqlite3_uri_boolean(zName, 'opfs-unlock-asap', 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
                  }
                  zName = wasm.cstrToJs(zName);
                }
                const fh = Object.create(null);
                fh.fid = pFile;
                fh.filename = zName;
                fh.sab = new SharedArrayBuffer(state.fileBufferSize);
                fh.flags = flags;
                const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);
                if (!rc) {
                  if (fh.readOnly) {
                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');
                  }
                  __openFiles[pFile] = fh;
                  fh.sabView = state.sabFileBufView;
                  fh.sq3File = new sqlite3_file(pFile);
                  fh.sq3File.$pMethods = opfsIoMethods.pointer;
                  fh.lockType = capi.SQLITE_LOCK_NONE;
                }
                mTimeEnd();
                return rc;
              },
            };

            if (dVfs) {
              opfsVfs.$xRandomness = dVfs.$xRandomness;
              opfsVfs.$xSleep = dVfs.$xSleep;
            }
            if (!opfsVfs.$xRandomness) {
              vfsSyncWrappers.xRandomness = function (pVfs, nOut, pOut) {
                const heap = wasm.heap8u();
                let i = 0;
                for (; i < nOut; ++i)
                  heap[pOut + i] = (Math.random() * 255000) & 0xff;
                return i;
              };
            }
            if (!opfsVfs.$xSleep) {
              vfsSyncWrappers.xSleep = function (pVfs, ms) {
                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
                return 0;
              };
            }

            opfsUtil.getResolvedPath = function (filename, splitIt) {
              const p = new URL(filename, 'file://irrelevant').pathname;
              return splitIt ? p.split('/').filter((v) => !!v) : p;
            };

            opfsUtil.getDirForFilename = async function f(
              absFilename,
              createDirs = false,
            ) {
              const path = opfsUtil.getResolvedPath(absFilename, true);
              const filename = path.pop();
              let dh = opfsUtil.rootDirectory;
              for (const dirName of path) {
                if (dirName) {
                  dh = await dh.getDirectoryHandle(dirName, {
                    create: !!createDirs,
                  });
                }
              }
              return [dh, filename];
            };

            opfsUtil.mkdir = async function (absDirName) {
              try {
                await opfsUtil.getDirForFilename(
                  absDirName + '/filepart',
                  true,
                );
                return true;
              } catch (e) {
                return false;
              }
            };

            opfsUtil.entryExists = async function (fsEntryName) {
              try {
                const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
                await dh.getFileHandle(fn);
                return true;
              } catch (e) {
                return false;
              }
            };

            opfsUtil.randomFilename = randomFilename;

            opfsUtil.registerVfs = (asDefault = false) => {
              return wasm.exports.sqlite3_vfs_register(
                opfsVfs.pointer,
                asDefault ? 1 : 0,
              );
            };

            opfsUtil.treeList = async function () {
              const doDir = async function callee(dirHandle, tgt) {
                tgt.name = dirHandle.name;
                tgt.dirs = [];
                tgt.files = [];
                for await (const handle of dirHandle.values()) {
                  if ('directory' === handle.kind) {
                    const subDir = Object.create(null);
                    tgt.dirs.push(subDir);
                    await callee(handle, subDir);
                  } else {
                    tgt.files.push(handle.name);
                  }
                }
              };
              const root = Object.create(null);
              await doDir(opfsUtil.rootDirectory, root);
              return root;
            };

            opfsUtil.rmfr = async function () {
              const dir = opfsUtil.rootDirectory,
                opt = { recurse: true };
              for await (const handle of dir.values()) {
                dir.removeEntry(handle.name, opt);
              }
            };

            opfsUtil.unlink = async function (
              fsEntryName,
              recursive = false,
              throwOnError = false,
            ) {
              try {
                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                  fsEntryName,
                  false,
                );
                await hDir.removeEntry(filenamePart, { recursive });
                return true;
              } catch (e) {
                if (throwOnError) {
                  throw new Error(
                    'unlink(',
                    arguments[0],
                    ') failed: ' + e.message,
                    {
                      cause: e,
                    },
                  );
                }
                return false;
              }
            };

            opfsUtil.traverse = async function (opt) {
              const defaultOpt = {
                recursive: true,
                directory: opfsUtil.rootDirectory,
              };
              if ('function' === typeof opt) {
                opt = { callback: opt };
              }
              opt = Object.assign(defaultOpt, opt || {});
              const doDir = async function callee(dirHandle, depth) {
                for await (const handle of dirHandle.values()) {
                  if (false === opt.callback(handle, dirHandle, depth))
                    return false;
                  else if (opt.recursive && 'directory' === handle.kind) {
                    if (false === (await callee(handle, depth + 1))) break;
                  }
                }
              };
              doDir(opt.directory, 0);
            };

            const importDbChunked = async function (filename, callback) {
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true,
              );
              const hFile = await hDir.getFileHandle(fnamePart, {
                create: true,
              });
              let sah = await hFile.createSyncAccessHandle();
              let nWrote = 0,
                chunk,
                checkedHeader = false,
                err = false;
              try {
                sah.truncate(0);
                while (undefined !== (chunk = await callback())) {
                  if (chunk instanceof ArrayBuffer)
                    chunk = new Uint8Array(chunk);
                  if (0 === nWrote && chunk.byteLength >= 15) {
                    util.affirmDbHeader(chunk);
                    checkedHeader = true;
                  }
                  sah.write(chunk, { at: nWrote });
                  nWrote += chunk.byteLength;
                }
                if (nWrote < 512 || 0 !== nWrote % 512) {
                  toss(
                    'Input size',
                    nWrote,
                    'is not correct for an SQLite database.',
                  );
                }
                if (!checkedHeader) {
                  const header = new Uint8Array(20);
                  sah.read(header, { at: 0 });
                  util.affirmDbHeader(header);
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e) {
                await sah.close();
                sah = undefined;
                await hDir.removeEntry(fnamePart).catch(() => {});
                throw e;
              } finally {
                if (sah) await sah.close();
              }
            };

            opfsUtil.importDb = async function (filename, bytes) {
              if (bytes instanceof Function) {
                return importDbChunked(filename, bytes);
              }
              if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
              util.affirmIsDb(bytes);
              const n = bytes.byteLength;
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true,
              );
              let sah,
                err,
                nWrote = 0;
              try {
                const hFile = await hDir.getFileHandle(fnamePart, {
                  create: true,
                });
                sah = await hFile.createSyncAccessHandle();
                sah.truncate(0);
                nWrote = sah.write(bytes, { at: 0 });
                if (nWrote != n) {
                  toss(
                    'Expected to write ' +
                      n +
                      ' bytes but wrote ' +
                      nWrote +
                      '.',
                  );
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e) {
                if (sah) {
                  await sah.close();
                  sah = undefined;
                }
                await hDir.removeEntry(fnamePart).catch(() => {});
                throw e;
              } finally {
                if (sah) await sah.close();
              }
            };

            if (sqlite3.oo1) {
              const OpfsDb = function (...args) {
                const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                opt.vfs = opfsVfs.$zName;
                sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
              };
              OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
              sqlite3.oo1.OpfsDb = OpfsDb;
              OpfsDb.importDb = opfsUtil.importDb;
              sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                opfsVfs.pointer,
                function (oo1Db, sqlite3) {
                  sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);
                  sqlite3.capi.sqlite3_exec(
                    oo1Db,
                    [
                      'pragma journal_mode=DELETE;',

                      'pragma cache_size=-16384;',
                    ],
                    0,
                    0,
                    0,
                  );
                },
              );
            }

            const sanityCheck = function () {
              const scope = wasm.scopedAllocPush();
              const sq3File = new sqlite3_file();
              try {
                const fid = sq3File.pointer;
                const openFlags =
                  capi.SQLITE_OPEN_CREATE |
                  capi.SQLITE_OPEN_READWRITE |
                  capi.SQLITE_OPEN_MAIN_DB;
                const pOut = wasm.scopedAlloc(8);
                const dbFile = '/sanity/check/file' + randomFilename(8);
                const zDbFile = wasm.scopedAllocCString(dbFile);
                let rc;
                state.s11n.serialize('This is ä string.');
                rc = state.s11n.deserialize();
                log('deserialize() says:', rc);
                if ('This is ä string.' !== rc[0]) toss('String d13n error.');
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, 'i32');
                log('xAccess(', dbFile, ') exists ?=', rc);
                rc = vfsSyncWrappers.xOpen(
                  opfsVfs.pointer,
                  zDbFile,
                  fid,
                  openFlags,
                  pOut,
                );
                log(
                  'open rc =',
                  rc,
                  'state.sabOPView[xOpen] =',
                  state.sabOPView[state.opIds.xOpen],
                );
                if (0 !== rc) {
                  error('open failed with code', rc);
                  return;
                }
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, 'i32');
                if (!rc) toss('xAccess() failed to detect file.');
                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                if (rc) toss('sync failed w/ rc', rc);
                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                if (rc) toss('truncate failed w/ rc', rc);
                wasm.poke(pOut, 0, 'i64');
                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                if (rc) toss('xFileSize failed w/ rc', rc);
                log('xFileSize says:', wasm.peek(pOut, 'i64'));
                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                if (rc) toss('xWrite() failed!');
                const readBuf = wasm.scopedAlloc(16);
                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                wasm.poke(readBuf + 6, 0);
                let jRead = wasm.cstrToJs(readBuf);
                log('xRead() got:', jRead);
                if ('sanity' !== jRead) toss('Unexpected xRead() value.');
                if (vfsSyncWrappers.xSleep) {
                  log('xSleep()ing before close()ing...');
                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2000);
                  log('waking up from xSleep()');
                }
                rc = ioSyncWrappers.xClose(fid);
                log('xClose rc =', rc, 'sabOPView =', state.sabOPView);
                log('Deleting file:', dbFile);
                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, 'i32');
                if (rc)
                  toss(
                    'Expecting 0 from xAccess(',
                    dbFile,
                    ') after xDelete().',
                  );
                warn('End of OPFS sanity checks.');
              } finally {
                sq3File.dispose();
                wasm.scopedAllocPop(scope);
              }
            };

            W.onmessage = function ({ data }) {
              switch (data.type) {
                case 'opfs-unavailable':
                  promiseReject(new Error(data.payload.join(' ')));
                  break;
                case 'opfs-async-loaded':
                  W.postMessage({ type: 'opfs-async-init', args: state });
                  break;
                case 'opfs-async-inited': {
                  if (true === promiseWasRejected) {
                    break;
                  }
                  try {
                    sqlite3.vfs.installVfs({
                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers },
                    });
                    state.sabOPView = new Int32Array(state.sabOP);
                    state.sabFileBufView = new Uint8Array(
                      state.sabIO,
                      0,
                      state.fileBufferSize,
                    );
                    state.sabS11nView = new Uint8Array(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize,
                    );
                    initS11n();
                    if (options.sanityChecks) {
                      warn(
                        'Running sanity checks because of opfs-sanity-check URL arg...',
                      );
                      sanityCheck();
                    }
                    if (thisThreadHasOPFS()) {
                      navigator.storage
                        .getDirectory()
                        .then((d) => {
                          W.onerror = W._originalOnError;
                          delete W._originalOnError;
                          sqlite3.opfs = opfsUtil;
                          opfsUtil.rootDirectory = d;
                          log('End of OPFS sqlite3_vfs setup.', opfsVfs);
                          promiseResolve();
                        })
                        .catch(promiseReject);
                    } else {
                      promiseResolve();
                    }
                  } catch (e) {
                    error(e);
                    promiseReject(e);
                  }
                  break;
                }
                default: {
                  const errMsg =
                    'Unexpected message from the OPFS async worker: ' +
                    JSON.stringify(data);
                  error(errMsg);
                  promiseReject(new Error(errMsg));
                  break;
                }
              }
            };
          });
          return thePromise;
        };
        installOpfsVfs.defaultProxyUri = 'sqlite3-opfs-async-proxy.js';
        globalThis.sqlite3ApiBootstrap.initializersAsync.push(
          async (sqlite3) => {
            try {
              let proxyJs = installOpfsVfs.defaultProxyUri;
              if (sqlite3.scriptInfo.sqlite3Dir) {
                installOpfsVfs.defaultProxyUri =
                  sqlite3.scriptInfo.sqlite3Dir + proxyJs;
              }
              return installOpfsVfs().catch((e) => {
                sqlite3.config.warn(
                  'Ignoring inability to install OPFS sqlite3_vfs:',
                  e.message,
                );
              });
            } catch (e) {
              sqlite3.config.error('installOpfsVfs() exception:', e);
              return Promise.reject(e);
            }
          },
        );
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        'use strict';
        const toss = sqlite3.util.toss;
        const toss3 = sqlite3.util.toss3;
        const initPromises = Object.create(null);
        const capi = sqlite3.capi;
        const util = sqlite3.util;
        const wasm = sqlite3.wasm;

        const SECTOR_SIZE = 4096;
        const HEADER_MAX_PATH_SIZE = 512;
        const HEADER_FLAGS_SIZE = 4;
        const HEADER_DIGEST_SIZE = 8;
        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
        const HEADER_OFFSET_DATA = SECTOR_SIZE;

        const PERSISTENT_FILE_TYPES =
          capi.SQLITE_OPEN_MAIN_DB |
          capi.SQLITE_OPEN_MAIN_JOURNAL |
          capi.SQLITE_OPEN_SUPER_JOURNAL |
          capi.SQLITE_OPEN_WAL;

        const OPAQUE_DIR_NAME = '.opaque';

        const getRandomName = () => Math.random().toString(36).slice(2);

        const textDecoder = new TextDecoder();
        const textEncoder = new TextEncoder();

        const optionDefaults = Object.assign(Object.create(null), {
          name: 'opfs-sahpool',
          directory: undefined,
          initialCapacity: 6,
          clearOnInit: false,

          verbosity: 2,
        });

        const loggers = [
          sqlite3.config.error,
          sqlite3.config.warn,
          sqlite3.config.log,
        ];
        const log = sqlite3.config.log;
        const warn = sqlite3.config.warn;
        const error = sqlite3.config.error;

        const __mapVfsToPool = new Map();
        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);
        const setPoolForVfs = (pVfs, pool) => {
          if (pool) __mapVfsToPool.set(pVfs, pool);
          else __mapVfsToPool.delete(pVfs);
        };

        const __mapSqlite3File = new Map();
        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);
        const setPoolForPFile = (pFile, pool) => {
          if (pool) __mapSqlite3File.set(pFile, pool);
          else __mapSqlite3File.delete(pFile);
        };

        const ioMethods = {
          xCheckReservedLock: function (pFile, pOut) {
            const pool = getPoolForPFile(pFile);
            pool.log('xCheckReservedLock');
            pool.storeErr();
            wasm.poke32(pOut, 1);
            return 0;
          },
          xClose: function (pFile) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            if (file) {
              try {
                pool.log(`xClose ${file.path}`);
                pool.mapS3FileToOFile(pFile, false);
                file.sah.flush();
                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                  pool.deletePath(file.path);
                }
              } catch (e) {
                return pool.storeErr(e, capi.SQLITE_IOERR);
              }
            }
            return 0;
          },
          xDeviceCharacteristics: function (pFile) {
            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
          },
          xFileControl: function (pFile, opId, pArg) {
            return capi.SQLITE_NOTFOUND;
          },
          xFileSize: function (pFile, pSz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xFileSize`);
            const file = pool.getOFileForS3File(pFile);
            const size = file.sah.getSize() - HEADER_OFFSET_DATA;

            wasm.poke64(pSz64, BigInt(size));
            return 0;
          },
          xLock: function (pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xLock ${lockType}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xRead: function (pFile, pDest, n, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xRead ${file.path} ${n} @ ${offset64}`);
            try {
              const nRead = file.sah.read(
                wasm.heap8u().subarray(pDest, pDest + n),
                { at: HEADER_OFFSET_DATA + Number(offset64) },
              );
              if (nRead < n) {
                wasm.heap8u().fill(0, pDest + nRead, pDest + n);
                return capi.SQLITE_IOERR_SHORT_READ;
              }
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xSectorSize: function (pFile) {
            return SECTOR_SIZE;
          },
          xSync: function (pFile, flags) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xSync ${flags}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);

            try {
              file.sah.flush();
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xTruncate: function (pFile, sz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xTruncate ${sz64}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);

            try {
              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xUnlock: function (pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log('xUnlock');
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xWrite: function (pFile, pSrc, n, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xWrite ${file.path} ${n} ${offset64}`);
            try {
              const nBytes = file.sah.write(
                wasm.heap8u().subarray(pSrc, pSrc + n),
                { at: HEADER_OFFSET_DATA + Number(offset64) },
              );
              return n === nBytes ? 0 : toss('Unknown write() failure.');
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
        };

        const opfsIoMethods = new capi.sqlite3_io_methods();
        opfsIoMethods.$iVersion = 1;
        sqlite3.vfs.installVfs({
          io: { struct: opfsIoMethods, methods: ioMethods },
        });

        const vfsMethods = {
          xAccess: function (pVfs, zName, flags, pOut) {
            const pool = getPoolForVfs(pVfs);
            pool.storeErr();
            try {
              const name = pool.getPath(zName);
              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
            } catch (e) {
              wasm.poke32(pOut, 0);
            }
            return 0;
          },
          xCurrentTime: function (pVfs, pOut) {
            wasm.poke(
              pOut,
              2440587.5 + new Date().getTime() / 86400000,
              'double',
            );
            return 0;
          },
          xCurrentTimeInt64: function (pVfs, pOut) {
            wasm.poke(pOut, 2440587.5 * 86400000 + new Date().getTime(), 'i64');
            return 0;
          },
          xDelete: function (pVfs, zName, doSyncDir) {
            const pool = getPoolForVfs(pVfs);
            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
            pool.storeErr();
            try {
              pool.deletePath(pool.getPath(zName));
              return 0;
            } catch (e) {
              pool.storeErr(e);
              return capi.SQLITE_IOERR_DELETE;
            }
          },
          xFullPathname: function (pVfs, zName, nOut, pOut) {
            const i = wasm.cstrncpy(pOut, zName, nOut);
            return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
          },
          xGetLastError: function (pVfs, nOut, pOut) {
            const pool = getPoolForVfs(pVfs);
            const e = pool.popErr();
            pool.log(`xGetLastError ${nOut} e =`, e);
            if (e) {
              const scope = wasm.scopedAllocPush();
              try {
                const [cMsg, n] = wasm.scopedAllocCString(e.message, true);
                wasm.cstrncpy(pOut, cMsg, nOut);
                if (n > nOut) wasm.poke8(pOut + nOut - 1, 0);
              } catch (e) {
                return capi.SQLITE_NOMEM;
              } finally {
                wasm.scopedAllocPop(scope);
              }
            }
            return e ? e.sqlite3Rc || capi.SQLITE_IOERR : 0;
          },

          xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
            const pool = getPoolForVfs(pVfs);
            try {
              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);

              const path =
                zName && wasm.peek8(zName)
                  ? pool.getPath(zName)
                  : getRandomName();
              let sah = pool.getSAHForPath(path);
              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {
                if (pool.getFileCount() < pool.getCapacity()) {
                  sah = pool.nextAvailableSAH();
                  pool.setAssociatedPath(sah, path, flags);
                } else {
                  toss('SAH pool is full. Cannot create file', path);
                }
              }
              if (!sah) {
                toss('file not found:', path);
              }

              const file = { path, flags, sah };
              pool.mapS3FileToOFile(pFile, file);
              file.lockType = capi.SQLITE_LOCK_NONE;
              const sq3File = new capi.sqlite3_file(pFile);
              sq3File.$pMethods = opfsIoMethods.pointer;
              sq3File.dispose();
              wasm.poke32(pOutFlags, flags);
              return 0;
            } catch (e) {
              pool.storeErr(e);
              return capi.SQLITE_CANTOPEN;
            }
          },
        };

        const createOpfsVfs = function (vfsName) {
          if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {
            toss3('VFS name is already registered:', vfsName);
          }
          const opfsVfs = new capi.sqlite3_vfs();

          const pDVfs = capi.sqlite3_vfs_find(null);
          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
          opfsVfs.$iVersion = 2;
          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
          opfsVfs.addOnDispose(
            (opfsVfs.$zName = wasm.allocCString(vfsName)),
            () => setPoolForVfs(opfsVfs.pointer, 0),
          );

          if (dVfs) {
            opfsVfs.$xRandomness = dVfs.$xRandomness;
            opfsVfs.$xSleep = dVfs.$xSleep;
            dVfs.dispose();
          }
          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
            vfsMethods.xRandomness = function (pVfs, nOut, pOut) {
              const heap = wasm.heap8u();
              let i = 0;
              for (; i < nOut; ++i)
                heap[pOut + i] = (Math.random() * 255000) & 0xff;
              return i;
            };
          }
          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
            vfsMethods.xSleep = (pVfs, ms) => 0;
          }
          sqlite3.vfs.installVfs({
            vfs: { struct: opfsVfs, methods: vfsMethods },
          });
          return opfsVfs;
        };

        class OpfsSAHPool {
          vfsDir;

          #dhVfsRoot;

          #dhOpaque;

          #dhVfsParent;

          #mapSAHToName = new Map();

          #mapFilenameToSAH = new Map();

          #availableSAH = new Set();

          #mapS3FileToOFile_ = new Map();

          #apBody = new Uint8Array(HEADER_CORPUS_SIZE);

          #dvBody;

          #cVfs;

          #verbosity;

          constructor(options = Object.create(null)) {
            this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
            this.vfsName = options.name || optionDefaults.name;
            this.#cVfs = createOpfsVfs(this.vfsName);
            setPoolForVfs(this.#cVfs.pointer, this);
            this.vfsDir = options.directory || '.' + this.vfsName;
            this.#dvBody = new DataView(
              this.#apBody.buffer,
              this.#apBody.byteOffset,
            );
            this.isReady = this.reset(
              !!(options.clearOnInit ?? optionDefaults.clearOnInit),
            ).then(() => {
              if (this.$error) throw this.$error;
              return this.getCapacity()
                ? Promise.resolve(undefined)
                : this.addCapacity(
                    options.initialCapacity || optionDefaults.initialCapacity,
                  );
            });
          }

          #logImpl(level, ...args) {
            if (this.#verbosity > level)
              loggers[level](this.vfsName + ':', ...args);
          }
          log(...args) {
            this.#logImpl(2, ...args);
          }
          warn(...args) {
            this.#logImpl(1, ...args);
          }
          error(...args) {
            this.#logImpl(0, ...args);
          }

          getVfs() {
            return this.#cVfs;
          }

          getCapacity() {
            return this.#mapSAHToName.size;
          }

          getFileCount() {
            return this.#mapFilenameToSAH.size;
          }

          getFileNames() {
            const rc = [];
            const iter = this.#mapFilenameToSAH.keys();
            for (const n of iter) rc.push(n);
            return rc;
          }

          async addCapacity(n) {
            for (let i = 0; i < n; ++i) {
              const name = getRandomName();
              const h = await this.#dhOpaque.getFileHandle(name, {
                create: true,
              });
              const ah = await h.createSyncAccessHandle();
              this.#mapSAHToName.set(ah, name);
              this.setAssociatedPath(ah, '', 0);
            }
            return this.getCapacity();
          }

          async reduceCapacity(n) {
            let nRm = 0;
            for (const ah of Array.from(this.#availableSAH)) {
              if (nRm === n || this.getFileCount() === this.getCapacity()) {
                break;
              }
              const name = this.#mapSAHToName.get(ah);

              ah.close();
              await this.#dhOpaque.removeEntry(name);
              this.#mapSAHToName.delete(ah);
              this.#availableSAH.delete(ah);
              ++nRm;
            }
            return nRm;
          }

          releaseAccessHandles() {
            for (const ah of this.#mapSAHToName.keys()) ah.close();
            this.#mapSAHToName.clear();
            this.#mapFilenameToSAH.clear();
            this.#availableSAH.clear();
          }

          async acquireAccessHandles(clearFiles) {
            const files = [];
            for await (const [name, h] of this.#dhOpaque) {
              if ('file' === h.kind) {
                files.push([name, h]);
              }
            }
            return Promise.all(
              files.map(async ([name, h]) => {
                try {
                  const ah = await h.createSyncAccessHandle();
                  this.#mapSAHToName.set(ah, name);
                  if (clearFiles) {
                    ah.truncate(HEADER_OFFSET_DATA);
                    this.setAssociatedPath(ah, '', 0);
                  } else {
                    const path = this.getAssociatedPath(ah);
                    if (path) {
                      this.#mapFilenameToSAH.set(path, ah);
                    } else {
                      this.#availableSAH.add(ah);
                    }
                  }
                } catch (e) {
                  this.storeErr(e);
                  this.releaseAccessHandles();
                  throw e;
                }
              }),
            );
          }

          getAssociatedPath(sah) {
            sah.read(this.#apBody, { at: 0 });

            const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
            if (
              this.#apBody[0] &&
              (flags & capi.SQLITE_OPEN_DELETEONCLOSE ||
                (flags & PERSISTENT_FILE_TYPES) === 0)
            ) {
              warn(
                `Removing file with unexpected flags ${flags.toString(16)}`,
                this.#apBody,
              );
              this.setAssociatedPath(sah, '', 0);
              return '';
            }

            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
            const compDigest = this.computeDigest(this.#apBody);
            if (fileDigest.every((v, i) => v === compDigest[i])) {
              const pathBytes = this.#apBody.findIndex((v) => 0 === v);
              if (0 === pathBytes) {
                sah.truncate(HEADER_OFFSET_DATA);
              }
              return pathBytes
                ? textDecoder.decode(this.#apBody.subarray(0, pathBytes))
                : '';
            } else {
              warn('Disassociating file with bad digest.');
              this.setAssociatedPath(sah, '', 0);
              return '';
            }
          }

          setAssociatedPath(sah, path, flags) {
            const enc = textEncoder.encodeInto(path, this.#apBody);
            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
              toss('Path too long:', path);
            }
            this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
            this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);

            const digest = this.computeDigest(this.#apBody);
            sah.write(this.#apBody, { at: 0 });
            sah.write(digest, { at: HEADER_OFFSET_DIGEST });
            sah.flush();

            if (path) {
              this.#mapFilenameToSAH.set(path, sah);
              this.#availableSAH.delete(sah);
            } else {
              sah.truncate(HEADER_OFFSET_DATA);
              this.#availableSAH.add(sah);
            }
          }

          computeDigest(byteArray) {
            let h1 = 0xdeadbeef;
            let h2 = 0x41c6ce57;
            for (const v of byteArray) {
              h1 = 31 * h1 + v * 307;
              h2 = 31 * h2 + v * 307;
            }
            return new Uint32Array([h1 >>> 0, h2 >>> 0]);
          }

          async reset(clearFiles) {
            await this.isReady;
            let h = await navigator.storage.getDirectory();
            let prev, prevName;
            for (const d of this.vfsDir.split('/')) {
              if (d) {
                prev = h;
                h = await h.getDirectoryHandle(d, { create: true });
              }
            }
            this.#dhVfsRoot = h;
            this.#dhVfsParent = prev;
            this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
              OPAQUE_DIR_NAME,
              { create: true },
            );
            this.releaseAccessHandles();
            return this.acquireAccessHandles(clearFiles);
          }

          getPath(arg) {
            if (wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);
            return (
              arg instanceof URL ? arg : new URL(arg, 'file://localhost/')
            ).pathname;
          }

          deletePath(path) {
            const sah = this.#mapFilenameToSAH.get(path);
            if (sah) {
              this.#mapFilenameToSAH.delete(path);
              this.setAssociatedPath(sah, '', 0);
            }
            return !!sah;
          }

          storeErr(e, code) {
            if (e) {
              e.sqlite3Rc = code || capi.SQLITE_IOERR;
              this.error(e);
            }
            this.$error = e;
            return code;
          }

          popErr() {
            const rc = this.$error;
            this.$error = undefined;
            return rc;
          }

          nextAvailableSAH() {
            const [rc] = this.#availableSAH.keys();
            return rc;
          }

          getOFileForS3File(pFile) {
            return this.#mapS3FileToOFile_.get(pFile);
          }

          mapS3FileToOFile(pFile, file) {
            if (file) {
              this.#mapS3FileToOFile_.set(pFile, file);
              setPoolForPFile(pFile, this);
            } else {
              this.#mapS3FileToOFile_.delete(pFile);
              setPoolForPFile(pFile, false);
            }
          }

          hasFilename(name) {
            return this.#mapFilenameToSAH.has(name);
          }

          getSAHForPath(path) {
            return this.#mapFilenameToSAH.get(path);
          }

          async removeVfs() {
            if (!this.#cVfs.pointer || !this.#dhOpaque) return false;
            capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
            this.#cVfs.dispose();
            try {
              this.releaseAccessHandles();
              await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {
                recursive: true,
              });
              this.#dhOpaque = undefined;
              await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {
                recursive: true,
              });
              this.#dhVfsRoot = this.#dhVfsParent = undefined;
            } catch (e) {
              sqlite3.config.error(this.vfsName, 'removeVfs() failed:', e);
            }
            return true;
          }

          exportFile(name) {
            const sah =
              this.#mapFilenameToSAH.get(name) || toss('File not found:', name);
            const n = sah.getSize() - HEADER_OFFSET_DATA;
            const b = new Uint8Array(n > 0 ? n : 0);
            if (n > 0) {
              const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });
              if (nRead != n) {
                toss(
                  'Expected to read ' + n + ' bytes but read ' + nRead + '.',
                );
              }
            }
            return b;
          }

          async importDbChunked(name, callback) {
            const sah =
              this.#mapFilenameToSAH.get(name) ||
              this.nextAvailableSAH() ||
              toss('No available handles to import to.');
            sah.truncate(0);
            let nWrote = 0,
              chunk,
              checkedHeader = false,
              err = false;
            try {
              while (undefined !== (chunk = await callback())) {
                if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
                if (0 === nWrote && chunk.byteLength >= 15) {
                  util.affirmDbHeader(chunk);
                  checkedHeader = true;
                }
                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                nWrote += chunk.byteLength;
              }
              if (nWrote < 512 || 0 !== nWrote % 512) {
                toss(
                  'Input size',
                  nWrote,
                  'is not correct for an SQLite database.',
                );
              }
              if (!checkedHeader) {
                const header = new Uint8Array(20);
                sah.read(header, { at: 0 });
                util.affirmDbHeader(header);
              }
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18,
              });
            } catch (e) {
              this.setAssociatedPath(sah, '', 0);
              throw e;
            }
            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            return nWrote;
          }

          importDb(name, bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            else if (bytes instanceof Function)
              return this.importDbChunked(name, bytes);
            const sah =
              this.#mapFilenameToSAH.get(name) ||
              this.nextAvailableSAH() ||
              toss('No available handles to import to.');
            const n = bytes.byteLength;
            if (n < 512 || n % 512 != 0) {
              toss('Byte array size is invalid for an SQLite db.');
            }
            const header = 'SQLite format 3';
            for (let i = 0; i < header.length; ++i) {
              if (header.charCodeAt(i) !== bytes[i]) {
                toss('Input does not contain an SQLite database header.');
              }
            }
            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
            if (nWrote != n) {
              this.setAssociatedPath(sah, '', 0);
              toss(
                'Expected to write ' + n + ' bytes but wrote ' + nWrote + '.',
              );
            } else {
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18,
              });
              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            }
            return nWrote;
          }
        }

        class OpfsSAHPoolUtil {
          #p;

          constructor(sahPool) {
            this.#p = sahPool;
            this.vfsName = sahPool.vfsName;
          }

          async addCapacity(n) {
            return this.#p.addCapacity(n);
          }

          async reduceCapacity(n) {
            return this.#p.reduceCapacity(n);
          }

          getCapacity() {
            return this.#p.getCapacity(this.#p);
          }

          getFileCount() {
            return this.#p.getFileCount();
          }
          getFileNames() {
            return this.#p.getFileNames();
          }

          async reserveMinimumCapacity(min) {
            const c = this.#p.getCapacity();
            return c < min ? this.#p.addCapacity(min - c) : c;
          }

          exportFile(name) {
            return this.#p.exportFile(name);
          }

          importDb(name, bytes) {
            return this.#p.importDb(name, bytes);
          }

          async wipeFiles() {
            return this.#p.reset(true);
          }

          unlink(filename) {
            return this.#p.deletePath(filename);
          }

          async removeVfs() {
            return this.#p.removeVfs();
          }
        }

        const apiVersionCheck = async () => {
          const dh = await navigator.storage.getDirectory();
          const fn = '.opfs-sahpool-sync-check-' + getRandomName();
          const fh = await dh.getFileHandle(fn, { create: true });
          const ah = await fh.createSyncAccessHandle();
          const close = ah.close();
          await close;
          await dh.removeEntry(fn);
          if (close?.then) {
            toss(
              'The local OPFS API is too old for opfs-sahpool:',
              'it has an async FileSystemSyncAccessHandle.close() method.',
            );
          }
          return true;
        };

        let instanceCounter = 0;

        sqlite3.installOpfsSAHPoolVfs = async function (
          options = Object.create(null),
        ) {
          const vfsName = options.name || optionDefaults.name;
          if (false) {}
          if (initPromises[vfsName]) {
            return initPromises[vfsName];
          }
          if (
            !globalThis.FileSystemHandle ||
            !globalThis.FileSystemDirectoryHandle ||
            !globalThis.FileSystemFileHandle ||
            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
            !navigator?.storage?.getDirectory
          ) {
            return (initPromises[vfsName] = Promise.reject(
              new Error('Missing required OPFS APIs.'),
            ));
          }

          return (initPromises[vfsName] = apiVersionCheck()
            .then(async function () {
              if (options.$testThrowInInit) {
                throw options.$testThrowInInit;
              }
              const thePool = new OpfsSAHPool(options);
              return thePool.isReady
                .then(async () => {
                  const poolUtil = new OpfsSAHPoolUtil(thePool);
                  if (sqlite3.oo1) {
                    const oo1 = sqlite3.oo1;
                    const theVfs = thePool.getVfs();
                    const OpfsSAHPoolDb = function (...args) {
                      const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                      opt.vfs = theVfs.$zName;
                      oo1.DB.dbCtorHelper.call(this, opt);
                    };
                    OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);

                    poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
                    oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                      theVfs.pointer,
                      function (oo1Db, sqlite3) {
                        sqlite3.capi.sqlite3_exec(
                          oo1Db,
                          [
                            'pragma journal_mode=DELETE;',
                            'pragma cache_size=-16384;',
                          ],
                          0,
                          0,
                          0,
                        );
                      },
                    );
                  }
                  thePool.log('VFS initialized.');
                  return poolUtil;
                })
                .catch(async (e) => {
                  await thePool.removeVfs().catch(() => {});
                  throw e;
                });
            })
            .catch((err) => {
              return (initPromises[vfsName] = Promise.reject(err));
            }));
        };
      });

      ('use strict');
      if ('undefined' !== typeof Module) {
        const SABC = Object.assign(
          Object.create(null),
          {
            exports:
              'undefined' === typeof wasmExports ? Module['asm'] : wasmExports,
            memory: Module.wasmMemory,
          },
          globalThis.sqlite3ApiConfig || {},
        );

        globalThis.sqlite3ApiConfig = SABC;
        let sqlite3;
        try {
          sqlite3 = globalThis.sqlite3ApiBootstrap();
        } catch (e) {
          console.error('sqlite3ApiBootstrap() error:', e);
          throw e;
        } finally {
          delete globalThis.sqlite3ApiBootstrap;
          delete globalThis.sqlite3ApiConfig;
        }

        Module.sqlite3 = sqlite3;
      } else {
        console.warn(
          'This is not running in an Emscripten module context, so',
          'globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack',
          'of config info for the WASM environment.',
          'It must be called manually.',
        );
      }
    });

    return sqlite3InitModule.ready;
  };
})();

const toExportForESM = (function () {
  const originalInit = sqlite3InitModule;
  if (!originalInit) {
    throw new Error(
      'Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.',
    );
  }

  const initModuleState = (globalThis.sqlite3InitModuleState = Object.assign(
    Object.create(null),
    {
      moduleScript: globalThis?.document?.currentScript,
      isWorker: 'undefined' !== typeof WorkerGlobalScope,
      location: globalThis.location,
      urlParams: globalThis?.location?.href
        ? new URL(globalThis.location.href).searchParams
        : new URLSearchParams(),
    },
  ));
  initModuleState.debugModule = initModuleState.urlParams.has(
    'sqlite3.debugModule',
  )
    ? (...args) => console.warn('sqlite3.debugModule:', ...args)
    : () => {};

  if (initModuleState.urlParams.has('sqlite3.dir')) {
    initModuleState.sqlite3Dir =
      initModuleState.urlParams.get('sqlite3.dir') + '/';
  } else if (initModuleState.moduleScript) {
    const li = initModuleState.moduleScript.src.split('/');
    li.pop();
    initModuleState.sqlite3Dir = li.join('/') + '/';
  }

  globalThis.sqlite3InitModule = function ff(...args) {
    return originalInit(...args)
      .then((EmscriptenModule) => {
        const s = EmscriptenModule.sqlite3;
        s.scriptInfo = initModuleState;

        if (ff.__isUnderTest) s.__isUnderTest = true;
        const f = s.asyncPostInit;
        delete s.asyncPostInit;
        return f();
      })
      .catch((e) => {
        console.error('Exception loading sqlite3 module:', e);
        throw e;
      });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;

  if (globalThis.sqlite3InitModuleState.moduleScript) {
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split('/');
    src.pop();
    sim.scriptDir = src.join('/') + '/';
  }
  initModuleState.debugModule('sqlite3InitModuleState =', initModuleState);
  if (false) {}
  return globalThis.sqlite3InitModule;
})();
sqlite3InitModule = toExportForESM;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sqlite3InitModule);


/***/ }),

/***/ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser-bundler-friendly.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser-bundler-friendly.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
  2022-08-24

  The author disclaims copyright to this source code.  In place of a
  legal notice, here is a blessing:

  *   May you do good and not evil.
  *   May you find forgiveness for yourself and forgive others.
  *   May you share freely, never taking more than you give.

  ***********************************************************************

  This file implements a Promise-based proxy for the sqlite3 Worker
  API #1. It is intended to be included either from the main thread or
  a Worker, but only if (A) the environment supports nested Workers
  and (B) it's _not_ a Worker which loads the sqlite3 WASM/JS
  module. This file's features will load that module and provide a
  slightly simpler client-side interface than the slightly-lower-level
  Worker API does.

  This script necessarily exposes one global symbol, but clients may
  freely `delete` that symbol after calling it.
*/


globalThis.sqlite3Worker1Promiser = function callee(
  config = callee.defaultConfig,
) {
  if (1 === arguments.length && 'function' === typeof arguments[0]) {
    const f = config;
    config = Object.assign(Object.create(null), callee.defaultConfig);
    config.onready = f;
  } else {
    config = Object.assign(Object.create(null), callee.defaultConfig, config);
  }
  const handlerMap = Object.create(null);
  const noop = function () {};
  const err = config.onerror || noop;
  const debug = config.debug || noop;
  const idTypeMap = config.generateMessageId ? undefined : Object.create(null);
  const genMsgId =
    config.generateMessageId ||
    function (msg) {
      return (
        msg.type + '#' + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1)
      );
    };
  const toss = (...args) => {
    throw new Error(args.join(' '));
  };
  if (!config.worker) config.worker = callee.defaultConfig.worker;
  if ('function' === typeof config.worker) config.worker = config.worker();
  let dbId;
  config.worker.onmessage = function (ev) {
    ev = ev.data;
    debug('worker1.onmessage', ev);
    let msgHandler = handlerMap[ev.messageId];
    if (!msgHandler) {
      if (ev && 'sqlite3-api' === ev.type && 'worker1-ready' === ev.result) {
        if (config.onready) config.onready();
        return;
      }
      msgHandler = handlerMap[ev.type];
      if (msgHandler && msgHandler.onrow) {
        msgHandler.onrow(ev);
        return;
      }
      if (config.onunhandled) config.onunhandled(arguments[0]);
      else err('sqlite3Worker1Promiser() unhandled worker message:', ev);
      return;
    }
    delete handlerMap[ev.messageId];
    switch (ev.type) {
      case 'error':
        msgHandler.reject(ev);
        return;
      case 'open':
        if (!dbId) dbId = ev.dbId;
        break;
      case 'close':
        if (ev.dbId === dbId) dbId = undefined;
        break;
      default:
        break;
    }
    try {
      msgHandler.resolve(ev);
    } catch (e) {
      msgHandler.reject(e);
    }
  };
  return function () {
    let msg;
    if (1 === arguments.length) {
      msg = arguments[0];
    } else if (2 === arguments.length) {
      msg = Object.create(null);
      msg.type = arguments[0];
      msg.args = arguments[1];
      msg.dbId = msg.args.dbId;
    } else {
      toss('Invalid arugments for sqlite3Worker1Promiser()-created factory.');
    }
    if (!msg.dbId && msg.type !== 'open') msg.dbId = dbId;
    msg.messageId = genMsgId(msg);
    msg.departureTime = performance.now();
    const proxy = Object.create(null);
    proxy.message = msg;
    let rowCallbackId;
    if ('exec' === msg.type && msg.args) {
      if ('function' === typeof msg.args.callback) {
        rowCallbackId = msg.messageId + ':row';
        proxy.onrow = msg.args.callback;
        msg.args.callback = rowCallbackId;
        handlerMap[rowCallbackId] = proxy;
      } else if ('string' === typeof msg.args.callback) {
        toss(
          'exec callback may not be a string when using the Promise interface.',
        );
      }
    }

    let p = new Promise(function (resolve, reject) {
      proxy.resolve = resolve;
      proxy.reject = reject;
      handlerMap[msg.messageId] = proxy;
      debug(
        'Posting',
        msg.type,
        'message to Worker dbId=' + (dbId || 'default') + ':',
        msg,
      );
      config.worker.postMessage(msg);
    });
    if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);
    return p;
  };
};
globalThis.sqlite3Worker1Promiser.defaultConfig = {
  worker: function () {
    return new Worker(
      new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("vendors-node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-worker1-bundler-friendly_mjs"), __webpack_require__.b),
      {
        type: undefined,
      },
    );
  },
  onerror: (...args) => console.error('worker1 promiser error', ...args),
};


/***/ }),

/***/ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm":
/*!******************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "b4d6efa36bdb8259647a.wasm";

/***/ }),

/***/ "./node_modules/buffer-from/index.js":
/*!*******************************************!*\
  !*** ./node_modules/buffer-from/index.js ***!
  \*******************************************/
/***/ ((module) => {

/* eslint-disable node/no-deprecated-api */

var toString = Object.prototype.toString

var isModern = (
  typeof Buffer !== 'undefined' &&
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css ***!
  \****************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `:root{--dt-row-selected: 13, 110, 253;--dt-row-selected-text: 255, 255, 255;--dt-row-selected-link: 9, 10, 11;--dt-row-stripe: 0, 0, 0;--dt-row-hover: 0, 0, 0;--dt-column-ordering: 0, 0, 0;--dt-html-background: white}:root.dark{--dt-html-background: rgb(33, 37, 41)}table.dataTable td.dt-control{text-align:center;cursor:pointer}table.dataTable td.dt-control:before{display:inline-block;box-sizing:border-box;content:"";border-top:5px solid transparent;border-left:10px solid rgba(0, 0, 0, 0.5);border-bottom:5px solid transparent;border-right:0px solid transparent}table.dataTable tr.dt-hasChild td.dt-control:before{border-top:10px solid rgba(0, 0, 0, 0.5);border-left:5px solid transparent;border-bottom:0px solid transparent;border-right:5px solid transparent}table.dataTable tfoot:empty{display:none}html.dark table.dataTable td.dt-control:before,:root[data-bs-theme=dark] table.dataTable td.dt-control:before,:root[data-theme=dark] table.dataTable td.dt-control:before{border-left-color:rgba(255, 255, 255, 0.5)}html.dark table.dataTable tr.dt-hasChild td.dt-control:before,:root[data-bs-theme=dark] table.dataTable tr.dt-hasChild td.dt-control:before,:root[data-theme=dark] table.dataTable tr.dt-hasChild td.dt-control:before{border-top-color:rgba(255, 255, 255, 0.5);border-left-color:transparent}div.dt-scroll{width:100%}div.dt-scroll-body thead tr,div.dt-scroll-body tfoot tr{height:0}div.dt-scroll-body thead tr th,div.dt-scroll-body thead tr td,div.dt-scroll-body tfoot tr th,div.dt-scroll-body tfoot tr td{height:0 !important;padding-top:0px !important;padding-bottom:0px !important;border-top-width:0px !important;border-bottom-width:0px !important}div.dt-scroll-body thead tr th div.dt-scroll-sizing,div.dt-scroll-body thead tr td div.dt-scroll-sizing,div.dt-scroll-body tfoot tr th div.dt-scroll-sizing,div.dt-scroll-body tfoot tr td div.dt-scroll-sizing{height:0 !important;overflow:hidden !important}table.dataTable thead>tr>th:active,table.dataTable thead>tr>td:active{outline:none}table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before{position:absolute;display:block;bottom:50%;content:"▲";content:"▲"/""}table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after{position:absolute;display:block;top:50%;content:"▼";content:"▼"/""}table.dataTable thead>tr>th.dt-orderable-asc,table.dataTable thead>tr>th.dt-orderable-desc,table.dataTable thead>tr>th.dt-ordering-asc,table.dataTable thead>tr>th.dt-ordering-desc,table.dataTable thead>tr>td.dt-orderable-asc,table.dataTable thead>tr>td.dt-orderable-desc,table.dataTable thead>tr>td.dt-ordering-asc,table.dataTable thead>tr>td.dt-ordering-desc{position:relative;padding-right:30px}table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order,table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order{position:absolute;right:12px;top:0;bottom:0;width:12px}table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:after,table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:before,table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:after,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:after,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:before,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after{left:0;opacity:.125;line-height:9px;font-size:.8em}table.dataTable thead>tr>th.dt-orderable-asc,table.dataTable thead>tr>th.dt-orderable-desc,table.dataTable thead>tr>td.dt-orderable-asc,table.dataTable thead>tr>td.dt-orderable-desc{cursor:pointer}table.dataTable thead>tr>th.dt-orderable-asc:hover,table.dataTable thead>tr>th.dt-orderable-desc:hover,table.dataTable thead>tr>td.dt-orderable-asc:hover,table.dataTable thead>tr>td.dt-orderable-desc:hover{outline:2px solid rgba(0, 0, 0, 0.05);outline-offset:-2px}table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after{opacity:.6}table.dataTable thead>tr>th.sorting_desc_disabled span.dt-column-order:after,table.dataTable thead>tr>th.sorting_asc_disabled span.dt-column-order:before,table.dataTable thead>tr>td.sorting_desc_disabled span.dt-column-order:after,table.dataTable thead>tr>td.sorting_asc_disabled span.dt-column-order:before{display:none}table.dataTable thead>tr>th:active,table.dataTable thead>tr>td:active{outline:none}div.dt-scroll-body>table.dataTable>thead>tr>th,div.dt-scroll-body>table.dataTable>thead>tr>td{overflow:hidden}:root.dark table.dataTable thead>tr>th.dt-orderable-asc:hover,:root.dark table.dataTable thead>tr>th.dt-orderable-desc:hover,:root.dark table.dataTable thead>tr>td.dt-orderable-asc:hover,:root.dark table.dataTable thead>tr>td.dt-orderable-desc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>th.dt-orderable-asc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>th.dt-orderable-desc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>td.dt-orderable-asc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>td.dt-orderable-desc:hover{outline:2px solid rgba(255, 255, 255, 0.05)}div.dt-processing{position:absolute;top:50%;left:50%;width:200px;margin-left:-100px;margin-top:-22px;text-align:center;padding:2px;z-index:10}div.dt-processing>div:last-child{position:relative;width:80px;height:15px;margin:1em auto}div.dt-processing>div:last-child>div{position:absolute;top:0;width:13px;height:13px;border-radius:50%;background:rgb(13, 110, 253);background:rgb(var(--dt-row-selected));animation-timing-function:cubic-bezier(0, 1, 1, 0)}div.dt-processing>div:last-child>div:nth-child(1){left:8px;animation:datatables-loader-1 .6s infinite}div.dt-processing>div:last-child>div:nth-child(2){left:8px;animation:datatables-loader-2 .6s infinite}div.dt-processing>div:last-child>div:nth-child(3){left:32px;animation:datatables-loader-2 .6s infinite}div.dt-processing>div:last-child>div:nth-child(4){left:56px;animation:datatables-loader-3 .6s infinite}@keyframes datatables-loader-1{0%{transform:scale(0)}100%{transform:scale(1)}}@keyframes datatables-loader-3{0%{transform:scale(1)}100%{transform:scale(0)}}@keyframes datatables-loader-2{0%{transform:translate(0, 0)}100%{transform:translate(24px, 0)}}table.dataTable.nowrap th,table.dataTable.nowrap td{white-space:nowrap}table.dataTable th,table.dataTable td{box-sizing:border-box}table.dataTable th.dt-type-numeric,table.dataTable th.dt-type-date,table.dataTable td.dt-type-numeric,table.dataTable td.dt-type-date{text-align:right}table.dataTable th.dt-left,table.dataTable td.dt-left{text-align:left}table.dataTable th.dt-center,table.dataTable td.dt-center{text-align:center}table.dataTable th.dt-right,table.dataTable td.dt-right{text-align:right}table.dataTable th.dt-justify,table.dataTable td.dt-justify{text-align:justify}table.dataTable th.dt-nowrap,table.dataTable td.dt-nowrap{white-space:nowrap}table.dataTable th.dt-empty,table.dataTable td.dt-empty{text-align:center;vertical-align:top}table.dataTable thead th,table.dataTable thead td,table.dataTable tfoot th,table.dataTable tfoot td{text-align:left}table.dataTable thead th.dt-head-left,table.dataTable thead td.dt-head-left,table.dataTable tfoot th.dt-head-left,table.dataTable tfoot td.dt-head-left{text-align:left}table.dataTable thead th.dt-head-center,table.dataTable thead td.dt-head-center,table.dataTable tfoot th.dt-head-center,table.dataTable tfoot td.dt-head-center{text-align:center}table.dataTable thead th.dt-head-right,table.dataTable thead td.dt-head-right,table.dataTable tfoot th.dt-head-right,table.dataTable tfoot td.dt-head-right{text-align:right}table.dataTable thead th.dt-head-justify,table.dataTable thead td.dt-head-justify,table.dataTable tfoot th.dt-head-justify,table.dataTable tfoot td.dt-head-justify{text-align:justify}table.dataTable thead th.dt-head-nowrap,table.dataTable thead td.dt-head-nowrap,table.dataTable tfoot th.dt-head-nowrap,table.dataTable tfoot td.dt-head-nowrap{white-space:nowrap}table.dataTable tbody th.dt-body-left,table.dataTable tbody td.dt-body-left{text-align:left}table.dataTable tbody th.dt-body-center,table.dataTable tbody td.dt-body-center{text-align:center}table.dataTable tbody th.dt-body-right,table.dataTable tbody td.dt-body-right{text-align:right}table.dataTable tbody th.dt-body-justify,table.dataTable tbody td.dt-body-justify{text-align:justify}table.dataTable tbody th.dt-body-nowrap,table.dataTable tbody td.dt-body-nowrap{white-space:nowrap}:root{--dt-row-hover-alpha: 0.035;--dt-row-stripe-alpha: 0.023;--dt-column-ordering-alpha: 0.019;--dt-row-selected-stripe-alpha: 0.923;--dt-row-selected-column-ordering-alpha: 0.919}table.dataTable{width:100%;margin:0 auto;border-spacing:0}table.dataTable thead th,table.dataTable tfoot th{font-weight:bold}table.dataTable>thead>tr>th,table.dataTable>thead>tr>td{padding:10px;border-bottom:1px solid rgba(0, 0, 0, 0.3)}table.dataTable>thead>tr>th:active,table.dataTable>thead>tr>td:active{outline:none}table.dataTable>tfoot>tr>th,table.dataTable>tfoot>tr>td{border-top:1px solid rgba(0, 0, 0, 0.3);padding:10px 10px 6px 10px}table.dataTable>tbody>tr{background-color:transparent}table.dataTable>tbody>tr:first-child>*{border-top:none}table.dataTable>tbody>tr:last-child>*{border-bottom:none}table.dataTable>tbody>tr.selected>*{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.9);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.9);color:rgb(255, 255, 255);color:rgb(var(--dt-row-selected-text))}table.dataTable>tbody>tr.selected a{color:rgb(9, 10, 11);color:rgb(var(--dt-row-selected-link))}table.dataTable>tbody>tr>th,table.dataTable>tbody>tr>td{padding:8px 10px}table.dataTable.row-border>tbody>tr>*,table.dataTable.display>tbody>tr>*{border-top:1px solid rgba(0, 0, 0, 0.15)}table.dataTable.row-border>tbody>tr:first-child>*,table.dataTable.display>tbody>tr:first-child>*{border-top:none}table.dataTable.row-border>tbody>tr.selected+tr.selected>td,table.dataTable.display>tbody>tr.selected+tr.selected>td{border-top-color:rgba(13, 110, 253, 0.65);border-top-color:rgba(var(--dt-row-selected), 0.65)}table.dataTable.cell-border>tbody>tr>*{border-top:1px solid rgba(0, 0, 0, 0.15);border-right:1px solid rgba(0, 0, 0, 0.15)}table.dataTable.cell-border>tbody>tr>*:first-child{border-left:1px solid rgba(0, 0, 0, 0.15)}table.dataTable.cell-border>tbody>tr:first-child>*{border-top:1px solid rgba(0, 0, 0, 0.3)}table.dataTable.stripe>tbody>tr:nth-child(odd)>*,table.dataTable.display>tbody>tr:nth-child(odd)>*{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.023);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-stripe), var(--dt-row-stripe-alpha))}table.dataTable.stripe>tbody>tr:nth-child(odd).selected>*,table.dataTable.display>tbody>tr:nth-child(odd).selected>*{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.923);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), var(--dt-row-selected-stripe-alpha))}table.dataTable.hover>tbody>tr:hover>*,table.dataTable.display>tbody>tr:hover>*{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.035);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), var(--dt-row-hover-alpha))}table.dataTable.hover>tbody>tr.selected:hover>*,table.dataTable.display>tbody>tr.selected:hover>*{box-shadow:inset 0 0 0 9999px #0d6efd !important;box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), 1) !important}table.dataTable.order-column>tbody tr>.sorting_1,table.dataTable.order-column>tbody tr>.sorting_2,table.dataTable.order-column>tbody tr>.sorting_3,table.dataTable.display>tbody tr>.sorting_1,table.dataTable.display>tbody tr>.sorting_2,table.dataTable.display>tbody tr>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.019);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), var(--dt-column-ordering-alpha))}table.dataTable.order-column>tbody tr.selected>.sorting_1,table.dataTable.order-column>tbody tr.selected>.sorting_2,table.dataTable.order-column>tbody tr.selected>.sorting_3,table.dataTable.display>tbody tr.selected>.sorting_1,table.dataTable.display>tbody tr.selected>.sorting_2,table.dataTable.display>tbody tr.selected>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.919);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), var(--dt-row-selected-column-ordering-alpha))}table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_1,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.054);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha)))}table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_2,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.047);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.007))}table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_3,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.039);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.015))}table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_1,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.954);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha)))}table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_2,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.947);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.007))}table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_3,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.939);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.015))}table.dataTable.display tbody tr:hover>.sorting_1,table.dataTable.order-column.hover tbody tr:hover>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.082);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha)))}table.dataTable.display tbody tr:hover>.sorting_2,table.dataTable.order-column.hover tbody tr:hover>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.074);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.007))}table.dataTable.display tbody tr:hover>.sorting_3,table.dataTable.order-column.hover tbody tr:hover>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.062);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.015))}table.dataTable.display tbody tr:hover.selected>.sorting_1,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.982);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha)))}table.dataTable.display tbody tr:hover.selected>.sorting_2,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.974);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.007))}table.dataTable.display tbody tr:hover.selected>.sorting_3,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.962);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.015))}table.dataTable.compact thead th,table.dataTable.compact thead td,table.dataTable.compact tfoot th,table.dataTable.compact tfoot td,table.dataTable.compact tbody th,table.dataTable.compact tbody td{padding:4px}div.dt-container div.dt-layout-row{display:flex;justify-content:space-between;align-items:center;width:100%;margin:.75em 0}div.dt-container div.dt-layout-row div.dt-layout-cell{display:flex;justify-content:space-between;align-items:center}div.dt-container div.dt-layout-row div.dt-layout-cell.dt-layout-start{justify-content:flex-start;margin-right:auto}div.dt-container div.dt-layout-row div.dt-layout-cell.dt-layout-end{justify-content:flex-end;margin-left:auto}div.dt-container div.dt-layout-row div.dt-layout-cell:empty{display:none}@media screen and (max-width: 767px){div.dt-container div.dt-layout-row:not(.dt-layout-table){display:block}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell{display:block;text-align:center}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell>*{margin:.5em 0}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell.dt-layout-start{margin-right:0}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell.dt-layout-end{margin-left:0}}div.dt-container div.dt-layout-start>*:not(:last-child){margin-right:1em}div.dt-container div.dt-layout-end>*:not(:first-child){margin-left:1em}div.dt-container div.dt-layout-full{width:100%}div.dt-container div.dt-layout-full>*:only-child{margin-left:auto;margin-right:auto}div.dt-container div.dt-layout-table>div{display:block !important}@media screen and (max-width: 767px){div.dt-container div.dt-layout-start>*:not(:last-child){margin-right:0}div.dt-container div.dt-layout-end>*:not(:first-child){margin-left:0}}div.dt-container{position:relative;clear:both}div.dt-container .dt-search input{border:1px solid #aaa;border-radius:3px;padding:5px;background-color:transparent;color:inherit;margin-left:3px}div.dt-container .dt-input{border:1px solid #aaa;border-radius:3px;padding:5px;background-color:transparent;color:inherit}div.dt-container select.dt-input{padding:4px}div.dt-container .dt-paging .dt-paging-button{box-sizing:border-box;display:inline-block;min-width:1.5em;padding:.5em 1em;margin-left:2px;text-align:center;text-decoration:none !important;cursor:pointer;color:inherit !important;border:1px solid transparent;border-radius:2px;background:transparent}div.dt-container .dt-paging .dt-paging-button.current,div.dt-container .dt-paging .dt-paging-button.current:hover{color:inherit !important;border:1px solid rgba(0, 0, 0, 0.3);background-color:rgba(0, 0, 0, 0.05);background:-webkit-gradient(linear, left top, left bottom, color-stop(0%, rgba(230, 230, 230, 0.05)), color-stop(100%, rgba(0, 0, 0, 0.05)));background:-webkit-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:-moz-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:-ms-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:-o-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:linear-gradient(to bottom, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%)}div.dt-container .dt-paging .dt-paging-button.disabled,div.dt-container .dt-paging .dt-paging-button.disabled:hover,div.dt-container .dt-paging .dt-paging-button.disabled:active{cursor:default;color:rgba(0, 0, 0, 0.5) !important;border:1px solid transparent;background:transparent;box-shadow:none}div.dt-container .dt-paging .dt-paging-button:hover{color:white !important;border:1px solid #111;background-color:#111;background:-webkit-gradient(linear, left top, left bottom, color-stop(0%, #585858), color-stop(100%, #111));background:-webkit-linear-gradient(top, #585858 0%, #111 100%);background:-moz-linear-gradient(top, #585858 0%, #111 100%);background:-ms-linear-gradient(top, #585858 0%, #111 100%);background:-o-linear-gradient(top, #585858 0%, #111 100%);background:linear-gradient(to bottom, #585858 0%, #111 100%)}div.dt-container .dt-paging .dt-paging-button:active{outline:none;background-color:#0c0c0c;background:-webkit-gradient(linear, left top, left bottom, color-stop(0%, #2b2b2b), color-stop(100%, #0c0c0c));background:-webkit-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:-moz-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:-ms-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:-o-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:linear-gradient(to bottom, #2b2b2b 0%, #0c0c0c 100%);box-shadow:inset 0 0 3px #111}div.dt-container .dt-paging .ellipsis{padding:0 1em}div.dt-container .dt-length,div.dt-container .dt-search,div.dt-container .dt-info,div.dt-container .dt-processing,div.dt-container .dt-paging{color:inherit}div.dt-container .dataTables_scroll{clear:both}div.dt-container .dataTables_scroll div.dt-scroll-body{-webkit-overflow-scrolling:touch}div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>th,div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>td,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>th,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>td{vertical-align:middle}div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>th>div.dataTables_sizing,div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>td>div.dataTables_sizing,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>th>div.dataTables_sizing,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>td>div.dataTables_sizing{height:0;overflow:hidden;margin:0 !important;padding:0 !important}div.dt-container.dt-empty-footer tbody>tr:last-child>*{border-bottom:1px solid rgba(0, 0, 0, 0.3)}div.dt-container.dt-empty-footer .dt-scroll-body{border-bottom:1px solid rgba(0, 0, 0, 0.3)}div.dt-container.dt-empty-footer .dt-scroll-body tbody>tr:last-child>*{border-bottom:none}html.dark{--dt-row-hover: 255, 255, 255;--dt-row-stripe: 255, 255, 255;--dt-column-ordering: 255, 255, 255}html.dark table.dataTable>thead>tr>th,html.dark table.dataTable>thead>tr>td{border-bottom:1px solid rgb(89, 91, 94)}html.dark table.dataTable>thead>tr>th:active,html.dark table.dataTable>thead>tr>td:active{outline:none}html.dark table.dataTable>tfoot>tr>th,html.dark table.dataTable>tfoot>tr>td{border-top:1px solid rgb(89, 91, 94)}html.dark table.dataTable.row-border>tbody>tr>*,html.dark table.dataTable.display>tbody>tr>*{border-top:1px solid rgb(64, 67, 70)}html.dark table.dataTable.row-border>tbody>tr:first-child>*,html.dark table.dataTable.display>tbody>tr:first-child>*{border-top:none}html.dark table.dataTable.row-border>tbody>tr.selected+tr.selected>td,html.dark table.dataTable.display>tbody>tr.selected+tr.selected>td{border-top-color:rgba(13, 110, 253, 0.65);border-top-color:rgba(var(--dt-row-selected), 0.65)}html.dark table.dataTable.cell-border>tbody>tr>th,html.dark table.dataTable.cell-border>tbody>tr>td{border-top:1px solid rgb(64, 67, 70);border-right:1px solid rgb(64, 67, 70)}html.dark table.dataTable.cell-border>tbody>tr>th:first-child,html.dark table.dataTable.cell-border>tbody>tr>td:first-child{border-left:1px solid rgb(64, 67, 70)}html.dark .dt-container.dt-empty-footer table.dataTable{border-bottom:1px solid rgb(89, 91, 94)}html.dark .dt-container .dt-search input,html.dark .dt-container .dt-length select{border:1px solid rgba(255, 255, 255, 0.2);background-color:var(--dt-html-background)}html.dark .dt-container .dt-paging .dt-paging-button.current,html.dark .dt-container .dt-paging .dt-paging-button.current:hover{border:1px solid rgb(89, 91, 94);background:rgba(255, 255, 255, 0.15)}html.dark .dt-container .dt-paging .dt-paging-button.disabled,html.dark .dt-container .dt-paging .dt-paging-button.disabled:hover,html.dark .dt-container .dt-paging .dt-paging-button.disabled:active{color:#666 !important}html.dark .dt-container .dt-paging .dt-paging-button:hover{border:1px solid rgb(53, 53, 53);background:rgb(53, 53, 53)}html.dark .dt-container .dt-paging .dt-paging-button:active{background:#3a3a3a}*[dir=rtl] table.dataTable thead th,*[dir=rtl] table.dataTable thead td,*[dir=rtl] table.dataTable tfoot th,*[dir=rtl] table.dataTable tfoot td{text-align:right}*[dir=rtl] table.dataTable th.dt-type-numeric,*[dir=rtl] table.dataTable th.dt-type-date,*[dir=rtl] table.dataTable td.dt-type-numeric,*[dir=rtl] table.dataTable td.dt-type-date{text-align:left}*[dir=rtl] div.dt-container div.dt-layout-cell.dt-start{text-align:right}*[dir=rtl] div.dt-container div.dt-layout-cell.dt-end{text-align:left}*[dir=rtl] div.dt-container div.dt-search input{margin:0 3px 0 0}
`, "",{"version":3,"sources":["webpack://./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css"],"names":[],"mappings":"AAAA,MAAM,+BAA+B,CAAC,qCAAqC,CAAC,iCAAiC,CAAC,wBAAwB,CAAC,uBAAuB,CAAC,6BAA6B,CAAC,2BAA2B,CAAC,WAAW,qCAAqC,CAAC,8BAA8B,iBAAiB,CAAC,cAAc,CAAC,qCAAqC,oBAAoB,CAAC,qBAAqB,CAAC,UAAU,CAAC,gCAAgC,CAAC,yCAAyC,CAAC,mCAAmC,CAAC,kCAAkC,CAAC,oDAAoD,wCAAwC,CAAC,iCAAiC,CAAC,mCAAmC,CAAC,kCAAkC,CAAC,4BAA4B,YAAY,CAAC,0KAA0K,0CAA0C,CAAC,uNAAuN,yCAAyC,CAAC,6BAA6B,CAAC,cAAc,UAAU,CAAC,wDAAwD,QAAQ,CAAC,4HAA4H,mBAAmB,CAAC,0BAA0B,CAAC,6BAA6B,CAAC,+BAA+B,CAAC,kCAAkC,CAAC,gNAAgN,mBAAmB,CAAC,0BAA0B,CAAC,sEAAsE,YAAY,CAAC,kSAAkS,iBAAiB,CAAC,aAAa,CAAC,UAAU,CAAC,WAAW,CAAC,cAAc,CAAC,kSAAkS,iBAAiB,CAAC,aAAa,CAAC,OAAO,CAAC,WAAW,CAAC,cAAc,CAAC,wWAAwW,iBAAiB,CAAC,kBAAkB,CAAC,ghBAAghB,iBAAiB,CAAC,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,woCAAwoC,MAAM,CAAC,YAAY,CAAC,eAAe,CAAC,cAAc,CAAC,sLAAsL,cAAc,CAAC,8MAA8M,qCAAqC,CAAC,mBAAmB,CAAC,gSAAgS,UAAU,CAAC,oTAAoT,YAAY,CAAC,sEAAsE,YAAY,CAAC,8FAA8F,eAAe,CAAC,gjBAAgjB,2CAA2C,CAAC,kBAAkB,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,WAAW,CAAC,UAAU,CAAC,iCAAiC,iBAAiB,CAAC,UAAU,CAAC,WAAW,CAAC,eAAe,CAAC,qCAAqC,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,iBAAiB,CAAC,4BAA4B,CAAC,sCAAsC,CAAC,kDAAkD,CAAC,kDAAkD,QAAQ,CAAC,0CAA0C,CAAC,kDAAkD,QAAQ,CAAC,0CAA0C,CAAC,kDAAkD,SAAS,CAAC,0CAA0C,CAAC,kDAAkD,SAAS,CAAC,0CAA0C,CAAC,+BAA+B,GAAG,kBAAkB,CAAC,KAAK,kBAAkB,CAAC,CAAC,+BAA+B,GAAG,kBAAkB,CAAC,KAAK,kBAAkB,CAAC,CAAC,+BAA+B,GAAG,yBAAyB,CAAC,KAAK,4BAA4B,CAAC,CAAC,oDAAoD,kBAAkB,CAAC,sCAAsC,qBAAqB,CAAC,sIAAsI,gBAAgB,CAAC,sDAAsD,eAAe,CAAC,0DAA0D,iBAAiB,CAAC,wDAAwD,gBAAgB,CAAC,4DAA4D,kBAAkB,CAAC,0DAA0D,kBAAkB,CAAC,wDAAwD,iBAAiB,CAAC,kBAAkB,CAAC,oGAAoG,eAAe,CAAC,wJAAwJ,eAAe,CAAC,gKAAgK,iBAAiB,CAAC,4JAA4J,gBAAgB,CAAC,oKAAoK,kBAAkB,CAAC,gKAAgK,kBAAkB,CAAC,4EAA4E,eAAe,CAAC,gFAAgF,iBAAiB,CAAC,8EAA8E,gBAAgB,CAAC,kFAAkF,kBAAkB,CAAC,gFAAgF,kBAAkB,CAAC,MAAM,2BAA2B,CAAC,4BAA4B,CAAC,iCAAiC,CAAC,qCAAqC,CAAC,8CAA8C,CAAC,gBAAgB,UAAU,CAAC,aAAa,CAAC,gBAAgB,CAAC,kDAAkD,gBAAgB,CAAC,wDAAwD,YAAY,CAAC,0CAA0C,CAAC,sEAAsE,YAAY,CAAC,wDAAwD,uCAAuC,CAAC,0BAA0B,CAAC,yBAAyB,4BAA4B,CAAC,uCAAuC,eAAe,CAAC,sCAAsC,kBAAkB,CAAC,oCAAoC,qDAAqD,CAAC,+DAA+D,CAAC,wBAAwB,CAAC,sCAAsC,CAAC,oCAAoC,oBAAoB,CAAC,sCAAsC,CAAC,wDAAwD,gBAAgB,CAAC,yEAAyE,wCAAwC,CAAC,iGAAiG,eAAe,CAAC,qHAAqH,yCAAyC,CAAC,mDAAmD,CAAC,uCAAuC,wCAAwC,CAAC,0CAA0C,CAAC,mDAAmD,yCAAyC,CAAC,mDAAmD,uCAAuC,CAAC,mGAAmG,kDAAkD,CAAC,oFAAoF,CAAC,qHAAqH,uDAAuD,CAAC,+FAA+F,CAAC,gFAAgF,kDAAkD,CAAC,kFAAkF,CAAC,kGAAkG,gDAAgD,CAAC,wEAAwE,CAAC,uRAAuR,kDAAkD,CAAC,8FAA8F,CAAC,6UAA6U,uDAAuD,CAAC,wGAAwG,CAAC,kIAAkI,kDAAkD,CAAC,iIAAiI,CAAC,kIAAkI,kDAAkD,CAAC,yIAAyI,CAAC,kIAAkI,kDAAkD,CAAC,yIAAyI,CAAC,oJAAoJ,uDAAuD,CAAC,uIAAuI,CAAC,oJAAoJ,uDAAuD,CAAC,+IAA+I,CAAC,oJAAoJ,uDAAuD,CAAC,+IAA+I,CAAC,+GAA+G,kDAAkD,CAAC,uJAAuJ,CAAC,+GAA+G,kDAAkD,CAAC,+JAA+J,CAAC,+GAA+G,kDAAkD,CAAC,+JAA+J,CAAC,iIAAiI,uDAAuD,CAAC,uIAAuI,CAAC,iIAAiI,uDAAuD,CAAC,2KAA2K,CAAC,iIAAiI,uDAAuD,CAAC,2KAA2K,CAAC,sMAAsM,WAAW,CAAC,mCAAmC,YAAY,CAAC,6BAA6B,CAAC,kBAAkB,CAAC,UAAU,CAAC,cAAc,CAAC,sDAAsD,YAAY,CAAC,6BAA6B,CAAC,kBAAkB,CAAC,sEAAsE,0BAA0B,CAAC,iBAAiB,CAAC,oEAAoE,wBAAwB,CAAC,gBAAgB,CAAC,4DAA4D,YAAY,CAAC,qCAAqC,yDAAyD,aAAa,CAAC,4EAA4E,aAAa,CAAC,iBAAiB,CAAC,8EAA8E,aAAa,CAAC,4FAA4F,cAAc,CAAC,0FAA0F,aAAa,CAAC,CAAC,wDAAwD,gBAAgB,CAAC,uDAAuD,eAAe,CAAC,oCAAoC,UAAU,CAAC,iDAAiD,gBAAgB,CAAC,iBAAiB,CAAC,yCAAyC,wBAAwB,CAAC,qCAAqC,wDAAwD,cAAc,CAAC,uDAAuD,aAAa,CAAC,CAAC,iBAAiB,iBAAiB,CAAC,UAAU,CAAC,kCAAkC,qBAAqB,CAAC,iBAAiB,CAAC,WAAW,CAAC,4BAA4B,CAAC,aAAa,CAAC,eAAe,CAAC,2BAA2B,qBAAqB,CAAC,iBAAiB,CAAC,WAAW,CAAC,4BAA4B,CAAC,aAAa,CAAC,iCAAiC,WAAW,CAAC,8CAA8C,qBAAqB,CAAC,oBAAoB,CAAC,eAAe,CAAC,gBAAgB,CAAC,eAAe,CAAC,iBAAiB,CAAC,+BAA+B,CAAC,cAAc,CAAC,wBAAwB,CAAC,4BAA4B,CAAC,iBAAiB,CAAC,sBAAsB,CAAC,kHAAkH,wBAAwB,CAAC,mCAAmC,CAAC,oCAAoC,CAAC,4IAA4I,CAAC,+FAA+F,CAAC,4FAA4F,CAAC,2FAA2F,CAAC,0FAA0F,CAAC,6FAA6F,CAAC,kLAAkL,cAAc,CAAC,mCAAmC,CAAC,4BAA4B,CAAC,sBAAsB,CAAC,eAAe,CAAC,oDAAoD,sBAAsB,CAAC,qBAAqB,CAAC,qBAAqB,CAAC,2GAA2G,CAAC,8DAA8D,CAAC,2DAA2D,CAAC,0DAA0D,CAAC,yDAAyD,CAAC,4DAA4D,CAAC,qDAAqD,YAAY,CAAC,wBAAwB,CAAC,8GAA8G,CAAC,iEAAiE,CAAC,8DAA8D,CAAC,6DAA6D,CAAC,4DAA4D,CAAC,+DAA+D,CAAC,6BAA6B,CAAC,sCAAsC,aAAa,CAAC,8IAA8I,aAAa,CAAC,oCAAoC,UAAU,CAAC,uDAAuD,gCAAgC,CAAC,oSAAoS,qBAAqB,CAAC,4XAA4X,QAAQ,CAAC,eAAe,CAAC,mBAAmB,CAAC,oBAAoB,CAAC,uDAAuD,0CAA0C,CAAC,iDAAiD,0CAA0C,CAAC,uEAAuE,kBAAkB,CAAC,UAAU,6BAA6B,CAAC,8BAA8B,CAAC,mCAAmC,CAAC,4EAA4E,uCAAuC,CAAC,0FAA0F,YAAY,CAAC,4EAA4E,oCAAoC,CAAC,6FAA6F,oCAAoC,CAAC,qHAAqH,eAAe,CAAC,yIAAyI,yCAAyC,CAAC,mDAAmD,CAAC,oGAAoG,oCAAoC,CAAC,sCAAsC,CAAC,4HAA4H,qCAAqC,CAAC,wDAAwD,uCAAuC,CAAC,mFAAmF,yCAAyC,CAAC,0CAA0C,CAAC,gIAAgI,gCAAgC,CAAC,oCAAoC,CAAC,uMAAuM,qBAAqB,CAAC,2DAA2D,gCAAgC,CAAC,0BAA0B,CAAC,4DAA4D,kBAAkB,CAAC,gJAAgJ,gBAAgB,CAAC,kLAAkL,eAAe,CAAC,wDAAwD,gBAAgB,CAAC,sDAAsD,eAAe,CAAC,gDAAgD,gBAAgB","sourcesContent":[":root{--dt-row-selected: 13, 110, 253;--dt-row-selected-text: 255, 255, 255;--dt-row-selected-link: 9, 10, 11;--dt-row-stripe: 0, 0, 0;--dt-row-hover: 0, 0, 0;--dt-column-ordering: 0, 0, 0;--dt-html-background: white}:root.dark{--dt-html-background: rgb(33, 37, 41)}table.dataTable td.dt-control{text-align:center;cursor:pointer}table.dataTable td.dt-control:before{display:inline-block;box-sizing:border-box;content:\"\";border-top:5px solid transparent;border-left:10px solid rgba(0, 0, 0, 0.5);border-bottom:5px solid transparent;border-right:0px solid transparent}table.dataTable tr.dt-hasChild td.dt-control:before{border-top:10px solid rgba(0, 0, 0, 0.5);border-left:5px solid transparent;border-bottom:0px solid transparent;border-right:5px solid transparent}table.dataTable tfoot:empty{display:none}html.dark table.dataTable td.dt-control:before,:root[data-bs-theme=dark] table.dataTable td.dt-control:before,:root[data-theme=dark] table.dataTable td.dt-control:before{border-left-color:rgba(255, 255, 255, 0.5)}html.dark table.dataTable tr.dt-hasChild td.dt-control:before,:root[data-bs-theme=dark] table.dataTable tr.dt-hasChild td.dt-control:before,:root[data-theme=dark] table.dataTable tr.dt-hasChild td.dt-control:before{border-top-color:rgba(255, 255, 255, 0.5);border-left-color:transparent}div.dt-scroll{width:100%}div.dt-scroll-body thead tr,div.dt-scroll-body tfoot tr{height:0}div.dt-scroll-body thead tr th,div.dt-scroll-body thead tr td,div.dt-scroll-body tfoot tr th,div.dt-scroll-body tfoot tr td{height:0 !important;padding-top:0px !important;padding-bottom:0px !important;border-top-width:0px !important;border-bottom-width:0px !important}div.dt-scroll-body thead tr th div.dt-scroll-sizing,div.dt-scroll-body thead tr td div.dt-scroll-sizing,div.dt-scroll-body tfoot tr th div.dt-scroll-sizing,div.dt-scroll-body tfoot tr td div.dt-scroll-sizing{height:0 !important;overflow:hidden !important}table.dataTable thead>tr>th:active,table.dataTable thead>tr>td:active{outline:none}table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before{position:absolute;display:block;bottom:50%;content:\"▲\";content:\"▲\"/\"\"}table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after{position:absolute;display:block;top:50%;content:\"▼\";content:\"▼\"/\"\"}table.dataTable thead>tr>th.dt-orderable-asc,table.dataTable thead>tr>th.dt-orderable-desc,table.dataTable thead>tr>th.dt-ordering-asc,table.dataTable thead>tr>th.dt-ordering-desc,table.dataTable thead>tr>td.dt-orderable-asc,table.dataTable thead>tr>td.dt-orderable-desc,table.dataTable thead>tr>td.dt-ordering-asc,table.dataTable thead>tr>td.dt-ordering-desc{position:relative;padding-right:30px}table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order,table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order{position:absolute;right:12px;top:0;bottom:0;width:12px}table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:after,table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:before,table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:after,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:after,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:before,table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after{left:0;opacity:.125;line-height:9px;font-size:.8em}table.dataTable thead>tr>th.dt-orderable-asc,table.dataTable thead>tr>th.dt-orderable-desc,table.dataTable thead>tr>td.dt-orderable-asc,table.dataTable thead>tr>td.dt-orderable-desc{cursor:pointer}table.dataTable thead>tr>th.dt-orderable-asc:hover,table.dataTable thead>tr>th.dt-orderable-desc:hover,table.dataTable thead>tr>td.dt-orderable-asc:hover,table.dataTable thead>tr>td.dt-orderable-desc:hover{outline:2px solid rgba(0, 0, 0, 0.05);outline-offset:-2px}table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before,table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after{opacity:.6}table.dataTable thead>tr>th.sorting_desc_disabled span.dt-column-order:after,table.dataTable thead>tr>th.sorting_asc_disabled span.dt-column-order:before,table.dataTable thead>tr>td.sorting_desc_disabled span.dt-column-order:after,table.dataTable thead>tr>td.sorting_asc_disabled span.dt-column-order:before{display:none}table.dataTable thead>tr>th:active,table.dataTable thead>tr>td:active{outline:none}div.dt-scroll-body>table.dataTable>thead>tr>th,div.dt-scroll-body>table.dataTable>thead>tr>td{overflow:hidden}:root.dark table.dataTable thead>tr>th.dt-orderable-asc:hover,:root.dark table.dataTable thead>tr>th.dt-orderable-desc:hover,:root.dark table.dataTable thead>tr>td.dt-orderable-asc:hover,:root.dark table.dataTable thead>tr>td.dt-orderable-desc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>th.dt-orderable-asc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>th.dt-orderable-desc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>td.dt-orderable-asc:hover,:root[data-bs-theme=dark] table.dataTable thead>tr>td.dt-orderable-desc:hover{outline:2px solid rgba(255, 255, 255, 0.05)}div.dt-processing{position:absolute;top:50%;left:50%;width:200px;margin-left:-100px;margin-top:-22px;text-align:center;padding:2px;z-index:10}div.dt-processing>div:last-child{position:relative;width:80px;height:15px;margin:1em auto}div.dt-processing>div:last-child>div{position:absolute;top:0;width:13px;height:13px;border-radius:50%;background:rgb(13, 110, 253);background:rgb(var(--dt-row-selected));animation-timing-function:cubic-bezier(0, 1, 1, 0)}div.dt-processing>div:last-child>div:nth-child(1){left:8px;animation:datatables-loader-1 .6s infinite}div.dt-processing>div:last-child>div:nth-child(2){left:8px;animation:datatables-loader-2 .6s infinite}div.dt-processing>div:last-child>div:nth-child(3){left:32px;animation:datatables-loader-2 .6s infinite}div.dt-processing>div:last-child>div:nth-child(4){left:56px;animation:datatables-loader-3 .6s infinite}@keyframes datatables-loader-1{0%{transform:scale(0)}100%{transform:scale(1)}}@keyframes datatables-loader-3{0%{transform:scale(1)}100%{transform:scale(0)}}@keyframes datatables-loader-2{0%{transform:translate(0, 0)}100%{transform:translate(24px, 0)}}table.dataTable.nowrap th,table.dataTable.nowrap td{white-space:nowrap}table.dataTable th,table.dataTable td{box-sizing:border-box}table.dataTable th.dt-type-numeric,table.dataTable th.dt-type-date,table.dataTable td.dt-type-numeric,table.dataTable td.dt-type-date{text-align:right}table.dataTable th.dt-left,table.dataTable td.dt-left{text-align:left}table.dataTable th.dt-center,table.dataTable td.dt-center{text-align:center}table.dataTable th.dt-right,table.dataTable td.dt-right{text-align:right}table.dataTable th.dt-justify,table.dataTable td.dt-justify{text-align:justify}table.dataTable th.dt-nowrap,table.dataTable td.dt-nowrap{white-space:nowrap}table.dataTable th.dt-empty,table.dataTable td.dt-empty{text-align:center;vertical-align:top}table.dataTable thead th,table.dataTable thead td,table.dataTable tfoot th,table.dataTable tfoot td{text-align:left}table.dataTable thead th.dt-head-left,table.dataTable thead td.dt-head-left,table.dataTable tfoot th.dt-head-left,table.dataTable tfoot td.dt-head-left{text-align:left}table.dataTable thead th.dt-head-center,table.dataTable thead td.dt-head-center,table.dataTable tfoot th.dt-head-center,table.dataTable tfoot td.dt-head-center{text-align:center}table.dataTable thead th.dt-head-right,table.dataTable thead td.dt-head-right,table.dataTable tfoot th.dt-head-right,table.dataTable tfoot td.dt-head-right{text-align:right}table.dataTable thead th.dt-head-justify,table.dataTable thead td.dt-head-justify,table.dataTable tfoot th.dt-head-justify,table.dataTable tfoot td.dt-head-justify{text-align:justify}table.dataTable thead th.dt-head-nowrap,table.dataTable thead td.dt-head-nowrap,table.dataTable tfoot th.dt-head-nowrap,table.dataTable tfoot td.dt-head-nowrap{white-space:nowrap}table.dataTable tbody th.dt-body-left,table.dataTable tbody td.dt-body-left{text-align:left}table.dataTable tbody th.dt-body-center,table.dataTable tbody td.dt-body-center{text-align:center}table.dataTable tbody th.dt-body-right,table.dataTable tbody td.dt-body-right{text-align:right}table.dataTable tbody th.dt-body-justify,table.dataTable tbody td.dt-body-justify{text-align:justify}table.dataTable tbody th.dt-body-nowrap,table.dataTable tbody td.dt-body-nowrap{white-space:nowrap}:root{--dt-row-hover-alpha: 0.035;--dt-row-stripe-alpha: 0.023;--dt-column-ordering-alpha: 0.019;--dt-row-selected-stripe-alpha: 0.923;--dt-row-selected-column-ordering-alpha: 0.919}table.dataTable{width:100%;margin:0 auto;border-spacing:0}table.dataTable thead th,table.dataTable tfoot th{font-weight:bold}table.dataTable>thead>tr>th,table.dataTable>thead>tr>td{padding:10px;border-bottom:1px solid rgba(0, 0, 0, 0.3)}table.dataTable>thead>tr>th:active,table.dataTable>thead>tr>td:active{outline:none}table.dataTable>tfoot>tr>th,table.dataTable>tfoot>tr>td{border-top:1px solid rgba(0, 0, 0, 0.3);padding:10px 10px 6px 10px}table.dataTable>tbody>tr{background-color:transparent}table.dataTable>tbody>tr:first-child>*{border-top:none}table.dataTable>tbody>tr:last-child>*{border-bottom:none}table.dataTable>tbody>tr.selected>*{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.9);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.9);color:rgb(255, 255, 255);color:rgb(var(--dt-row-selected-text))}table.dataTable>tbody>tr.selected a{color:rgb(9, 10, 11);color:rgb(var(--dt-row-selected-link))}table.dataTable>tbody>tr>th,table.dataTable>tbody>tr>td{padding:8px 10px}table.dataTable.row-border>tbody>tr>*,table.dataTable.display>tbody>tr>*{border-top:1px solid rgba(0, 0, 0, 0.15)}table.dataTable.row-border>tbody>tr:first-child>*,table.dataTable.display>tbody>tr:first-child>*{border-top:none}table.dataTable.row-border>tbody>tr.selected+tr.selected>td,table.dataTable.display>tbody>tr.selected+tr.selected>td{border-top-color:rgba(13, 110, 253, 0.65);border-top-color:rgba(var(--dt-row-selected), 0.65)}table.dataTable.cell-border>tbody>tr>*{border-top:1px solid rgba(0, 0, 0, 0.15);border-right:1px solid rgba(0, 0, 0, 0.15)}table.dataTable.cell-border>tbody>tr>*:first-child{border-left:1px solid rgba(0, 0, 0, 0.15)}table.dataTable.cell-border>tbody>tr:first-child>*{border-top:1px solid rgba(0, 0, 0, 0.3)}table.dataTable.stripe>tbody>tr:nth-child(odd)>*,table.dataTable.display>tbody>tr:nth-child(odd)>*{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.023);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-stripe), var(--dt-row-stripe-alpha))}table.dataTable.stripe>tbody>tr:nth-child(odd).selected>*,table.dataTable.display>tbody>tr:nth-child(odd).selected>*{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.923);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), var(--dt-row-selected-stripe-alpha))}table.dataTable.hover>tbody>tr:hover>*,table.dataTable.display>tbody>tr:hover>*{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.035);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), var(--dt-row-hover-alpha))}table.dataTable.hover>tbody>tr.selected:hover>*,table.dataTable.display>tbody>tr.selected:hover>*{box-shadow:inset 0 0 0 9999px #0d6efd !important;box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), 1) !important}table.dataTable.order-column>tbody tr>.sorting_1,table.dataTable.order-column>tbody tr>.sorting_2,table.dataTable.order-column>tbody tr>.sorting_3,table.dataTable.display>tbody tr>.sorting_1,table.dataTable.display>tbody tr>.sorting_2,table.dataTable.display>tbody tr>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.019);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), var(--dt-column-ordering-alpha))}table.dataTable.order-column>tbody tr.selected>.sorting_1,table.dataTable.order-column>tbody tr.selected>.sorting_2,table.dataTable.order-column>tbody tr.selected>.sorting_3,table.dataTable.display>tbody tr.selected>.sorting_1,table.dataTable.display>tbody tr.selected>.sorting_2,table.dataTable.display>tbody tr.selected>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.919);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), var(--dt-row-selected-column-ordering-alpha))}table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_1,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.054);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha)))}table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_2,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.047);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.007))}table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_3,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.039);box-shadow:inset 0 0 0 9999px rgba(var(--dt-column-ordering), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.015))}table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_1,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.954);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha)))}table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_2,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.947);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.007))}table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_3,table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.939);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) - 0.015))}table.dataTable.display tbody tr:hover>.sorting_1,table.dataTable.order-column.hover tbody tr:hover>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.082);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha)))}table.dataTable.display tbody tr:hover>.sorting_2,table.dataTable.order-column.hover tbody tr:hover>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.074);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.007))}table.dataTable.display tbody tr:hover>.sorting_3,table.dataTable.order-column.hover tbody tr:hover>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(0, 0, 0, 0.062);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-hover), calc(var(--dt-row-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.015))}table.dataTable.display tbody tr:hover.selected>.sorting_1,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_1{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.982);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha)))}table.dataTable.display tbody tr:hover.selected>.sorting_2,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_2{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.974);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.007))}table.dataTable.display tbody tr:hover.selected>.sorting_3,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_3{box-shadow:inset 0 0 0 9999px rgba(13, 110, 253, 0.962);box-shadow:inset 0 0 0 9999px rgba(var(--dt-row-selected), calc(var(--dt-row-selected-stripe-alpha) + var(--dt-column-ordering-alpha) + var(--dt-row-hover-alpha) - 0.015))}table.dataTable.compact thead th,table.dataTable.compact thead td,table.dataTable.compact tfoot th,table.dataTable.compact tfoot td,table.dataTable.compact tbody th,table.dataTable.compact tbody td{padding:4px}div.dt-container div.dt-layout-row{display:flex;justify-content:space-between;align-items:center;width:100%;margin:.75em 0}div.dt-container div.dt-layout-row div.dt-layout-cell{display:flex;justify-content:space-between;align-items:center}div.dt-container div.dt-layout-row div.dt-layout-cell.dt-layout-start{justify-content:flex-start;margin-right:auto}div.dt-container div.dt-layout-row div.dt-layout-cell.dt-layout-end{justify-content:flex-end;margin-left:auto}div.dt-container div.dt-layout-row div.dt-layout-cell:empty{display:none}@media screen and (max-width: 767px){div.dt-container div.dt-layout-row:not(.dt-layout-table){display:block}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell{display:block;text-align:center}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell>*{margin:.5em 0}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell.dt-layout-start{margin-right:0}div.dt-container div.dt-layout-row:not(.dt-layout-table) div.dt-layout-cell.dt-layout-end{margin-left:0}}div.dt-container div.dt-layout-start>*:not(:last-child){margin-right:1em}div.dt-container div.dt-layout-end>*:not(:first-child){margin-left:1em}div.dt-container div.dt-layout-full{width:100%}div.dt-container div.dt-layout-full>*:only-child{margin-left:auto;margin-right:auto}div.dt-container div.dt-layout-table>div{display:block !important}@media screen and (max-width: 767px){div.dt-container div.dt-layout-start>*:not(:last-child){margin-right:0}div.dt-container div.dt-layout-end>*:not(:first-child){margin-left:0}}div.dt-container{position:relative;clear:both}div.dt-container .dt-search input{border:1px solid #aaa;border-radius:3px;padding:5px;background-color:transparent;color:inherit;margin-left:3px}div.dt-container .dt-input{border:1px solid #aaa;border-radius:3px;padding:5px;background-color:transparent;color:inherit}div.dt-container select.dt-input{padding:4px}div.dt-container .dt-paging .dt-paging-button{box-sizing:border-box;display:inline-block;min-width:1.5em;padding:.5em 1em;margin-left:2px;text-align:center;text-decoration:none !important;cursor:pointer;color:inherit !important;border:1px solid transparent;border-radius:2px;background:transparent}div.dt-container .dt-paging .dt-paging-button.current,div.dt-container .dt-paging .dt-paging-button.current:hover{color:inherit !important;border:1px solid rgba(0, 0, 0, 0.3);background-color:rgba(0, 0, 0, 0.05);background:-webkit-gradient(linear, left top, left bottom, color-stop(0%, rgba(230, 230, 230, 0.05)), color-stop(100%, rgba(0, 0, 0, 0.05)));background:-webkit-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:-moz-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:-ms-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:-o-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);background:linear-gradient(to bottom, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%)}div.dt-container .dt-paging .dt-paging-button.disabled,div.dt-container .dt-paging .dt-paging-button.disabled:hover,div.dt-container .dt-paging .dt-paging-button.disabled:active{cursor:default;color:rgba(0, 0, 0, 0.5) !important;border:1px solid transparent;background:transparent;box-shadow:none}div.dt-container .dt-paging .dt-paging-button:hover{color:white !important;border:1px solid #111;background-color:#111;background:-webkit-gradient(linear, left top, left bottom, color-stop(0%, #585858), color-stop(100%, #111));background:-webkit-linear-gradient(top, #585858 0%, #111 100%);background:-moz-linear-gradient(top, #585858 0%, #111 100%);background:-ms-linear-gradient(top, #585858 0%, #111 100%);background:-o-linear-gradient(top, #585858 0%, #111 100%);background:linear-gradient(to bottom, #585858 0%, #111 100%)}div.dt-container .dt-paging .dt-paging-button:active{outline:none;background-color:#0c0c0c;background:-webkit-gradient(linear, left top, left bottom, color-stop(0%, #2b2b2b), color-stop(100%, #0c0c0c));background:-webkit-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:-moz-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:-ms-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:-o-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);background:linear-gradient(to bottom, #2b2b2b 0%, #0c0c0c 100%);box-shadow:inset 0 0 3px #111}div.dt-container .dt-paging .ellipsis{padding:0 1em}div.dt-container .dt-length,div.dt-container .dt-search,div.dt-container .dt-info,div.dt-container .dt-processing,div.dt-container .dt-paging{color:inherit}div.dt-container .dataTables_scroll{clear:both}div.dt-container .dataTables_scroll div.dt-scroll-body{-webkit-overflow-scrolling:touch}div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>th,div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>td,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>th,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>td{vertical-align:middle}div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>th>div.dataTables_sizing,div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>td>div.dataTables_sizing,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>th>div.dataTables_sizing,div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>td>div.dataTables_sizing{height:0;overflow:hidden;margin:0 !important;padding:0 !important}div.dt-container.dt-empty-footer tbody>tr:last-child>*{border-bottom:1px solid rgba(0, 0, 0, 0.3)}div.dt-container.dt-empty-footer .dt-scroll-body{border-bottom:1px solid rgba(0, 0, 0, 0.3)}div.dt-container.dt-empty-footer .dt-scroll-body tbody>tr:last-child>*{border-bottom:none}html.dark{--dt-row-hover: 255, 255, 255;--dt-row-stripe: 255, 255, 255;--dt-column-ordering: 255, 255, 255}html.dark table.dataTable>thead>tr>th,html.dark table.dataTable>thead>tr>td{border-bottom:1px solid rgb(89, 91, 94)}html.dark table.dataTable>thead>tr>th:active,html.dark table.dataTable>thead>tr>td:active{outline:none}html.dark table.dataTable>tfoot>tr>th,html.dark table.dataTable>tfoot>tr>td{border-top:1px solid rgb(89, 91, 94)}html.dark table.dataTable.row-border>tbody>tr>*,html.dark table.dataTable.display>tbody>tr>*{border-top:1px solid rgb(64, 67, 70)}html.dark table.dataTable.row-border>tbody>tr:first-child>*,html.dark table.dataTable.display>tbody>tr:first-child>*{border-top:none}html.dark table.dataTable.row-border>tbody>tr.selected+tr.selected>td,html.dark table.dataTable.display>tbody>tr.selected+tr.selected>td{border-top-color:rgba(13, 110, 253, 0.65);border-top-color:rgba(var(--dt-row-selected), 0.65)}html.dark table.dataTable.cell-border>tbody>tr>th,html.dark table.dataTable.cell-border>tbody>tr>td{border-top:1px solid rgb(64, 67, 70);border-right:1px solid rgb(64, 67, 70)}html.dark table.dataTable.cell-border>tbody>tr>th:first-child,html.dark table.dataTable.cell-border>tbody>tr>td:first-child{border-left:1px solid rgb(64, 67, 70)}html.dark .dt-container.dt-empty-footer table.dataTable{border-bottom:1px solid rgb(89, 91, 94)}html.dark .dt-container .dt-search input,html.dark .dt-container .dt-length select{border:1px solid rgba(255, 255, 255, 0.2);background-color:var(--dt-html-background)}html.dark .dt-container .dt-paging .dt-paging-button.current,html.dark .dt-container .dt-paging .dt-paging-button.current:hover{border:1px solid rgb(89, 91, 94);background:rgba(255, 255, 255, 0.15)}html.dark .dt-container .dt-paging .dt-paging-button.disabled,html.dark .dt-container .dt-paging .dt-paging-button.disabled:hover,html.dark .dt-container .dt-paging .dt-paging-button.disabled:active{color:#666 !important}html.dark .dt-container .dt-paging .dt-paging-button:hover{border:1px solid rgb(53, 53, 53);background:rgb(53, 53, 53)}html.dark .dt-container .dt-paging .dt-paging-button:active{background:#3a3a3a}*[dir=rtl] table.dataTable thead th,*[dir=rtl] table.dataTable thead td,*[dir=rtl] table.dataTable tfoot th,*[dir=rtl] table.dataTable tfoot td{text-align:right}*[dir=rtl] table.dataTable th.dt-type-numeric,*[dir=rtl] table.dataTable th.dt-type-date,*[dir=rtl] table.dataTable td.dt-type-numeric,*[dir=rtl] table.dataTable td.dt-type-date{text-align:left}*[dir=rtl] div.dt-container div.dt-layout-cell.dt-start{text-align:right}*[dir=rtl] div.dt-container div.dt-layout-cell.dt-end{text-align:left}*[dir=rtl] div.dt-container div.dt-search input{margin:0 3px 0 0}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css ***!
  \*****************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `table.fixedHeader-floating,table.fixedHeader-locked{position:relative !important;background-color:var(--dt-html-background);background-color:var(--dt-html-background)}@media print{table.fixedHeader-floating{display:none}}
`, "",{"version":3,"sources":["webpack://./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css"],"names":[],"mappings":"AAAA,oDAAoD,4BAA4B,CAAC,0CAA0C,CAAC,0CAA0C,CAAC,aAAa,2BAA2B,YAAY,CAAC","sourcesContent":["table.fixedHeader-floating,table.fixedHeader-locked{position:relative !important;background-color:var(--dt-html-background);background-color:var(--dt-html-background)}@media print{table.fixedHeader-floating{display:none}}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/app.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/app.css ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `body {
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
  overflow: hidden;
  height: 100vh;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f0f0f0;
}

.menu-bar {
  display: flex;
  background-color: rgb(30, 30, 30);
  padding: 4px;
  color: white;
}

.menu-group {
  display: flex;
  margin-right: 15px;
  border-right: 1px solid rgba(255, 255, 255, 0.2);
  padding-right: 15px;
}

.menu-button {
  background: none;
  border: none;
  color: white;
  padding: 5px 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  font-size: 12px;
}

.menu-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.icon {
  margin-right: 5px;
  font-style: normal;
}

.main-layout {
  display: flex;
  flex: 1;
  overflow: hidden;
}

.sidebar {
  width: 250px;
  background-color: #f8f8f8;
  border-right: 1px solid #ddd;
  display: flex;
  flex-direction: column;
}

.tree-title {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: bold;
  padding: 8px;
  background-color: #e8e8e8;
  border-bottom: 1px solid #ddd;
}

.tree-view {
  flex: 1;
  overflow: auto;
  padding: 5px;
}

.tree-item {
  margin: 2px 0;
  cursor: pointer;
}

.tree-label {
  padding: 3px;
  display: flex;
  align-items: center;
  font-size: 16px; /* 文字サイズ */
}

/* ツリーラベル内のアイコンサイズ調整 */
.tree-label .material-symbols-outlined {
  font-size: 18px; /* アイコンサイズ */
  margin-right: 4px; /* アイコンとテキストの間隔調整 */
}

/* トグルアイコンの調整 (必要に応じて) */
.tree-label .toggle-icon {
  margin-right: 2px;
}

.tree-label:hover {
  background-color: #e0e0e0;
}

.tree-items {
  margin-left: 30px; /* インデントを 20px から 30px に変更 */
}

.main-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.query-tabs {
  display: flex;
  background-color: #e8e8e8;
  border-bottom: 1px solid #ddd;
}

.query-tab {
  padding: 8px 15px;
  background-color: #f0f0f0;
  border-right: 1px solid #ddd;
  cursor: pointer;
  position: relative;
  font-size: 13px;
  display: flex;
  align-items: center;
}

.query-tab.active {
  background-color: white;
}

.close-tab {
  margin-left: 8px;
  font-size: 14px;
  opacity: 0.6;
}

.close-tab:hover {
  opacity: 1;
}

/* タブの背景色: アクティブと非アクティブ */
.query-tab {
  background-color: #f0f0f0;
}
.query-tab.active {
  background-color: white;
}

.query-editor {
  height: 200px;
  border-bottom: 1px solid #ddd;
}

.query-editor textarea {
  width: 100%;
  height: 100%;
  resize: none;
  border: none;
  padding: 10px;
  font-family: 'Courier New', monospace;
  font-size: 14px;
}

.results-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.results-tabs {
  display: flex;
  border-bottom: 1px solid #ddd;
  background-color: #f0f0f0;
}

.result-tab {
  padding: 5px 15px;
  cursor: pointer;
}

.result-tab.active {
  border-bottom: 2px solid #0078d7;
}

.results-grid {
  flex: 1;
  padding: 0; /* パディングを 0 に変更 */
  overflow-y: auto; /* 縦スクロールをコンテナで管理 */
  overflow-x: auto; /* 横スクロール */
  background-color: white;
  display: flex; /* DataTablesコンテナがflexアイテムとして高さを占めるように */
  flex-direction: column; /* DataTablesコンテナを縦に配置 */
}

/* DataTablesのコンテナの高さを100%にする */
.dataTables_wrapper {
  padding-top: 0; /* 上の余白を削除 */
  flex: 1; /* 親要素(.results-grid)の残りの高さを占める */
  display: flex;
  flex-direction: column;
}

/* DataTablesのスクロール可能な本体 */
.dataTables_scrollBody {
  flex: 1; /* 利用可能な高さを占める */
}

.status-bar {
  background-color: #f0f0f0;
  border-top: 1px solid #ddd;
  padding: 3px 10px;
  font-size: 12px;
  color: #555;
  height: 20px;
}

.status-error {
  color: #d83b01;
}

.status-success {
  color: #107c10;
}

/* DataTables スタイル上書き */
.dataTables_wrapper {
  padding-top: 0; /* 上の余白を削除 (重複するが念のため) */
}

table.dataTable {
  border-collapse: collapse;
  width: 100%;
}

table.dataTable thead th {
  background-color: #e8e8e8;
  border: 1px solid #ddd;
  padding: 8px;
  text-align: left;
  font-size: 13px; /* フォントサイズ変更 */
}

table.dataTable tbody td {
  border: 1px solid #ddd;
  padding: 6px;
  font-size: 13px; /* フォントサイズ変更 */
}

.dataTables_info, .dataTables_paginate {
  font-size: 16px; /* フォントサイズ変更 */
  padding: 10px 0;
}

.splitter {
  flex: none;
  width: 5px;
  cursor: col-resize;
  background-color: transparent;
}
.splitter:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

/* 水平スプリッタ */
.row-splitter {
  height: 5px;
  cursor: row-resize;
  background-color: transparent;
}
.row-splitter:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

/* 更新ボタンのアイコン色 */
#refresh-db-button .material-symbols-outlined {
  color: black;
}`, "",{"version":3,"sources":["webpack://./src/css/app.css"],"names":[],"mappings":"AAAA;EACE,SAAS;EACT,UAAU;EACV,8BAA8B;EAC9B,gBAAgB;EAChB,aAAa;AACf;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,aAAa;EACb,yBAAyB;AAC3B;;AAEA;EACE,aAAa;EACb,iCAAiC;EACjC,YAAY;EACZ,YAAY;AACd;;AAEA;EACE,aAAa;EACb,kBAAkB;EAClB,gDAAgD;EAChD,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;EAChB,YAAY;EACZ,YAAY;EACZ,iBAAiB;EACjB,eAAe;EACf,aAAa;EACb,mBAAmB;EACnB,eAAe;AACjB;;AAEA;EACE,0CAA0C;AAC5C;;AAEA;EACE,iBAAiB;EACjB,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,OAAO;EACP,gBAAgB;AAClB;;AAEA;EACE,YAAY;EACZ,yBAAyB;EACzB,4BAA4B;EAC5B,aAAa;EACb,sBAAsB;AACxB;;AAEA;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;EACnB,iBAAiB;EACjB,YAAY;EACZ,yBAAyB;EACzB,6BAA6B;AAC/B;;AAEA;EACE,OAAO;EACP,cAAc;EACd,YAAY;AACd;;AAEA;EACE,aAAa;EACb,eAAe;AACjB;;AAEA;EACE,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,eAAe,EAAE,UAAU;AAC7B;;AAEA,sBAAsB;AACtB;EACE,eAAe,EAAE,YAAY;EAC7B,iBAAiB,EAAE,mBAAmB;AACxC;;AAEA,wBAAwB;AACxB;EACE,iBAAiB;AACnB;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,iBAAiB,EAAE,4BAA4B;AACjD;;AAEA;EACE,OAAO;EACP,aAAa;EACb,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,yBAAyB;EACzB,6BAA6B;AAC/B;;AAEA;EACE,iBAAiB;EACjB,yBAAyB;EACzB,4BAA4B;EAC5B,eAAe;EACf,kBAAkB;EAClB,eAAe;EACf,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;AACzB;;AAEA;EACE,gBAAgB;EAChB,eAAe;EACf,YAAY;AACd;;AAEA;EACE,UAAU;AACZ;;AAEA,yBAAyB;AACzB;EACE,yBAAyB;AAC3B;AACA;EACE,uBAAuB;AACzB;;AAEA;EACE,aAAa;EACb,6BAA6B;AAC/B;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,aAAa;EACb,qCAAqC;EACrC,eAAe;AACjB;;AAEA;EACE,OAAO;EACP,aAAa;EACb,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,6BAA6B;EAC7B,yBAAyB;AAC3B;;AAEA;EACE,iBAAiB;EACjB,eAAe;AACjB;;AAEA;EACE,gCAAgC;AAClC;;AAEA;EACE,OAAO;EACP,UAAU,EAAE,iBAAiB;EAC7B,gBAAgB,EAAE,mBAAmB;EACrC,gBAAgB,EAAE,WAAW;EAC7B,uBAAuB;EACvB,aAAa,EAAE,wCAAwC;EACvD,sBAAsB,EAAE,wBAAwB;AAClD;;AAEA,+BAA+B;AAC/B;EACE,cAAc,EAAE,YAAY;EAC5B,OAAO,EAAE,iCAAiC;EAC1C,aAAa;EACb,sBAAsB;AACxB;;AAEA,0BAA0B;AAC1B;EACE,OAAO,EAAE,gBAAgB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,0BAA0B;EAC1B,iBAAiB;EACjB,eAAe;EACf,WAAW;EACX,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA,uBAAuB;AACvB;EACE,cAAc,EAAE,wBAAwB;AAC1C;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,yBAAyB;EACzB,sBAAsB;EACtB,YAAY;EACZ,gBAAgB;EAChB,eAAe,EAAE,cAAc;AACjC;;AAEA;EACE,sBAAsB;EACtB,YAAY;EACZ,eAAe,EAAE,cAAc;AACjC;;AAEA;EACE,eAAe,EAAE,cAAc;EAC/B,eAAe;AACjB;;AAEA;EACE,UAAU;EACV,UAAU;EACV,kBAAkB;EAClB,6BAA6B;AAC/B;AACA;EACE,oCAAoC;AACtC;;AAEA,YAAY;AACZ;EACE,WAAW;EACX,kBAAkB;EAClB,6BAA6B;AAC/B;AACA;EACE,oCAAoC;AACtC;;AAEA,gBAAgB;AAChB;EACE,YAAY;AACd","sourcesContent":["body {\n  margin: 0;\n  padding: 0;\n  font-family: Arial, sans-serif;\n  overflow: hidden;\n  height: 100vh;\n}\n\n.app-container {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  background-color: #f0f0f0;\n}\n\n.menu-bar {\n  display: flex;\n  background-color: rgb(30, 30, 30);\n  padding: 4px;\n  color: white;\n}\n\n.menu-group {\n  display: flex;\n  margin-right: 15px;\n  border-right: 1px solid rgba(255, 255, 255, 0.2);\n  padding-right: 15px;\n}\n\n.menu-button {\n  background: none;\n  border: none;\n  color: white;\n  padding: 5px 10px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  font-size: 12px;\n}\n\n.menu-button:hover {\n  background-color: rgba(255, 255, 255, 0.1);\n}\n\n.icon {\n  margin-right: 5px;\n  font-style: normal;\n}\n\n.main-layout {\n  display: flex;\n  flex: 1;\n  overflow: hidden;\n}\n\n.sidebar {\n  width: 250px;\n  background-color: #f8f8f8;\n  border-right: 1px solid #ddd;\n  display: flex;\n  flex-direction: column;\n}\n\n.tree-title {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  font-weight: bold;\n  padding: 8px;\n  background-color: #e8e8e8;\n  border-bottom: 1px solid #ddd;\n}\n\n.tree-view {\n  flex: 1;\n  overflow: auto;\n  padding: 5px;\n}\n\n.tree-item {\n  margin: 2px 0;\n  cursor: pointer;\n}\n\n.tree-label {\n  padding: 3px;\n  display: flex;\n  align-items: center;\n  font-size: 16px; /* 文字サイズ */\n}\n\n/* ツリーラベル内のアイコンサイズ調整 */\n.tree-label .material-symbols-outlined {\n  font-size: 18px; /* アイコンサイズ */\n  margin-right: 4px; /* アイコンとテキストの間隔調整 */\n}\n\n/* トグルアイコンの調整 (必要に応じて) */\n.tree-label .toggle-icon {\n  margin-right: 2px;\n}\n\n.tree-label:hover {\n  background-color: #e0e0e0;\n}\n\n.tree-items {\n  margin-left: 30px; /* インデントを 20px から 30px に変更 */\n}\n\n.main-area {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.query-tabs {\n  display: flex;\n  background-color: #e8e8e8;\n  border-bottom: 1px solid #ddd;\n}\n\n.query-tab {\n  padding: 8px 15px;\n  background-color: #f0f0f0;\n  border-right: 1px solid #ddd;\n  cursor: pointer;\n  position: relative;\n  font-size: 13px;\n  display: flex;\n  align-items: center;\n}\n\n.query-tab.active {\n  background-color: white;\n}\n\n.close-tab {\n  margin-left: 8px;\n  font-size: 14px;\n  opacity: 0.6;\n}\n\n.close-tab:hover {\n  opacity: 1;\n}\n\n/* タブの背景色: アクティブと非アクティブ */\n.query-tab {\n  background-color: #f0f0f0;\n}\n.query-tab.active {\n  background-color: white;\n}\n\n.query-editor {\n  height: 200px;\n  border-bottom: 1px solid #ddd;\n}\n\n.query-editor textarea {\n  width: 100%;\n  height: 100%;\n  resize: none;\n  border: none;\n  padding: 10px;\n  font-family: 'Courier New', monospace;\n  font-size: 14px;\n}\n\n.results-container {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.results-tabs {\n  display: flex;\n  border-bottom: 1px solid #ddd;\n  background-color: #f0f0f0;\n}\n\n.result-tab {\n  padding: 5px 15px;\n  cursor: pointer;\n}\n\n.result-tab.active {\n  border-bottom: 2px solid #0078d7;\n}\n\n.results-grid {\n  flex: 1;\n  padding: 0; /* パディングを 0 に変更 */\n  overflow-y: auto; /* 縦スクロールをコンテナで管理 */\n  overflow-x: auto; /* 横スクロール */\n  background-color: white;\n  display: flex; /* DataTablesコンテナがflexアイテムとして高さを占めるように */\n  flex-direction: column; /* DataTablesコンテナを縦に配置 */\n}\n\n/* DataTablesのコンテナの高さを100%にする */\n.dataTables_wrapper {\n  padding-top: 0; /* 上の余白を削除 */\n  flex: 1; /* 親要素(.results-grid)の残りの高さを占める */\n  display: flex;\n  flex-direction: column;\n}\n\n/* DataTablesのスクロール可能な本体 */\n.dataTables_scrollBody {\n  flex: 1; /* 利用可能な高さを占める */\n}\n\n.status-bar {\n  background-color: #f0f0f0;\n  border-top: 1px solid #ddd;\n  padding: 3px 10px;\n  font-size: 12px;\n  color: #555;\n  height: 20px;\n}\n\n.status-error {\n  color: #d83b01;\n}\n\n.status-success {\n  color: #107c10;\n}\n\n/* DataTables スタイル上書き */\n.dataTables_wrapper {\n  padding-top: 0; /* 上の余白を削除 (重複するが念のため) */\n}\n\ntable.dataTable {\n  border-collapse: collapse;\n  width: 100%;\n}\n\ntable.dataTable thead th {\n  background-color: #e8e8e8;\n  border: 1px solid #ddd;\n  padding: 8px;\n  text-align: left;\n  font-size: 13px; /* フォントサイズ変更 */\n}\n\ntable.dataTable tbody td {\n  border: 1px solid #ddd;\n  padding: 6px;\n  font-size: 13px; /* フォントサイズ変更 */\n}\n\n.dataTables_info, .dataTables_paginate {\n  font-size: 16px; /* フォントサイズ変更 */\n  padding: 10px 0;\n}\n\n.splitter {\n  flex: none;\n  width: 5px;\n  cursor: col-resize;\n  background-color: transparent;\n}\n.splitter:hover {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n\n/* 水平スプリッタ */\n.row-splitter {\n  height: 5px;\n  cursor: row-resize;\n  background-color: transparent;\n}\n.row-splitter:hover {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n\n/* 更新ボタンのアイコン色 */\n#refresh-db-button .material-symbols-outlined {\n  color: black;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css":
/*!**************************************************************************!*\
  !*** ./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_dataTables_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./dataTables.dataTables.min.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_dataTables_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_dataTables_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_dataTables_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_dataTables_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs");
/*! DataTables styling integration
 * © SpryMedia Ltd - datatables.net/license
 */




// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css":
/*!***************************************************************************************!*\
  !*** ./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_fixedHeader_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./fixedHeader.dataTables.min.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_fixedHeader_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_fixedHeader_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_fixedHeader_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_fixedHeader_dataTables_min_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/datatables.net-fixedheader-dt/js/fixedHeader.dataTables.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/datatables.net-fixedheader-dt/js/fixedHeader.dataTables.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net_dt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net-dt */ "./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs");
/* harmony import */ var datatables_net_fixedheader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-fixedheader */ "./node_modules/datatables.net-fixedheader/js/dataTables.fixedHeader.mjs");
/*! DataTables styling wrapper for FixedHeader
 * © SpryMedia Ltd - datatables.net/license
 */





// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net_dt__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-fixedheader/js/dataTables.fixedHeader.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/datatables.net-fixedheader/js/dataTables.fixedHeader.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs");
/*! FixedHeader 4.0.1
 * © SpryMedia Ltd - datatables.net/license
 */




// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


/**
 * @summary     FixedHeader
 * @description Fix a table's header or footer, so it is always visible while
 *              scrolling
 * @version     4.0.1
 * @author      SpryMedia Ltd
 * @contact     datatables.net
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

var _instCounter = 0;

var FixedHeader = function (dt, config) {
	if (!datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].versionCheck('2')) {
		throw 'Warning: FixedHeader requires DataTables 2 or newer';
	}

	// Sanity check - you just know it will happen
	if (!(this instanceof FixedHeader)) {
		throw "FixedHeader must be initialised with the 'new' keyword.";
	}

	// Allow a boolean true for defaults
	if (config === true) {
		config = {};
	}

	dt = new datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api(dt);

	this.c = $.extend(true, {}, FixedHeader.defaults, config);

	this.s = {
		dt: dt,
		position: {
			theadTop: 0,
			tbodyTop: 0,
			tfootTop: 0,
			tfootBottom: 0,
			width: 0,
			left: 0,
			tfootHeight: 0,
			theadHeight: 0,
			windowHeight: $(window).height(),
			visible: true
		},
		headerMode: null,
		footerMode: null,
		autoWidth: dt.settings()[0].oFeatures.bAutoWidth,
		namespace: '.dtfc' + _instCounter++,
		scrollLeft: {
			header: -1,
			footer: -1
		},
		enable: true,
		autoDisable: false
	};

	this.dom = {
		floatingHeader: null,
		thead: $(dt.table().header()),
		tbody: $(dt.table().body()),
		tfoot: $(dt.table().footer()),
		header: {
			host: null,
			floating: null,
			floatingParent: $('<div class="dtfh-floatingparent"><div></div></div>'),
			placeholder: null
		},
		footer: {
			host: null,
			floating: null,
			floatingParent: $('<div class="dtfh-floatingparent"><div></div></div>'),
			placeholder: null
		}
	};

	this.dom.header.host = this.dom.thead.parent();
	this.dom.footer.host = this.dom.tfoot.parent();

	var dtSettings = dt.settings()[0];
	if (dtSettings._fixedHeader) {
		throw (
			'FixedHeader already initialised on table ' + dtSettings.nTable.id
		);
	}

	dtSettings._fixedHeader = this;

	this._constructor();
};

/*
 * Variable: FixedHeader
 * Purpose:  Prototype for FixedHeader
 * Scope:    global
 */
$.extend(FixedHeader.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * API methods
	 */

	/**
	 * Kill off FH and any events
	 */
	destroy: function () {
		var dom = this.dom;

		this.s.dt.off('.dtfc');
		$(window).off(this.s.namespace);

		// Remove clones of FC blockers
		if (dom.header.rightBlocker) {
			dom.header.rightBlocker.remove();
		}
		if (dom.header.leftBlocker) {
			dom.header.leftBlocker.remove();
		}
		if (dom.footer.rightBlocker) {
			dom.footer.rightBlocker.remove();
		}
		if (dom.footer.leftBlocker) {
			dom.footer.leftBlocker.remove();
		}

		if (this.c.header) {
			this._modeChange('in-place', 'header', true);
		}

		if (this.c.footer && dom.tfoot.length) {
			this._modeChange('in-place', 'footer', true);
		}
	},

	/**
	 * Enable / disable the fixed elements
	 *
	 * @param  {boolean} enable `true` to enable, `false` to disable
	 */
	enable: function (enable, update, type) {
		this.s.enable = enable;

		this.s.enableType = type;

		if (update || update === undefined) {
			this._positions();
			this._scroll(true);
		}
	},

	/**
	 * Get enabled status
	 */
	enabled: function () {
		return this.s.enable;
	},

	/**
	 * Set header offset
	 *
	 * @param  {int} new value for headerOffset
	 */
	headerOffset: function (offset) {
		if (offset !== undefined) {
			this.c.headerOffset = offset;
			this.update();
		}

		return this.c.headerOffset;
	},

	/**
	 * Set footer offset
	 *
	 * @param  {int} new value for footerOffset
	 */
	footerOffset: function (offset) {
		if (offset !== undefined) {
			this.c.footerOffset = offset;
			this.update();
		}

		return this.c.footerOffset;
	},

	/**
	 * Recalculate the position of the fixed elements and force them into place
	 */
	update: function (force) {
		var table = this.s.dt.table().node();

		// Update should only do something if enabled by the dev.
		if (!this.s.enable && !this.s.autoDisable) {
			return;
		}

		if ($(table).is(':visible')) {
			this.s.autoDisable = false;
			this.enable(true, false);
		}
		else {
			this.s.autoDisable = true;
			this.enable(false, false);
		}

		// Don't update if header is not in the document atm (due to
		// async events)
		if ($(table).children('thead').length === 0) {
			return;
		}

		this._positions();
		this._scroll(force !== undefined ? force : true);
		this._widths(this.dom.header);
		this._widths(this.dom.footer);
	},

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * FixedHeader constructor - adding the required event listeners and
	 * simple initialisation
	 *
	 * @private
	 */
	_constructor: function () {
		var that = this;
		var dt = this.s.dt;

		$(window)
			.on('scroll' + this.s.namespace, function () {
				that._scroll();
			})
			.on(
				'resize' + this.s.namespace,
				datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].util.throttle(function () {
					that.s.position.windowHeight = $(window).height();
					that.update();
				}, 50)
			);

		var autoHeader = $('.fh-fixedHeader');
		if (!this.c.headerOffset && autoHeader.length) {
			this.c.headerOffset = autoHeader.outerHeight();
		}

		var autoFooter = $('.fh-fixedFooter');
		if (!this.c.footerOffset && autoFooter.length) {
			this.c.footerOffset = autoFooter.outerHeight();
		}

		dt.on(
			'column-reorder.dt.dtfc column-visibility.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc',
			function (e, ctx) {
				that.update();
			}
		).on('draw.dt.dtfc', function (e, ctx) {
			// For updates from our own table, don't reclone, but for all others, do
			that.update(ctx === dt.settings()[0] ? false : true);
		});

		dt.on('destroy.dtfc', function () {
			that.destroy();
		});

		this._positions();
		this._scroll();
	},

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Clone a fixed item to act as a place holder for the original element
	 * which is moved into a clone of the table element, and moved around the
	 * document to give the fixed effect.
	 *
	 * @param  {string}  item  'header' or 'footer'
	 * @param  {boolean} force Force the clone to happen, or allow automatic
	 *   decision (reuse existing if available)
	 * @private
	 */
	_clone: function (item, force) {
		var that = this;
		var dt = this.s.dt;
		var itemDom = this.dom[item];
		var itemElement = item === 'header' ? this.dom.thead : this.dom.tfoot;

		// If footer and scrolling is enabled then we don't clone
		// Instead the table's height is decreased accordingly - see `_scroll()`
		if (item === 'footer' && this._scrollEnabled()) {
			return;
		}

		if (!force && itemDom.floating) {
			// existing floating element - reuse it
			itemDom.floating.removeClass(
				'fixedHeader-floating fixedHeader-locked'
			);
		}
		else {
			if (itemDom.floating) {
				if (itemDom.placeholder !== null) {
					itemDom.placeholder.remove();
				}

				itemDom.floating.children().detach();
				itemDom.floating.remove();
			}

			var tableNode = $(dt.table().node());
			var scrollBody = $(tableNode.parent());
			var scrollEnabled = this._scrollEnabled();

			itemDom.floating = $(dt.table().node().cloneNode(false))
				.attr('aria-hidden', 'true')
				.css({
					top: 0,
					left: 0
				})
				.removeAttr('id');

			itemDom.floatingParent
				.css({
					width: scrollBody[0].offsetWidth,
					overflow: 'hidden',
					height: 'fit-content',
					position: 'fixed',
					left: scrollEnabled
						? tableNode.offset().left + scrollBody.scrollLeft()
						: 0
				})
				.css(
					item === 'header'
						? {
								top: this.c.headerOffset,
								bottom: ''
						}
						: {
								top: '',
								bottom: this.c.footerOffset
						}
				)
				.addClass(
					item === 'footer'
						? 'dtfh-floatingparent-foot'
						: 'dtfh-floatingparent-head'
				)
				.appendTo('body')
				.children()
				.eq(0)
				.append(itemDom.floating);

			this._stickyPosition(itemDom.floating, '-');

			var scrollLeftUpdate = function () {
				var scrollLeft = scrollBody.scrollLeft();
				that.s.scrollLeft = { footer: scrollLeft, header: scrollLeft };
				itemDom.floatingParent.scrollLeft(that.s.scrollLeft.header);
			};

			scrollLeftUpdate();
			scrollBody.off('scroll.dtfh').on('scroll.dtfh', scrollLeftUpdate);

			// Need padding on the header's container to allow for a scrollbar,
			// just like how DataTables handles it
			itemDom.floatingParent.children().css({
				width: 'fit-content',
				paddingRight: that.s.dt.settings()[0].oBrowser.barWidth
			});

			// Blocker to hide the table behind the scrollbar - this needs to use
			// fixed positioning in the container since we don't have an outer wrapper
			let blocker = $(
				item === 'footer'
					? 'div.dtfc-bottom-blocker'
					: 'div.dtfc-top-blocker',
				dt.table().container()
			);

			if (blocker.length) {
				blocker
					.clone()
					.appendTo(itemDom.floatingParent)
					.css({
						position: 'fixed',
						right: blocker.width()
					});
			}

			// Insert a fake thead/tfoot into the DataTable to stop it jumping around
			itemDom.placeholder = itemElement.clone(false);
			itemDom.placeholder.find('*[id]').removeAttr('id');

			// Move the thead / tfoot elements around - original into the floating
			// element and clone into the original table
			itemDom.host.prepend(itemDom.placeholder);
			itemDom.floating.append(itemElement);

			this._widths(itemDom);
		}
	},

	/**
	 * This method sets the sticky position of the header elements to match fixed columns
	 * @param {JQuery<HTMLElement>} el
	 * @param {string} sign
	 */
	_stickyPosition: function (el, sign) {
		if (this._scrollEnabled()) {
			var that = this;
			var rtl = $(that.s.dt.table().node()).css('direction') === 'rtl';

			el.find('th').each(function () {
				// Find out if fixed header has previously set this column
				if ($(this).css('position') === 'sticky') {
					var right = $(this).css('right');
					var left = $(this).css('left');
					var potential;

					if (right !== 'auto' && !rtl) {
						potential = +right.replace(/px/g, '')

						$(this).css('right', potential > 0 ? potential : 0);
					}
					else if (left !== 'auto' && rtl) {
						potential = +left.replace(/px/g, '');

						$(this).css('left', potential > 0 ? potential : 0);
					}
				}
			});
		}
	},

	/**
	 * Reposition the floating elements to take account of horizontal page
	 * scroll
	 *
	 * @param  {string} item       The `header` or `footer`
	 * @param  {int}    scrollLeft Document scrollLeft
	 * @private
	 */
	_horizontal: function (item, scrollLeft) {
		var itemDom = this.dom[item];
		var lastScrollLeft = this.s.scrollLeft;

		if (itemDom.floating && lastScrollLeft[item] !== scrollLeft) {
			// If scrolling is enabled we need to match the floating header to the body
			if (this._scrollEnabled()) {
				var newScrollLeft = $(
					$(this.s.dt.table().node()).parent()
				).scrollLeft();
				itemDom.floating.scrollLeft(newScrollLeft);
				itemDom.floatingParent.scrollLeft(newScrollLeft);
			}

			lastScrollLeft[item] = scrollLeft;
		}
	},

	/**
	 * Change from one display mode to another. Each fixed item can be in one
	 * of:
	 *
	 * * `in-place` - In the main DataTable
	 * * `in` - Floating over the DataTable
	 * * `below` - (Header only) Fixed to the bottom of the table body
	 * * `above` - (Footer only) Fixed to the top of the table body
	 *
	 * @param  {string}  mode        Mode that the item should be shown in
	 * @param  {string}  item        'header' or 'footer'
	 * @param  {boolean} forceChange Force a redraw of the mode, even if already
	 *     in that mode.
	 * @private
	 */
	_modeChange: function (mode, item, forceChange) {
		var itemDom = this.dom[item];
		var position = this.s.position;

		// Just determine if scroll is enabled once
		var scrollEnabled = this._scrollEnabled();

		// If footer and scrolling is enabled then we don't clone
		// Instead the table's height is decreased accordingly - see `_scroll()`
		if (item === 'footer' && scrollEnabled) {
			return;
		}

		// It isn't trivial to add a !important css attribute...
		var importantWidth = function (w) {
			itemDom.floating[0].style.setProperty('width', w + 'px', 'important');

			// If not scrolling also have to update the floatingParent
			if (!scrollEnabled) {
				itemDom.floatingParent[0].style.setProperty('width', w + 'px', 'important');
			}
		};

		// Record focus. Browser's will cause input elements to loose focus if
		// they are inserted else where in the doc
		var tablePart = this.dom[item === 'footer' ? 'tfoot' : 'thead'];
		var focus = $.contains(tablePart[0], document.activeElement)
			? document.activeElement
			: null;
		var scrollBody = $($(this.s.dt.table().node()).parent());

		if (mode === 'in-place') {
			// Insert the header back into the table's real header
			if (itemDom.placeholder) {
				itemDom.placeholder.remove();
				itemDom.placeholder = null;
			}

			if (item === 'header') {
				itemDom.host.prepend(tablePart);
			}
			else {
				itemDom.host.append(tablePart);
			}

			if (itemDom.floating) {
				itemDom.floating.remove();
				itemDom.floating = null;
				this._stickyPosition(itemDom.host, '+');
			}

			if (itemDom.floatingParent) {
				itemDom.floatingParent.find('div.dtfc-top-blocker').remove();
				itemDom.floatingParent.remove();
			}

			$($(itemDom.host.parent()).parent()).scrollLeft(
				scrollBody.scrollLeft()
			);
		}
		else if (mode === 'in') {
			// Remove the header from the real table and insert into a fixed
			// positioned floating table clone
			this._clone(item, forceChange);

			// Get useful position values
			var scrollOffset = scrollBody.offset();
			var windowTop = $(document).scrollTop();
			var windowHeight = $(window).height();
			var windowBottom = windowTop + windowHeight;
			var bodyTop = scrollEnabled ? scrollOffset.top : position.tbodyTop;
			var bodyBottom = scrollEnabled
				? scrollOffset.top + scrollBody.outerHeight()
				: position.tfootTop;

			// Calculate the amount that the footer or header needs to be shuffled
			var shuffle;

			if (item === 'footer') {
				shuffle =
					bodyTop > windowBottom
						? position.tfootHeight // Yes - push the footer below
						: bodyTop + position.tfootHeight - windowBottom; // No
			}
			else {
				// Otherwise must be a header so get the difference from the bottom of the
				//  desired floating header and the bottom of the table body
				shuffle =
					windowTop +
					this.c.headerOffset +
					position.theadHeight -
					bodyBottom;
			}

			// Set the top or bottom based off of the offset and the shuffle value
			var prop = item === 'header' ? 'top' : 'bottom';
			var val = this.c[item + 'Offset'] - (shuffle > 0 ? shuffle : 0);

			itemDom.floating.addClass('fixedHeader-floating');
			itemDom.floatingParent
				.css(prop, val)
				.css({
					left: position.left,
					'z-index': 3
				});

			importantWidth(position.width);

			if (item === 'footer') {
				itemDom.floating.css('top', '');
			}
		}
		else if (mode === 'below') {
			// only used for the header
			// Fix the position of the floating header at base of the table body
			this._clone(item, forceChange);

			itemDom.floating.addClass('fixedHeader-locked');
			itemDom.floatingParent.css({
				position: 'absolute',
				top: position.tfootTop - position.theadHeight,
				left: position.left + 'px'
			});

			importantWidth(position.width);
		}
		else if (mode === 'above') {
			// only used for the footer
			// Fix the position of the floating footer at top of the table body
			this._clone(item, forceChange);

			itemDom.floating.addClass('fixedHeader-locked');
			itemDom.floatingParent.css({
				position: 'absolute',
				top: position.tbodyTop,
				left: position.left + 'px'
			});

			importantWidth(position.width);
		}

		// Restore focus if it was lost
		if (focus && focus !== document.activeElement) {
			setTimeout(function () {
				focus.focus();
			}, 10);
		}

		this.s.scrollLeft.header = -1;
		this.s.scrollLeft.footer = -1;
		this.s[item + 'Mode'] = mode;
	},

	/**
	 * Cache the positional information that is required for the mode
	 * calculations that FixedHeader performs.
	 *
	 * @private
	 */
	_positions: function () {
		var dt = this.s.dt;
		var table = dt.table();
		var position = this.s.position;
		var dom = this.dom;
		var tableNode = $(table.node());
		var scrollEnabled = this._scrollEnabled();

		// Need to use the header and footer that are in the main table,
		// regardless of if they are clones, since they hold the positions we
		// want to measure from
		var thead = $(dt.table().header());
		var tfoot = $(dt.table().footer());
		var tbody = dom.tbody;
		var scrollBody = tableNode.parent();

		position.visible = tableNode.is(':visible');
		position.width = tableNode.outerWidth();
		position.left = tableNode.offset().left;
		position.theadTop = thead.offset().top;
		position.tbodyTop = scrollEnabled
			? scrollBody.offset().top
			: tbody.offset().top;
		position.tbodyHeight = scrollEnabled
			? scrollBody.outerHeight()
			: tbody.outerHeight();
		position.theadHeight = thead.outerHeight();
		position.theadBottom = position.theadTop + position.theadHeight;
		position.tfootTop = position.tbodyTop + position.tbodyHeight; //tfoot.offset().top;

		if (tfoot.length) {
			position.tfootBottom = position.tfootTop + tfoot.outerHeight();
			position.tfootHeight = tfoot.outerHeight();
		}
		else {
			position.tfootBottom = position.tfootTop;
			position.tfootHeight = 0;
		}
	},

	/**
	 * Mode calculation - determine what mode the fixed items should be placed
	 * into.
	 *
	 * @param  {boolean} forceChange Force a redraw of the mode, even if already
	 *     in that mode.
	 * @private
	 */
	_scroll: function (forceChange) {
		if (this.s.dt.settings()[0].bDestroying) {
			return;
		}

		// ScrollBody details
		var scrollEnabled = this._scrollEnabled();
		var scrollBody = $(this.s.dt.table().node()).parent();
		var scrollOffset = scrollBody.offset();
		var scrollHeight = scrollBody.outerHeight();

		// Window details
		var windowLeft = $(document).scrollLeft();
		var windowTop = $(document).scrollTop();
		var windowHeight = $(window).height();
		var windowBottom = windowHeight + windowTop;

		var position = this.s.position;
		var headerMode, footerMode;

		// Body Details
		var bodyTop = scrollEnabled ? scrollOffset.top : position.tbodyTop;
		var bodyLeft = scrollEnabled ? scrollOffset.left : position.left;
		var bodyBottom = scrollEnabled
			? scrollOffset.top + scrollHeight
			: position.tfootTop;
		var bodyWidth = scrollEnabled
			? scrollBody.outerWidth()
			: position.tbodyWidth;

		if (this.c.header) {
			if (!this.s.enable) {
				headerMode = 'in-place';
			}
			// The header is in it's normal place if the body top is lower than
			//  the scroll of the window plus the headerOffset and the height of the header
			else if (
				!position.visible ||
				windowTop + this.c.headerOffset + position.theadHeight <=
					bodyTop
			) {
				headerMode = 'in-place';
			}
			// The header should be floated if
			else if (
				// The scrolling plus the header offset plus the height of the header is lower than the top of the body
				windowTop + this.c.headerOffset + position.theadHeight >
					bodyTop &&
				// And the scrolling at the top plus the header offset is above the bottom of the body
				windowTop + this.c.headerOffset + position.theadHeight <
					bodyBottom
			) {
				headerMode = 'in';

				// Further to the above, If the scrolling plus the header offset plus the header height is lower
				// than the bottom of the table a shuffle is required so have to force the calculation
				if (
					windowTop + this.c.headerOffset + position.theadHeight >
						bodyBottom ||
					this.dom.header.floatingParent === undefined
				) {
					forceChange = true;
				}
				else {
					this.dom.header.floatingParent
						.css({
							top: this.c.headerOffset,
							position: 'fixed'
						})
						.children()
						.eq(0)
						.append(this.dom.header.floating);
				}
			}
			// Anything else and the view is below the table
			else {
				headerMode = 'below';
			}

			if (forceChange || headerMode !== this.s.headerMode) {
				this._modeChange(headerMode, 'header', forceChange);
			}

			this._horizontal('header', windowLeft);
		}

		var header = {
			offset: { top: 0, left: 0 },
			height: 0
		};
		var footer = {
			offset: { top: 0, left: 0 },
			height: 0
		};

		if (
			this.c.footer &&
			this.dom.tfoot.length &&
			this.dom.tfoot.find('th, td').length
		) {
			if (!this.s.enable) {
				footerMode = 'in-place';
			}
			else if (
				!position.visible ||
				position.tfootBottom + this.c.footerOffset <= windowBottom
			) {
				footerMode = 'in-place';
			}
			else if (
				bodyBottom + position.tfootHeight + this.c.footerOffset >
					windowBottom &&
				bodyTop + this.c.footerOffset < windowBottom
			) {
				footerMode = 'in';
				forceChange = true;
			}
			else {
				footerMode = 'above';
			}

			if (forceChange || footerMode !== this.s.footerMode) {
				this._modeChange(footerMode, 'footer', forceChange);
			}

			this._horizontal('footer', windowLeft);

			var getOffsetHeight = function (el) {
				return {
					offset: el.offset(),
					height: el.outerHeight()
				};
			};

			header = this.dom.header.floating
				? getOffsetHeight(this.dom.header.floating)
				: getOffsetHeight(this.dom.thead);
			footer = this.dom.footer.floating
				? getOffsetHeight(this.dom.footer.floating)
				: getOffsetHeight(this.dom.tfoot);

			// If scrolling is enabled and the footer is off the screen
			if (scrollEnabled && footer.offset.top > windowTop) {
				// && footer.offset.top >= windowBottom) {
				// Calculate the gap between the top of the scrollBody and the top of the window
				var overlap = windowTop - scrollOffset.top;
				// The new height is the bottom of the window
				var newHeight =
					windowBottom +
					// If the gap between the top of the scrollbody and the window is more than
					//  the height of the header then the top of the table is still visible so add that gap
					// Doing this has effectively calculated the height from the top of the table to the bottom of the current page
					(overlap > -header.height ? overlap : 0) -
					// Take from that
					// The top of the header plus
					(header.offset.top +
						// The header height if the standard header is present
						(overlap < -header.height ? header.height : 0) +
						// And the height of the footer
						footer.height);

				// Don't want a negative height
				if (newHeight < 0) {
					newHeight = 0;
				}

				// At the end of the above calculation the space between the header (top of the page if floating)
				// and the point just above the footer should be the new value for the height of the table.
				scrollBody.outerHeight(newHeight);

				// Need some rounding here as sometimes very small decimal places are encountered
				// If the actual height is bigger or equal to the height we just applied then the footer is "Floating"
				if (
					Math.round(scrollBody.outerHeight()) >=
					Math.round(newHeight)
				) {
					$(this.dom.tfoot.parent()).addClass('fixedHeader-floating');
				}
				// Otherwise max-width has kicked in so it is not floating
				else {
					$(this.dom.tfoot.parent()).removeClass(
						'fixedHeader-floating'
					);
				}
			}
		}

		if (this.dom.header.floating) {
			this.dom.header.floatingParent.css('left', bodyLeft - windowLeft);
		}
		if (this.dom.footer.floating) {
			this.dom.footer.floatingParent.css('left', bodyLeft - windowLeft);
		}

		// If fixed columns is being used on this table then the blockers need to be copied across
		// Cloning these is cleaner than creating as our own as it will keep consistency with fixedColumns automatically
		// ASSUMING that the class remains the same
		if (this.s.dt.settings()[0]._fixedColumns !== undefined) {
			var adjustBlocker = function (side, end, el) {
				if (el === undefined) {
					var blocker = $(
						'div.dtfc-' + side + '-' + end + '-blocker'
					);

					el =
						blocker.length === 0
							? null
							: blocker.clone().css('z-index', 1);
				}

				if (el !== null) {
					if (headerMode === 'in' || headerMode === 'below') {
						el.appendTo('body').css({
							top:
								end === 'top'
									? header.offset.top
									: footer.offset.top,
							left:
								side === 'right'
									? bodyLeft + bodyWidth - el.width()
									: bodyLeft
						});
					}
					else {
						el.detach();
					}
				}

				return el;
			};

			// Adjust all blockers
			this.dom.header.rightBlocker = adjustBlocker(
				'right',
				'top',
				this.dom.header.rightBlocker
			);
			this.dom.header.leftBlocker = adjustBlocker(
				'left',
				'top',
				this.dom.header.leftBlocker
			);
			this.dom.footer.rightBlocker = adjustBlocker(
				'right',
				'bottom',
				this.dom.footer.rightBlocker
			);
			this.dom.footer.leftBlocker = adjustBlocker(
				'left',
				'bottom',
				this.dom.footer.leftBlocker
			);
		}
	},

	/**
	 * Function to check if scrolling is enabled on the table or not
	 * @returns Boolean value indicating if scrolling on the table is enabled or not
	 */
	_scrollEnabled: function () {
		var oScroll = this.s.dt.settings()[0].oScroll;
		if (oScroll.sY !== '' || oScroll.sX !== '') {
			return true;
		}
		return false;
	},

	/**
	 * Realign columns by using the colgroup tag and
	 * checking column widths
	 */
	_widths: function (itemDom) {
		if (! itemDom || ! itemDom.placeholder) {
			return;
		}

		// Match the table overall width
		var tableNode = $(this.s.dt.table().node());
		var scrollBody = $(tableNode.parent());

		itemDom.floatingParent.css('width', scrollBody[0].offsetWidth);
		itemDom.floating.css('width', tableNode[0].offsetWidth);

		// Strip out the old colgroup
		$('colgroup', itemDom.floating).remove();

		// Copy the `colgroup` element to define the number of columns - needed
		// for complex header cases where a column might not have a unique
		// header
		var cols = itemDom.placeholder
			.parent()
			.find('colgroup')
			.clone()
			.appendTo(itemDom.floating)
			.find('col');

		// However, the widths defined in the colgroup from the DataTable might
		// not exactly reflect the actual widths of the columns (content can
		// force it to stretch). So we need to copy the actual widths into the
		// colgroup / col's used for the floating header.
		var widths = this.s.dt.columns(':visible').widths();

		for (var i=0 ; i<widths.length ; i++) {
			cols.eq(i).css('width', widths[i]);
		}
	}
});

/**
 * Version
 * @type {String}
 * @static
 */
FixedHeader.version = '4.0.1';

/**
 * Defaults
 * @type {Object}
 * @static
 */
FixedHeader.defaults = {
	header: true,
	footer: false,
	headerOffset: 0,
	footerOffset: 0
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interfaces
 */

// Attach for constructor access
$.fn.dataTable.FixedHeader = FixedHeader;
$.fn.DataTable.FixedHeader = FixedHeader;

// DataTables creation - check if the FixedHeader option has been defined on the
// table and if so, initialise
$(document).on('init.dt.dtfh', function (e, settings, json) {
	if (e.namespace !== 'dt') {
		return;
	}

	var init = settings.oInit.fixedHeader;
	var defaults = datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults.fixedHeader;

	if ((init || defaults) && !settings._fixedHeader) {
		var opts = $.extend({}, defaults, init);

		if (init !== false) {
			new FixedHeader(settings, opts);
		}
	}
});

// DataTables API methods
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('fixedHeader()', function () { });

datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('fixedHeader.adjust()', function () {
	return this.iterator('table', function (ctx) {
		var fh = ctx._fixedHeader;

		if (fh) {
			fh.update();
		}
	});
});

datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('fixedHeader.enable()', function (flag) {
	return this.iterator('table', function (ctx) {
		var fh = ctx._fixedHeader;

		flag = flag !== undefined ? flag : true;
		if (fh && flag !== fh.enabled()) {
			fh.enable(flag);
		}
	});
});

datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('fixedHeader.enabled()', function () {
	if (this.context.length) {
		var fh = this.context[0]._fixedHeader;

		if (fh) {
			return fh.enabled();
		}
	}

	return false;
});

datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('fixedHeader.disable()', function () {
	return this.iterator('table', function (ctx) {
		var fh = ctx._fixedHeader;

		if (fh && fh.enabled()) {
			fh.enable(false);
		}
	});
});

$.each(['header', 'footer'], function (i, el) {
	datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api.register('fixedHeader.' + el + 'Offset()', function (offset) {
		var ctx = this.context;

		if (offset === undefined) {
			return ctx.length && ctx[0]._fixedHeader
				? ctx[0]._fixedHeader[el + 'Offset']()
				: undefined;
		}

		return this.iterator('table', function (ctx) {
			var fh = ctx._fixedHeader;

			if (fh) {
				fh[el + 'Offset'](offset);
			}
		});
	});
});


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net/js/dataTables.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/datatables.net/js/dataTables.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/*! DataTables 2.2.2
 * © SpryMedia Ltd - datatables.net/license
 */



// DataTables code uses $ internally, but we want to be able to
// reassign $ with the `use` method, so it is a regular var.
var $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


var DataTable = function ( selector, options )
{
	// Check if called with a window or jQuery object for DOM less applications
	// This is for backwards compatibility
	if (DataTable.factory(selector, options)) {
		return DataTable;
	}

	// When creating with `new`, create a new DataTable, returning the API instance
	if (this instanceof DataTable) {
		return $(selector).DataTable(options);
	}
	else {
		// Argument switching
		options = selector;
	}

	var _that = this;
	var emptyInit = options === undefined;
	var len = this.length;

	if ( emptyInit ) {
		options = {};
	}

	// Method to get DT API instance from jQuery object
	this.api = function ()
	{
		return new _Api( this );
	};

	this.each(function() {
		// For each initialisation we want to give it a clean initialisation
		// object that can be bashed around
		var o = {};
		var oInit = len > 1 ? // optimisation for single table case
			_fnExtend( o, options, true ) :
			options;

		
		var i=0, iLen;
		var sId = this.getAttribute( 'id' );
		var defaults = DataTable.defaults;
		var $this = $(this);
		
		
		/* Sanity check */
		if ( this.nodeName.toLowerCase() != 'table' )
		{
			_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
			return;
		}
		
		$(this).trigger( 'options.dt', oInit );
		
		/* Backwards compatibility for the defaults */
		_fnCompatOpts( defaults );
		_fnCompatCols( defaults.column );
		
		/* Convert the camel-case defaults to Hungarian */
		_fnCamelToHungarian( defaults, defaults, true );
		_fnCamelToHungarian( defaults.column, defaults.column, true );
		
		/* Setting up the initialisation object */
		_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ), true );
		
		
		
		/* Check to see if we are re-initialising a table */
		var allSettings = DataTable.settings;
		for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
		{
			var s = allSettings[i];
		
			/* Base check on table node */
			if (
				s.nTable == this ||
				(s.nTHead && s.nTHead.parentNode == this) ||
				(s.nTFoot && s.nTFoot.parentNode == this)
			) {
				var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
				var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
		
				if ( emptyInit || bRetrieve )
				{
					return s.oInstance;
				}
				else if ( bDestroy )
				{
					new DataTable.Api(s).destroy();
					break;
				}
				else
				{
					_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
					return;
				}
			}
		
			/* If the element we are initialising has the same ID as a table which was previously
			 * initialised, but the table nodes don't match (from before) then we destroy the old
			 * instance by simply deleting it. This is under the assumption that the table has been
			 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
			 */
			if ( s.sTableId == this.id )
			{
				allSettings.splice( i, 1 );
				break;
			}
		}
		
		/* Ensure the table has an ID - required for accessibility */
		if ( sId === null || sId === "" )
		{
			sId = "DataTables_Table_"+(DataTable.ext._unique++);
			this.id = sId;
		}
		
		/* Create the settings object for this table and set some of the default parameters */
		var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
			"sDestroyWidth": $this[0].style.width,
			"sInstance":     sId,
			"sTableId":      sId,
			colgroup: $('<colgroup>').prependTo(this),
			fastData: function (row, column, type) {
				return _fnGetCellData(oSettings, row, column, type);
			}
		} );
		oSettings.nTable = this;
		oSettings.oInit  = oInit;
		
		allSettings.push( oSettings );
		
		// Make a single API instance available for internal handling
		oSettings.api = new _Api( oSettings );
		
		// Need to add the instance after the instance after the settings object has been added
		// to the settings array, so we can self reference the table instance if more than one
		oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
		
		// Backwards compatibility, before we apply all the defaults
		_fnCompatOpts( oInit );
		
		// If the length menu is given, but the init display length is not, use the length menu
		if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
		{
			oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0])
				? oInit.aLengthMenu[0][0]
				: $.isPlainObject( oInit.aLengthMenu[0] )
					? oInit.aLengthMenu[0].value
					: oInit.aLengthMenu[0];
		}
		
		// Apply the defaults and init options to make a single init object will all
		// options defined from defaults and instance options.
		oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
		
		
		// Map the initialisation options onto the settings object
		_fnMap( oSettings.oFeatures, oInit, [
			"bPaginate",
			"bLengthChange",
			"bFilter",
			"bSort",
			"bSortMulti",
			"bInfo",
			"bProcessing",
			"bAutoWidth",
			"bSortClasses",
			"bServerSide",
			"bDeferRender"
		] );
		_fnMap( oSettings, oInit, [
			"ajax",
			"fnFormatNumber",
			"sServerMethod",
			"aaSorting",
			"aaSortingFixed",
			"aLengthMenu",
			"sPaginationType",
			"iStateDuration",
			"bSortCellsTop",
			"iTabIndex",
			"sDom",
			"fnStateLoadCallback",
			"fnStateSaveCallback",
			"renderer",
			"searchDelay",
			"rowId",
			"caption",
			"layout",
			"orderDescReverse",
			"typeDetect",
			[ "iCookieDuration", "iStateDuration" ], // backwards compat
			[ "oSearch", "oPreviousSearch" ],
			[ "aoSearchCols", "aoPreSearchCols" ],
			[ "iDisplayLength", "_iDisplayLength" ]
		] );
		_fnMap( oSettings.oScroll, oInit, [
			[ "sScrollX", "sX" ],
			[ "sScrollXInner", "sXInner" ],
			[ "sScrollY", "sY" ],
			[ "bScrollCollapse", "bCollapse" ]
		] );
		_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
		
		/* Callback functions which are array driven */
		_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback );
		_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams );
		_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams );
		_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded );
		_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback );
		_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow );
		_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback );
		_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback );
		_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete );
		_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback );
		
		oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
		
		/* Browser support detection */
		_fnBrowserDetect( oSettings );
		
		var oClasses = oSettings.oClasses;
		
		$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
		$this.addClass( oClasses.table );
		
		if (! oSettings.oFeatures.bPaginate) {
			oInit.iDisplayStart = 0;
		}
		
		if ( oSettings.iInitDisplayStart === undefined )
		{
			/* Display start point, taking into account the save saving */
			oSettings.iInitDisplayStart = oInit.iDisplayStart;
			oSettings._iDisplayStart = oInit.iDisplayStart;
		}
		
		var defer = oInit.iDeferLoading;
		if ( defer !== null )
		{
			oSettings.deferLoading = true;
		
			var tmp = Array.isArray(defer);
			oSettings._iRecordsDisplay = tmp ? defer[0] : defer;
			oSettings._iRecordsTotal = tmp ? defer[1] : defer;
		}
		
		/*
		 * Columns
		 * See if we should load columns automatically or use defined ones
		 */
		var columnsInit = [];
		var thead = this.getElementsByTagName('thead');
		var initHeaderLayout = _fnDetectHeader( oSettings, thead[0] );
		
		// If we don't have a columns array, then generate one with nulls
		if ( oInit.aoColumns ) {
			columnsInit = oInit.aoColumns;
		}
		else if ( initHeaderLayout.length ) {
			for ( i=0, iLen=initHeaderLayout[0].length ; i<iLen ; i++ ) {
				columnsInit.push( null );
			}
		}
		
		// Add the columns
		for ( i=0, iLen=columnsInit.length ; i<iLen ; i++ ) {
			_fnAddColumn( oSettings );
		}
		
		// Apply the column definitions
		_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function (iCol, oDef) {
			_fnColumnOptions( oSettings, iCol, oDef );
		} );
		
		/* HTML5 attribute detection - build an mData object automatically if the
		 * attributes are found
		 */
		var rowOne = $this.children('tbody').find('tr').eq(0);
		
		if ( rowOne.length ) {
			var a = function ( cell, name ) {
				return cell.getAttribute( 'data-'+name ) !== null ? name : null;
			};
		
			$( rowOne[0] ).children('th, td').each( function (i, cell) {
				var col = oSettings.aoColumns[i];
		
				if (! col) {
					_fnLog( oSettings, 0, 'Incorrect column count', 18 );
				}
		
				if ( col.mData === i ) {
					var sort = a( cell, 'sort' ) || a( cell, 'order' );
					var filter = a( cell, 'filter' ) || a( cell, 'search' );
		
					if ( sort !== null || filter !== null ) {
						col.mData = {
							_:      i+'.display',
							sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
							type:   sort !== null   ? i+'.@data-'+sort   : undefined,
							filter: filter !== null ? i+'.@data-'+filter : undefined
						};
						col._isArrayHost = true;
		
						_fnColumnOptions( oSettings, i );
					}
				}
			} );
		}
		
		// Must be done after everything which can be overridden by the state saving!
		_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState );
		
		var features = oSettings.oFeatures;
		if ( oInit.bStateSave )
		{
			features.bStateSave = true;
		}
		
		// If aaSorting is not defined, then we use the first indicator in asSorting
		// in case that has been altered, so the default sort reflects that option
		if ( oInit.aaSorting === undefined ) {
			var sorting = oSettings.aaSorting;
			for ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {
				sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
			}
		}
		
		// Do a first pass on the sorting classes (allows any size changes to be taken into
		// account, and also will apply sorting disabled classes if disabled
		_fnSortingClasses( oSettings );
		
		_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
			if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
				_fnSortingClasses( oSettings );
			}
		} );
		
		
		/*
		 * Table HTML init
		 * Cache the header, body and footer as required, creating them if needed
		 */
		var caption = $this.children('caption');
		
		if ( oSettings.caption ) {
			if ( caption.length === 0 ) {
				caption = $('<caption/>').appendTo( $this );
			}
		
			caption.html( oSettings.caption );
		}
		
		// Store the caption side, so we can remove the element from the document
		// when creating the element
		if (caption.length) {
			caption[0]._captionSide = caption.css('caption-side');
			oSettings.captionNode = caption[0];
		}
		
		if ( thead.length === 0 ) {
			thead = $('<thead/>').appendTo($this);
		}
		oSettings.nTHead = thead[0];
		
		var tbody = $this.children('tbody');
		if ( tbody.length === 0 ) {
			tbody = $('<tbody/>').insertAfter(thead);
		}
		oSettings.nTBody = tbody[0];
		
		var tfoot = $this.children('tfoot');
		if ( tfoot.length === 0 ) {
			// If we are a scrolling table, and no footer has been given, then we need to create
			// a tfoot element for the caption element to be appended to
			tfoot = $('<tfoot/>').appendTo($this);
		}
		oSettings.nTFoot = tfoot[0];
		
		// Copy the data index array
		oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
		
		// Initialisation complete - table can be drawn
		oSettings.bInitialised = true;
		
		// Language definitions
		var oLanguage = oSettings.oLanguage;
		$.extend( true, oLanguage, oInit.oLanguage );
		
		if ( oLanguage.sUrl ) {
			// Get the language definitions from a file
			$.ajax( {
				dataType: 'json',
				url: oLanguage.sUrl,
				success: function ( json ) {
					_fnCamelToHungarian( defaults.oLanguage, json );
					$.extend( true, oLanguage, json, oSettings.oInit.oLanguage );
		
					_fnCallbackFire( oSettings, null, 'i18n', [oSettings], true);
					_fnInitialise( oSettings );
				},
				error: function () {
					// Error occurred loading language file
					_fnLog( oSettings, 0, 'i18n file loading error', 21 );
		
					// Continue on as best we can
					_fnInitialise( oSettings );
				}
			} );
		}
		else {
			_fnCallbackFire( oSettings, null, 'i18n', [oSettings], true);
			_fnInitialise( oSettings );
		}
	} );
	_that = null;
	return this;
};



/**
 * DataTables extensions
 * 
 * This namespace acts as a collection area for plug-ins that can be used to
 * extend DataTables capabilities. Indeed many of the build in methods
 * use this method to provide their own capabilities (sorting methods for
 * example).
 *
 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
 * reasons
 *
 *  @namespace
 */
DataTable.ext = _ext = {
	/**
	 * Buttons. For use with the Buttons extension for DataTables. This is
	 * defined here so other extensions can define buttons regardless of load
	 * order. It is _not_ used by DataTables core.
	 *
	 *  @type object
	 *  @default {}
	 */
	buttons: {},


	/**
	 * Element class names
	 *
	 *  @type object
	 *  @default {}
	 */
	classes: {},


	/**
	 * DataTables build type (expanded by the download builder)
	 *
	 *  @type string
	 */
	builder: "-source-",


	/**
	 * Error reporting.
	 * 
	 * How should DataTables report an error. Can take the value 'alert',
	 * 'throw', 'none' or a function.
	 *
	 *  @type string|function
	 *  @default alert
	 */
	errMode: "alert",


	/**
	 * Legacy so v1 plug-ins don't throw js errors on load
	 */
	feature: [],

	/**
	 * Feature plug-ins.
	 * 
	 * This is an object of callbacks which provide the features for DataTables
	 * to be initialised via the `layout` option.
	 */
	features: {},


	/**
	 * Row searching.
	 * 
	 * This method of searching is complimentary to the default type based
	 * searching, and a lot more comprehensive as it allows you complete control
	 * over the searching logic. Each element in this array is a function
	 * (parameters described below) that is called for every row in the table,
	 * and your logic decides if it should be included in the searching data set
	 * or not.
	 *
	 * Searching functions have the following input parameters:
	 *
	 * 1. `{object}` DataTables settings object: see
	 *    {@link DataTable.models.oSettings}
	 * 2. `{array|object}` Data for the row to be processed (same as the
	 *    original format that was passed in as the data source, or an array
	 *    from a DOM data source
	 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
	 *    can be useful to retrieve the `TR` element if you need DOM interaction.
	 *
	 * And the following return is expected:
	 *
	 * * {boolean} Include the row in the searched result set (true) or not
	 *   (false)
	 *
	 * Note that as with the main search ability in DataTables, technically this
	 * is "filtering", since it is subtractive. However, for consistency in
	 * naming we call it searching here.
	 *
	 *  @type array
	 *  @default []
	 *
	 *  @example
	 *    // The following example shows custom search being applied to the
	 *    // fourth column (i.e. the data[3] index) based on two input values
	 *    // from the end-user, matching the data in a certain range.
	 *    $.fn.dataTable.ext.search.push(
	 *      function( settings, data, dataIndex ) {
	 *        var min = document.getElementById('min').value * 1;
	 *        var max = document.getElementById('max').value * 1;
	 *        var version = data[3] == "-" ? 0 : data[3]*1;
	 *
	 *        if ( min == "" && max == "" ) {
	 *          return true;
	 *        }
	 *        else if ( min == "" && version < max ) {
	 *          return true;
	 *        }
	 *        else if ( min < version && "" == max ) {
	 *          return true;
	 *        }
	 *        else if ( min < version && version < max ) {
	 *          return true;
	 *        }
	 *        return false;
	 *      }
	 *    );
	 */
	search: [],


	/**
	 * Selector extensions
	 *
	 * The `selector` option can be used to extend the options available for the
	 * selector modifier options (`selector-modifier` object data type) that
	 * each of the three built in selector types offer (row, column and cell +
	 * their plural counterparts). For example the Select extension uses this
	 * mechanism to provide an option to select only rows, columns and cells
	 * that have been marked as selected by the end user (`{selected: true}`),
	 * which can be used in conjunction with the existing built in selector
	 * options.
	 *
	 * Each property is an array to which functions can be pushed. The functions
	 * take three attributes:
	 *
	 * * Settings object for the host table
	 * * Options object (`selector-modifier` object type)
	 * * Array of selected item indexes
	 *
	 * The return is an array of the resulting item indexes after the custom
	 * selector has been applied.
	 *
	 *  @type object
	 */
	selector: {
		cell: [],
		column: [],
		row: []
	},


	/**
	 * Legacy configuration options. Enable and disable legacy options that
	 * are available in DataTables.
	 *
	 *  @type object
	 */
	legacy: {
		/**
		 * Enable / disable DataTables 1.9 compatible server-side processing
		 * requests
		 *
		 *  @type boolean
		 *  @default null
		 */
		ajax: null
	},


	/**
	 * Pagination plug-in methods.
	 * 
	 * Each entry in this object is a function and defines which buttons should
	 * be shown by the pagination rendering method that is used for the table:
	 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
	 * buttons are displayed in the document, while the functions here tell it
	 * what buttons to display. This is done by returning an array of button
	 * descriptions (what each button will do).
	 *
	 * Pagination types (the four built in options and any additional plug-in
	 * options defined here) can be used through the `paginationType`
	 * initialisation parameter.
	 *
	 * The functions defined take two parameters:
	 *
	 * 1. `{int} page` The current page index
	 * 2. `{int} pages` The number of pages in the table
	 *
	 * Each function is expected to return an array where each element of the
	 * array can be one of:
	 *
	 * * `first` - Jump to first page when activated
	 * * `last` - Jump to last page when activated
	 * * `previous` - Show previous page when activated
	 * * `next` - Show next page when activated
	 * * `{int}` - Show page of the index given
	 * * `{array}` - A nested array containing the above elements to add a
	 *   containing 'DIV' element (might be useful for styling).
	 *
	 * Note that DataTables v1.9- used this object slightly differently whereby
	 * an object with two functions would be defined for each plug-in. That
	 * ability is still supported by DataTables 1.10+ to provide backwards
	 * compatibility, but this option of use is now decremented and no longer
	 * documented in DataTables 1.10+.
	 *
	 *  @type object
	 *  @default {}
	 *
	 *  @example
	 *    // Show previous, next and current page buttons only
	 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
	 *      return [ 'previous', page, 'next' ];
	 *    };
	 */
	pager: {},


	renderer: {
		pageButton: {},
		header: {}
	},


	/**
	 * Ordering plug-ins - custom data source
	 * 
	 * The extension options for ordering of data available here is complimentary
	 * to the default type based ordering that DataTables typically uses. It
	 * allows much greater control over the the data that is being used to
	 * order a column, but is necessarily therefore more complex.
	 * 
	 * This type of ordering is useful if you want to do ordering based on data
	 * live from the DOM (for example the contents of an 'input' element) rather
	 * than just the static string that DataTables knows of.
	 * 
	 * The way these plug-ins work is that you create an array of the values you
	 * wish to be ordering for the column in question and then return that
	 * array. The data in the array much be in the index order of the rows in
	 * the table (not the currently ordering order!). Which order data gathering
	 * function is run here depends on the `dt-init columns.orderDataType`
	 * parameter that is used for the column (if any).
	 *
	 * The functions defined take two parameters:
	 *
	 * 1. `{object}` DataTables settings object: see
	 *    {@link DataTable.models.oSettings}
	 * 2. `{int}` Target column index
	 *
	 * Each function is expected to return an array:
	 *
	 * * `{array}` Data for the column to be ordering upon
	 *
	 *  @type array
	 *
	 *  @example
	 *    // Ordering using `input` node values
	 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
	 *    {
	 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
	 *        return $('input', td).val();
	 *      } );
	 *    }
	 */
	order: {},


	/**
	 * Type based plug-ins.
	 *
	 * Each column in DataTables has a type assigned to it, either by automatic
	 * detection or by direct assignment using the `type` option for the column.
	 * The type of a column will effect how it is ordering and search (plug-ins
	 * can also make use of the column type if required).
	 *
	 * @namespace
	 */
	type: {
		/**
		 * Automatic column class assignment
		 */
		className: {},

		/**
		 * Type detection functions.
		 *
		 * The functions defined in this object are used to automatically detect
		 * a column's type, making initialisation of DataTables super easy, even
		 * when complex data is in the table.
		 *
		 * The functions defined take two parameters:
		 *
	     *  1. `{*}` Data from the column cell to be analysed
	     *  2. `{settings}` DataTables settings object. This can be used to
	     *     perform context specific type detection - for example detection
	     *     based on language settings such as using a comma for a decimal
	     *     place. Generally speaking the options from the settings will not
	     *     be required
		 *
		 * Each function is expected to return:
		 *
		 * * `{string|null}` Data type detected, or null if unknown (and thus
		 *   pass it on to the other type detection functions.
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Currency type detection plug-in:
		 *    $.fn.dataTable.ext.type.detect.push(
		 *      function ( data, settings ) {
		 *        // Check the numeric part
		 *        if ( ! data.substring(1).match(/[0-9]/) ) {
		 *          return null;
		 *        }
		 *
		 *        // Check prefixed by currency
		 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
		 *          return 'currency';
		 *        }
		 *        return null;
		 *      }
		 *    );
		 */
		detect: [],

		/**
		 * Automatic renderer assignment
		 */
		render: {},


		/**
		 * Type based search formatting.
		 *
		 * The type based searching functions can be used to pre-format the
		 * data to be search on. For example, it can be used to strip HTML
		 * tags or to de-format telephone numbers for numeric only searching.
		 *
		 * Note that is a search is not defined for a column of a given type,
		 * no search formatting will be performed.
		 * 
		 * Pre-processing of searching data plug-ins - When you assign the sType
		 * for a column (or have it automatically detected for you by DataTables
		 * or a type detection plug-in), you will typically be using this for
		 * custom sorting, but it can also be used to provide custom searching
		 * by allowing you to pre-processing the data and returning the data in
		 * the format that should be searched upon. This is done by adding
		 * functions this object with a parameter name which matches the sType
		 * for that target column. This is the corollary of <i>afnSortData</i>
		 * for searching data.
		 *
		 * The functions defined take a single parameter:
		 *
	     *  1. `{*}` Data from the column cell to be prepared for searching
		 *
		 * Each function is expected to return:
		 *
		 * * `{string|null}` Formatted string that will be used for the searching.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
		 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
		 *    }
		 */
		search: {},


		/**
		 * Type based ordering.
		 *
		 * The column type tells DataTables what ordering to apply to the table
		 * when a column is sorted upon. The order for each type that is defined,
		 * is defined by the functions available in this object.
		 *
		 * Each ordering option can be described by three properties added to
		 * this object:
		 *
		 * * `{type}-pre` - Pre-formatting function
		 * * `{type}-asc` - Ascending order function
		 * * `{type}-desc` - Descending order function
		 *
		 * All three can be used together, only `{type}-pre` or only
		 * `{type}-asc` and `{type}-desc` together. It is generally recommended
		 * that only `{type}-pre` is used, as this provides the optimal
		 * implementation in terms of speed, although the others are provided
		 * for compatibility with existing Javascript sort functions.
		 *
		 * `{type}-pre`: Functions defined take a single parameter:
		 *
	     *  1. `{*}` Data from the column cell to be prepared for ordering
		 *
		 * And return:
		 *
		 * * `{*}` Data to be sorted upon
		 *
		 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
		 * functions, taking two parameters:
		 *
	     *  1. `{*}` Data to compare to the second parameter
	     *  2. `{*}` Data to compare to the first parameter
		 *
		 * And returning:
		 *
		 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
		 *   than the second parameter, ===0 if the two parameters are equal and
		 *   >0 if the first parameter should be sorted height than the second
		 *   parameter.
		 * 
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Numeric ordering of formatted numbers with a pre-formatter
		 *    $.extend( $.fn.dataTable.ext.type.order, {
		 *      "string-pre": function(x) {
		 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
		 *        return parseFloat( a );
		 *      }
		 *    } );
		 *
		 *  @example
		 *    // Case-sensitive string ordering, with no pre-formatting method
		 *    $.extend( $.fn.dataTable.ext.order, {
		 *      "string-case-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-case-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
		 */
		order: {}
	},

	/**
	 * Unique DataTables instance counter
	 *
	 * @type int
	 * @private
	 */
	_unique: 0,


	//
	// Depreciated
	// The following properties are retained for backwards compatibility only.
	// The should not be used in new projects and will be removed in a future
	// version
	//

	/**
	 * Version check function.
	 *  @type function
	 *  @depreciated Since 1.10
	 */
	fnVersionCheck: DataTable.fnVersionCheck,


	/**
	 * Index for what 'this' index API functions should use
	 *  @type int
	 *  @deprecated Since v1.10
	 */
	iApiIndex: 0,


	/**
	 * Software version
	 *  @type string
	 *  @deprecated Since v1.10
	 */
	sVersion: DataTable.version
};


//
// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
//
$.extend( _ext, {
	afnFiltering: _ext.search,
	aTypes:       _ext.type.detect,
	ofnSearch:    _ext.type.search,
	oSort:        _ext.type.order,
	afnSortData:  _ext.order,
	aoFeatures:   _ext.feature,
	oStdClasses:  _ext.classes,
	oPagination:  _ext.pager
} );


$.extend( DataTable.ext.classes, {
	container: 'dt-container',
	empty: {
		row: 'dt-empty'
	},
	info: {
		container: 'dt-info'
	},
	layout: {
		row: 'dt-layout-row',
		cell: 'dt-layout-cell',
		tableRow: 'dt-layout-table',
		tableCell: '',
		start: 'dt-layout-start',
		end: 'dt-layout-end',
		full: 'dt-layout-full'
	},
	length: {
		container: 'dt-length',
		select: 'dt-input'
	},
	order: {
		canAsc: 'dt-orderable-asc',
		canDesc: 'dt-orderable-desc',
		isAsc: 'dt-ordering-asc',
		isDesc: 'dt-ordering-desc',
		none: 'dt-orderable-none',
		position: 'sorting_'
	},
	processing: {
		container: 'dt-processing'
	},
	scrolling: {
		body: 'dt-scroll-body',
		container: 'dt-scroll',
		footer: {
			self: 'dt-scroll-foot',
			inner: 'dt-scroll-footInner'
		},
		header: {
			self: 'dt-scroll-head',
			inner: 'dt-scroll-headInner'
		}
	},
	search: {
		container: 'dt-search',
		input: 'dt-input'
	},
	table: 'dataTable',	
	tbody: {
		cell: '',
		row: ''
	},
	thead: {
		cell: '',
		row: ''
	},
	tfoot: {
		cell: '',
		row: ''
	},
	paging: {
		active: 'current',
		button: 'dt-paging-button',
		container: 'dt-paging',
		disabled: 'disabled',
		nav: ''
	}
} );


/*
 * It is useful to have variables which are scoped locally so only the
 * DataTables functions can access them and they don't leak into global space.
 * At the same time these functions are often useful over multiple files in the
 * core and API, so we list, or at least document, all variables which are used
 * by DataTables as private variables here. This also ensures that there is no
 * clashing of variable names and that they can easily referenced for reuse.
 */


// Defined else where
//  _selector_run
//  _selector_opts
//  _selector_row_indexes

var _ext; // DataTable.ext
var _Api; // DataTable.Api
var _api_register; // DataTable.Api.register
var _api_registerPlural; // DataTable.Api.registerPlural

var _re_dic = {};
var _re_new_lines = /[\r\n\u2028]/g;
var _re_html = /<([^>]*>)/g;
var _max_str_len = Math.pow(2, 28);

// This is not strict ISO8601 - Date.parse() is quite lax, although
// implementations differ between browsers.
var _re_date = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;

// Escape regular expression special characters
var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );

// https://en.wikipedia.org/wiki/Foreign_exchange_market
// - \u20BD - Russian ruble.
// - \u20a9 - South Korean Won
// - \u20BA - Turkish Lira
// - \u20B9 - Indian Rupee
// - R - Brazil (R$) and South Africa
// - fr - Swiss Franc
// - kr - Swedish krona, Norwegian krone and Danish krone
// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
// - Ƀ - Bitcoin
// - Ξ - Ethereum
//   standards as thousands separators.
var _re_formatted_numeric = /['\u00A0,$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfkɃΞ]/gi;


var _empty = function ( d ) {
	return !d || d === true || d === '-' ? true : false;
};


var _intVal = function ( s ) {
	var integer = parseInt( s, 10 );
	return !isNaN(integer) && isFinite(s) ? integer : null;
};

// Convert from a formatted number with characters other than `.` as the
// decimal place, to a Javascript number
var _numToDecimal = function ( num, decimalPoint ) {
	// Cache created regular expressions for speed as this function is called often
	if ( ! _re_dic[ decimalPoint ] ) {
		_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
	}
	return typeof num === 'string' && decimalPoint !== '.' ?
		num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
		num;
};


var _isNumber = function ( d, decimalPoint, formatted, allowEmpty ) {
	var type = typeof d;
	var strType = type === 'string';

	if ( type === 'number' || type === 'bigint') {
		return true;
	}

	// If empty return immediately so there must be a number if it is a
	// formatted string (this stops the string "k", or "kr", etc being detected
	// as a formatted number for currency
	if ( allowEmpty && _empty( d ) ) {
		return true;
	}

	if ( decimalPoint && strType ) {
		d = _numToDecimal( d, decimalPoint );
	}

	if ( formatted && strType ) {
		d = d.replace( _re_formatted_numeric, '' );
	}

	return !isNaN( parseFloat(d) ) && isFinite( d );
};


// A string without HTML in it can be considered to be HTML still
var _isHtml = function ( d ) {
	return _empty( d ) || typeof d === 'string';
};

// Is a string a number surrounded by HTML?
var _htmlNumeric = function ( d, decimalPoint, formatted, allowEmpty ) {
	if ( allowEmpty && _empty( d ) ) {
		return true;
	}

	// input and select strings mean that this isn't just a number
	if (typeof d === 'string' && d.match(/<(input|select)/i)) {
		return null;
	}

	var html = _isHtml( d );
	return ! html ?
		null :
		_isNumber( _stripHtml( d ), decimalPoint, formatted, allowEmpty ) ?
			true :
			null;
};


var _pluck = function ( a, prop, prop2 ) {
	var out = [];
	var i=0, ien=a.length;

	// Could have the test in the loop for slightly smaller code, but speed
	// is essential here
	if ( prop2 !== undefined ) {
		for ( ; i<ien ; i++ ) {
			if ( a[i] && a[i][ prop ] ) {
				out.push( a[i][ prop ][ prop2 ] );
			}
		}
	}
	else {
		for ( ; i<ien ; i++ ) {
			if ( a[i] ) {
				out.push( a[i][ prop ] );
			}
		}
	}

	return out;
};


// Basically the same as _pluck, but rather than looping over `a` we use `order`
// as the indexes to pick from `a`
var _pluck_order = function ( a, order, prop, prop2 )
{
	var out = [];
	var i=0, ien=order.length;

	// Could have the test in the loop for slightly smaller code, but speed
	// is essential here
	if ( prop2 !== undefined ) {
		for ( ; i<ien ; i++ ) {
			if ( a[ order[i] ] && a[ order[i] ][ prop ] ) {
				out.push( a[ order[i] ][ prop ][ prop2 ] );
			}
		}
	}
	else {
		for ( ; i<ien ; i++ ) {
			if ( a[ order[i] ] ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	}

	return out;
};


var _range = function ( len, start )
{
	var out = [];
	var end;

	if ( start === undefined ) {
		start = 0;
		end = len;
	}
	else {
		end = start;
		start = len;
	}

	for ( var i=start ; i<end ; i++ ) {
		out.push( i );
	}

	return out;
};


var _removeEmpty = function ( a )
{
	var out = [];

	for ( var i=0, ien=a.length ; i<ien ; i++ ) {
		if ( a[i] ) { // careful - will remove all falsy values!
			out.push( a[i] );
		}
	}

	return out;
};

// Replaceable function in api.util
var _stripHtml = function (input) {
	if (! input || typeof input !== 'string') {
		return input;
	}

	// Irrelevant check to workaround CodeQL's false positive on the regex
	if (input.length > _max_str_len) {
		throw new Error('Exceeded max str len');
	}

	var previous;

	input = input.replace(_re_html, ''); // Complete tags

	// Safety for incomplete script tag - use do / while to ensure that
	// we get all instances
	do {
		previous = input;
		input = input.replace(/<script/i, '');
	} while (input !== previous);

	return previous;
};

// Replaceable function in api.util
var _escapeHtml = function ( d ) {
	if (Array.isArray(d)) {
		d = d.join(',');
	}

	return typeof d === 'string' ?
		d
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;') :
		d;
};

// Remove diacritics from a string by decomposing it and then removing
// non-ascii characters
var _normalize = function (str, both) {
	if (typeof str !== 'string') {
		return str;
	}

	// It is faster to just run `normalize` than it is to check if
	// we need to with a regex! (Check as it isn't available in old
	// Safari)
	var res = str.normalize
		? str.normalize("NFD")
		: str;

	// Equally, here we check if a regex is needed or not
	return res.length !== str.length
		? (both === true ? str + ' ' : '' ) + res.replace(/[\u0300-\u036f]/g, "")
		: res;
}

/**
 * Determine if all values in the array are unique. This means we can short
 * cut the _unique method at the cost of a single loop. A sorted array is used
 * to easily check the values.
 *
 * @param  {array} src Source array
 * @return {boolean} true if all unique, false otherwise
 * @ignore
 */
var _areAllUnique = function ( src ) {
	if ( src.length < 2 ) {
		return true;
	}

	var sorted = src.slice().sort();
	var last = sorted[0];

	for ( var i=1, ien=sorted.length ; i<ien ; i++ ) {
		if ( sorted[i] === last ) {
			return false;
		}

		last = sorted[i];
	}

	return true;
};


/**
 * Find the unique elements in a source array.
 *
 * @param  {array} src Source array
 * @return {array} Array of unique items
 * @ignore
 */
var _unique = function ( src )
{
	if (Array.from && Set) {
		return Array.from(new Set(src));
	}

	if ( _areAllUnique( src ) ) {
		return src.slice();
	}

	// A faster unique method is to use object keys to identify used values,
	// but this doesn't work with arrays or objects, which we must also
	// consider. See jsperf.app/compare-array-unique-versions/4 for more
	// information.
	var
		out = [],
		val,
		i, ien=src.length,
		j, k=0;

	again: for ( i=0 ; i<ien ; i++ ) {
		val = src[i];

		for ( j=0 ; j<k ; j++ ) {
			if ( out[j] === val ) {
				continue again;
			}
		}

		out.push( val );
		k++;
	}

	return out;
};

// Surprisingly this is faster than [].concat.apply
// https://jsperf.com/flatten-an-array-loop-vs-reduce/2
var _flatten = function (out, val) {
	if (Array.isArray(val)) {
		for (var i=0 ; i<val.length ; i++) {
			_flatten(out, val[i]);
		}
	}
	else {
		out.push(val);
	}

	return out;
}

// Similar to jQuery's addClass, but use classList.add
function _addClass(el, name) {
	if (name) {
		name.split(' ').forEach(function (n) {
			if (n) {
				// `add` does deduplication, so no need to check `contains`
				el.classList.add(n);
			}
		});
	}
}

/**
 * DataTables utility methods
 * 
 * This namespace provides helper methods that DataTables uses internally to
 * create a DataTable, but which are not exclusively used only for DataTables.
 * These methods can be used by extension authors to save the duplication of
 * code.
 *
 *  @namespace
 */
DataTable.util = {
	/**
	 * Return a string with diacritic characters decomposed
	 * @param {*} mixed Function or string to normalize
	 * @param {*} both Return original string and the normalized string
	 * @returns String or undefined
	 */
	diacritics: function (mixed, both) {
		var type = typeof mixed;

		if (type !== 'function') {
			return _normalize(mixed, both);
		}
		_normalize = mixed;
	},

	/**
	 * Debounce a function
	 *
	 * @param {function} fn Function to be called
	 * @param {integer} freq Call frequency in mS
	 * @return {function} Wrapped function
	 */
	debounce: function ( fn, timeout ) {
		var timer;

		return function () {
			var that = this;
			var args = arguments;

			clearTimeout(timer);

			timer = setTimeout( function () {
				fn.apply(that, args);
			}, timeout || 250 );
		};
	},

	/**
	 * Throttle the calls to a function. Arguments and context are maintained
	 * for the throttled function.
	 *
	 * @param {function} fn Function to be called
	 * @param {integer} freq Call frequency in mS
	 * @return {function} Wrapped function
	 */
	throttle: function ( fn, freq ) {
		var
			frequency = freq !== undefined ? freq : 200,
			last,
			timer;

		return function () {
			var
				that = this,
				now  = +new Date(),
				args = arguments;

			if ( last && now < last + frequency ) {
				clearTimeout( timer );

				timer = setTimeout( function () {
					last = undefined;
					fn.apply( that, args );
				}, frequency );
			}
			else {
				last = now;
				fn.apply( that, args );
			}
		};
	},

	/**
	 * Escape a string such that it can be used in a regular expression
	 *
	 *  @param {string} val string to escape
	 *  @returns {string} escaped string
	 */
	escapeRegex: function ( val ) {
		return val.replace( _re_escape_regex, '\\$1' );
	},

	/**
	 * Create a function that will write to a nested object or array
	 * @param {*} source JSON notation string
	 * @returns Write function
	 */
	set: function ( source ) {
		if ( $.isPlainObject( source ) ) {
			/* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don't know the type here. This is why an object
			 * option is not documented for `mData` (which is read/write), but it is
			 * for `mRender` which is read only.
			 */
			return DataTable.util.set( source._ );
		}
		else if ( source === null ) {
			// Nothing to do when the data source is null
			return function () {};
		}
		else if ( typeof source === 'function' ) {
			return function (data, val, meta) {
				source( data, 'set', val, meta );
			};
		}
		else if (
			typeof source === 'string' && (source.indexOf('.') !== -1 ||
			source.indexOf('[') !== -1 || source.indexOf('(') !== -1)
		) {
			// Like the get, we need to get data from a nested object
			var setData = function (data, val, src) {
				var a = _fnSplitObjNotation( src ), b;
				var aLast = a[a.length-1];
				var arrayNotation, funcNotation, o, innerSrc;
	
				for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ ) {
					// Protect against prototype pollution
					if (a[i] === '__proto__' || a[i] === 'constructor') {
						throw new Error('Cannot set prototype values');
					}
	
					// Check if we are dealing with an array notation request
					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);
	
					if ( arrayNotation ) {
						a[i] = a[i].replace(__reArray, '');
						data[ a[i] ] = [];
	
						// Get the remainder of the nested object to set so we can recurse
						b = a.slice();
						b.splice( 0, i+1 );
						innerSrc = b.join('.');
	
						// Traverse each entry in the array setting the properties requested
						if ( Array.isArray( val ) ) {
							for ( var j=0, jLen=val.length ; j<jLen ; j++ ) {
								o = {};
								setData( o, val[j], innerSrc );
								data[ a[i] ].push( o );
							}
						}
						else {
							// We've been asked to save data to an array, but it
							// isn't array data to be saved. Best that can be done
							// is to just save the value.
							data[ a[i] ] = val;
						}
	
						// The inner call to setData has already traversed through the remainder
						// of the source and has set the data, thus we can exit here
						return;
					}
					else if ( funcNotation ) {
						// Function call
						a[i] = a[i].replace(__reFn, '');
						data = data[ a[i] ]( val );
					}
	
					// If the nested object doesn't currently exist - since we are
					// trying to set the value - create it
					if ( data[ a[i] ] === null || data[ a[i] ] === undefined ) {
						data[ a[i] ] = {};
					}
					data = data[ a[i] ];
				}
	
				// Last item in the input - i.e, the actual set
				if ( aLast.match(__reFn ) ) {
					// Function call
					data = data[ aLast.replace(__reFn, '') ]( val );
				}
				else {
					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn't used, then we get the result we want anyway
					data[ aLast.replace(__reArray, '') ] = val;
				}
			};
	
			return function (data, val) { // meta is also passed in, but not used
				return setData( data, val, source );
			};
		}
		else {
			// Array or flat object mapping
			return function (data, val) { // meta is also passed in, but not used
				data[source] = val;
			};
		}
	},

	/**
	 * Create a function that will read nested objects from arrays, based on JSON notation
	 * @param {*} source JSON notation string
	 * @returns Value read
	 */
	get: function ( source ) {
		if ( $.isPlainObject( source ) ) {
			// Build an object of get functions, and wrap them in a single call
			var o = {};
			$.each( source, function (key, val) {
				if ( val ) {
					o[key] = DataTable.util.get( val );
				}
			} );
	
			return function (data, type, row, meta) {
				var t = o[type] || o._;
				return t !== undefined ?
					t(data, type, row, meta) :
					data;
			};
		}
		else if ( source === null ) {
			// Give an empty string for rendering / sorting etc
			return function (data) { // type, row and meta also passed, but not used
				return data;
			};
		}
		else if ( typeof source === 'function' ) {
			return function (data, type, row, meta) {
				return source( data, type, row, meta );
			};
		}
		else if (
			typeof source === 'string' && (source.indexOf('.') !== -1 ||
			source.indexOf('[') !== -1 || source.indexOf('(') !== -1)
		) {
			/* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
			var fetchData = function (data, type, src) {
				var arrayNotation, funcNotation, out, innerSrc;
	
				if ( src !== "" ) {
					var a = _fnSplitObjNotation( src );
	
					for ( var i=0, iLen=a.length ; i<iLen ; i++ ) {
						// Check if we are dealing with special notation
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
	
						if ( arrayNotation ) {
							// Array notation
							a[i] = a[i].replace(__reArray, '');
	
							// Condition allows simply [] to be passed in
							if ( a[i] !== "" ) {
								data = data[ a[i] ];
							}
							out = [];
	
							// Get the remainder of the nested object to get
							a.splice( 0, i+1 );
							innerSrc = a.join('.');
	
							// Traverse each entry in the array getting the properties requested
							if ( Array.isArray( data ) ) {
								for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
									out.push( fetchData( data[j], type, innerSrc ) );
								}
							}
	
							// If a string is given in between the array notation indicators, that
							// is used to join the strings together, otherwise an array is returned
							var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
							data = (join==="") ? out : out.join(join);
	
							// The inner call to fetchData has already traversed through the remainder
							// of the source requested, so we exit from the loop
							break;
						}
						else if ( funcNotation ) {
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]();
							continue;
						}
	
						if (data === null || data[ a[i] ] === null) {
							return null;
						}
						else if ( data === undefined || data[ a[i] ] === undefined ) {
							return undefined;
						}

						data = data[ a[i] ];
					}
				}
	
				return data;
			};
	
			return function (data, type) { // row and meta also passed, but not used
				return fetchData( data, type, source );
			};
		}
		else {
			// Array or flat object mapping
			return function (data) { // row and meta also passed, but not used
				return data[source];
			};
		}
	},

	stripHtml: function (mixed) {
		var type = typeof mixed;

		if (type === 'function') {
			_stripHtml = mixed;
			return;
		}
		else if (type === 'string') {
			return _stripHtml(mixed);
		}
		return mixed;
	},

	escapeHtml: function (mixed) {
		var type = typeof mixed;

		if (type === 'function') {
			_escapeHtml = mixed;
			return;
		}
		else if (type === 'string' || Array.isArray(mixed)) {
			return _escapeHtml(mixed);
		}
		return mixed;
	},

	unique: _unique
};



/**
 * Create a mapping object that allows camel case parameters to be looked up
 * for their Hungarian counterparts. The mapping is stored in a private
 * parameter called `_hungarianMap` which can be accessed on the source object.
 *  @param {object} o
 *  @memberof DataTable#oApi
 */
function _fnHungarianMap ( o )
{
	var
		hungarian = 'a aa ai ao as b fn i m o s ',
		match,
		newKey,
		map = {};

	$.each( o, function (key) {
		match = key.match(/^([^A-Z]+?)([A-Z])/);

		if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
		{
			newKey = key.replace( match[0], match[2].toLowerCase() );
			map[ newKey ] = key;

			if ( match[1] === 'o' )
			{
				_fnHungarianMap( o[key] );
			}
		}
	} );

	o._hungarianMap = map;
}


/**
 * Convert from camel case parameters to Hungarian, based on a Hungarian map
 * created by _fnHungarianMap.
 *  @param {object} src The model object which holds all parameters that can be
 *    mapped.
 *  @param {object} user The object to convert from camel case to Hungarian.
 *  @param {boolean} force When set to `true`, properties which already have a
 *    Hungarian value in the `user` object will be overwritten. Otherwise they
 *    won't be.
 *  @memberof DataTable#oApi
 */
function _fnCamelToHungarian ( src, user, force )
{
	if ( ! src._hungarianMap ) {
		_fnHungarianMap( src );
	}

	var hungarianKey;

	$.each( user, function (key) {
		hungarianKey = src._hungarianMap[ key ];

		if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
		{
			// For objects, we need to buzz down into the object to copy parameters
			if ( hungarianKey.charAt(0) === 'o' )
			{
				// Copy the camelCase options over to the hungarian
				if ( ! user[ hungarianKey ] ) {
					user[ hungarianKey ] = {};
				}
				$.extend( true, user[hungarianKey], user[key] );

				_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
			}
			else {
				user[hungarianKey] = user[ key ];
			}
		}
	} );
}

/**
 * Map one parameter onto another
 *  @param {object} o Object to map
 *  @param {*} knew The new parameter name
 *  @param {*} old The old parameter name
 */
var _fnCompatMap = function ( o, knew, old ) {
	if ( o[ knew ] !== undefined ) {
		o[ old ] = o[ knew ];
	}
};


/**
 * Provide backwards compatibility for the main DT options. Note that the new
 * options are mapped onto the old parameters, so this is an external interface
 * change only.
 *  @param {object} init Object to map
 */
function _fnCompatOpts ( init )
{
	_fnCompatMap( init, 'ordering',      'bSort' );
	_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
	_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
	_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
	_fnCompatMap( init, 'order',         'aaSorting' );
	_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
	_fnCompatMap( init, 'paging',        'bPaginate' );
	_fnCompatMap( init, 'pagingType',    'sPaginationType' );
	_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
	_fnCompatMap( init, 'searching',     'bFilter' );

	// Boolean initialisation of x-scrolling
	if ( typeof init.sScrollX === 'boolean' ) {
		init.sScrollX = init.sScrollX ? '100%' : '';
	}
	if ( typeof init.scrollX === 'boolean' ) {
		init.scrollX = init.scrollX ? '100%' : '';
	}

	// Column search objects are in an array, so it needs to be converted
	// element by element
	var searchCols = init.aoSearchCols;

	if ( searchCols ) {
		for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
			if ( searchCols[i] ) {
				_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
			}
		}
	}

	// Enable search delay if server-side processing is enabled
	if (init.serverSide && ! init.searchDelay) {
		init.searchDelay = 400;
	}
}


/**
 * Provide backwards compatibility for column options. Note that the new options
 * are mapped onto the old parameters, so this is an external interface change
 * only.
 *  @param {object} init Object to map
 */
function _fnCompatCols ( init )
{
	_fnCompatMap( init, 'orderable',     'bSortable' );
	_fnCompatMap( init, 'orderData',     'aDataSort' );
	_fnCompatMap( init, 'orderSequence', 'asSorting' );
	_fnCompatMap( init, 'orderDataType', 'sortDataType' );

	// orderData can be given as an integer
	var dataSort = init.aDataSort;
	if ( typeof dataSort === 'number' && ! Array.isArray( dataSort ) ) {
		init.aDataSort = [ dataSort ];
	}
}


/**
 * Browser feature detection for capabilities, quirks
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnBrowserDetect( settings )
{
	// We don't need to do this every time DataTables is constructed, the values
	// calculated are specific to the browser and OS configuration which we
	// don't expect to change between initialisations
	if ( ! DataTable.__browser ) {
		var browser = {};
		DataTable.__browser = browser;

		// Scrolling feature / quirks detection
		var n = $('<div/>')
			.css( {
				position: 'fixed',
				top: 0,
				left: -1 * window.pageXOffset, // allow for scrolling
				height: 1,
				width: 1,
				overflow: 'hidden'
			} )
			.append(
				$('<div/>')
					.css( {
						position: 'absolute',
						top: 1,
						left: 1,
						width: 100,
						overflow: 'scroll'
					} )
					.append(
						$('<div/>')
							.css( {
								width: '100%',
								height: 10
							} )
					)
			)
			.appendTo( 'body' );

		var outer = n.children();
		var inner = outer.children();

		// Get scrollbar width
		browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;

		// In rtl text layout, some browsers (most, but not all) will place the
		// scrollbar on the left, rather than the right.
		browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;

		n.remove();
	}

	$.extend( settings.oBrowser, DataTable.__browser );
	settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
}

/**
 * Add a column to the list used for the table with default values
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAddColumn( oSettings )
{
	// Add column to aoColumns array
	var oDefaults = DataTable.defaults.column;
	var iCol = oSettings.aoColumns.length;
	var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
		"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
		"mData": oDefaults.mData ? oDefaults.mData : iCol,
		idx: iCol,
		searchFixed: {},
		colEl: $('<col>').attr('data-dt-column', iCol)
	} );
	oSettings.aoColumns.push( oCol );

	// Add search object for column specific search. Note that the `searchCols[ iCol ]`
	// passed into extend can be undefined. This allows the user to give a default
	// with only some of the parameters defined, and also not give a default
	var searchCols = oSettings.aoPreSearchCols;
	searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
}


/**
 * Apply options for a column
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iCol column index to consider
 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
 *  @memberof DataTable#oApi
 */
function _fnColumnOptions( oSettings, iCol, oOptions )
{
	var oCol = oSettings.aoColumns[ iCol ];

	/* User specified column options */
	if ( oOptions !== undefined && oOptions !== null )
	{
		// Backwards compatibility
		_fnCompatCols( oOptions );

		// Map camel case parameters to their Hungarian counterparts
		_fnCamelToHungarian( DataTable.defaults.column, oOptions, true );

		/* Backwards compatibility for mDataProp */
		if ( oOptions.mDataProp !== undefined && !oOptions.mData )
		{
			oOptions.mData = oOptions.mDataProp;
		}

		if ( oOptions.sType )
		{
			oCol._sManualType = oOptions.sType;
		}
	
		// `class` is a reserved word in Javascript, so we need to provide
		// the ability to use a valid name for the camel case input
		if ( oOptions.className && ! oOptions.sClass )
		{
			oOptions.sClass = oOptions.className;
		}

		var origClass = oCol.sClass;

		$.extend( oCol, oOptions );
		_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );

		// Merge class from previously defined classes with this one, rather than just
		// overwriting it in the extend above
		if (origClass !== oCol.sClass) {
			oCol.sClass = origClass + ' ' + oCol.sClass;
		}

		/* iDataSort to be applied (backwards compatibility), but aDataSort will take
		 * priority if defined
		 */
		if ( oOptions.iDataSort !== undefined )
		{
			oCol.aDataSort = [ oOptions.iDataSort ];
		}
		_fnMap( oCol, oOptions, "aDataSort" );
	}

	/* Cache the data get and set functions for speed */
	var mDataSrc = oCol.mData;
	var mData = _fnGetObjectDataFn( mDataSrc );

	// The `render` option can be given as an array to access the helper rendering methods.
	// The first element is the rendering method to use, the rest are the parameters to pass
	if ( oCol.mRender && Array.isArray( oCol.mRender ) ) {
		var copy = oCol.mRender.slice();
		var name = copy.shift();

		oCol.mRender = DataTable.render[name].apply(window, copy);
	}

	oCol._render = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;

	var attrTest = function( src ) {
		return typeof src === 'string' && src.indexOf('@') !== -1;
	};
	oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
		attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
	);
	oCol._setter = null;

	oCol.fnGetData = function (rowData, type, meta) {
		var innerData = mData( rowData, type, undefined, meta );

		return oCol._render && type ?
			oCol._render( innerData, type, rowData, meta ) :
			innerData;
	};
	oCol.fnSetData = function ( rowData, val, meta ) {
		return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
	};

	// Indicate if DataTables should read DOM data as an object or array
	// Used in _fnGetRowElements
	if ( typeof mDataSrc !== 'number' && ! oCol._isArrayHost ) {
		oSettings._rowReadObject = true;
	}

	/* Feature sorting overrides column specific when off */
	if ( !oSettings.oFeatures.bSort )
	{
		oCol.bSortable = false;
	}
}


/**
 * Adjust the table column widths for new data. Note: you would probably want to
 * do a redraw after calling this function!
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAdjustColumnSizing ( settings )
{
	_fnCalculateColumnWidths( settings );
	_fnColumnSizes( settings );

	var scroll = settings.oScroll;
	if ( scroll.sY !== '' || scroll.sX !== '') {
		_fnScrollDraw( settings );
	}

	_fnCallbackFire( settings, null, 'column-sizing', [settings] );
}

/**
 * Apply column sizes
 *
 * @param {*} settings DataTables settings object
 */
function _fnColumnSizes ( settings )
{
	var cols = settings.aoColumns;

	for (var i=0 ; i<cols.length ; i++) {
		var width = _fnColumnsSumWidth(settings, [i], false, false);

		cols[i].colEl.css('width', width);

		if (settings.oScroll.sX) {
			cols[i].colEl.css('min-width', width);
		}
	}
}


/**
 * Convert the index of a visible column to the index in the data array (take account
 * of hidden columns)
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iMatch Visible column index to lookup
 *  @returns {int} i the data index
 *  @memberof DataTable#oApi
 */
function _fnVisibleToColumnIndex( oSettings, iMatch )
{
	var aiVis = _fnGetColumns( oSettings, 'bVisible' );

	return typeof aiVis[iMatch] === 'number' ?
		aiVis[iMatch] :
		null;
}


/**
 * Convert the index of an index in the data array and convert it to the visible
 *   column index (take account of hidden columns)
 *  @param {int} iMatch Column index to lookup
 *  @param {object} oSettings dataTables settings object
 *  @returns {int} i the data index
 *  @memberof DataTable#oApi
 */
function _fnColumnIndexToVisible( oSettings, iMatch )
{
	var aiVis = _fnGetColumns( oSettings, 'bVisible' );
	var iPos = aiVis.indexOf(iMatch);

	return iPos !== -1 ? iPos : null;
}


/**
 * Get the number of visible columns
 *  @param {object} oSettings dataTables settings object
 *  @returns {int} i the number of visible columns
 *  @memberof DataTable#oApi
 */
function _fnVisbleColumns( settings )
{
	var layout = settings.aoHeader;
	var columns = settings.aoColumns;
	var vis = 0;

	if ( layout.length ) {
		for ( var i=0, ien=layout[0].length ; i<ien ; i++ ) {
			if ( columns[i].bVisible && $(layout[0][i].cell).css('display') !== 'none' ) {
				vis++;
			}
		}
	}

	return vis;
}


/**
 * Get an array of column indexes that match a given property
 *  @param {object} oSettings dataTables settings object
 *  @param {string} sParam Parameter in aoColumns to look for - typically
 *    bVisible or bSearchable
 *  @returns {array} Array of indexes with matched properties
 *  @memberof DataTable#oApi
 */
function _fnGetColumns( oSettings, sParam )
{
	var a = [];

	oSettings.aoColumns.map( function(val, i) {
		if ( val[sParam] ) {
			a.push( i );
		}
	} );

	return a;
}

/**
 * Allow the result from a type detection function to be `true` while
 * translating that into a string. Old type detection functions will
 * return the type name if it passes. An obect store would be better,
 * but not backwards compatible.
 *
 * @param {*} typeDetect Object or function for type detection
 * @param {*} res Result from the type detection function
 * @returns Type name or false
 */
function _typeResult (typeDetect, res) {
	return res === true
		? typeDetect._name
		: res;
}

/**
 * Calculate the 'type' of a column
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnColumnTypes ( settings )
{
	var columns = settings.aoColumns;
	var data = settings.aoData;
	var types = DataTable.ext.type.detect;
	var i, ien, j, jen, k, ken;
	var col, detectedType, cache;

	// For each column, spin over the data type detection functions, seeing if one matches
	for ( i=0, ien=columns.length ; i<ien ; i++ ) {
		col = columns[i];
		cache = [];

		if ( ! col.sType && col._sManualType ) {
			col.sType = col._sManualType;
		}
		else if ( ! col.sType ) {
			// With SSP type detection can be unreliable and error prone, so we provide a way
			// to turn it off.
			if (! settings.typeDetect) {
				return;
			}

			for ( j=0, jen=types.length ; j<jen ; j++ ) {
				var typeDetect = types[j];

				// There can be either one, or three type detection functions
				var oneOf = typeDetect.oneOf;
				var allOf = typeDetect.allOf || typeDetect;
				var init = typeDetect.init;
				var one = false;

				detectedType = null;

				// Fast detect based on column assignment
				if (init) {
					detectedType = _typeResult(typeDetect, init(settings, col, i));

					if (detectedType) {
						col.sType = detectedType;
						break;
					}
				}

				for ( k=0, ken=data.length ; k<ken ; k++ ) {
					if (! data[k]) {
						continue;
					}

					// Use a cache array so we only need to get the type data
					// from the formatter once (when using multiple detectors)
					if ( cache[k] === undefined ) {
						cache[k] = _fnGetCellData( settings, k, i, 'type' );
					}

					// Only one data point in the column needs to match this function
					if (oneOf && ! one) {
						one = _typeResult(typeDetect, oneOf( cache[k], settings ));
					}

					// All data points need to match this function
					detectedType = _typeResult(typeDetect, allOf( cache[k], settings ));

					// If null, then this type can't apply to this column, so
					// rather than testing all cells, break out. There is an
					// exception for the last type which is `html`. We need to
					// scan all rows since it is possible to mix string and HTML
					// types
					if ( ! detectedType && j !== types.length-3 ) {
						break;
					}

					// Only a single match is needed for html type since it is
					// bottom of the pile and very similar to string - but it
					// must not be empty
					if ( detectedType === 'html' && ! _empty(cache[k]) ) {
						break;
					}
				}

				// Type is valid for all data points in the column - use this
				// type
				if ( (oneOf && one && detectedType) || (!oneOf && detectedType) ) {
					col.sType = detectedType;
					break;
				}
			}

			// Fall back - if no type was detected, always use string
			if ( ! col.sType ) {
				col.sType = 'string';
			}
		}

		// Set class names for header / footer for auto type classes
		var autoClass = _ext.type.className[col.sType];

		if (autoClass) {
			_columnAutoClass(settings.aoHeader, i, autoClass);
			_columnAutoClass(settings.aoFooter, i, autoClass);
		}

		var renderer = _ext.type.render[col.sType];

		// This can only happen once! There is no way to remove
		// a renderer. After the first time the renderer has
		// already been set so createTr will run the renderer itself.
		if (renderer && ! col._render) {
			col._render = DataTable.util.get(renderer);

			_columnAutoRender(settings, i);
		}
	}
}

/**
 * Apply an auto detected renderer to data which doesn't yet have
 * a renderer
 */
function _columnAutoRender(settings, colIdx) {
	var data = settings.aoData;

	for (var i=0 ; i<data.length ; i++) {
		if (data[i].nTr) {
			// We have to update the display here since there is no
			// invalidation check for the data
			var display = _fnGetCellData( settings, i, colIdx, 'display' );

			data[i].displayData[colIdx] = display;
			_fnWriteCell(data[i].anCells[colIdx], display);

			// No need to update sort / filter data since it has
			// been invalidated and will be re-read with the
			// renderer now applied
		}
	}
}

/**
 * Apply a class name to a column's header cells
 */
function _columnAutoClass(container, colIdx, className) {
	container.forEach(function (row) {
		if (row[colIdx] && row[colIdx].unique) {
			_addClass(row[colIdx].cell, className);
		}
	});
}

/**
 * Take the column definitions and static columns arrays and calculate how
 * they relate to column indexes. The callback function will then apply the
 * definition found for a column to a suitable configuration object.
 *  @param {object} oSettings dataTables settings object
 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
 *  @param {array} aoCols The aoColumns array that defines columns individually
 *  @param {array} headerLayout Layout for header as it was loaded
 *  @param {function} fn Callback function - takes two parameters, the calculated
 *    column index and the definition for that column.
 *  @memberof DataTable#oApi
 */
function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, headerLayout, fn )
{
	var i, iLen, j, jLen, k, kLen, def;
	var columns = oSettings.aoColumns;

	if ( aoCols ) {
		for ( i=0, iLen=aoCols.length ; i<iLen ; i++ ) {
			if (aoCols[i] && aoCols[i].name) {
				columns[i].sName = aoCols[i].name;
			}
		}
	}

	// Column definitions with aTargets
	if ( aoColDefs )
	{
		/* Loop over the definitions array - loop in reverse so first instance has priority */
		for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
		{
			def = aoColDefs[i];

			/* Each definition can target multiple columns, as it is an array */
			var aTargets = def.target !== undefined
				? def.target
				: def.targets !== undefined
					? def.targets
					: def.aTargets;

			if ( ! Array.isArray( aTargets ) )
			{
				aTargets = [ aTargets ];
			}

			for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
			{
				var target = aTargets[j];

				if ( typeof target === 'number' && target >= 0 )
				{
					/* Add columns that we don't yet know about */
					while( columns.length <= target )
					{
						_fnAddColumn( oSettings );
					}

					/* Integer, basic index */
					fn( target, def );
				}
				else if ( typeof target === 'number' && target < 0 )
				{
					/* Negative integer, right to left column counting */
					fn( columns.length+target, def );
				}
				else if ( typeof target === 'string' )
				{
					for ( k=0, kLen=columns.length ; k<kLen ; k++ ) {
						if (target === '_all') {
							// Apply to all columns
							fn( k, def );
						}
						else if (target.indexOf(':name') !== -1) {
							// Column selector
							if (columns[k].sName === target.replace(':name', '')) {
								fn( k, def );
							}
						}
						else {
							// Cell selector
							headerLayout.forEach(function (row) {
								if (row[k]) {
									var cell = $(row[k].cell);

									// Legacy support. Note that it means that we don't support
									// an element name selector only, since they are treated as
									// class names for 1.x compat.
									if (target.match(/^[a-z][\w-]*$/i)) {
										target = '.' + target;
									}

									if (cell.is( target )) {
										fn( k, def );
									}
								}
							});
						}
					}
				}
			}
		}
	}

	// Statically defined columns array
	if ( aoCols ) {
		for ( i=0, iLen=aoCols.length ; i<iLen ; i++ ) {
			fn( i, aoCols[i] );
		}
	}
}


/**
 * Get the width for a given set of columns
 *
 * @param {*} settings DataTables settings object
 * @param {*} targets Columns - comma separated string or array of numbers
 * @param {*} original Use the original width (true) or calculated (false)
 * @param {*} incVisible Include visible columns (true) or not (false)
 * @returns Combined CSS value
 */
function _fnColumnsSumWidth( settings, targets, original, incVisible ) {
	if ( ! Array.isArray( targets ) ) {
		targets = _fnColumnsFromHeader( targets );
	}

	var sum = 0;
	var unit;
	var columns = settings.aoColumns;
	
	for ( var i=0, ien=targets.length ; i<ien ; i++ ) {
		var column = columns[ targets[i] ];
		var definedWidth = original ?
			column.sWidthOrig :
			column.sWidth;

		if ( ! incVisible && column.bVisible === false ) {
			continue;
		}

		if ( definedWidth === null || definedWidth === undefined ) {
			return null; // can't determine a defined width - browser defined
		}
		else if ( typeof definedWidth === 'number' ) {
			unit = 'px';
			sum += definedWidth;
		}
		else {
			var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);

			if ( matched ) {
				sum += matched[1] * 1;
				unit = matched.length === 3 ?
					matched[2] :
					'px';
			}
		}
	}

	return sum + unit;
}

function _fnColumnsFromHeader( cell )
{
	var attr = $(cell).closest('[data-dt-column]').attr('data-dt-column');

	if ( ! attr ) {
		return [];
	}

	return attr.split(',').map( function (val) {
		return val * 1;
	} );
}
/**
 * Add a data array to the table, creating DOM node etc. This is the parallel to
 * _fnGatherData, but for adding rows from a Javascript source, rather than a
 * DOM source.
 *  @param {object} settings dataTables settings object
 *  @param {array} data data array to be added
 *  @param {node} [tr] TR element to add to the table - optional. If not given,
 *    DataTables will create a row automatically
 *  @param {array} [tds] Array of TD|TH elements for the row - must be given
 *    if nTr is.
 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
 *  @memberof DataTable#oApi
 */
function _fnAddData ( settings, dataIn, tr, tds )
{
	/* Create the object for storing information about this new row */
	var rowIdx = settings.aoData.length;
	var rowModel = $.extend( true, {}, DataTable.models.oRow, {
		src: tr ? 'dom' : 'data',
		idx: rowIdx
	} );

	rowModel._aData = dataIn;
	settings.aoData.push( rowModel );

	var columns = settings.aoColumns;

	for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
	{
		// Invalidate the column types as the new data needs to be revalidated
		columns[i].sType = null;
	}

	/* Add to the display array */
	settings.aiDisplayMaster.push( rowIdx );

	var id = settings.rowIdFn( dataIn );
	if ( id !== undefined ) {
		settings.aIds[ id ] = rowModel;
	}

	/* Create the DOM information, or register it if already present */
	if ( tr || ! settings.oFeatures.bDeferRender )
	{
		_fnCreateTr( settings, rowIdx, tr, tds );
	}

	return rowIdx;
}


/**
 * Add one or more TR elements to the table. Generally we'd expect to
 * use this for reading data from a DOM sourced table, but it could be
 * used for an TR element. Note that if a TR is given, it is used (i.e.
 * it is not cloned).
 *  @param {object} settings dataTables settings object
 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
 *  @returns {array} Array of indexes for the added rows
 *  @memberof DataTable#oApi
 */
function _fnAddTr( settings, trs )
{
	var row;

	// Allow an individual node to be passed in
	if ( ! (trs instanceof $) ) {
		trs = $(trs);
	}

	return trs.map( function (i, el) {
		row = _fnGetRowElements( settings, el );
		return _fnAddData( settings, row.data, el, row.cells );
	} );
}


/**
 * Get the data for a given cell from the internal cache, taking into account data mapping
 *  @param {object} settings dataTables settings object
 *  @param {int} rowIdx aoData row id
 *  @param {int} colIdx Column index
 *  @param {string} type data get type ('display', 'type' 'filter|search' 'sort|order')
 *  @returns {*} Cell data
 *  @memberof DataTable#oApi
 */
function _fnGetCellData( settings, rowIdx, colIdx, type )
{
	if (type === 'search') {
		type = 'filter';
	}
	else if (type === 'order') {
		type = 'sort';
	}

	var row = settings.aoData[rowIdx];

	if (! row) {
		return undefined;
	}

	var draw           = settings.iDraw;
	var col            = settings.aoColumns[colIdx];
	var rowData        = row._aData;
	var defaultContent = col.sDefaultContent;
	var cellData       = col.fnGetData( rowData, type, {
		settings: settings,
		row:      rowIdx,
		col:      colIdx
	} );

	// Allow for a node being returned for non-display types
	if (type !== 'display' && cellData && typeof cellData === 'object' && cellData.nodeName) {
		cellData = cellData.innerHTML;
	}

	if ( cellData === undefined ) {
		if ( settings.iDrawError != draw && defaultContent === null ) {
			_fnLog( settings, 0, "Requested unknown parameter "+
				(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
				" for row "+rowIdx+", column "+colIdx, 4 );
			settings.iDrawError = draw;
		}
		return defaultContent;
	}

	// When the data source is null and a specific data type is requested (i.e.
	// not the original data), we can use default column data
	if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
		cellData = defaultContent;
	}
	else if ( typeof cellData === 'function' ) {
		// If the data source is a function, then we run it and use the return,
		// executing in the scope of the data object (for instances)
		return cellData.call( rowData );
	}

	if ( cellData === null && type === 'display' ) {
		return '';
	}

	if ( type === 'filter' ) {
		var fomatters = DataTable.ext.type.search;

		if ( fomatters[ col.sType ] ) {
			cellData = fomatters[ col.sType ]( cellData );
		}
	}

	return cellData;
}


/**
 * Set the value for a specific cell, into the internal data cache
 *  @param {object} settings dataTables settings object
 *  @param {int} rowIdx aoData row id
 *  @param {int} colIdx Column index
 *  @param {*} val Value to set
 *  @memberof DataTable#oApi
 */
function _fnSetCellData( settings, rowIdx, colIdx, val )
{
	var col     = settings.aoColumns[colIdx];
	var rowData = settings.aoData[rowIdx]._aData;

	col.fnSetData( rowData, val, {
		settings: settings,
		row:      rowIdx,
		col:      colIdx
	}  );
}

/**
 * Write a value to a cell
 * @param {*} td Cell
 * @param {*} val Value
 */
function _fnWriteCell(td, val)
{
	if (val && typeof val === 'object' && val.nodeName) {
		$(td)
			.empty()
			.append(val);
	}
	else {
		td.innerHTML = val;
	}
}


// Private variable that is used to match action syntax in the data property object
var __reArray = /\[.*?\]$/;
var __reFn = /\(\)$/;

/**
 * Split string on periods, taking into account escaped periods
 * @param  {string} str String to split
 * @return {array} Split string
 */
function _fnSplitObjNotation( str )
{
	var parts = str.match(/(\\.|[^.])+/g) || [''];

	return parts.map( function ( s ) {
		return s.replace(/\\\./g, '.');
	} );
}


/**
 * Return a function that can be used to get data from a source object, taking
 * into account the ability to use nested objects as a source
 *  @param {string|int|function} mSource The data source for the object
 *  @returns {function} Data get function
 *  @memberof DataTable#oApi
 */
var _fnGetObjectDataFn = DataTable.util.get;


/**
 * Return a function that can be used to set data from a source object, taking
 * into account the ability to use nested objects as a source
 *  @param {string|int|function} mSource The data source for the object
 *  @returns {function} Data set function
 *  @memberof DataTable#oApi
 */
var _fnSetObjectDataFn = DataTable.util.set;


/**
 * Return an array with the full table data
 *  @param {object} oSettings dataTables settings object
 *  @returns array {array} aData Master data array
 *  @memberof DataTable#oApi
 */
function _fnGetDataMaster ( settings )
{
	return _pluck( settings.aoData, '_aData' );
}


/**
 * Nuke the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnClearTable( settings )
{
	settings.aoData.length = 0;
	settings.aiDisplayMaster.length = 0;
	settings.aiDisplay.length = 0;
	settings.aIds = {};
}


/**
 * Mark cached data as invalid such that a re-read of the data will occur when
 * the cached data is next requested. Also update from the data source object.
 *
 * @param {object} settings DataTables settings object
 * @param {int}    rowIdx   Row index to invalidate
 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
 *     or 'data'
 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
 *     row will be invalidated
 * @memberof DataTable#oApi
 *
 * @todo For the modularisation of v1.11 this will need to become a callback, so
 *   the sort and filter methods can subscribe to it. That will required
 *   initialisation options for sorting, which is why it is not already baked in
 */
function _fnInvalidate( settings, rowIdx, src, colIdx )
{
	var row = settings.aoData[ rowIdx ];
	var i, ien;

	// Remove the cached data for the row
	row._aSortData = null;
	row._aFilterData = null;
	row.displayData = null;

	// Are we reading last data from DOM or the data object?
	if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
		// Read the data from the DOM
		row._aData = _fnGetRowElements(
				settings, row, colIdx, colIdx === undefined ? undefined : row._aData
			)
			.data;
	}
	else {
		// Reading from data object, update the DOM
		var cells = row.anCells;
		var display = _fnGetRowDisplay(settings, rowIdx);

		if ( cells ) {
			if ( colIdx !== undefined ) {
				_fnWriteCell(cells[colIdx], display[colIdx]);
			}
			else {
				for ( i=0, ien=cells.length ; i<ien ; i++ ) {
					_fnWriteCell(cells[i], display[i]);
				}
			}
		}
	}

	// Column specific invalidation
	var cols = settings.aoColumns;
	if ( colIdx !== undefined ) {
		// Type - the data might have changed
		cols[ colIdx ].sType = null;

		// Max length string. Its a fairly cheep recalculation, so not worth
		// something more complicated
		cols[ colIdx ].maxLenString = null;
	}
	else {
		for ( i=0, ien=cols.length ; i<ien ; i++ ) {
			cols[i].sType = null;
			cols[i].maxLenString = null;
		}

		// Update DataTables special `DT_*` attributes for the row
		_fnRowAttributes( settings, row );
	}
}


/**
 * Build a data source object from an HTML row, reading the contents of the
 * cells that are in the row.
 *
 * @param {object} settings DataTables settings object
 * @param {node|object} TR element from which to read data or existing row
 *   object from which to re-read the data from the cells
 * @param {int} [colIdx] Optional column index
 * @param {array|object} [d] Data source object. If `colIdx` is given then this
 *   parameter should also be given and will be used to write the data into.
 *   Only the column in question will be written
 * @returns {object} Object with two parameters: `data` the data read, in
 *   document order, and `cells` and array of nodes (they can be useful to the
 *   caller, so rather than needing a second traversal to get them, just return
 *   them from here).
 * @memberof DataTable#oApi
 */
function _fnGetRowElements( settings, row, colIdx, d )
{
	var
		tds = [],
		td = row.firstChild,
		name, col, i=0, contents,
		columns = settings.aoColumns,
		objectRead = settings._rowReadObject;

	// Allow the data object to be passed in, or construct
	d = d !== undefined ?
		d :
		objectRead ?
			{} :
			[];

	var attr = function ( str, td  ) {
		if ( typeof str === 'string' ) {
			var idx = str.indexOf('@');

			if ( idx !== -1 ) {
				var attr = str.substring( idx+1 );
				var setter = _fnSetObjectDataFn( str );
				setter( d, td.getAttribute( attr ) );
			}
		}
	};

	// Read data from a cell and store into the data object
	var cellProcess = function ( cell ) {
		if ( colIdx === undefined || colIdx === i ) {
			col = columns[i];
			contents = (cell.innerHTML).trim();

			if ( col && col._bAttrSrc ) {
				var setter = _fnSetObjectDataFn( col.mData._ );
				setter( d, contents );

				attr( col.mData.sort, cell );
				attr( col.mData.type, cell );
				attr( col.mData.filter, cell );
			}
			else {
				// Depending on the `data` option for the columns the data can
				// be read to either an object or an array.
				if ( objectRead ) {
					if ( ! col._setter ) {
						// Cache the setter function
						col._setter = _fnSetObjectDataFn( col.mData );
					}
					col._setter( d, contents );
				}
				else {
					d[i] = contents;
				}
			}
		}

		i++;
	};

	if ( td ) {
		// `tr` element was passed in
		while ( td ) {
			name = td.nodeName.toUpperCase();

			if ( name == "TD" || name == "TH" ) {
				cellProcess( td );
				tds.push( td );
			}

			td = td.nextSibling;
		}
	}
	else {
		// Existing row object passed in
		tds = row.anCells;

		for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
			cellProcess( tds[j] );
		}
	}

	// Read the ID from the DOM if present
	var rowNode = row.firstChild ? row : row.nTr;

	if ( rowNode ) {
		var id = rowNode.getAttribute( 'id' );

		if ( id ) {
			_fnSetObjectDataFn( settings.rowId )( d, id );
		}
	}

	return {
		data: d,
		cells: tds
	};
}

/**
 * Render and cache a row's display data for the columns, if required
 * @returns 
 */
function _fnGetRowDisplay (settings, rowIdx) {
	var rowModal = settings.aoData[rowIdx];
	var columns = settings.aoColumns;

	if (! rowModal.displayData) {
		// Need to render and cache
		rowModal.displayData = [];
	
		for ( var colIdx=0, len=columns.length ; colIdx<len ; colIdx++ ) {
			rowModal.displayData.push(
				_fnGetCellData( settings, rowIdx, colIdx, 'display' )
			);
		}
	}

	return rowModal.displayData;
}

/**
 * Create a new TR element (and it's TD children) for a row
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iRow Row to consider
 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
 *    DataTables will create a row automatically
 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
 *    if nTr is.
 *  @memberof DataTable#oApi
 */
function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
{
	var
		row = oSettings.aoData[iRow],
		rowData = row._aData,
		cells = [],
		nTr, nTd, oCol,
		i, iLen, create,
		trClass = oSettings.oClasses.tbody.row;

	if ( row.nTr === null )
	{
		nTr = nTrIn || document.createElement('tr');

		row.nTr = nTr;
		row.anCells = cells;

		_addClass(nTr, trClass);

		/* Use a private property on the node to allow reserve mapping from the node
		 * to the aoData array for fast look up
		 */
		nTr._DT_RowIndex = iRow;

		/* Special parameters can be given by the data source to be used on the row */
		_fnRowAttributes( oSettings, row );

		/* Process each column */
		for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
		{
			oCol = oSettings.aoColumns[i];
			create = nTrIn && anTds[i] ? false : true;

			nTd = create ? document.createElement( oCol.sCellType ) : anTds[i];

			if (! nTd) {
				_fnLog( oSettings, 0, 'Incorrect column count', 18 );
			}

			nTd._DT_CellIndex = {
				row: iRow,
				column: i
			};
			
			cells.push( nTd );
			
			var display = _fnGetRowDisplay(oSettings, iRow);

			// Need to create the HTML if new, or if a rendering function is defined
			if (
				create ||
				(
					(oCol.mRender || oCol.mData !== i) &&
					(!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
				)
			) {
				_fnWriteCell(nTd, display[i]);
			}

			// column class
			_addClass(nTd, oCol.sClass);

			// Visibility - add or remove as required
			if ( oCol.bVisible && create )
			{
				nTr.appendChild( nTd );
			}
			else if ( ! oCol.bVisible && ! create )
			{
				nTd.parentNode.removeChild( nTd );
			}

			if ( oCol.fnCreatedCell )
			{
				oCol.fnCreatedCell.call( oSettings.oInstance,
					nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
				);
			}
		}

		_fnCallbackFire( oSettings, 'aoRowCreatedCallback', 'row-created', [nTr, rowData, iRow, cells] );
	}
	else {
		_addClass(row.nTr, trClass);
	}
}


/**
 * Add attributes to a row based on the special `DT_*` parameters in a data
 * source object.
 *  @param {object} settings DataTables settings object
 *  @param {object} DataTables row object for the row to be modified
 *  @memberof DataTable#oApi
 */
function _fnRowAttributes( settings, row )
{
	var tr = row.nTr;
	var data = row._aData;

	if ( tr ) {
		var id = settings.rowIdFn( data );

		if ( id ) {
			tr.id = id;
		}

		if ( data.DT_RowClass ) {
			// Remove any classes added by DT_RowClass before
			var a = data.DT_RowClass.split(' ');
			row.__rowc = row.__rowc ?
				_unique( row.__rowc.concat( a ) ) :
				a;

			$(tr)
				.removeClass( row.__rowc.join(' ') )
				.addClass( data.DT_RowClass );
		}

		if ( data.DT_RowAttr ) {
			$(tr).attr( data.DT_RowAttr );
		}

		if ( data.DT_RowData ) {
			$(tr).data( data.DT_RowData );
		}
	}
}


/**
 * Create the HTML header for the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnBuildHead( settings, side )
{
	var classes = settings.oClasses;
	var columns = settings.aoColumns;
	var i, ien, row;
	var target = side === 'header'
		? settings.nTHead
		: settings.nTFoot;
	var titleProp = side === 'header' ? 'sTitle' : side;

	// Footer might be defined
	if (! target) {
		return;
	}

	// If no cells yet and we have content for them, then create
	if (side === 'header' || _pluck(settings.aoColumns, titleProp).join('')) {
		row = $('tr', target);

		// Add a row if needed
		if (! row.length) {
			row = $('<tr/>').appendTo(target)
		}

		// Add the number of cells needed to make up to the number of columns
		if (row.length === 1) {
			var cellCount = 0;
			
			$('td, th', row).each(function () {
				cellCount += this.colSpan;
			});

			for ( i=cellCount, ien=columns.length ; i<ien ; i++ ) {
				$('<th/>')
					.html( columns[i][titleProp] || '' )
					.appendTo( row );
			}
		}
	}

	var detected = _fnDetectHeader( settings, target, true );

	if (side === 'header') {
		settings.aoHeader = detected;
		$('tr', target).addClass(classes.thead.row);
	}
	else {
		settings.aoFooter = detected;
		$('tr', target).addClass(classes.tfoot.row);
	}

	// Every cell needs to be passed through the renderer
	$(target).children('tr').children('th, td')
		.each( function () {
			_fnRenderer( settings, side )(
				settings, $(this), classes
			);
		} );
}

/**
 * Build a layout structure for a header or footer
 *
 * @param {*} settings DataTables settings
 * @param {*} source Source layout array
 * @param {*} incColumns What columns should be included
 * @returns Layout array
 */
function _fnHeaderLayout( settings, source, incColumns )
{
	var row, column, cell;
	var local = [];
	var structure = [];
	var columns = settings.aoColumns;
	var columnCount = columns.length;
	var rowspan, colspan;

	if ( ! source ) {
		return;
	}

	// Default is to work on only visible columns
	if ( ! incColumns ) {
		incColumns = _range(columnCount)
			.filter(function (idx) {
				return columns[idx].bVisible;
			});
	}

	// Make a copy of the master layout array, but with only the columns we want
	for ( row=0 ; row<source.length ; row++ ) {
		// Remove any columns we haven't selected
		local[row] = source[row].slice().filter(function (cell, i) {
			return incColumns.includes(i);
		});

		// Prep the structure array - it needs an element for each row
		structure.push( [] );
	}

	for ( row=0 ; row<local.length ; row++ ) {
		for ( column=0 ; column<local[row].length ; column++ ) {
			rowspan = 1;
			colspan = 1;

			// Check to see if there is already a cell (row/colspan) covering our target
			// insert point. If there is, then there is nothing to do.
			if ( structure[row][column] === undefined ) {
				cell = local[row][column].cell;

				// Expand for rowspan
				while (
					local[row+rowspan] !== undefined &&
					local[row][column].cell == local[row+rowspan][column].cell
				) {
					structure[row+rowspan][column] = null;
					rowspan++;
				}

				// And for colspan
				while (
					local[row][column+colspan] !== undefined &&
					local[row][column].cell == local[row][column+colspan].cell
				) {
					// Which also needs to go over rows
					for ( var k=0 ; k<rowspan ; k++ ) {
						structure[row+k][column+colspan] = null;
					}

					colspan++;
				}

				var titleSpan = $('span.dt-column-title', cell);

				structure[row][column] = {
					cell: cell,
					colspan: colspan,
					rowspan: rowspan,
					title: titleSpan.length
						? titleSpan.html()
						: $(cell).html()
				};
			}
		}
	}

	return structure;
}


/**
 * Draw the header (or footer) element based on the column visibility states.
 *
 *  @param object oSettings dataTables settings object
 *  @param array aoSource Layout array from _fnDetectHeader
 *  @memberof DataTable#oApi
 */
function _fnDrawHead( settings, source )
{
	var layout = _fnHeaderLayout(settings, source);
	var tr, n;

	for ( var row=0 ; row<source.length ; row++ ) {
		tr = source[row].row;

		// All cells are going to be replaced, so empty out the row
		// Can't use $().empty() as that kills event handlers
		if (tr) {
			while( (n = tr.firstChild) ) {
				tr.removeChild( n );
			}
		}

		for ( var column=0 ; column<layout[row].length ; column++ ) {
			var point = layout[row][column];

			if (point) {
				$(point.cell)
					.appendTo(tr)
					.attr('rowspan', point.rowspan)
					.attr('colspan', point.colspan);
			}
		}
	}
}


/**
 * Insert the required TR nodes into the table for display
 *  @param {object} oSettings dataTables settings object
 *  @param ajaxComplete true after ajax call to complete rendering
 *  @memberof DataTable#oApi
 */
function _fnDraw( oSettings, ajaxComplete )
{
	// Allow for state saving and a custom start position
	_fnStart( oSettings );

	/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
	var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
	if ( aPreDraw.indexOf(false) !== -1 )
	{
		_fnProcessingDisplay( oSettings, false );
		return;
	}

	var anRows = [];
	var iRowCount = 0;
	var bServerSide = _fnDataSource( oSettings ) == 'ssp';
	var aiDisplay = oSettings.aiDisplay;
	var iDisplayStart = oSettings._iDisplayStart;
	var iDisplayEnd = oSettings.fnDisplayEnd();
	var columns = oSettings.aoColumns;
	var body = $(oSettings.nTBody);

	oSettings.bDrawing = true;

	/* Server-side processing draw intercept */
	if ( oSettings.deferLoading )
	{
		oSettings.deferLoading = false;
		oSettings.iDraw++;
		_fnProcessingDisplay( oSettings, false );
	}
	else if ( !bServerSide )
	{
		oSettings.iDraw++;
	}
	else if ( !oSettings.bDestroying && !ajaxComplete)
	{
		// Show loading message for server-side processing
		if (oSettings.iDraw === 0) {
			body.empty().append(_emptyRow(oSettings));
		}

		_fnAjaxUpdate( oSettings );
		return;
	}

	if ( aiDisplay.length !== 0 )
	{
		var iStart = bServerSide ? 0 : iDisplayStart;
		var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

		for ( var j=iStart ; j<iEnd ; j++ )
		{
			var iDataIndex = aiDisplay[j];
			var aoData = oSettings.aoData[ iDataIndex ];
			if ( aoData.nTr === null )
			{
				_fnCreateTr( oSettings, iDataIndex );
			}

			var nRow = aoData.nTr;

			// Add various classes as needed
			for (var i=0 ; i<columns.length ; i++) {
				var col = columns[i];
				var td = aoData.anCells[i];

				_addClass(td, _ext.type.className[col.sType]); // auto class
				_addClass(td, oSettings.oClasses.tbody.cell); // all cells
			}

			// Row callback functions - might want to manipulate the row
			// iRowCount and j are not currently documented. Are they at all
			// useful?
			_fnCallbackFire( oSettings, 'aoRowCallback', null,
				[nRow, aoData._aData, iRowCount, j, iDataIndex] );

			anRows.push( nRow );
			iRowCount++;
		}
	}
	else
	{
		anRows[ 0 ] = _emptyRow(oSettings);
	}

	/* Header and footer callbacks */
	_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
		_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

	_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
		_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

	// replaceChildren is faster, but only became widespread in 2020,
	// so a fall back in jQuery is provided for older browsers.
	if (body[0].replaceChildren) {
		body[0].replaceChildren.apply(body[0], anRows);
	}
	else {
		body.children().detach();
		body.append( $(anRows) );
	}

	// Empty table needs a specific class
	$(oSettings.nTableWrapper).toggleClass('dt-empty-footer', $('tr', oSettings.nTFoot).length === 0);

	/* Call all required callback functions for the end of a draw */
	_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings], true );

	/* Draw is complete, sorting and filtering must be as well */
	oSettings.bSorted = false;
	oSettings.bFiltered = false;
	oSettings.bDrawing = false;
}


/**
 * Redraw the table - taking account of the various features which are enabled
 *  @param {object} oSettings dataTables settings object
 *  @param {boolean} [holdPosition] Keep the current paging position. By default
 *    the paging is reset to the first page
 *  @memberof DataTable#oApi
 */
function _fnReDraw( settings, holdPosition, recompute )
{
	var
		features = settings.oFeatures,
		sort     = features.bSort,
		filter   = features.bFilter;

	if (recompute === undefined || recompute === true) {
		// Resolve any column types that are unknown due to addition or invalidation
		_fnColumnTypes( settings );

		if ( sort ) {
			_fnSort( settings );
		}

		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	}

	if ( holdPosition !== true ) {
		settings._iDisplayStart = 0;
	}

	// Let any modules know about the draw hold position state (used by
	// scrolling internally)
	settings._drawHold = holdPosition;

	_fnDraw( settings );

	settings._drawHold = false;
}


/*
 * Table is empty - create a row with an empty message in it
 */
function _emptyRow ( settings ) {
	var oLang = settings.oLanguage;
	var zero = oLang.sZeroRecords;
	var dataSrc = _fnDataSource( settings );

	if (
		(settings.iDraw < 1 && dataSrc === 'ssp') ||
		(settings.iDraw <= 1 && dataSrc === 'ajax')
	) {
		zero = oLang.sLoadingRecords;
	}
	else if ( oLang.sEmptyTable && settings.fnRecordsTotal() === 0 )
	{
		zero = oLang.sEmptyTable;
	}

	return $( '<tr/>' )
		.append( $('<td />', {
			'colSpan': _fnVisbleColumns( settings ),
			'class':   settings.oClasses.empty.row
		} ).html( zero ) )[0];
}


/**
 * Expand the layout items into an object for the rendering function
 */
function _layoutItems (row, align, items) {
	if ( Array.isArray(items)) {
		for (var i=0 ; i<items.length ; i++) {
			_layoutItems(row, align, items[i]);
		}

		return;
	}

	var rowCell = row[align];

	// If it is an object, then there can be multiple features contained in it
	if ( $.isPlainObject( items ) ) {
		// A feature plugin cannot be named "features" due to this check
		if (items.features) {
			if (items.rowId) {
				row.id = items.rowId;
			}
			if (items.rowClass) {
				row.className = items.rowClass;
			}

			rowCell.id = items.id;
			rowCell.className = items.className;

			_layoutItems(row, align, items.features);
		}
		else {
			Object.keys(items).map(function (key) {
				rowCell.contents.push( {
					feature: key,
					opts: items[key]
				});
			});
		}
	}
	else {
		rowCell.contents.push(items);
	}
}

/**
 * Find, or create a layout row
 */
function _layoutGetRow(rows, rowNum, align) {
	var row;

	// Find existing rows
	for (var i=0; i<rows.length; i++) {
		row = rows[i];

		if (row.rowNum === rowNum) {
			// full is on its own, but start and end share a row
			if (
				(align === 'full' && row.full) ||
				((align === 'start' || align === 'end') && (row.start || row.end))
			) {
				if (! row[align]) {
					row[align] = {
						contents: []
					};
				}

				return row;
			}
		}
	}

	// If we get this far, then there was no match, create a new row
	row = {
		rowNum: rowNum	
	};

	row[align] = {
		contents: []
	};

	rows.push(row);

	return row;
}

/**
 * Convert a `layout` object given by a user to the object structure needed
 * for the renderer. This is done twice, once for above and once for below
 * the table. Ordering must also be considered.
 *
 * @param {*} settings DataTables settings object
 * @param {*} layout Layout object to convert
 * @param {string} side `top` or `bottom`
 * @returns Converted array structure - one item for each row.
 */
function _layoutArray ( settings, layout, side ) {
	var rows = [];
	
	// Split out into an array
	$.each( layout, function ( pos, items ) {
		if (items === null) {
			return;
		}

		var parts = pos.match(/^([a-z]+)([0-9]*)([A-Za-z]*)$/);
		var rowNum = parts[2]
			? parts[2] * 1
			: 0;
		var align = parts[3]
			? parts[3].toLowerCase()
			: 'full';

		// Filter out the side we aren't interested in
		if (parts[1] !== side) {
			return;
		}

		// Get or create the row we should attach to
		var row = _layoutGetRow(rows, rowNum, align);

		_layoutItems(row, align, items);
	});

	// Order by item identifier
	rows.sort( function ( a, b ) {
		var order1 = a.rowNum;
		var order2 = b.rowNum;

		// If both in the same row, then the row with `full` comes first
		if (order1 === order2) {
			var ret = a.full && ! b.full ? -1 : 1;

			return side === 'bottom'
				? ret * -1
				: ret;
		}

		return order2 - order1;
	} );

	// Invert for below the table
	if ( side === 'bottom' ) {
		rows.reverse();
	}

	for (var row = 0; row<rows.length; row++) {
		delete rows[row].rowNum;

		_layoutResolve(settings, rows[row]);
	}

	return rows;
}


/**
 * Convert the contents of a row's layout object to nodes that can be inserted
 * into the document by a renderer. Execute functions, look up plug-ins, etc.
 *
 * @param {*} settings DataTables settings object
 * @param {*} row Layout object for this row
 */
function _layoutResolve( settings, row ) {
	var getFeature = function (feature, opts) {
		if ( ! _ext.features[ feature ] ) {
			_fnLog( settings, 0, 'Unknown feature: '+ feature );
		}

		return _ext.features[ feature ].apply( this, [settings, opts] );
	};

	var resolve = function ( item ) {
		if (! row[ item ]) {
			return;
		}

		var line = row[ item ].contents;

		for ( var i=0, ien=line.length ; i<ien ; i++ ) {
			if ( ! line[i] ) {
				continue;
			}
			else if ( typeof line[i] === 'string' ) {
				line[i] = getFeature( line[i], null );
			}
			else if ( $.isPlainObject(line[i]) ) {
				// If it's an object, it just has feature and opts properties from
				// the transform in _layoutArray
				line[i] = getFeature(line[i].feature, line[i].opts);
			}
			else if ( typeof line[i].node === 'function' ) {
				line[i] = line[i].node( settings );
			}
			else if ( typeof line[i] === 'function' ) {
				var inst = line[i]( settings );

				line[i] = typeof inst.node === 'function' ?
					inst.node() :
					inst;
			}
		}
	};

	resolve('start');
	resolve('end');
	resolve('full');
}


/**
 * Add the options to the page HTML for the table
 *  @param {object} settings DataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAddOptionsHtml ( settings )
{
	var classes = settings.oClasses;
	var table = $(settings.nTable);

	// Wrapper div around everything DataTables controls
	var insert = $('<div/>')
		.attr({
			id:      settings.sTableId+'_wrapper',
			'class': classes.container
		})
		.insertBefore(table);

	settings.nTableWrapper = insert[0];

	if (settings.sDom) {
		// Legacy
		_fnLayoutDom(settings, settings.sDom, insert);
	}
	else {
		var top = _layoutArray( settings, settings.layout, 'top' );
		var bottom = _layoutArray( settings, settings.layout, 'bottom' );
		var renderer = _fnRenderer( settings, 'layout' );
	
		// Everything above - the renderer will actually insert the contents into the document
		top.forEach(function (item) {
			renderer( settings, insert, item );
		});

		// The table - always the center of attention
		renderer( settings, insert, {
			full: {
				table: true,
				contents: [ _fnFeatureHtmlTable(settings) ]
			}
		} );

		// Everything below
		bottom.forEach(function (item) {
			renderer( settings, insert, item );
		});
	}

	// Processing floats on top, so it isn't an inserted feature
	_processingHtml( settings );
}

/**
 * Draw the table with the legacy DOM property
 * @param {*} settings DT settings object
 * @param {*} dom DOM string
 * @param {*} insert Insert point
 */
function _fnLayoutDom( settings, dom, insert )
{
	var parts = dom.match(/(".*?")|('.*?')|./g);
	var featureNode, option, newNode, next, attr;

	for ( var i=0 ; i<parts.length ; i++ ) {
		featureNode = null;
		option = parts[i];

		if ( option == '<' ) {
			// New container div
			newNode = $('<div/>');

			// Check to see if we should append an id and/or a class name to the container
			next = parts[i+1];

			if ( next[0] == "'" || next[0] == '"' ) {
				attr = next.replace(/['"]/g, '');

				var id = '', className;

				/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
				 * breaks the string into parts and applies them as needed
				 */
				if ( attr.indexOf('.') != -1 ) {
					var split = attr.split('.');

					id = split[0];
					className = split[1];
				}
				else if ( attr[0] == "#" ) {
					id = attr;
				}
				else {
					className = attr;
				}

				newNode
					.attr('id', id.substring(1))
					.addClass(className);

				i++; // Move along the position array
			}

			insert.append( newNode );
			insert = newNode;
		}
		else if ( option == '>' ) {
			// End container div
			insert = insert.parent();
		}
		else if ( option == 't' ) {
			// Table
			featureNode = _fnFeatureHtmlTable( settings );
		}
		else
		{
			DataTable.ext.feature.forEach(function(feature) {
				if ( option == feature.cFeature ) {
					featureNode = feature.fnInit( settings );
				}
			});
		}

		// Add to the display
		if ( featureNode ) {
			insert.append( featureNode );
		}
	}
}


/**
 * Use the DOM source to create up an array of header cells. The idea here is to
 * create a layout grid (array) of rows x columns, which contains a reference
 * to the cell that that point in the grid (regardless of col/rowspan), such that
 * any column / row could be removed and the new grid constructed
 *  @param {node} thead The header/footer element for the table
 *  @returns {array} Calculated layout array
 *  @memberof DataTable#oApi
 */
function _fnDetectHeader ( settings, thead, write )
{
	var columns = settings.aoColumns;
	var rows = $(thead).children('tr');
	var row, cell;
	var i, k, l, iLen, shifted, column, colspan, rowspan;
	var isHeader = thead && thead.nodeName.toLowerCase() === 'thead';
	var layout = [];
	var unique;
	var shift = function ( a, i, j ) {
		var k = a[i];
		while ( k[j] ) {
			j++;
		}
		return j;
	};

	// We know how many rows there are in the layout - so prep it
	for ( i=0, iLen=rows.length ; i<iLen ; i++ ) {
		layout.push( [] );
	}

	for ( i=0, iLen=rows.length ; i<iLen ; i++ ) {
		row = rows[i];
		column = 0;

		// For every cell in the row..
		cell = row.firstChild;
		while ( cell ) {
			if (
				cell.nodeName.toUpperCase() == 'TD' ||
				cell.nodeName.toUpperCase() == 'TH'
			) {
				var cols = [];

				// Get the col and rowspan attributes from the DOM and sanitise them
				colspan = cell.getAttribute('colspan') * 1;
				rowspan = cell.getAttribute('rowspan') * 1;
				colspan = (!colspan || colspan===0 || colspan===1) ? 1 : colspan;
				rowspan = (!rowspan || rowspan===0 || rowspan===1) ? 1 : rowspan;

				// There might be colspan cells already in this row, so shift our target
				// accordingly
				shifted = shift( layout, i, column );

				// Cache calculation for unique columns
				unique = colspan === 1 ?
					true :
					false;
				
				// Perform header setup
				if ( write ) {
					if (unique) {
						// Allow column options to be set from HTML attributes
						_fnColumnOptions( settings, shifted, $(cell).data() );
						
						// Get the width for the column. This can be defined from the
						// width attribute, style attribute or `columns.width` option
						var columnDef = columns[shifted];
						var width = cell.getAttribute('width') || null;
						var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
						if ( t ) {
							width = t[1];
						}

						columnDef.sWidthOrig = columnDef.sWidth || width;

						if (isHeader) {
							// Column title handling - can be user set, or read from the DOM
							// This happens before the render, so the original is still in place
							if ( columnDef.sTitle !== null && ! columnDef.autoTitle ) {
								cell.innerHTML = columnDef.sTitle;
							}

							if (! columnDef.sTitle && unique) {
								columnDef.sTitle = _stripHtml(cell.innerHTML);
								columnDef.autoTitle = true;
							}
						}
						else {
							// Footer specific operations
							if (columnDef.footer) {
								cell.innerHTML = columnDef.footer;
							}
						}

						// Fall back to the aria-label attribute on the table header if no ariaTitle is
						// provided.
						if (! columnDef.ariaTitle) {
							columnDef.ariaTitle = $(cell).attr("aria-label") || columnDef.sTitle;
						}

						// Column specific class names
						if ( columnDef.className ) {
							$(cell).addClass( columnDef.className );
						}
					}

					// Wrap the column title so we can write to it in future
					if ( $('span.dt-column-title', cell).length === 0) {
						$('<span>')
							.addClass('dt-column-title')
							.append(cell.childNodes)
							.appendTo(cell);
					}

					if ( isHeader && $('span.dt-column-order', cell).length === 0) {
						$('<span>')
							.addClass('dt-column-order')
							.appendTo(cell);
					}
				}

				// If there is col / rowspan, copy the information into the layout grid
				for ( l=0 ; l<colspan ; l++ ) {
					for ( k=0 ; k<rowspan ; k++ ) {
						layout[i+k][shifted+l] = {
							cell: cell,
							unique: unique
						};

						layout[i+k].row = row;
					}

					cols.push( shifted+l );
				}

				// Assign an attribute so spanning cells can still be identified
				// as belonging to a column
				cell.setAttribute('data-dt-column', _unique(cols).join(','));
			}

			cell = cell.nextSibling;
		}
	}

	return layout;
}

/**
 * Set the start position for draw
 *  @param {object} oSettings dataTables settings object
 */
function _fnStart( oSettings )
{
	var bServerSide = _fnDataSource( oSettings ) == 'ssp';
	var iInitDisplayStart = oSettings.iInitDisplayStart;

	// Check and see if we have an initial draw position from state saving
	if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
	{
		oSettings._iDisplayStart = bServerSide ?
			iInitDisplayStart :
			iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
				0 :
				iInitDisplayStart;

		oSettings.iInitDisplayStart = -1;
	}
}

/**
 * Create an Ajax call based on the table's settings, taking into account that
 * parameters can have multiple forms, and backwards compatibility.
 *
 * @param {object} oSettings dataTables settings object
 * @param {array} data Data to send to the server, required by
 *     DataTables - may be augmented by developer callbacks
 * @param {function} fn Callback function to run when data is obtained
 */
function _fnBuildAjax( oSettings, data, fn )
{
	var ajaxData;
	var ajax = oSettings.ajax;
	var instance = oSettings.oInstance;
	var callback = function ( json ) {
		var status = oSettings.jqXHR
			? oSettings.jqXHR.status
			: null;

		if ( json === null || (typeof status === 'number' && status == 204 ) ) {
			json = {};
			_fnAjaxDataSrc( oSettings, json, [] );
		}

		var error = json.error || json.sError;
		if ( error ) {
			_fnLog( oSettings, 0, error );
		}

		// Microsoft often wrap JSON as a string in another JSON object
		// Let's handle that automatically
		if (json.d && typeof json.d === 'string') {
			try {
				json = JSON.parse(json.d);
			}
			catch (e) {
				// noop
			}
		}

		oSettings.json = json;

		_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR], true );
		fn( json );
	};

	if ( $.isPlainObject( ajax ) && ajax.data )
	{
		ajaxData = ajax.data;

		var newData = typeof ajaxData === 'function' ?
			ajaxData( data, oSettings ) :  // fn can manipulate data or return
			ajaxData;                      // an object object or array to merge

		// If the function returned something, use that alone
		data = typeof ajaxData === 'function' && newData ?
			newData :
			$.extend( true, data, newData );

		// Remove the data property as we've resolved it already and don't want
		// jQuery to do it again (it is restored at the end of the function)
		delete ajax.data;
	}

	var baseAjax = {
		"url": typeof ajax === 'string' ?
			ajax :
			'',
		"data": data,
		"success": callback,
		"dataType": "json",
		"cache": false,
		"type": oSettings.sServerMethod,
		"error": function (xhr, error) {
			var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR], true );

			if ( ret.indexOf(true) === -1 ) {
				if ( error == "parsererror" ) {
					_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
				}
				else if ( xhr.readyState === 4 ) {
					_fnLog( oSettings, 0, 'Ajax error', 7 );
				}
			}

			_fnProcessingDisplay( oSettings, false );
		}
	};

	// If `ajax` option is an object, extend and override our default base
	if ( $.isPlainObject( ajax ) ) {
		$.extend( baseAjax, ajax )
	}

	// Store the data submitted for the API
	oSettings.oAjaxData = data;

	// Allow plug-ins and external processes to modify the data
	_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data, baseAjax], true );

	if ( typeof ajax === 'function' )
	{
		// Is a function - let the caller define what needs to be done
		oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
	}
	else if (ajax.url === '') {
		// No url, so don't load any data. Just apply an empty data array
		// to the object for the callback.
		var empty = {};

		DataTable.util.set(ajax.dataSrc)(empty, []);
		callback(empty);
	}
	else {
		// Object to extend the base settings
		oSettings.jqXHR = $.ajax( baseAjax );
	}

	// Restore for next time around
	if ( ajaxData ) {
		ajax.data = ajaxData;
	}
}


/**
 * Update the table using an Ajax call
 *  @param {object} settings dataTables settings object
 *  @returns {boolean} Block the table drawing or not
 *  @memberof DataTable#oApi
 */
function _fnAjaxUpdate( settings )
{
	settings.iDraw++;
	_fnProcessingDisplay( settings, true );

	_fnBuildAjax(
		settings,
		_fnAjaxParameters( settings ),
		function(json) {
			_fnAjaxUpdateDraw( settings, json );
		}
	);
}


/**
 * Build up the parameters in an object needed for a server-side processing
 * request.
 *  @param {object} oSettings dataTables settings object
 *  @returns {bool} block the table drawing or not
 *  @memberof DataTable#oApi
 */
function _fnAjaxParameters( settings )
{
	var
		columns = settings.aoColumns,
		features = settings.oFeatures,
		preSearch = settings.oPreviousSearch,
		preColSearch = settings.aoPreSearchCols,
		colData = function ( idx, prop ) {
			return typeof columns[idx][prop] === 'function' ?
				'function' :
				columns[idx][prop];
		};

	return {
		draw: settings.iDraw,
		columns: columns.map( function ( column, i ) {
			return {
				data: colData(i, 'mData'),
				name: column.sName,
				searchable: column.bSearchable,
				orderable: column.bSortable,
				search: {
					value: preColSearch[i].search,
					regex: preColSearch[i].regex,
					fixed: Object.keys(column.searchFixed).map( function(name) {
						return {
							name: name,
							term: column.searchFixed[name].toString()
						}
					})
				}
			};
		} ),
		order: _fnSortFlatten( settings ).map( function ( val ) {
			return {
				column: val.col,
				dir: val.dir,
				name: colData(val.col, 'sName')
			};
		} ),
		start: settings._iDisplayStart,
		length: features.bPaginate ?
			settings._iDisplayLength :
			-1,
		search: {
			value: preSearch.search,
			regex: preSearch.regex,
			fixed: Object.keys(settings.searchFixed).map( function(name) {
				return {
					name: name,
					term: settings.searchFixed[name].toString()
				}
			})
		}
	};
}


/**
 * Data the data from the server (nuking the old) and redraw the table
 *  @param {object} oSettings dataTables settings object
 *  @param {object} json json data return from the server.
 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
 *  @param {array} json.aaData The data to display on this page
 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
 *  @memberof DataTable#oApi
 */
function _fnAjaxUpdateDraw ( settings, json )
{
	var data = _fnAjaxDataSrc(settings, json);
	var draw = _fnAjaxDataSrcParam(settings, 'draw', json);
	var recordsTotal = _fnAjaxDataSrcParam(settings, 'recordsTotal', json);
	var recordsFiltered = _fnAjaxDataSrcParam(settings, 'recordsFiltered', json);

	if ( draw !== undefined ) {
		// Protect against out of sequence returns
		if ( draw*1 < settings.iDraw ) {
			return;
		}
		settings.iDraw = draw * 1;
	}

	// No data in returned object, so rather than an array, we show an empty table
	if ( ! data ) {
		data = [];
	}

	_fnClearTable( settings );
	settings._iRecordsTotal   = parseInt(recordsTotal, 10);
	settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

	for ( var i=0, ien=data.length ; i<ien ; i++ ) {
		_fnAddData( settings, data[i] );
	}
	settings.aiDisplay = settings.aiDisplayMaster.slice();

	_fnColumnTypes(settings);
	_fnDraw( settings, true );
	_fnInitComplete( settings );
	_fnProcessingDisplay( settings, false );
}


/**
 * Get the data from the JSON data source to use for drawing a table. Using
 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
 * source object, or from a processing function.
 *  @param {object} settings dataTables settings object
 *  @param  {object} json Data source object / array from the server
 *  @return {array} Array of data to use
 */
function _fnAjaxDataSrc ( settings, json, write )
{
	var dataProp = 'data';

	if ($.isPlainObject( settings.ajax ) && settings.ajax.dataSrc !== undefined) {
		// Could in inside a `dataSrc` object, or not!
		var dataSrc = settings.ajax.dataSrc;

		// string, function and object are valid types
		if (typeof dataSrc === 'string' || typeof dataSrc === 'function') {
			dataProp = dataSrc;
		}
		else if (dataSrc.data !== undefined) {
			dataProp = dataSrc.data;
		}
	}

	if ( ! write ) {
		if ( dataProp === 'data' ) {
			// If the default, then we still want to support the old style, and safely ignore
			// it if possible
			return json.aaData || json[dataProp];
		}

		return dataProp !== "" ?
			_fnGetObjectDataFn( dataProp )( json ) :
			json;
	}
	
	// set
	_fnSetObjectDataFn( dataProp )( json, write );
}

/**
 * Very similar to _fnAjaxDataSrc, but for the other SSP properties
 * @param {*} settings DataTables settings object
 * @param {*} param Target parameter
 * @param {*} json JSON data
 * @returns Resolved value
 */
function _fnAjaxDataSrcParam (settings, param, json) {
	var dataSrc = $.isPlainObject( settings.ajax )
		? settings.ajax.dataSrc
		: null;

	if (dataSrc && dataSrc[param]) {
		// Get from custom location
		return _fnGetObjectDataFn( dataSrc[param] )( json );
	}

	// else - Default behaviour
	var old = '';

	// Legacy support
	if (param === 'draw') {
		old = 'sEcho';
	}
	else if (param === 'recordsTotal') {
		old = 'iTotalRecords';
	}
	else if (param === 'recordsFiltered') {
		old = 'iTotalDisplayRecords';
	}

	return json[old] !== undefined
		? json[old]
		: json[param];
}


/**
 * Filter the table using both the global filter and column based filtering
 *  @param {object} settings dataTables settings object
 *  @param {object} input search information
 *  @memberof DataTable#oApi
 */
function _fnFilterComplete ( settings, input )
{
	var columnsSearch = settings.aoPreSearchCols;

	// In server-side processing all filtering is done by the server, so no point hanging around here
	if ( _fnDataSource( settings ) != 'ssp' )
	{
		// Check if any of the rows were invalidated
		_fnFilterData( settings );

		// Start from the full data set
		settings.aiDisplay = settings.aiDisplayMaster.slice();

		// Global filter first
		_fnFilter( settings.aiDisplay, settings, input.search, input );

		$.each(settings.searchFixed, function (name, term) {
			_fnFilter(settings.aiDisplay, settings, term, {});
		});

		// Then individual column filters
		for ( var i=0 ; i<columnsSearch.length ; i++ )
		{
			var col = columnsSearch[i];

			_fnFilter(
				settings.aiDisplay,
				settings,
				col.search,
				col,
				i
			);

			$.each(settings.aoColumns[i].searchFixed, function (name, term) {
				_fnFilter(settings.aiDisplay, settings, term, {}, i);
			});
		}

		// And finally global filtering
		_fnFilterCustom( settings );
	}

	// Tell the draw function we have been filtering
	settings.bFiltered = true;

	_fnCallbackFire( settings, null, 'search', [settings] );
}


/**
 * Apply custom filtering functions
 * 
 * This is legacy now that we have named functions, but it is widely used
 * from 1.x, so it is not yet deprecated.
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnFilterCustom( settings )
{
	var filters = DataTable.ext.search;
	var displayRows = settings.aiDisplay;
	var row, rowIdx;

	for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
		var rows = [];

		// Loop over each row and see if it should be included
		for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
			rowIdx = displayRows[ j ];
			row = settings.aoData[ rowIdx ];

			if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
				rows.push( rowIdx );
			}
		}

		// So the array reference doesn't break set the results into the
		// existing array
		displayRows.length = 0;
		_fnArrayApply(displayRows, rows);
	}
}


/**
 * Filter the data table based on user input and draw the table
 */
function _fnFilter( searchRows, settings, input, options, column )
{
	if ( input === '' ) {
		return;
	}

	var i = 0;
	var matched = [];

	// Search term can be a function, regex or string - if a string we apply our
	// smart filtering regex (assuming the options require that)
	var searchFunc = typeof input === 'function' ? input : null;
	var rpSearch = input instanceof RegExp
		? input
		: searchFunc
			? null
			: _fnFilterCreateSearch( input, options );

	// Then for each row, does the test pass. If not, lop the row from the array
	for (i=0 ; i<searchRows.length ; i++) {
		var row = settings.aoData[ searchRows[i] ];
		var data = column === undefined
			? row._sFilterRow
			: row._aFilterData[ column ];

		if ( (searchFunc && searchFunc(data, row._aData, searchRows[i], column)) || (rpSearch && rpSearch.test(data)) ) {
			matched.push(searchRows[i]);
		}
	}

	// Mutate the searchRows array
	searchRows.length = matched.length;

	for (i=0 ; i<matched.length ; i++) {
		searchRows[i] = matched[i];
	}
}


/**
 * Build a regular expression object suitable for searching a table
 *  @param {string} sSearch string to search for
 *  @param {bool} bRegex treat as a regular expression or not
 *  @param {bool} bSmart perform smart filtering or not
 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
 *  @returns {RegExp} constructed object
 *  @memberof DataTable#oApi
 */
function _fnFilterCreateSearch( search, inOpts )
{
	var not = [];
	var options = $.extend({}, {
		boundary: false,
		caseInsensitive: true,
		exact: false,
		regex: false,
		smart: true
	}, inOpts);

	if (typeof search !== 'string') {
		search = search.toString();
	}

	// Remove diacritics if normalize is set up to do so
	search = _normalize(search);

	if (options.exact) {
		return new RegExp(
			'^'+_fnEscapeRegex(search)+'$',
			options.caseInsensitive ? 'i' : ''
		);
	}

	search = options.regex ?
		search :
		_fnEscapeRegex( search );
	
	if ( options.smart ) {
		/* For smart filtering we want to allow the search to work regardless of
		 * word order. We also want double quoted text to be preserved, so word
		 * order is important - a la google. And a negative look around for
		 * finding rows which don't contain a given string.
		 * 
		 * So this is the sort of thing we want to generate:
		 * 
		 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
		 */
		var parts = search.match( /!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g ) || [''];
		var a = parts.map( function ( word ) {
			var negative = false;
			var m;

			// Determine if it is a "does not include"
			if ( word.charAt(0) === '!' ) {
				negative = true;
				word = word.substring(1);
			}

			// Strip the quotes from around matched phrases
			if ( word.charAt(0) === '"' ) {
				m = word.match( /^"(.*)"$/ );
				word = m ? m[1] : word;
			}
			else if ( word.charAt(0) === '\u201C' ) {
				// Smart quote match (iPhone users)
				m = word.match( /^\u201C(.*)\u201D$/ );
				word = m ? m[1] : word;
			}

			// For our "not" case, we need to modify the string that is
			// allowed to match at the end of the expression.
			if (negative) {
				if (word.length > 1) {
					not.push('(?!'+word+')');
				}

				word = '';
			}

			return word.replace(/"/g, '');
		} );

		var match = not.length
			? not.join('')
			: '';

		var boundary = options.boundary
			? '\\b'
			: '';

		search = '^(?=.*?'+boundary+a.join( ')(?=.*?'+boundary )+')('+match+'.)*$';
	}

	return new RegExp( search, options.caseInsensitive ? 'i' : '' );
}


/**
 * Escape a string such that it can be used in a regular expression
 *  @param {string} sVal string to escape
 *  @returns {string} escaped string
 *  @memberof DataTable#oApi
 */
var _fnEscapeRegex = DataTable.util.escapeRegex;

var __filter_div = $('<div>')[0];
var __filter_div_textContent = __filter_div.textContent !== undefined;

// Update the filtering data for each row if needed (by invalidation or first run)
function _fnFilterData ( settings )
{
	var columns = settings.aoColumns;
	var data = settings.aoData;
	var column;
	var j, jen, filterData, cellData, row;
	var wasInvalidated = false;

	for ( var rowIdx=0 ; rowIdx<data.length ; rowIdx++ ) {
		if (! data[rowIdx]) {
			continue;
		}

		row = data[rowIdx];

		if ( ! row._aFilterData ) {
			filterData = [];

			for ( j=0, jen=columns.length ; j<jen ; j++ ) {
				column = columns[j];

				if ( column.bSearchable ) {
					cellData = _fnGetCellData( settings, rowIdx, j, 'filter' );

					// Search in DataTables is string based
					if ( cellData === null ) {
						cellData = '';
					}

					if ( typeof cellData !== 'string' && cellData.toString ) {
						cellData = cellData.toString();
					}
				}
				else {
					cellData = '';
				}

				// If it looks like there is an HTML entity in the string,
				// attempt to decode it so sorting works as expected. Note that
				// we could use a single line of jQuery to do this, but the DOM
				// method used here is much faster https://jsperf.com/html-decode
				if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
					__filter_div.innerHTML = cellData;
					cellData = __filter_div_textContent ?
						__filter_div.textContent :
						__filter_div.innerText;
				}

				if ( cellData.replace ) {
					cellData = cellData.replace(/[\r\n\u2028]/g, '');
				}

				filterData.push( cellData );
			}

			row._aFilterData = filterData;
			row._sFilterRow = filterData.join('  ');
			wasInvalidated = true;
		}
	}

	return wasInvalidated;
}


/**
 * Draw the table for the first time, adding all required features
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnInitialise ( settings )
{
	var i;
	var init = settings.oInit;
	var deferLoading = settings.deferLoading;
	var dataSrc = _fnDataSource( settings );

	// Ensure that the table data is fully initialised
	if ( ! settings.bInitialised ) {
		setTimeout( function(){ _fnInitialise( settings ); }, 200 );
		return;
	}

	// Build the header / footer for the table
	_fnBuildHead( settings, 'header' );
	_fnBuildHead( settings, 'footer' );

	// Load the table's state (if needed) and then render around it and draw
	_fnLoadState( settings, init, function () {
		// Then draw the header / footer
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );

		// Cache the paging start point, as the first redraw will reset it
		var iAjaxStart = settings.iInitDisplayStart

		// Local data load
		// Check if there is data passing into the constructor
		if ( init.aaData ) {
			for ( i=0 ; i<init.aaData.length ; i++ ) {
				_fnAddData( settings, init.aaData[ i ] );
			}
		}
		else if ( deferLoading || dataSrc == 'dom' ) {
			// Grab the data from the page
			_fnAddTr( settings, $(settings.nTBody).children('tr') );
		}

		// Filter not yet applied - copy the display master
		settings.aiDisplay = settings.aiDisplayMaster.slice();

		// Enable features
		_fnAddOptionsHtml( settings );
		_fnSortInit( settings );

		_colGroup( settings );

		/* Okay to show that something is going on now */
		_fnProcessingDisplay( settings, true );

		_fnCallbackFire( settings, null, 'preInit', [settings], true );

		// If there is default sorting required - let's do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show 'loading' message possibly)
		_fnReDraw( settings );

		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		if ( dataSrc != 'ssp' || deferLoading ) {
			// if there is an ajax source load the data
			if ( dataSrc == 'ajax' ) {
				_fnBuildAjax( settings, {}, function(json) {
					var aData = _fnAjaxDataSrc( settings, json );

					// Got the data - add it to the table
					for ( i=0 ; i<aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}

					// Reset the init display for cookie saving. We've already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear 'fresh'
					settings.iInitDisplayStart = iAjaxStart;

					_fnReDraw( settings );
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings );
				}, settings );
			}
			else {
				_fnInitComplete( settings );
				_fnProcessingDisplay( settings, false );
			}
		}
	} );
}


/**
 * Draw the table for the first time, adding all required features
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnInitComplete ( settings )
{
	if (settings._bInitComplete) {
		return;
	}

	var args = [settings, settings.json];

	settings._bInitComplete = true;

	// Table is fully set up and we have data, so calculate the
	// column widths
	_fnAdjustColumnSizing( settings );

	_fnCallbackFire( settings, null, 'plugin-init', args, true );
	_fnCallbackFire( settings, 'aoInitComplete', 'init', args, true );
}

function _fnLengthChange ( settings, val )
{
	var len = parseInt( val, 10 );
	settings._iDisplayLength = len;

	_fnLengthOverflow( settings );

	// Fire length change event
	_fnCallbackFire( settings, null, 'length', [settings, len] );
}

/**
 * Alter the display settings to change the page
 *  @param {object} settings DataTables settings object
 *  @param {string|int} action Paging action to take: "first", "previous",
 *    "next" or "last" or page number to jump to (integer)
 *  @param [bool] redraw Automatically draw the update or not
 *  @returns {bool} true page has changed, false - no change
 *  @memberof DataTable#oApi
 */
function _fnPageChange ( settings, action, redraw )
{
	var
		start     = settings._iDisplayStart,
		len       = settings._iDisplayLength,
		records   = settings.fnRecordsDisplay();

	if ( records === 0 || len === -1 )
	{
		start = 0;
	}
	else if ( typeof action === "number" )
	{
		start = action * len;

		if ( start > records )
		{
			start = 0;
		}
	}
	else if ( action == "first" )
	{
		start = 0;
	}
	else if ( action == "previous" )
	{
		start = len >= 0 ?
			start - len :
			0;

		if ( start < 0 )
		{
			start = 0;
		}
	}
	else if ( action == "next" )
	{
		if ( start + len < records )
		{
			start += len;
		}
	}
	else if ( action == "last" )
	{
		start = Math.floor( (records-1) / len) * len;
	}
	else if ( action === 'ellipsis' )
	{
		return;
	}
	else
	{
		_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
	}

	var changed = settings._iDisplayStart !== start;
	settings._iDisplayStart = start;

	_fnCallbackFire( settings, null, changed ? 'page' : 'page-nc', [settings] );

	if ( changed && redraw ) {
		_fnDraw( settings );
	}

	return changed;
}


/**
 * Generate the node required for the processing node
 *  @param {object} settings DataTables settings object
 */
function _processingHtml ( settings )
{
	var table = settings.nTable;
	var scrolling = settings.oScroll.sX !== '' || settings.oScroll.sY !== '';

	if ( settings.oFeatures.bProcessing ) {
		var n = $('<div/>', {
				'id': settings.sTableId + '_processing',
				'class': settings.oClasses.processing.container,
				'role': 'status'
			} )
			.html( settings.oLanguage.sProcessing )
			.append('<div><div></div><div></div><div></div><div></div></div>');

		// Different positioning depending on if scrolling is enabled or not
		if (scrolling) {
			n.prependTo( $('div.dt-scroll', settings.nTableWrapper) );
		}
		else {
			n.insertBefore( table );
		}

		$(table).on( 'processing.dt.DT', function (e, s, show) {
			n.css( 'display', show ? 'block' : 'none' );
		} );
	}
}


/**
 * Display or hide the processing indicator
 *  @param {object} settings DataTables settings object
 *  @param {bool} show Show the processing indicator (true) or not (false)
 */
function _fnProcessingDisplay ( settings, show )
{
	// Ignore cases when we are still redrawing
	if (settings.bDrawing && show === false) {
		return;
	}

	_fnCallbackFire( settings, null, 'processing', [settings, show] );
}

/**
 * Show the processing element if an action takes longer than a given time
 *
 * @param {*} settings DataTables settings object
 * @param {*} enable Do (true) or not (false) async processing (local feature enablement)
 * @param {*} run Function to run
 */
function _fnProcessingRun( settings, enable, run ) {
	if (! enable) {
		// Immediate execution, synchronous
		run();
	}
	else {
		_fnProcessingDisplay(settings, true);
		
		// Allow the processing display to show if needed
		setTimeout(function () {
			run();

			_fnProcessingDisplay(settings, false);
		}, 0);
	}
}
/**
 * Add any control elements for the table - specifically scrolling
 *  @param {object} settings dataTables settings object
 *  @returns {node} Node to add to the DOM
 *  @memberof DataTable#oApi
 */
function _fnFeatureHtmlTable ( settings )
{
	var table = $(settings.nTable);

	// Scrolling from here on in
	var scroll = settings.oScroll;

	if ( scroll.sX === '' && scroll.sY === '' ) {
		return settings.nTable;
	}

	var scrollX = scroll.sX;
	var scrollY = scroll.sY;
	var classes = settings.oClasses.scrolling;
	var caption = settings.captionNode;
	var captionSide = caption ? caption._captionSide : null;
	var headerClone = $( table[0].cloneNode(false) );
	var footerClone = $( table[0].cloneNode(false) );
	var footer = table.children('tfoot');
	var _div = '<div/>';
	var size = function ( s ) {
		return !s ? null : _fnStringToCss( s );
	};

	if ( ! footer.length ) {
		footer = null;
	}

	/*
	 * The HTML structure that we want to generate in this function is:
	 *  div - scroller
	 *    div - scroll head
	 *      div - scroll head inner
	 *        table - scroll head table
	 *          thead - thead
	 *    div - scroll body
	 *      table - table (master table)
	 *        thead - thead clone for sizing
	 *        tbody - tbody
	 *    div - scroll foot
	 *      div - scroll foot inner
	 *        table - scroll foot table
	 *          tfoot - tfoot
	 */
	var scroller = $( _div, { 'class': classes.container } )
		.append(
			$(_div, { 'class': classes.header.self } )
				.css( {
					overflow: 'hidden',
					position: 'relative',
					border: 0,
					width: scrollX ? size(scrollX) : '100%'
				} )
				.append(
					$(_div, { 'class': classes.header.inner } )
						.css( {
							'box-sizing': 'content-box',
							width: scroll.sXInner || '100%'
						} )
						.append(
							headerClone
								.removeAttr('id')
								.css( 'margin-left', 0 )
								.append( captionSide === 'top' ? caption : null )
								.append(
									table.children('thead')
								)
						)
				)
		)
		.append(
			$(_div, { 'class': classes.body } )
				.css( {
					position: 'relative',
					overflow: 'auto',
					width: size( scrollX )
				} )
				.append( table )
		);

	if ( footer ) {
		scroller.append(
			$(_div, { 'class': classes.footer.self } )
				.css( {
					overflow: 'hidden',
					border: 0,
					width: scrollX ? size(scrollX) : '100%'
				} )
				.append(
					$(_div, { 'class': classes.footer.inner } )
						.append(
							footerClone
								.removeAttr('id')
								.css( 'margin-left', 0 )
								.append( captionSide === 'bottom' ? caption : null )
								.append(
									table.children('tfoot')
								)
						)
				)
		);
	}

	var children = scroller.children();
	var scrollHead = children[0];
	var scrollBody = children[1];
	var scrollFoot = footer ? children[2] : null;

	// When the body is scrolled, then we also want to scroll the headers
	$(scrollBody).on( 'scroll.DT', function () {
		var scrollLeft = this.scrollLeft;

		scrollHead.scrollLeft = scrollLeft;

		if ( footer ) {
			scrollFoot.scrollLeft = scrollLeft;
		}
	} );

	// When focus is put on the header cells, we might need to scroll the body
	$('th, td', scrollHead).on('focus', function () {
		var scrollLeft = scrollHead.scrollLeft;

		scrollBody.scrollLeft = scrollLeft;

		if ( footer ) {
			scrollBody.scrollLeft = scrollLeft;
		}
	});

	$(scrollBody).css('max-height', scrollY);
	if (! scroll.bCollapse) {
		$(scrollBody).css('height', scrollY);
	}

	settings.nScrollHead = scrollHead;
	settings.nScrollBody = scrollBody;
	settings.nScrollFoot = scrollFoot;

	// On redraw - align columns
	settings.aoDrawCallback.push(_fnScrollDraw);

	return scroller[0];
}



/**
 * Update the header, footer and body tables for resizing - i.e. column
 * alignment.
 *
 * Welcome to the most horrible function DataTables. The process that this
 * function follows is basically:
 *   1. Re-create the table inside the scrolling div
 *   2. Correct colgroup > col values if needed
 *   3. Copy colgroup > col over to header and footer
 *   4. Clean up
 *
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnScrollDraw ( settings )
{
	// Given that this is such a monster function, a lot of variables are use
	// to try and keep the minimised size as small as possible
	var
		scroll         = settings.oScroll,
		barWidth       = scroll.iBarWidth,
		divHeader      = $(settings.nScrollHead),
		divHeaderInner = divHeader.children('div'),
		divHeaderTable = divHeaderInner.children('table'),
		divBodyEl      = settings.nScrollBody,
		divBody        = $(divBodyEl),
		divFooter      = $(settings.nScrollFoot),
		divFooterInner = divFooter.children('div'),
		divFooterTable = divFooterInner.children('table'),
		header         = $(settings.nTHead),
		table          = $(settings.nTable),
		footer         = settings.nTFoot && $('th, td', settings.nTFoot).length ? $(settings.nTFoot) : null,
		browser        = settings.oBrowser,
		headerCopy, footerCopy;

	// If the scrollbar visibility has changed from the last draw, we need to
	// adjust the column sizes as the table width will have changed to account
	// for the scrollbar
	var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
	
	if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
		settings.scrollBarVis = scrollBarVis;
		_fnAdjustColumnSizing( settings );
		return; // adjust column sizing will call this function again
	}
	else {
		settings.scrollBarVis = scrollBarVis;
	}

	// 1. Re-create the table inside the scrolling div
	// Remove the old minimised thead and tfoot elements in the inner table
	table.children('thead, tfoot').remove();

	// Clone the current header and footer elements and then place it into the inner table
	headerCopy = header.clone().prependTo( table );
	headerCopy.find('th, td').removeAttr('tabindex');
	headerCopy.find('[id]').removeAttr('id');

	if ( footer ) {
		footerCopy = footer.clone().prependTo( table );
		footerCopy.find('[id]').removeAttr('id');
	}

	// 2. Correct colgroup > col values if needed
	// It is possible that the cell sizes are smaller than the content, so we need to
	// correct colgroup>col for such cases. This can happen if the auto width detection
	// uses a cell which has a longer string, but isn't the widest! For example 
	// "Chief Executive Officer (CEO)" is the longest string in the demo, but
	// "Systems Administrator" is actually the widest string since it doesn't collapse.
	// Note the use of translating into a column index to get the `col` element. This
	// is because of Responsive which might remove `col` elements, knocking the alignment
	// of the indexes out.
	if (settings.aiDisplay.length) {
		// Get the column sizes from the first row in the table. This should really be a
		// [].find, but it wasn't supported in Chrome until Sept 2015, and DT has 10 year
		// browser support
		var firstTr = null;
		var start = _fnDataSource( settings ) !== 'ssp'
			? settings._iDisplayStart
			: 0;

		for (i=start ; i<start + settings.aiDisplay.length ; i++) {
			var idx = settings.aiDisplay[i];
			var tr = settings.aoData[idx].nTr;

			if (tr) {
				firstTr = tr;
				break;
			}
		}

		if (firstTr) {
			var colSizes = $(firstTr).children('th, td').map(function (vis) {
				return {
					idx: _fnVisibleToColumnIndex(settings, vis),
					width: $(this).outerWidth()
				};
			});

			// Check against what the colgroup > col is set to and correct if needed
			for (var i=0 ; i<colSizes.length ; i++) {
				var colEl = settings.aoColumns[ colSizes[i].idx ].colEl[0];
				var colWidth = colEl.style.width.replace('px', '');

				if (colWidth !== colSizes[i].width) {
					colEl.style.width = colSizes[i].width + 'px';

					if (scroll.sX) {
						colEl.style.minWidth = colSizes[i].width + 'px';
					}
				}
			}
		}
	}

	// 3. Copy the colgroup over to the header and footer
	divHeaderTable
		.find('colgroup')
		.remove();

	divHeaderTable.append(settings.colgroup.clone());

	if ( footer ) {
		divFooterTable
			.find('colgroup')
			.remove();

		divFooterTable.append(settings.colgroup.clone());
	}

	// "Hide" the header and footer that we used for the sizing. We need to keep
	// the content of the cell so that the width applied to the header and body
	// both match, but we want to hide it completely.
	$('th, td', headerCopy).each(function () {
		$(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
	});

	if ( footer ) {
		$('th, td', footerCopy).each(function () {
			$(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
		});
	}

	// 4. Clean up
	// Figure out if there are scrollbar present - if so then we need a the header and footer to
	// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
	var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
	var paddingSide = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );

	// Set the width's of the header and footer tables
	var outerWidth = table.outerWidth();

	divHeaderTable.css('width', _fnStringToCss( outerWidth ));
	divHeaderInner
		.css('width', _fnStringToCss( outerWidth ))
		.css(paddingSide, isScrolling ? barWidth+"px" : "0px");

	if ( footer ) {
		divFooterTable.css('width', _fnStringToCss( outerWidth ));
		divFooterInner
			.css('width', _fnStringToCss( outerWidth ))
			.css(paddingSide, isScrolling ? barWidth+"px" : "0px");
	}

	// Correct DOM ordering for colgroup - comes before the thead
	table.children('colgroup').prependTo(table);

	// Adjust the position of the header in case we loose the y-scrollbar
	divBody.trigger('scroll');

	// If sorting or filtering has occurred, jump the scrolling back to the top
	// only if we aren't holding the position
	if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
		divBodyEl.scrollTop = 0;
	}
}

/**
 * Calculate the width of columns for the table
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnCalculateColumnWidths ( settings )
{
	// Not interested in doing column width calculation if auto-width is disabled
	if (! settings.oFeatures.bAutoWidth) {
		return;
	}

	var
		table = settings.nTable,
		columns = settings.aoColumns,
		scroll = settings.oScroll,
		scrollY = scroll.sY,
		scrollX = scroll.sX,
		scrollXInner = scroll.sXInner,
		visibleColumns = _fnGetColumns( settings, 'bVisible' ),
		tableWidthAttr = table.getAttribute('width'), // from DOM element
		tableContainer = table.parentNode,
		i, column, columnIdx;
		
	var styleWidth = table.style.width;
	var containerWidth = _fnWrapperWidth(settings);

	// Don't re-run for the same width as the last time
	if (containerWidth === settings.containerWidth) {
		return false;
	}

	settings.containerWidth = containerWidth;

	// If there is no width applied as a CSS style or as an attribute, we assume that
	// the width is intended to be 100%, which is usually is in CSS, but it is very
	// difficult to correctly parse the rules to get the final result.
	if ( ! styleWidth && ! tableWidthAttr) {
		table.style.width = '100%';
		styleWidth = '100%';
	}

	if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
		tableWidthAttr = styleWidth;
	}

	// Let plug-ins know that we are doing a recalc, in case they have changed any of the
	// visible columns their own way (e.g. Responsive uses display:none).
	_fnCallbackFire(
		settings,
		null,
		'column-calc',
		{visible: visibleColumns},
		false
	);

	// Construct a single row, worst case, table with the widest
	// node in the data, assign any user defined widths, then insert it into
	// the DOM and allow the browser to do all the hard work of calculating
	// table widths
	var tmpTable = $(table.cloneNode())
		.css( 'visibility', 'hidden' )
		.removeAttr( 'id' );

	// Clean up the table body
	tmpTable.append('<tbody>')
	var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );

	// Clone the table header and footer - we can't use the header / footer
	// from the cloned table, since if scrolling is active, the table's
	// real header and footer are contained in different table tags
	tmpTable
		.append( $(settings.nTHead).clone() )
		.append( $(settings.nTFoot).clone() );

	// Remove any assigned widths from the footer (from scrolling)
	tmpTable.find('tfoot th, tfoot td').css('width', '');

	// Apply custom sizing to the cloned header
	tmpTable.find('thead th, thead td').each( function () {
		// Get the `width` from the header layout
		var width = _fnColumnsSumWidth( settings, this, true, false );

		if ( width ) {
			this.style.width = width;

			// For scrollX we need to force the column width otherwise the
			// browser will collapse it. If this width is smaller than the
			// width the column requires, then it will have no effect
			if ( scrollX ) {
				this.style.minWidth = width;

				$( this ).append( $('<div/>').css( {
					width: width,
					margin: 0,
					padding: 0,
					border: 0,
					height: 1
				} ) );
			}
		}
		else {
			this.style.width = '';
		}
	} );

	// Find the widest piece of data for each column and put it into the table
	for ( i=0 ; i<visibleColumns.length ; i++ ) {
		columnIdx = visibleColumns[i];
		column = columns[ columnIdx ];

		var longest = _fnGetMaxLenString(settings, columnIdx);
		var autoClass = _ext.type.className[column.sType];
		var text = longest + column.sContentPadding;
		var insert = longest.indexOf('<') === -1
			? document.createTextNode(text)
			: text
		
		$('<td/>')
			.addClass(autoClass)
			.addClass(column.sClass)
			.append(insert)
			.appendTo(tr);
	}

	// Tidy the temporary table - remove name attributes so there aren't
	// duplicated in the dom (radio elements for example)
	$('[name]', tmpTable).removeAttr('name');

	// Table has been built, attach to the document so we can work with it.
	// A holding element is used, positioned at the top of the container
	// with minimal height, so it has no effect on if the container scrolls
	// or not. Otherwise it might trigger scrolling when it actually isn't
	// needed
	var holder = $('<div/>').css( scrollX || scrollY ?
			{
				position: 'absolute',
				top: 0,
				left: 0,
				height: 1,
				right: 0,
				overflow: 'hidden'
			} :
			{}
		)
		.append( tmpTable )
		.appendTo( tableContainer );

	// When scrolling (X or Y) we want to set the width of the table as 
	// appropriate. However, when not scrolling leave the table width as it
	// is. This results in slightly different, but I think correct behaviour
	if ( scrollX && scrollXInner ) {
		tmpTable.width( scrollXInner );
	}
	else if ( scrollX ) {
		tmpTable.css( 'width', 'auto' );
		tmpTable.removeAttr('width');

		// If there is no width attribute or style, then allow the table to
		// collapse
		if ( tmpTable.outerWidth() < tableContainer.clientWidth && tableWidthAttr ) {
			tmpTable.outerWidth( tableContainer.clientWidth );
		}
	}
	else if ( scrollY ) {
		tmpTable.outerWidth( tableContainer.clientWidth );
	}
	else if ( tableWidthAttr ) {
		tmpTable.outerWidth( tableWidthAttr );
	}

	// Get the width of each column in the constructed table
	var total = 0;
	var bodyCells = tmpTable.find('tbody tr').eq(0).children();

	for ( i=0 ; i<visibleColumns.length ; i++ ) {
		// Use getBounding for sub-pixel accuracy, which we then want to round up!
		var bounding = bodyCells[i].getBoundingClientRect().width;

		// Total is tracked to remove any sub-pixel errors as the outerWidth
		// of the table might not equal the total given here
		total += bounding;

		// Width for each column to use
		columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding );
	}

	table.style.width = _fnStringToCss( total );

	// Finished with the table - ditch it
	holder.remove();

	// If there is a width attr, we want to attach an event listener which
	// allows the table sizing to automatically adjust when the window is
	// resized. Use the width attr rather than CSS, since we can't know if the
	// CSS is a relative value or absolute - DOM read is always px.
	if ( tableWidthAttr ) {
		table.style.width = _fnStringToCss( tableWidthAttr );
	}

	if ( (tableWidthAttr || scrollX) && ! settings._reszEvt ) {
		var resize = DataTable.util.throttle( function () {
			var newWidth = _fnWrapperWidth(settings);

			// Don't do it if destroying or the container width is 0
			if (! settings.bDestroying && newWidth !== 0) {
				_fnAdjustColumnSizing( settings );
			}
		} );

		// For browsers that support it (~2020 onwards for wide support) we can watch for the
		// container changing width.
		if (window.ResizeObserver) {
			// This is a tricky beast - if the element is visible when `.observe()` is called,
			// then the callback is immediately run. Which we don't want. If the element isn't
			// visible, then it isn't run, but we want it to run when it is then made visible.
			// This flag allows the above to be satisfied.
			var first = $(settings.nTableWrapper).is(':visible');

			// Use an empty div to attach the observer so it isn't impacted by height changes
			var resizer = $('<div>')
				.css({
					width: '100%',
					height: 0
				})
				.addClass('dt-autosize')
				.appendTo(settings.nTableWrapper);

			settings.resizeObserver = new ResizeObserver(function (e) {
				if (first) {
					first = false;
				}
				else {
					resize();
				}
			});

			settings.resizeObserver.observe(resizer[0]);
		}
		else {
			// For old browsers, the best we can do is listen for a window resize
			$(window).on('resize.DT-'+settings.sInstance, resize);
		}

		settings._reszEvt = true;
	}
}

/**
 * Get the width of the DataTables wrapper element
 *
 * @param {*} settings DataTables settings object
 * @returns Width
 */
function _fnWrapperWidth(settings) {
	return $(settings.nTableWrapper).is(':visible')
		? $(settings.nTableWrapper).width()
		: 0;
}

/**
 * Get the maximum strlen for each data column
 *  @param {object} settings dataTables settings object
 *  @param {int} colIdx column of interest
 *  @returns {string} string of the max length
 *  @memberof DataTable#oApi
 */
function _fnGetMaxLenString( settings, colIdx )
{
	var column = settings.aoColumns[colIdx];

	if (! column.maxLenString) {
		var s, max='', maxLen = -1;
	
		for ( var i=0, ien=settings.aiDisplayMaster.length ; i<ien ; i++ ) {
			var rowIdx = settings.aiDisplayMaster[i];
			var data = _fnGetRowDisplay(settings, rowIdx)[colIdx];

			var cellString = data && typeof data === 'object' && data.nodeType
				? data.innerHTML
				: data+'';

			// Remove id / name attributes from elements so they
			// don't interfere with existing elements
			cellString = cellString
				.replace(/id=".*?"/g, '')
				.replace(/name=".*?"/g, '');

			s = _stripHtml(cellString)
				.replace( /&nbsp;/g, ' ' );
	
			if ( s.length > maxLen ) {
				// We want the HTML in the string, but the length that
				// is important is the stripped string
				max = cellString;
				maxLen = s.length;
			}
		}

		column.maxLenString = max;
	}

	return column.maxLenString;
}


/**
 * Append a CSS unit (only if required) to a string
 *  @param {string} value to css-ify
 *  @returns {string} value with css unit
 *  @memberof DataTable#oApi
 */
function _fnStringToCss( s )
{
	if ( s === null ) {
		return '0px';
	}

	if ( typeof s == 'number' ) {
		return s < 0 ?
			'0px' :
			s+'px';
	}

	// Check it has a unit character already
	return s.match(/\d$/) ?
		s+'px' :
		s;
}

/**
 * Re-insert the `col` elements for current visibility
 *
 * @param {*} settings DT settings
 */
function _colGroup( settings ) {
	var cols = settings.aoColumns;

	settings.colgroup.empty();

	for (i=0 ; i<cols.length ; i++) {
		if (cols[i].bVisible) {
			settings.colgroup.append(cols[i].colEl);
		}
	}
}


function _fnSortInit( settings ) {
	var target = settings.nTHead;
	var headerRows = target.querySelectorAll('tr');
	var legacyTop = settings.bSortCellsTop;
	var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
	
	// Legacy support for `orderCellsTop`
	if (legacyTop === true) {
		target = headerRows[0];
	}
	else if (legacyTop === false) {
		target = headerRows[ headerRows.length - 1 ];
	}

	_fnSortAttachListener(
		settings,
		target,
		target === settings.nTHead
			? 'tr'+notSelector+' th'+notSelector+', tr'+notSelector+' td'+notSelector
			: 'th'+notSelector+', td'+notSelector
	);

	// Need to resolve the user input array into our internal structure
	var order = [];
	_fnSortResolve( settings, order, settings.aaSorting );

	settings.aaSorting = order;
}


function _fnSortAttachListener(settings, node, selector, column, callback) {
	_fnBindAction( node, selector, function (e) {
		var run = false;
		var columns = column === undefined
			? _fnColumnsFromHeader( e.target )
			: [column];

		if ( columns.length ) {
			for ( var i=0, ien=columns.length ; i<ien ; i++ ) {
				var ret = _fnSortAdd( settings, columns[i], i, e.shiftKey );

				if (ret !== false) {
					run = true;
				}					

				// If the first entry is no sort, then subsequent
				// sort columns are ignored
				if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === '') {
					break;
				}
			}

			if (run) {
				_fnProcessingRun(settings, true, function () {
					_fnSort( settings );
					_fnSortDisplay( settings, settings.aiDisplay );

					_fnReDraw( settings, false, false );

					if (callback) {
						callback();
					}
				});
			}
		}
	} );
}

/**
 * Sort the display array to match the master's order
 * @param {*} settings
 */
function _fnSortDisplay(settings, display) {
	if (display.length < 2) {
		return;
	}

	var master = settings.aiDisplayMaster;
	var masterMap = {};
	var map = {};
	var i;

	// Rather than needing an `indexOf` on master array, we can create a map
	for (i=0 ; i<master.length ; i++) {
		masterMap[master[i]] = i;
	}

	// And then cache what would be the indexOf fom the display
	for (i=0 ; i<display.length ; i++) {
		map[display[i]] = masterMap[display[i]];
	}

	display.sort(function(a, b){
		// Short version of this function is simply `master.indexOf(a) - master.indexOf(b);`
		return map[a] - map[b];
	});
}


function _fnSortResolve (settings, nestedSort, sort) {
	var push = function ( a ) {
		if ($.isPlainObject(a)) {
			if (a.idx !== undefined) {
				// Index based ordering
				nestedSort.push([a.idx, a.dir]);
			}
			else if (a.name) {
				// Name based ordering
				var cols = _pluck( settings.aoColumns, 'sName');
				var idx = cols.indexOf(a.name);

				if (idx !== -1) {
					nestedSort.push([idx, a.dir]);
				}
			}
		}
		else {
			// Plain column index and direction pair
			nestedSort.push(a);
		}
	};

	if ( $.isPlainObject(sort) ) {
		// Object
		push(sort);
	}
	else if ( sort.length && typeof sort[0] === 'number' ) {
		// 1D array
		push(sort);
	}
	else if ( sort.length ) {
		// 2D array
		for (var z=0; z<sort.length; z++) {
			push(sort[z]); // Object or array
		}
	}
}


function _fnSortFlatten ( settings )
{
	var
		i, k, kLen,
		aSort = [],
		extSort = DataTable.ext.type.order,
		aoColumns = settings.aoColumns,
		aDataSort, iCol, sType, srcCol,
		fixed = settings.aaSortingFixed,
		fixedObj = $.isPlainObject( fixed ),
		nestedSort = [];
	
	if ( ! settings.oFeatures.bSort ) {
		return aSort;
	}

	// Build the sort array, with pre-fix and post-fix options if they have been
	// specified
	if ( Array.isArray( fixed ) ) {
		_fnSortResolve( settings, nestedSort, fixed );
	}

	if ( fixedObj && fixed.pre ) {
		_fnSortResolve( settings, nestedSort, fixed.pre );
	}

	_fnSortResolve( settings, nestedSort, settings.aaSorting );

	if (fixedObj && fixed.post ) {
		_fnSortResolve( settings, nestedSort, fixed.post );
	}

	for ( i=0 ; i<nestedSort.length ; i++ )
	{
		srcCol = nestedSort[i][0];

		if ( aoColumns[ srcCol ] ) {
			aDataSort = aoColumns[ srcCol ].aDataSort;

			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || 'string';

				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
				}

				if ( nestedSort[i][1] ) {
					aSort.push( {
						src:       srcCol,
						col:       iCol,
						dir:       nestedSort[i][1],
						index:     nestedSort[i]._idx,
						type:      sType,
						formatter: extSort[ sType+"-pre" ],
						sorter:    extSort[ sType+"-"+nestedSort[i][1] ]
					} );
				}
			}
		}
	}

	return aSort;
}

/**
 * Change the order of the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnSort ( oSettings, col, dir )
{
	var
		i, ien, iLen,
		aiOrig = [],
		extSort = DataTable.ext.type.order,
		aoData = oSettings.aoData,
		sortCol,
		displayMaster = oSettings.aiDisplayMaster,
		aSort;

	// Make sure the columns all have types defined
	_fnColumnTypes(oSettings);

	// Allow a specific column to be sorted, which will _not_ alter the display
	// master
	if (col !== undefined) {
		var srcCol = oSettings.aoColumns[col];

		aSort = [{
			src:       col,
			col:       col,
			dir:       dir,
			index:     0,
			type:      srcCol.sType,
			formatter: extSort[ srcCol.sType+"-pre" ],
			sorter:    extSort[ srcCol.sType+"-"+dir ]
		}];
		displayMaster = displayMaster.slice();
	}
	else {
		aSort = _fnSortFlatten( oSettings );
	}

	for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
		sortCol = aSort[i];

		// Load the data needed for the sort, for each cell
		_fnSortData( oSettings, sortCol.col );
	}

	/* No sorting required if server-side or no sorting array */
	if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
	{
		// Reset the initial positions on each pass so we get a stable sort
		for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
			aiOrig[ i ] = i;
		}

		// If the first sort is desc, then reverse the array to preserve original
		// order, just in reverse
		if (aSort.length && aSort[0].dir === 'desc' && oSettings.orderDescReverse) {
			aiOrig.reverse();
		}

		/* Do the sort - here we want multi-column sorting based on a given data source (column)
		 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
		 * follow on it's own, but this is what we want (example two column sorting):
		 *  fnLocalSorting = function(a,b){
		 *    var test;
		 *    test = oSort['string-asc']('data11', 'data12');
		 *      if (test !== 0)
		 *        return test;
		 *    test = oSort['numeric-desc']('data21', 'data22');
		 *    if (test !== 0)
		 *      return test;
		 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
		 *  }
		 * Basically we have a test for each sorting column, if the data in that column is equal,
		 * test the next column. If all columns match, then we use a numeric sort on the row
		 * positions in the original data array to provide a stable sort.
		 */
		displayMaster.sort( function ( a, b ) {
			var
				x, y, k, test, sort,
				len=aSort.length,
				dataA = aoData[a]._aSortData,
				dataB = aoData[b]._aSortData;

			for ( k=0 ; k<len ; k++ ) {
				sort = aSort[k];

				// Data, which may have already been through a `-pre` function
				x = dataA[ sort.col ];
				y = dataB[ sort.col ];

				if (sort.sorter) {
					// If there is a custom sorter (`-asc` or `-desc`) for this
					// data type, use it
					test = sort.sorter(x, y);

					if ( test !== 0 ) {
						return test;
					}
				}
				else {
					// Otherwise, use generic sorting
					test = x<y ? -1 : x>y ? 1 : 0;

					if ( test !== 0 ) {
						return sort.dir === 'asc' ? test : -test;
					}
				}
			}

			x = aiOrig[a];
			y = aiOrig[b];

			return x<y ? -1 : x>y ? 1 : 0;
		} );
	}
	else if ( aSort.length === 0 ) {
		// Apply index order
		displayMaster.sort(function (x, y) {
			return x<y ? -1 : x>y ? 1 : 0;
		});
	}

	if (col === undefined) {
		// Tell the draw function that we have sorted the data
		oSettings.bSorted = true;
		oSettings.sortDetails = aSort;

		_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort] );
	}

	return displayMaster;
}


/**
 * Function to run on user sort request
 *  @param {object} settings dataTables settings object
 *  @param {node} attachTo node to attach the handler to
 *  @param {int} colIdx column sorting index
 *  @param {int} addIndex Counter
 *  @param {boolean} [shift=false] Shift click add
 *  @param {function} [callback] callback function
 *  @memberof DataTable#oApi
 */
function _fnSortAdd ( settings, colIdx, addIndex, shift )
{
	var col = settings.aoColumns[ colIdx ];
	var sorting = settings.aaSorting;
	var asSorting = col.asSorting;
	var nextSortIdx;
	var next = function ( a, overflow ) {
		var idx = a._idx;
		if ( idx === undefined ) {
			idx = asSorting.indexOf(a[1]);
		}

		return idx+1 < asSorting.length ?
			idx+1 :
			overflow ?
				null :
				0;
	};

	if ( ! col.bSortable ) {
		return false;
	}

	// Convert to 2D array if needed
	if ( typeof sorting[0] === 'number' ) {
		sorting = settings.aaSorting = [ sorting ];
	}

	// If appending the sort then we are multi-column sorting
	if ( (shift || addIndex) && settings.oFeatures.bSortMulti ) {
		// Are we already doing some kind of sort on this column?
		var sortIdx = _pluck(sorting, '0').indexOf(colIdx);

		if ( sortIdx !== -1 ) {
			// Yes, modify the sort
			nextSortIdx = next( sorting[sortIdx], true );

			if ( nextSortIdx === null && sorting.length === 1 ) {
				nextSortIdx = 0; // can't remove sorting completely
			}

			if ( nextSortIdx === null ) {
				sorting.splice( sortIdx, 1 );
			}
			else {
				sorting[sortIdx][1] = asSorting[ nextSortIdx ];
				sorting[sortIdx]._idx = nextSortIdx;
			}
		}
		else if (shift) {
			// No sort on this column yet, being added by shift click
			// add it as itself
			sorting.push( [ colIdx, asSorting[0], 0 ] );
			sorting[sorting.length-1]._idx = 0;
		}
		else {
			// No sort on this column yet, being added from a colspan
			// so add with same direction as first column
			sorting.push( [ colIdx, sorting[0][1], 0 ] );
			sorting[sorting.length-1]._idx = 0;
		}
	}
	else if ( sorting.length && sorting[0][0] == colIdx ) {
		// Single column - already sorting on this column, modify the sort
		nextSortIdx = next( sorting[0] );

		sorting.length = 1;
		sorting[0][1] = asSorting[ nextSortIdx ];
		sorting[0]._idx = nextSortIdx;
	}
	else {
		// Single column - sort only on this column
		sorting.length = 0;
		sorting.push( [ colIdx, asSorting[0] ] );
		sorting[0]._idx = 0;
	}
}


/**
 * Set the sorting classes on table's body, Note: it is safe to call this function
 * when bSort and bSortClasses are false
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnSortingClasses( settings )
{
	var oldSort = settings.aLastSort;
	var sortClass = settings.oClasses.order.position;
	var sort = _fnSortFlatten( settings );
	var features = settings.oFeatures;
	var i, ien, colIdx;

	if ( features.bSort && features.bSortClasses ) {
		// Remove old sorting classes
		for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
			colIdx = oldSort[i].src;

			// Remove column sorting
			$( _pluck( settings.aoData, 'anCells', colIdx ) )
				.removeClass( sortClass + (i<2 ? i+1 : 3) );
		}

		// Add new column sorting
		for ( i=0, ien=sort.length ; i<ien ; i++ ) {
			colIdx = sort[i].src;

			$( _pluck( settings.aoData, 'anCells', colIdx ) )
				.addClass( sortClass + (i<2 ? i+1 : 3) );
		}
	}

	settings.aLastSort = sort;
}


// Get the data to sort a column, be it from cache, fresh (populating the
// cache), or from a sort formatter
function _fnSortData( settings, colIdx )
{
	// Custom sorting function - provided by the sort data type
	var column = settings.aoColumns[ colIdx ];
	var customSort = DataTable.ext.order[ column.sSortDataType ];
	var customData;

	if ( customSort ) {
		customData = customSort.call( settings.oInstance, settings, colIdx,
			_fnColumnIndexToVisible( settings, colIdx )
		);
	}

	// Use / populate cache
	var row, cellData;
	var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
	var data = settings.aoData;

	for ( var rowIdx=0 ; rowIdx<data.length ; rowIdx++ ) {
		// Sparse array
		if (! data[rowIdx]) {
			continue;
		}

		row = data[rowIdx];

		if ( ! row._aSortData ) {
			row._aSortData = [];
		}

		if ( ! row._aSortData[colIdx] || customSort ) {
			cellData = customSort ?
				customData[rowIdx] : // If there was a custom sort function, use data from there
				_fnGetCellData( settings, rowIdx, colIdx, 'sort' );

			row._aSortData[ colIdx ] = formatter ?
				formatter( cellData, settings ) :
				cellData;
		}
	}
}


/**
 * State information for a table
 *
 * @param {*} settings
 * @returns State object
 */
function _fnSaveState ( settings )
{
	if (settings._bLoadingState) {
		return;
	}

	// Sort state saving uses [[idx, order]] structure.
	var sorting = [];
	_fnSortResolve(settings, sorting, settings.aaSorting );

	/* Store the interesting variables */
	var columns = settings.aoColumns;
	var state = {
		time:    +new Date(),
		start:   settings._iDisplayStart,
		length:  settings._iDisplayLength,
		order:   sorting.map(function (sort) {
			// If a column name is available, use it
			return columns[sort[0]] && columns[sort[0]].sName
				? [ columns[sort[0]].sName, sort[1] ]
				: sort.slice();
		} ),
		search:  $.extend({}, settings.oPreviousSearch),
		columns: settings.aoColumns.map( function ( col, i ) {
			return {
				name: col.sName,
				visible: col.bVisible,
				search: $.extend({}, settings.aoPreSearchCols[i])
			};
		} )
	};

	settings.oSavedState = state;
	_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
	
	if ( settings.oFeatures.bStateSave && !settings.bDestroying )
	{
		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
	}	
}


/**
 * Attempt to load a saved table state
 *  @param {object} oSettings dataTables settings object
 *  @param {object} oInit DataTables init object so we can override settings
 *  @param {function} callback Callback to execute when the state has been loaded
 *  @memberof DataTable#oApi
 */
function _fnLoadState ( settings, init, callback )
{
	if ( ! settings.oFeatures.bStateSave ) {
		callback();
		return;
	}

	var loaded = function(state) {
		_fnImplementState(settings, state, callback);
	}

	var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );

	if ( state !== undefined ) {
		_fnImplementState( settings, state, callback );
	}
	// otherwise, wait for the loaded callback to be executed

	return true;
}

function _fnImplementState ( settings, s, callback) {
	var i, ien;
	var columns = settings.aoColumns;
	var currentNames = _pluck(settings.aoColumns, 'sName');

	settings._bLoadingState = true;

	// When StateRestore was introduced the state could now be implemented at any time
	// Not just initialisation. To do this an api instance is required in some places
	var api = settings._bInitComplete ? new DataTable.Api(settings) : null;

	if ( ! s || ! s.time ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Reject old data
	var duration = settings.iStateDuration;
	if ( duration > 0 && s.time < +new Date() - (duration*1000) ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Allow custom and plug-in manipulation functions to alter the saved data set and
	// cancelling of loading by returning false
	var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );
	if ( abStateLoad.indexOf(false) !== -1 ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Store the saved state so it might be accessed at any time
	settings.oLoadedState = $.extend( true, {}, s );

	// This is needed for ColReorder, which has to happen first to allow all
	// the stored indexes to be usable. It is not publicly documented.
	_fnCallbackFire( settings, null, 'stateLoadInit', [settings, s], true );

	// Page Length
	if ( s.length !== undefined ) {
		// If already initialised just set the value directly so that the select element is also updated
		if (api) {
			api.page.len(s.length)
		}
		else {
			settings._iDisplayLength   = s.length;
		}
	}

	// Restore key features
	if ( s.start !== undefined ) {
		if(api === null) {
			settings._iDisplayStart    = s.start;
			settings.iInitDisplayStart = s.start;
		}
		else {
			_fnPageChange(settings, s.start/settings._iDisplayLength);
		}
	}

	// Order
	if ( s.order !== undefined ) {
		settings.aaSorting = [];
		$.each( s.order, function ( i, col ) {
			var set = [ col[0], col[1] ];

			// A column name was stored and should be used for restore
			if (typeof col[0] === 'string') {
				var idx = currentNames.indexOf(col[0]);

				// Find the name from the current list of column names, or fallback to index 0
				set[0] = idx >= 0
					? idx
					: 0;
			}
			else if (set[0] >= columns.length) {
				// If a column name, but it is out of bounds, set to 0
				set[0] = 0;
			}

			settings.aaSorting.push(set);
		} );
	}

	// Search
	if ( s.search !== undefined ) {
		$.extend( settings.oPreviousSearch, s.search );
	}

	// Columns
	if ( s.columns ) {
		var set = s.columns;
		var incoming = _pluck(s.columns, 'name');

		// Check if it is a 2.2 style state object with a `name` property for the columns, and if
		// the name was defined. If so, then create a new array that will map the state object
		// given, to the current columns (don't bother if they are already matching tho).
		if (incoming.join('').length && incoming.join('') !== currentNames.join('')) {
			set = [];

			// For each column, try to find the name in the incoming array
			for (i=0 ; i<currentNames.length ; i++) {
				if (currentNames[i] != '') {
					var idx = incoming.indexOf(currentNames[i]);

					if (idx >= 0) {
						set.push(s.columns[idx]);
					}
					else {
						// No matching column name in the state's columns, so this might be a new
						// column and thus can't have a state already.
						set.push({});
					}
				}
				else {
					// If no name, but other columns did have a name, then there is no knowing
					// where this one came from originally so it can't be restored.
					set.push({});
				}
			}
		}

		// If the number of columns to restore is different from current, then all bets are off.
		if (set.length === columns.length) {
			for ( i=0, ien=set.length ; i<ien ; i++ ) {
				var col = set[i];

				// Visibility
				if ( col.visible !== undefined ) {
					// If the api is defined, the table has been initialised so we need to use it rather than internal settings
					if (api) {
						// Don't redraw the columns on every iteration of this loop, we will do this at the end instead
						api.column(i).visible(col.visible, false);
					}
					else {
						columns[i].bVisible = col.visible;
					}
				}

				// Search
				if ( col.search !== undefined ) {
					$.extend( settings.aoPreSearchCols[i], col.search );
				}
			}

			// If the api is defined then we need to adjust the columns once the visibility has been changed
			if (api) {
				api.columns.adjust();
			}
		}
	}

	settings._bLoadingState = false;
	_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );
	callback();
}

/**
 * Log an error message
 *  @param {object} settings dataTables settings object
 *  @param {int} level log error messages, or display them to the user
 *  @param {string} msg error message
 *  @param {int} tn Technical note id to get more information about the error.
 *  @memberof DataTable#oApi
 */
function _fnLog( settings, level, msg, tn )
{
	msg = 'DataTables warning: '+
		(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;

	if ( tn ) {
		msg += '. For more information about this error, please see '+
		'https://datatables.net/tn/'+tn;
	}

	if ( ! level  ) {
		// Backwards compatibility pre 1.10
		var ext = DataTable.ext;
		var type = ext.sErrMode || ext.errMode;

		if ( settings ) {
			_fnCallbackFire( settings, null, 'dt-error', [ settings, tn, msg ], true );
		}

		if ( type == 'alert' ) {
			alert( msg );
		}
		else if ( type == 'throw' ) {
			throw new Error(msg);
		}
		else if ( typeof type == 'function' ) {
			type( settings, tn, msg );
		}
	}
	else if ( window.console && console.log ) {
		console.log( msg );
	}
}


/**
 * See if a property is defined on one object, if so assign it to the other object
 *  @param {object} ret target object
 *  @param {object} src source object
 *  @param {string} name property
 *  @param {string} [mappedName] name to map too - optional, name used if not given
 *  @memberof DataTable#oApi
 */
function _fnMap( ret, src, name, mappedName )
{
	if ( Array.isArray( name ) ) {
		$.each( name, function (i, val) {
			if ( Array.isArray( val ) ) {
				_fnMap( ret, src, val[0], val[1] );
			}
			else {
				_fnMap( ret, src, val );
			}
		} );

		return;
	}

	if ( mappedName === undefined ) {
		mappedName = name;
	}

	if ( src[name] !== undefined ) {
		ret[mappedName] = src[name];
	}
}


/**
 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
 * shallow copy arrays. The reason we need to do this, is that we don't want to
 * deep copy array init values (such as aaSorting) since the dev wouldn't be
 * able to override them, but we do want to deep copy arrays.
 *  @param {object} out Object to extend
 *  @param {object} extender Object from which the properties will be applied to
 *      out
 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
 *      independent copy with the exception of the `data` or `aaData` parameters
 *      if they are present. This is so you can pass in a collection to
 *      DataTables and have that used as your data source without breaking the
 *      references
 *  @returns {object} out Reference, just for convenience - out === the return.
 *  @memberof DataTable#oApi
 *  @todo This doesn't take account of arrays inside the deep copied objects.
 */
function _fnExtend( out, extender, breakRefs )
{
	var val;

	for ( var prop in extender ) {
		if ( Object.prototype.hasOwnProperty.call(extender, prop) ) {
			val = extender[prop];

			if ( $.isPlainObject( val ) ) {
				if ( ! $.isPlainObject( out[prop] ) ) {
					out[prop] = {};
				}
				$.extend( true, out[prop], val );
			}
			else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val) ) {
				out[prop] = val.slice();
			}
			else {
				out[prop] = val;
			}
		}
	}

	return out;
}


/**
 * Bind an event handers to allow a click or return key to activate the callback.
 * This is good for accessibility since a return on the keyboard will have the
 * same effect as a click, if the element has focus.
 *  @param {element} n Element to bind the action to
 *  @param {object|string} selector Selector (for delegated events) or data object
 *   to pass to the triggered function
 *  @param {function} fn Callback function for when the event is triggered
 *  @memberof DataTable#oApi
 */
function _fnBindAction( n, selector, fn )
{
	$(n)
		.on( 'click.DT', selector, function (e) {
			fn(e);
		} )
		.on( 'keypress.DT', selector, function (e){
			if ( e.which === 13 ) {
				e.preventDefault();
				fn(e);
			}
		} )
		.on( 'selectstart.DT', selector, function () {
			// Don't want a double click resulting in text selection
			return false;
		} );
}


/**
 * Register a callback function. Easily allows a callback function to be added to
 * an array store of callback functions that can then all be called together.
 *  @param {object} settings dataTables settings object
 *  @param {string} store Name of the array storage for the callbacks in oSettings
 *  @param {function} fn Function to be called back
 *  @memberof DataTable#oApi
 */
function _fnCallbackReg( settings, store, fn )
{
	if ( fn ) {
		settings[store].push(fn);
	}
}


/**
 * Fire callback functions and trigger events. Note that the loop over the
 * callback array store is done backwards! Further note that you do not want to
 * fire off triggers in time sensitive applications (for example cell creation)
 * as its slow.
 *  @param {object} settings dataTables settings object
 *  @param {string} callbackArr Name of the array storage for the callbacks in
 *      oSettings
 *  @param {string} eventName Name of the jQuery custom event to trigger. If
 *      null no trigger is fired
 *  @param {array} args Array of arguments to pass to the callback function /
 *      trigger
 *  @param {boolean} [bubbles] True if the event should bubble
 *  @memberof DataTable#oApi
 */
function _fnCallbackFire( settings, callbackArr, eventName, args, bubbles )
{
	var ret = [];

	if ( callbackArr ) {
		ret = settings[callbackArr].slice().reverse().map( function (val) {
			return val.apply( settings.oInstance, args );
		} );
	}

	if ( eventName !== null) {
		var e = $.Event( eventName+'.dt' );
		var table = $(settings.nTable);
		
		// Expose the DataTables API on the event object for easy access
		e.dt = settings.api;

		table[bubbles ?  'trigger' : 'triggerHandler']( e, args );

		// If not yet attached to the document, trigger the event
		// on the body directly to sort of simulate the bubble
		if (bubbles && table.parents('body').length === 0) {
			$('body').trigger( e, args );
		}

		ret.push( e.result );
	}

	return ret;
}


function _fnLengthOverflow ( settings )
{
	var
		start = settings._iDisplayStart,
		end = settings.fnDisplayEnd(),
		len = settings._iDisplayLength;

	/* If we have space to show extra rows (backing up from the end point - then do so */
	if ( start >= end )
	{
		start = end - len;
	}

	// Keep the start record on the current page
	start -= (start % len);

	if ( len === -1 || start < 0 )
	{
		start = 0;
	}

	settings._iDisplayStart = start;
}


function _fnRenderer( settings, type )
{
	var renderer = settings.renderer;
	var host = DataTable.ext.renderer[type];

	if ( $.isPlainObject( renderer ) && renderer[type] ) {
		// Specific renderer for this type. If available use it, otherwise use
		// the default.
		return host[renderer[type]] || host._;
	}
	else if ( typeof renderer === 'string' ) {
		// Common renderer - if there is one available for this type use it,
		// otherwise use the default
		return host[renderer] || host._;
	}

	// Use the default
	return host._;
}


/**
 * Detect the data source being used for the table. Used to simplify the code
 * a little (ajax) and to make it compress a little smaller.
 *
 *  @param {object} settings dataTables settings object
 *  @returns {string} Data source
 *  @memberof DataTable#oApi
 */
function _fnDataSource ( settings )
{
	if ( settings.oFeatures.bServerSide ) {
		return 'ssp';
	}
	else if ( settings.ajax ) {
		return 'ajax';
	}
	return 'dom';
}

/**
 * Common replacement for language strings
 *
 * @param {*} settings DT settings object
 * @param {*} str String with values to replace
 * @param {*} entries Plural number for _ENTRIES_ - can be undefined
 * @returns String
 */
function _fnMacros ( settings, str, entries )
{
	// When infinite scrolling, we are always starting at 1. _iDisplayStart is
	// used only internally
	var
		formatter  = settings.fnFormatNumber,
		start      = settings._iDisplayStart+1,
		len        = settings._iDisplayLength,
		vis        = settings.fnRecordsDisplay(),
		max        = settings.fnRecordsTotal(),
		all        = len === -1;

	return str.
		replace(/_START_/g, formatter.call( settings, start ) ).
		replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
		replace(/_MAX_/g,   formatter.call( settings, max ) ).
		replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
		replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
		replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) ).
		replace(/_ENTRIES_/g, settings.api.i18n('entries', '', entries) ).
		replace(/_ENTRIES-MAX_/g, settings.api.i18n('entries', '', max) ).
		replace(/_ENTRIES-TOTAL_/g, settings.api.i18n('entries', '', vis) );
}

/**
 * Add elements to an array as quickly as possible, but stack stafe.
 *
 * @param {*} arr Array to add the data to
 * @param {*} data Data array that is to be added
 * @returns 
 */
function _fnArrayApply(arr, data) {
	if (! data) {
		return;
	}

	// Chrome can throw a max stack error if apply is called with
	// too large an array, but apply is faster.
	if (data.length < 10000) {
		arr.push.apply(arr, data);
	}
	else {
		for (i=0 ; i<data.length ; i++) {
			arr.push(data[i]);
		}
	}
}



/**
 * Computed structure of the DataTables API, defined by the options passed to
 * `DataTable.Api.register()` when building the API.
 *
 * The structure is built in order to speed creation and extension of the Api
 * objects since the extensions are effectively pre-parsed.
 *
 * The array is an array of objects with the following structure, where this
 * base array represents the Api prototype base:
 *
 *     [
 *       {
 *         name:      'data'                -- string   - Property name
 *         val:       function () {},       -- function - Api method (or undefined if just an object
 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
 *       },
 *       {
 *         name:     'row'
 *         val:       {},
 *         methodExt: [ ... ],
 *         propExt:   [
 *           {
 *             name:      'data'
 *             val:       function () {},
 *             methodExt: [ ... ],
 *             propExt:   [ ... ]
 *           },
 *           ...
 *         ]
 *       }
 *     ]
 *
 * @type {Array}
 * @ignore
 */
var __apiStruct = [];


/**
 * `Array.prototype` reference.
 *
 * @type object
 * @ignore
 */
var __arrayProto = Array.prototype;


/**
 * Abstraction for `context` parameter of the `Api` constructor to allow it to
 * take several different forms for ease of use.
 *
 * Each of the input parameter types will be converted to a DataTables settings
 * object where possible.
 *
 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
 *   of:
 *
 *   * `string` - jQuery selector. Any DataTables' matching the given selector
 *     with be found and used.
 *   * `node` - `TABLE` node which has already been formed into a DataTable.
 *   * `jQuery` - A jQuery object of `TABLE` nodes.
 *   * `object` - DataTables settings object
 *   * `DataTables.Api` - API instance
 * @return {array|null} Matching DataTables settings objects. `null` or
 *   `undefined` is returned if no matching DataTable is found.
 * @ignore
 */
var _toSettings = function ( mixed )
{
	var idx, jq;
	var settings = DataTable.settings;
	var tables = _pluck(settings, 'nTable');

	if ( ! mixed ) {
		return [];
	}
	else if ( mixed.nTable && mixed.oFeatures ) {
		// DataTables settings object
		return [ mixed ];
	}
	else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
		// Table node
		idx = tables.indexOf(mixed);
		return idx !== -1 ? [ settings[idx] ] : null;
	}
	else if ( mixed && typeof mixed.settings === 'function' ) {
		return mixed.settings().toArray();
	}
	else if ( typeof mixed === 'string' ) {
		// jQuery selector
		jq = $(mixed).get();
	}
	else if ( mixed instanceof $ ) {
		// jQuery object (also DataTables instance)
		jq = mixed.get();
	}

	if ( jq ) {
		return settings.filter(function (v, idx) {
			return jq.includes(tables[idx]);
		});
	}
};


/**
 * DataTables API class - used to control and interface with  one or more
 * DataTables enhanced tables.
 *
 * The API class is heavily based on jQuery, presenting a chainable interface
 * that you can use to interact with tables. Each instance of the API class has
 * a "context" - i.e. the tables that it will operate on. This could be a single
 * table, all tables on a page or a sub-set thereof.
 *
 * Additionally the API is designed to allow you to easily work with the data in
 * the tables, retrieving and manipulating it as required. This is done by
 * presenting the API class as an array like interface. The contents of the
 * array depend upon the actions requested by each method (for example
 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
 * return an array of objects or arrays depending upon your table's
 * configuration). The API object has a number of array like methods (`push`,
 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
 * `unique` etc) to assist your working with the data held in a table.
 *
 * Most methods (those which return an Api instance) are chainable, which means
 * the return from a method call also has all of the methods available that the
 * top level object had. For example, these two calls are equivalent:
 *
 *     // Not chained
 *     api.row.add( {...} );
 *     api.draw();
 *
 *     // Chained
 *     api.row.add( {...} ).draw();
 *
 * @class DataTable.Api
 * @param {array|object|string|jQuery} context DataTable identifier. This is
 *   used to define which DataTables enhanced tables this API will operate on.
 *   Can be one of:
 *
 *   * `string` - jQuery selector. Any DataTables' matching the given selector
 *     with be found and used.
 *   * `node` - `TABLE` node which has already been formed into a DataTable.
 *   * `jQuery` - A jQuery object of `TABLE` nodes.
 *   * `object` - DataTables settings object
 * @param {array} [data] Data to initialise the Api instance with.
 *
 * @example
 *   // Direct initialisation during DataTables construction
 *   var api = $('#example').DataTable();
 *
 * @example
 *   // Initialisation using a DataTables jQuery object
 *   var api = $('#example').dataTable().api();
 *
 * @example
 *   // Initialisation as a constructor
 *   var api = new DataTable.Api( 'table.dataTable' );
 */
_Api = function ( context, data )
{
	if ( ! (this instanceof _Api) ) {
		return new _Api( context, data );
	}

	var i;
	var settings = [];
	var ctxSettings = function ( o ) {
		var a = _toSettings( o );
		if ( a ) {
			settings.push.apply( settings, a );
		}
	};

	if ( Array.isArray( context ) ) {
		for ( i=0 ; i<context.length ; i++ ) {
			ctxSettings( context[i] );
		}
	}
	else {
		ctxSettings( context );
	}

	// Remove duplicates
	this.context = settings.length > 1
		? _unique( settings )
		: settings;

	// Initial data
	_fnArrayApply(this, data);

	// selector
	this.selector = {
		rows: null,
		cols: null,
		opts: null
	};

	_Api.extend( this, this, __apiStruct );
};

DataTable.Api = _Api;

// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
// isPlainObject.
$.extend( _Api.prototype, {
	any: function ()
	{
		return this.count() !== 0;
	},

	context: [], // array of table settings objects

	count: function ()
	{
		return this.flatten().length;
	},

	each: function ( fn )
	{
		for ( var i=0, ien=this.length ; i<ien; i++ ) {
			fn.call( this, this[i], i, this );
		}

		return this;
	},

	eq: function ( idx )
	{
		var ctx = this.context;

		return ctx.length > idx ?
			new _Api( ctx[idx], this[idx] ) :
			null;
	},

	filter: function ( fn )
	{
		var a = __arrayProto.filter.call( this, fn, this );

		return new _Api( this.context, a );
	},

	flatten: function ()
	{
		var a = [];

		return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
	},

	get: function ( idx )
	{
		return this[ idx ];
	},

	join:    __arrayProto.join,

	includes: function ( find ) {
		return this.indexOf( find ) === -1 ? false : true;
	},

	indexOf: __arrayProto.indexOf,

	iterator: function ( flatten, type, fn, alwaysNew ) {
		var
			a = [], ret,
			i, ien, j, jen,
			context = this.context,
			rows, items, item,
			selector = this.selector;

		// Argument shifting
		if ( typeof flatten === 'string' ) {
			alwaysNew = fn;
			fn = type;
			type = flatten;
			flatten = false;
		}

		for ( i=0, ien=context.length ; i<ien ; i++ ) {
			var apiInst = new _Api( context[i] );

			if ( type === 'table' ) {
				ret = fn.call( apiInst, context[i], i );

				if ( ret !== undefined ) {
					a.push( ret );
				}
			}
			else if ( type === 'columns' || type === 'rows' ) {
				// this has same length as context - one entry for each table
				ret = fn.call( apiInst, context[i], this[i], i );

				if ( ret !== undefined ) {
					a.push( ret );
				}
			}
			else if ( type === 'every' || type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
				// columns and rows share the same structure.
				// 'this' is an array of column indexes for each context
				items = this[i];

				if ( type === 'column-rows' ) {
					rows = _selector_row_indexes( context[i], selector.opts );
				}

				for ( j=0, jen=items.length ; j<jen ; j++ ) {
					item = items[j];

					if ( type === 'cell' ) {
						ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
					}
					else {
						ret = fn.call( apiInst, context[i], item, i, j, rows );
					}

					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
			}
		}

		if ( a.length || alwaysNew ) {
			var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
			var apiSelector = api.selector;
			apiSelector.rows = selector.rows;
			apiSelector.cols = selector.cols;
			apiSelector.opts = selector.opts;
			return api;
		}
		return this;
	},

	lastIndexOf: __arrayProto.lastIndexOf,

	length:  0,

	map: function ( fn )
	{
		var a = __arrayProto.map.call( this, fn, this );

		return new _Api( this.context, a );
	},

	pluck: function ( prop )
	{
		var fn = DataTable.util.get(prop);

		return this.map( function ( el ) {
			return fn(el);
		} );
	},

	pop:     __arrayProto.pop,

	push:    __arrayProto.push,

	reduce: __arrayProto.reduce,

	reduceRight: __arrayProto.reduceRight,

	reverse: __arrayProto.reverse,

	// Object with rows, columns and opts
	selector: null,

	shift:   __arrayProto.shift,

	slice: function () {
		return new _Api( this.context, this );
	},

	sort:    __arrayProto.sort,

	splice:  __arrayProto.splice,

	toArray: function ()
	{
		return __arrayProto.slice.call( this );
	},

	to$: function ()
	{
		return $( this );
	},

	toJQuery: function ()
	{
		return $( this );
	},

	unique: function ()
	{
		return new _Api( this.context, _unique(this.toArray()) );
	},

	unshift: __arrayProto.unshift
} );


function _api_scope( scope, fn, struc ) {
	return function () {
		var ret = fn.apply( scope || this, arguments );

		// Method extension
		_Api.extend( ret, ret, struc.methodExt );
		return ret;
	};
}

function _api_find( src, name ) {
	for ( var i=0, ien=src.length ; i<ien ; i++ ) {
		if ( src[i].name === name ) {
			return src[i];
		}
	}
	return null;
}

window.__apiStruct = __apiStruct;

_Api.extend = function ( scope, obj, ext )
{
	// Only extend API instances and static properties of the API
	if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
		return;
	}

	var
		i, ien,
		struct;

	for ( i=0, ien=ext.length ; i<ien ; i++ ) {
		struct = ext[i];

		if (struct.name === '__proto__') {
			continue;
		}

		// Value
		obj[ struct.name ] = struct.type === 'function' ?
			_api_scope( scope, struct.val, struct ) :
			struct.type === 'object' ?
				{} :
				struct.val;

		obj[ struct.name ].__dt_wrapper = true;

		// Property extension
		_Api.extend( scope, obj[ struct.name ], struct.propExt );
	}
};

//     [
//       {
//         name:      'data'                -- string   - Property name
//         val:       function () {},       -- function - Api method (or undefined if just an object
//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
//       },
//       {
//         name:     'row'
//         val:       {},
//         methodExt: [ ... ],
//         propExt:   [
//           {
//             name:      'data'
//             val:       function () {},
//             methodExt: [ ... ],
//             propExt:   [ ... ]
//           },
//           ...
//         ]
//       }
//     ]


_Api.register = _api_register = function ( name, val )
{
	if ( Array.isArray( name ) ) {
		for ( var j=0, jen=name.length ; j<jen ; j++ ) {
			_Api.register( name[j], val );
		}
		return;
	}

	var
		i, ien,
		heir = name.split('.'),
		struct = __apiStruct,
		key, method;

	for ( i=0, ien=heir.length ; i<ien ; i++ ) {
		method = heir[i].indexOf('()') !== -1;
		key = method ?
			heir[i].replace('()', '') :
			heir[i];

		var src = _api_find( struct, key );
		if ( ! src ) {
			src = {
				name:      key,
				val:       {},
				methodExt: [],
				propExt:   [],
				type:      'object'
			};
			struct.push( src );
		}

		if ( i === ien-1 ) {
			src.val = val;
			src.type = typeof val === 'function' ?
				'function' :
				$.isPlainObject( val ) ?
					'object' :
					'other';
		}
		else {
			struct = method ?
				src.methodExt :
				src.propExt;
		}
	}
};

_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
	_Api.register( pluralName, val );

	_Api.register( singularName, function () {
		var ret = val.apply( this, arguments );

		if ( ret === this ) {
			// Returned item is the API instance that was passed in, return it
			return this;
		}
		else if ( ret instanceof _Api ) {
			// New API instance returned, want the value from the first item
			// in the returned array for the singular result.
			return ret.length ?
				Array.isArray( ret[0] ) ?
					new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
					ret[0] :
				undefined;
		}

		// Non-API return - just fire it back
		return ret;
	} );
};


/**
 * Selector for HTML tables. Apply the given selector to the give array of
 * DataTables settings objects.
 *
 * @param {string|integer} [selector] jQuery selector string or integer
 * @param  {array} Array of DataTables settings objects to be filtered
 * @return {array}
 * @ignore
 */
var __table_selector = function ( selector, a )
{
	if ( Array.isArray(selector) ) {
		var result = [];

		selector.forEach(function (sel) {
			var inner = __table_selector(sel, a);

			_fnArrayApply(result, inner);
		});

		return result.filter( function (item) {
			return item;
		});
	}

	// Integer is used to pick out a table by index
	if ( typeof selector === 'number' ) {
		return [ a[ selector ] ];
	}

	// Perform a jQuery selector on the table nodes
	var nodes = a.map( function (el) {
		return el.nTable;
	} );

	return $(nodes)
		.filter( selector )
		.map( function () {
			// Need to translate back from the table node to the settings
			var idx = nodes.indexOf(this);
			return a[ idx ];
		} )
		.toArray();
};



/**
 * Context selector for the API's context (i.e. the tables the API instance
 * refers to.
 *
 * @name    DataTable.Api#tables
 * @param {string|integer} [selector] Selector to pick which tables the iterator
 *   should operate on. If not given, all tables in the current context are
 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
 *   select multiple tables or as an integer to select a single table.
 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
 */
_api_register( 'tables()', function ( selector ) {
	// A new instance is created if there was a selector specified
	return selector !== undefined && selector !== null ?
		new _Api( __table_selector( selector, this.context ) ) :
		this;
} );


_api_register( 'table()', function ( selector ) {
	var tables = this.tables( selector );
	var ctx = tables.context;

	// Truncate to the first matched table
	return ctx.length ?
		new _Api( ctx[0] ) :
		tables;
} );

// Common methods, combined to reduce size
[
	['nodes', 'node', 'nTable'],
	['body', 'body', 'nTBody'],
	['header', 'header', 'nTHead'],
	['footer', 'footer', 'nTFoot'],
].forEach(function (item) {
	_api_registerPlural(
		'tables().' + item[0] + '()',
		'table().' + item[1] + '()' ,
		function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx[item[2]];
			}, 1 );
		}
	);
});

// Structure methods
[
	['header', 'aoHeader'],
	['footer', 'aoFooter'],
].forEach(function (item) {
	_api_register( 'table().' + item[0] + '.structure()' , function (selector) {
		var indexes = this.columns(selector).indexes().flatten();
		var ctx = this.context[0];
		
		return _fnHeaderLayout(ctx, ctx[item[1]], indexes);
	} );
})


_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
	return this.iterator( 'table', function ( ctx ) {
		return ctx.nTableWrapper;
	}, 1 );
} );

_api_register( 'tables().every()', function ( fn ) {
	var that = this;

	return this.iterator('table', function (s, i) {
		fn.call(that.table(i), i);
	});
});

_api_register( 'caption()', function ( value, side ) {
	var context = this.context;

	// Getter - return existing node's content
	if ( value === undefined ) {
		var caption = context[0].captionNode;

		return caption && context.length ?
			caption.innerHTML : 
			null;
	}

	return this.iterator( 'table', function ( ctx ) {
		var table = $(ctx.nTable);
		var caption = $(ctx.captionNode);
		var container = $(ctx.nTableWrapper);

		// Create the node if it doesn't exist yet
		if ( ! caption.length ) {
			caption = $('<caption/>').html( value );
			ctx.captionNode = caption[0];

			// If side isn't set, we need to insert into the document to let the
			// CSS decide so we can read it back, otherwise there is no way to
			// know if the CSS would put it top or bottom for scrolling
			if (! side) {
				table.prepend(caption);

				side = caption.css('caption-side');
			}
		}

		caption.html( value );

		if ( side ) {
			caption.css( 'caption-side', side );
			caption[0]._captionSide = side;
		}

		if (container.find('div.dataTables_scroll').length) {
			var selector = (side === 'top' ? 'Head' : 'Foot');

			container.find('div.dataTables_scroll'+ selector +' table').prepend(caption);
		}
		else {
			table.prepend(caption);
		}
	}, 1 );
} );

_api_register( 'caption.node()', function () {
	var ctx = this.context;

	return ctx.length ? ctx[0].captionNode : null;
} );


/**
 * Redraw the tables in the current context.
 */
_api_register( 'draw()', function ( paging ) {
	return this.iterator( 'table', function ( settings ) {
		if ( paging === 'page' ) {
			_fnDraw( settings );
		}
		else {
			if ( typeof paging === 'string' ) {
				paging = paging === 'full-hold' ?
					false :
					true;
			}

			_fnReDraw( settings, paging===false );
		}
	} );
} );



/**
 * Get the current page index.
 *
 * @return {integer} Current page index (zero based)
 *//**
 * Set the current page.
 *
 * Note that if you attempt to show a page which does not exist, DataTables will
 * not throw an error, but rather reset the paging.
 *
 * @param {integer|string} action The paging action to take. This can be one of:
 *  * `integer` - The page index to jump to
 *  * `string` - An action to take:
 *    * `first` - Jump to first page.
 *    * `next` - Jump to the next page
 *    * `previous` - Jump to previous page
 *    * `last` - Jump to the last page.
 * @returns {DataTables.Api} this
 */
_api_register( 'page()', function ( action ) {
	if ( action === undefined ) {
		return this.page.info().page; // not an expensive call
	}

	// else, have an action to take on all tables
	return this.iterator( 'table', function ( settings ) {
		_fnPageChange( settings, action );
	} );
} );


/**
 * Paging information for the first table in the current context.
 *
 * If you require paging information for another table, use the `table()` method
 * with a suitable selector.
 *
 * @return {object} Object with the following properties set:
 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
 *  * `pages` - Total number of pages
 *  * `start` - Display index for the first record shown on the current page
 *  * `end` - Display index for the last record shown on the current page
 *  * `length` - Display length (number of records). Note that generally `start
 *    + length = end`, but this is not always true, for example if there are
 *    only 2 records to show on the final page, with a length of 10.
 *  * `recordsTotal` - Full data set length
 *  * `recordsDisplay` - Data set length once the current filtering criterion
 *    are applied.
 */
_api_register( 'page.info()', function () {
	if ( this.context.length === 0 ) {
		return undefined;
	}

	var
		settings   = this.context[0],
		start      = settings._iDisplayStart,
		len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
		visRecords = settings.fnRecordsDisplay(),
		all        = len === -1;

	return {
		"page":           all ? 0 : Math.floor( start / len ),
		"pages":          all ? 1 : Math.ceil( visRecords / len ),
		"start":          start,
		"end":            settings.fnDisplayEnd(),
		"length":         len,
		"recordsTotal":   settings.fnRecordsTotal(),
		"recordsDisplay": visRecords,
		"serverSide":     _fnDataSource( settings ) === 'ssp'
	};
} );


/**
 * Get the current page length.
 *
 * @return {integer} Current page length. Note `-1` indicates that all records
 *   are to be shown.
 *//**
 * Set the current page length.
 *
 * @param {integer} Page length to set. Use `-1` to show all records.
 * @returns {DataTables.Api} this
 */
_api_register( 'page.len()', function ( len ) {
	// Note that we can't call this function 'length()' because `length`
	// is a Javascript property of functions which defines how many arguments
	// the function expects.
	if ( len === undefined ) {
		return this.context.length !== 0 ?
			this.context[0]._iDisplayLength :
			undefined;
	}

	// else, set the page length
	return this.iterator( 'table', function ( settings ) {
		_fnLengthChange( settings, len );
	} );
} );



var __reload = function ( settings, holdPosition, callback ) {
	// Use the draw event to trigger a callback
	if ( callback ) {
		var api = new _Api( settings );

		api.one( 'draw', function () {
			callback( api.ajax.json() );
		} );
	}

	if ( _fnDataSource( settings ) == 'ssp' ) {
		_fnReDraw( settings, holdPosition );
	}
	else {
		_fnProcessingDisplay( settings, true );

		// Cancel an existing request
		var xhr = settings.jqXHR;
		if ( xhr && xhr.readyState !== 4 ) {
			xhr.abort();
		}

		// Trigger xhr
		_fnBuildAjax( settings, {}, function( json ) {
			_fnClearTable( settings );

			var data = _fnAjaxDataSrc( settings, json );
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				_fnAddData( settings, data[i] );
			}

			_fnReDraw( settings, holdPosition );
			_fnInitComplete( settings );
			_fnProcessingDisplay( settings, false );
		} );
	}
};


/**
 * Get the JSON response from the last Ajax request that DataTables made to the
 * server. Note that this returns the JSON from the first table in the current
 * context.
 *
 * @return {object} JSON received from the server.
 */
_api_register( 'ajax.json()', function () {
	var ctx = this.context;

	if ( ctx.length > 0 ) {
		return ctx[0].json;
	}

	// else return undefined;
} );


/**
 * Get the data submitted in the last Ajax request
 */
_api_register( 'ajax.params()', function () {
	var ctx = this.context;

	if ( ctx.length > 0 ) {
		return ctx[0].oAjaxData;
	}

	// else return undefined;
} );


/**
 * Reload tables from the Ajax data source. Note that this function will
 * automatically re-draw the table when the remote data has been loaded.
 *
 * @param {boolean} [reset=true] Reset (default) or hold the current paging
 *   position. A full re-sort and re-filter is performed when this method is
 *   called, which is why the pagination reset is the default action.
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
	return this.iterator( 'table', function (settings) {
		__reload( settings, resetPaging===false, callback );
	} );
} );


/**
 * Get the current Ajax URL. Note that this returns the URL from the first
 * table in the current context.
 *
 * @return {string} Current Ajax source URL
 *//**
 * Set the Ajax URL. Note that this will set the URL for all tables in the
 * current context.
 *
 * @param {string} url URL to set.
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.url()', function ( url ) {
	var ctx = this.context;

	if ( url === undefined ) {
		// get
		if ( ctx.length === 0 ) {
			return undefined;
		}
		ctx = ctx[0];

		return $.isPlainObject( ctx.ajax ) ?
			ctx.ajax.url :
			ctx.ajax;
	}

	// set
	return this.iterator( 'table', function ( settings ) {
		if ( $.isPlainObject( settings.ajax ) ) {
			settings.ajax.url = url;
		}
		else {
			settings.ajax = url;
		}
	} );
} );


/**
 * Load data from the newly set Ajax URL. Note that this method is only
 * available when `ajax.url()` is used to set a URL. Additionally, this method
 * has the same effect as calling `ajax.reload()` but is provided for
 * convenience when setting a new URL. Like `ajax.reload()` it will
 * automatically redraw the table once the remote data has been loaded.
 *
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
	// Same as a reload, but makes sense to present it for easy access after a
	// url change
	return this.iterator( 'table', function ( ctx ) {
		__reload( ctx, resetPaging===false, callback );
	} );
} );




var _selector_run = function ( type, selector, selectFn, settings, opts )
{
	var
		out = [], res,
		a, i, ien, j, jen,
		selectorType = typeof selector;

	// Can't just check for isArray here, as an API or jQuery instance might be
	// given with their array like look
	if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
		selector = [ selector ];
	}

	for ( i=0, ien=selector.length ; i<ien ; i++ ) {
		// Only split on simple strings - complex expressions will be jQuery selectors
		a = selector[i] && selector[i].split && ! selector[i].match(/[[(:]/) ?
			selector[i].split(',') :
			[ selector[i] ];

		for ( j=0, jen=a.length ; j<jen ; j++ ) {
			res = selectFn( typeof a[j] === 'string' ? (a[j]).trim() : a[j] );

			// Remove empty items
			res = res.filter( function (item) {
				return item !== null && item !== undefined;
			});

			if ( res && res.length ) {
				out = out.concat( res );
			}
		}
	}

	// selector extensions
	var ext = _ext.selector[ type ];
	if ( ext.length ) {
		for ( i=0, ien=ext.length ; i<ien ; i++ ) {
			out = ext[i]( settings, opts, out );
		}
	}

	return _unique( out );
};


var _selector_opts = function ( opts )
{
	if ( ! opts ) {
		opts = {};
	}

	// Backwards compatibility for 1.9- which used the terminology filter rather
	// than search
	if ( opts.filter && opts.search === undefined ) {
		opts.search = opts.filter;
	}

	return $.extend( {
		search: 'none',
		order: 'current',
		page: 'all'
	}, opts );
};


// Reduce the API instance to the first item found
var _selector_first = function ( old )
{
	var inst = new _Api(old.context[0]);

	// Use a push rather than passing to the constructor, since it will
	// merge arrays down automatically, which isn't what is wanted here
	if (old.length) {
		inst.push( old[0] );
	}

	inst.selector = old.selector;

	// Limit to a single row / column / cell
	if (inst.length && inst[0].length > 1) {
		inst[0].splice(1);
	}

	return inst;
};


var _selector_row_indexes = function ( settings, opts )
{
	var
		i, ien, tmp, a=[],
		displayFiltered = settings.aiDisplay,
		displayMaster = settings.aiDisplayMaster;

	var
		search = opts.search,  // none, applied, removed
		order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
		page   = opts.page;    // all, current

	if ( _fnDataSource( settings ) == 'ssp' ) {
		// In server-side processing mode, most options are irrelevant since
		// rows not shown don't exist and the index order is the applied order
		// Removed is a special case - for consistency just return an empty
		// array
		return search === 'removed' ?
			[] :
			_range( 0, displayMaster.length );
	}

	if ( page == 'current' ) {
		// Current page implies that order=current and filter=applied, since it is
		// fairly senseless otherwise, regardless of what order and search actually
		// are
		for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
			a.push( displayFiltered[i] );
		}
	}
	else if ( order == 'current' || order == 'applied' ) {
		if ( search == 'none') {
			a = displayMaster.slice();
		}
		else if ( search == 'applied' ) {
			a = displayFiltered.slice();
		}
		else if ( search == 'removed' ) {
			// O(n+m) solution by creating a hash map
			var displayFilteredMap = {};

			for ( i=0, ien=displayFiltered.length ; i<ien ; i++ ) {
				displayFilteredMap[displayFiltered[i]] = null;
			}

			displayMaster.forEach(function (item) {
				if (! Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
					a.push(item);
				}
			});
		}
	}
	else if ( order == 'index' || order == 'original' ) {
		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			if (! settings.aoData[i]) {
				continue;
			}

			if ( search == 'none' ) {
				a.push( i );
			}
			else { // applied | removed
				tmp = displayFiltered.indexOf(i);

				if ((tmp === -1 && search == 'removed') ||
					(tmp >= 0   && search == 'applied') )
				{
					a.push( i );
				}
			}
		}
	}
	else if ( typeof order === 'number' ) {
		// Order the rows by the given column
		var ordered = _fnSort(settings, order, 'asc');

		if (search === 'none') {
			a = ordered;
		}
		else { // applied | removed
			for (i=0; i<ordered.length; i++) {
				tmp = displayFiltered.indexOf(ordered[i]);

				if ((tmp === -1 && search == 'removed') ||
					(tmp >= 0   && search == 'applied') )
				{
					a.push( ordered[i] );
				}
			}
		}
	}

	return a;
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Rows
 *
 * {}          - no selector - use all available rows
 * {integer}   - row aoData index
 * {node}      - TR node
 * {string}    - jQuery selector to apply to the TR elements
 * {array}     - jQuery array of nodes, or simply an array of TR nodes
 *
 */
var __row_selector = function ( settings, selector, opts )
{
	var rows;
	var run = function ( sel ) {
		var selInt = _intVal( sel );
		var aoData = settings.aoData;

		// Short cut - selector is a number and no options provided (default is
		// all records, so no need to check if the index is in there, since it
		// must be - dev error if the index doesn't exist).
		if ( selInt !== null && ! opts ) {
			return [ selInt ];
		}

		if ( ! rows ) {
			rows = _selector_row_indexes( settings, opts );
		}

		if ( selInt !== null && rows.indexOf(selInt) !== -1 ) {
			// Selector - integer
			return [ selInt ];
		}
		else if ( sel === null || sel === undefined || sel === '' ) {
			// Selector - none
			return rows;
		}

		// Selector - function
		if ( typeof sel === 'function' ) {
			return rows.map( function (idx) {
				var row = aoData[ idx ];
				return sel( idx, row._aData, row.nTr ) ? idx : null;
			} );
		}

		// Selector - node
		if ( sel.nodeName ) {
			var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup
			var cellIdx = sel._DT_CellIndex;

			if ( rowIdx !== undefined ) {
				// Make sure that the row is actually still present in the table
				return aoData[ rowIdx ] && aoData[ rowIdx ].nTr === sel ?
					[ rowIdx ] :
					[];
			}
			else if ( cellIdx ) {
				return aoData[ cellIdx.row ] && aoData[ cellIdx.row ].nTr === sel.parentNode ?
					[ cellIdx.row ] :
					[];
			}
			else {
				var host = $(sel).closest('*[data-dt-row]');
				return host.length ?
					[ host.data('dt-row') ] :
					[];
			}
		}

		// ID selector. Want to always be able to select rows by id, regardless
		// of if the tr element has been created or not, so can't rely upon
		// jQuery here - hence a custom implementation. This does not match
		// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
		// but to select it using a CSS selector engine (like Sizzle or
		// querySelect) it would need to need to be escaped for some characters.
		// DataTables simplifies this for row selectors since you can select
		// only a row. A # indicates an id any anything that follows is the id -
		// unescaped.
		if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
			// get row index from id
			var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
			if ( rowObj !== undefined ) {
				return [ rowObj.idx ];
			}

			// need to fall through to jQuery in case there is DOM id that
			// matches
		}
		
		// Get nodes in the order from the `rows` array with null values removed
		var nodes = _removeEmpty(
			_pluck_order( settings.aoData, rows, 'nTr' )
		);

		// Selector - jQuery selector string, array of nodes or jQuery object/
		// As jQuery's .filter() allows jQuery objects to be passed in filter,
		// it also allows arrays, so this will cope with all three options
		return $(nodes)
			.filter( sel )
			.map( function () {
				return this._DT_RowIndex;
			} )
			.toArray();
	};

	var matched = _selector_run( 'row', selector, run, settings, opts );

	if (opts.order === 'current' || opts.order === 'applied') {
		_fnSortDisplay(settings, matched);
	}

	return matched;
};


_api_register( 'rows()', function ( selector, opts ) {
	// argument shifting
	if ( selector === undefined ) {
		selector = '';
	}
	else if ( $.isPlainObject( selector ) ) {
		opts = selector;
		selector = '';
	}

	opts = _selector_opts( opts );

	var inst = this.iterator( 'table', function ( settings ) {
		return __row_selector( settings, selector, opts );
	}, 1 );

	// Want argument shifting here and in __row_selector?
	inst.selector.rows = selector;
	inst.selector.opts = opts;

	return inst;
} );

_api_register( 'rows().nodes()', function () {
	return this.iterator( 'row', function ( settings, row ) {
		return settings.aoData[ row ].nTr || undefined;
	}, 1 );
} );

_api_register( 'rows().data()', function () {
	return this.iterator( true, 'rows', function ( settings, rows ) {
		return _pluck_order( settings.aoData, rows, '_aData' );
	}, 1 );
} );

_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
	return this.iterator( 'row', function ( settings, row ) {
		var r = settings.aoData[ row ];
		return type === 'search' ? r._aFilterData : r._aSortData;
	}, 1 );
} );

_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
	return this.iterator( 'row', function ( settings, row ) {
		_fnInvalidate( settings, row, src );
	} );
} );

_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
	return this.iterator( 'row', function ( settings, row ) {
		return row;
	}, 1 );
} );

_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
	var a = [];
	var context = this.context;

	// `iterator` will drop undefined values, but in this case we want them
	for ( var i=0, ien=context.length ; i<ien ; i++ ) {
		for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
			var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
			a.push( (hash === true ? '#' : '' )+ id );
		}
	}

	return new _Api( context, a );
} );

_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
	this.iterator( 'row', function ( settings, row ) {
		var data = settings.aoData;
		var rowData = data[ row ];

		// Delete from the display arrays
		var idx = settings.aiDisplayMaster.indexOf(row);
		if (idx !== -1) {
			settings.aiDisplayMaster.splice(idx, 1);
		}

		// For server-side processing tables - subtract the deleted row from the count
		if ( settings._iRecordsDisplay > 0 ) {
			settings._iRecordsDisplay--;
		}

		// Check for an 'overflow' they case for displaying the table
		_fnLengthOverflow( settings );

		// Remove the row's ID reference if there is one
		var id = settings.rowIdFn( rowData._aData );
		if ( id !== undefined ) {
			delete settings.aIds[ id ];
		}

		data[row] = null;
	} );

	return this;
} );


_api_register( 'rows.add()', function ( rows ) {
	var newRows = this.iterator( 'table', function ( settings ) {
			var row, i, ien;
			var out = [];

			for ( i=0, ien=rows.length ; i<ien ; i++ ) {
				row = rows[i];

				if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
					out.push( _fnAddTr( settings, row )[0] );
				}
				else {
					out.push( _fnAddData( settings, row ) );
				}
			}

			return out;
		}, 1 );

	// Return an Api.rows() extended instance, so rows().nodes() etc can be used
	var modRows = this.rows( -1 );
	modRows.pop();
	_fnArrayApply(modRows, newRows);

	return modRows;
} );





/**
 *
 */
_api_register( 'row()', function ( selector, opts ) {
	return _selector_first( this.rows( selector, opts ) );
} );


_api_register( 'row().data()', function ( data ) {
	var ctx = this.context;

	if ( data === undefined ) {
		// Get
		return ctx.length && this.length && this[0].length ?
			ctx[0].aoData[ this[0] ]._aData :
			undefined;
	}

	// Set
	var row = ctx[0].aoData[ this[0] ];
	row._aData = data;

	// If the DOM has an id, and the data source is an array
	if ( Array.isArray( data ) && row.nTr && row.nTr.id ) {
		_fnSetObjectDataFn( ctx[0].rowId )( data, row.nTr.id );
	}

	// Automatically invalidate
	_fnInvalidate( ctx[0], this[0], 'data' );

	return this;
} );


_api_register( 'row().node()', function () {
	var ctx = this.context;

	if (ctx.length && this.length && this[0].length) {
		var row = ctx[0].aoData[ this[0] ];

		if (row && row.nTr) {
			return row.nTr;
		}
	}

	return null;
} );


_api_register( 'row.add()', function ( row ) {
	// Allow a jQuery object to be passed in - only a single row is added from
	// it though - the first element in the set
	if ( row instanceof $ && row.length ) {
		row = row[0];
	}

	var rows = this.iterator( 'table', function ( settings ) {
		if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
			return _fnAddTr( settings, row )[0];
		}
		return _fnAddData( settings, row );
	} );

	// Return an Api.rows() extended instance, with the newly added row selected
	return this.row( rows[0] );
} );


$(document).on('plugin-init.dt', function (e, context) {
	var api = new _Api( context );

	api.on( 'stateSaveParams.DT', function ( e, settings, d ) {
		// This could be more compact with the API, but it is a lot faster as a simple
		// internal loop
		var idFn = settings.rowIdFn;
		var rows = settings.aiDisplayMaster;
		var ids = [];

		for (var i=0 ; i<rows.length ; i++) {
			var rowIdx = rows[i];
			var data = settings.aoData[rowIdx];

			if (data._detailsShow) {
				ids.push( '#' + idFn(data._aData) );
			}
		}

		d.childRows = ids;
	});

	// For future state loads (e.g. with StateRestore)
	api.on( 'stateLoaded.DT', function (e, settings, state) {
		__details_state_load( api, state );
	});

	// And the initial load state
	__details_state_load( api, api.state.loaded() );
});

var __details_state_load = function (api, state)
{
	if ( state && state.childRows ) {
		api
			.rows( state.childRows.map(function (id) {
				// Escape any `:` characters from the row id. Accounts for
				// already escaped characters.
				return id.replace(/([^:\\]*(?:\\.[^:\\]*)*):/g, "$1\\:");
			}) )
			.every( function () {
				_fnCallbackFire( api.settings()[0], null, 'requestChild', [ this ] )
			});
	}
}

var __details_add = function ( ctx, row, data, klass )
{
	// Convert to array of TR elements
	var rows = [];
	var addRow = function ( r, k ) {
		// Recursion to allow for arrays of jQuery objects
		if ( Array.isArray( r ) || r instanceof $ ) {
			for ( var i=0, ien=r.length ; i<ien ; i++ ) {
				addRow( r[i], k );
			}
			return;
		}

		// If we get a TR element, then just add it directly - up to the dev
		// to add the correct number of columns etc
		if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
			r.setAttribute( 'data-dt-row', row.idx );
			rows.push( r );
		}
		else {
			// Otherwise create a row with a wrapper
			var created = $('<tr><td></td></tr>')
				.attr( 'data-dt-row', row.idx )
				.addClass( k );
			
			$('td', created)
				.addClass( k )
				.html( r )[0].colSpan = _fnVisbleColumns( ctx );

			rows.push( created[0] );
		}
	};

	addRow( data, klass );

	if ( row._details ) {
		row._details.detach();
	}

	row._details = $(rows);

	// If the children were already shown, that state should be retained
	if ( row._detailsShow ) {
		row._details.insertAfter( row.nTr );
	}
};


// Make state saving of child row details async to allow them to be batch processed
var __details_state = DataTable.util.throttle(
	function (ctx) {
		_fnSaveState( ctx[0] )
	},
	500
);


var __details_remove = function ( api, idx )
{
	var ctx = api.context;

	if ( ctx.length ) {
		var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];

		if ( row && row._details ) {
			row._details.remove();

			row._detailsShow = undefined;
			row._details = undefined;
			$( row.nTr ).removeClass( 'dt-hasChild' );
			__details_state( ctx );
		}
	}
};


var __details_display = function ( api, show ) {
	var ctx = api.context;

	if ( ctx.length && api.length ) {
		var row = ctx[0].aoData[ api[0] ];

		if ( row._details ) {
			row._detailsShow = show;

			if ( show ) {
				row._details.insertAfter( row.nTr );
				$( row.nTr ).addClass( 'dt-hasChild' );
			}
			else {
				row._details.detach();
				$( row.nTr ).removeClass( 'dt-hasChild' );
			}

			_fnCallbackFire( ctx[0], null, 'childRow', [ show, api.row( api[0] ) ] )

			__details_events( ctx[0] );
			__details_state( ctx );
		}
	}
};


var __details_events = function ( settings )
{
	var api = new _Api( settings );
	var namespace = '.dt.DT_details';
	var drawEvent = 'draw'+namespace;
	var colvisEvent = 'column-sizing'+namespace;
	var destroyEvent = 'destroy'+namespace;
	var data = settings.aoData;

	api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );

	if ( _pluck( data, '_details' ).length > 0 ) {
		// On each draw, insert the required elements into the document
		api.on( drawEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			api.rows( {page:'current'} ).eq(0).each( function (idx) {
				// Internal data grab
				var row = data[ idx ];

				if ( row._detailsShow ) {
					row._details.insertAfter( row.nTr );
				}
			} );
		} );

		// Column visibility change - update the colspan
		api.on( colvisEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			// Update the colspan for the details rows (note, only if it already has
			// a colspan)
			var row, visible = _fnVisbleColumns( ctx );

			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				row = data[i];

				if ( row && row._details ) {
					row._details.each(function () {
						var el = $(this).children('td');

						if (el.length == 1) {
							el.attr('colspan', visible);
						}
					});
				}
			}
		} );

		// Table destroyed - nuke any child rows
		api.on( destroyEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				if ( data[i] && data[i]._details ) {
					__details_remove( api, i );
				}
			}
		} );
	}
};

// Strings for the method names to help minification
var _emp = '';
var _child_obj = _emp+'row().child';
var _child_mth = _child_obj+'()';

// data can be:
//  tr
//  string
//  jQuery or array of any of the above
_api_register( _child_mth, function ( data, klass ) {
	var ctx = this.context;

	if ( data === undefined ) {
		// get
		return ctx.length && this.length && ctx[0].aoData[ this[0] ]
			? ctx[0].aoData[ this[0] ]._details
			: undefined;
	}
	else if ( data === true ) {
		// show
		this.child.show();
	}
	else if ( data === false ) {
		// remove
		__details_remove( this );
	}
	else if ( ctx.length && this.length ) {
		// set
		__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
	}

	return this;
} );


_api_register( [
	_child_obj+'.show()',
	_child_mth+'.show()' // only when `child()` was called with parameters (without
], function () {         // it returns an object and this method is not executed)
	__details_display( this, true );
	return this;
} );


_api_register( [
	_child_obj+'.hide()',
	_child_mth+'.hide()' // only when `child()` was called with parameters (without
], function () {         // it returns an object and this method is not executed)
	__details_display( this, false );
	return this;
} );


_api_register( [
	_child_obj+'.remove()',
	_child_mth+'.remove()' // only when `child()` was called with parameters (without
], function () {           // it returns an object and this method is not executed)
	__details_remove( this );
	return this;
} );


_api_register( _child_obj+'.isShown()', function () {
	var ctx = this.context;

	if ( ctx.length && this.length && ctx[0].aoData[ this[0] ] ) {
		// _detailsShown as false or undefined will fall through to return false
		return ctx[0].aoData[ this[0] ]._detailsShow || false;
	}
	return false;
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Columns
 *
 * {integer}           - column index (>=0 count from left, <0 count from right)
 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
 * "{string}:name"     - column name
 * "{string}"          - jQuery selector on column header nodes
 *
 */

// can be an array of these items, comma separated list, or an array of comma
// separated lists

var __re_column_selector = /^([^:]+)?:(name|title|visIdx|visible)$/;


// r1 and r2 are redundant - but it means that the parameters match for the
// iterator callback in columns().data()
var __columnData = function ( settings, column, r1, r2, rows, type ) {
	var a = [];
	for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
		a.push( _fnGetCellData( settings, rows[row], column, type ) );
	}
	return a;
};


var __column_header = function ( settings, column, row ) {
	var header = settings.aoHeader;
	var target = row !== undefined
		? row
		: settings.bSortCellsTop // legacy support
			? 0
			: header.length - 1;

	return header[target][column].cell;
};

var __column_selector = function ( settings, selector, opts )
{
	var
		columns = settings.aoColumns,
		names = _pluck( columns, 'sName' ),
		titles = _pluck( columns, 'sTitle' ),
		cells = DataTable.util.get('[].[].cell')(settings.aoHeader),
		nodes = _unique( _flatten([], cells) );
	
	var run = function ( s ) {
		var selInt = _intVal( s );

		// Selector - all
		if ( s === '' ) {
			return _range( columns.length );
		}

		// Selector - index
		if ( selInt !== null ) {
			return [ selInt >= 0 ?
				selInt : // Count from left
				columns.length + selInt // Count from right (+ because its a negative value)
			];
		}

		// Selector = function
		if ( typeof s === 'function' ) {
			var rows = _selector_row_indexes( settings, opts );

			return columns.map(function (col, idx) {
				return s(
						idx,
						__columnData( settings, idx, 0, 0, rows ),
						__column_header( settings, idx )
					) ? idx : null;
			});
		}

		// jQuery or string selector
		var match = typeof s === 'string' ?
			s.match( __re_column_selector ) :
			'';

		if ( match ) {
			switch( match[2] ) {
				case 'visIdx':
				case 'visible':
					// Selector is a column index
					if (match[1] && match[1].match(/^\d+$/)) {
						var idx = parseInt( match[1], 10 );

						// Visible index given, convert to column index
						if ( idx < 0 ) {
							// Counting from the right
							var visColumns = columns.map( function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
					}
					
					return columns.map( function (col, idx) {
						// Not visible, can't match
						if (! col.bVisible) {
							return null;
						}

						// Selector
						if (match[1]) {
							return $(nodes[idx]).filter(match[1]).length > 0 ? idx : null;
						}

						// `:visible` on its own
						return idx;
					} );

				case 'name':
					// match by name. `names` is column index complete and in order
					return names.map( function (name, i) {
						return name === match[1] ? i : null;
					} );

				case 'title':
					// match by column title
					return titles.map( function (title, i) {
						return title === match[1] ? i : null;
					} );

				default:
					return [];
			}
		}

		// Cell in the table body
		if ( s.nodeName && s._DT_CellIndex ) {
			return [ s._DT_CellIndex.column ];
		}

		// jQuery selector on the TH elements for the columns
		var jqResult = $( nodes )
			.filter( s )
			.map( function () {
				return _fnColumnsFromHeader( this ); // `nodes` is column index complete and in order
			} )
			.toArray()
			.sort(function (a, b) {
				return a - b;
			});

		if ( jqResult.length || ! s.nodeName ) {
			return jqResult;
		}

		// Otherwise a node which might have a `dt-column` data attribute, or be
		// a child or such an element
		var host = $(s).closest('*[data-dt-column]');
		return host.length ?
			[ host.data('dt-column') ] :
			[];
	};

	return _selector_run( 'column', selector, run, settings, opts );
};


var __setColumnVis = function ( settings, column, vis ) {
	var
		cols = settings.aoColumns,
		col  = cols[ column ],
		data = settings.aoData,
		cells, i, ien, tr;

	// Get
	if ( vis === undefined ) {
		return col.bVisible;
	}

	// Set
	// No change
	if ( col.bVisible === vis ) {
		return false;
	}

	if ( vis ) {
		// Insert column
		// Need to decide if we should use appendChild or insertBefore
		var insertBefore = _pluck(cols, 'bVisible').indexOf(true, column+1);

		for ( i=0, ien=data.length ; i<ien ; i++ ) {
			if (data[i]) {
				tr = data[i].nTr;
				cells = data[i].anCells;

				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
	}
	else {
		// Remove column
		$( _pluck( settings.aoData, 'anCells', column ) ).detach();
	}

	// Common actions
	col.bVisible = vis;

	_colGroup(settings);
	
	return true;
};


_api_register( 'columns()', function ( selector, opts ) {
	// argument shifting
	if ( selector === undefined ) {
		selector = '';
	}
	else if ( $.isPlainObject( selector ) ) {
		opts = selector;
		selector = '';
	}

	opts = _selector_opts( opts );

	var inst = this.iterator( 'table', function ( settings ) {
		return __column_selector( settings, selector, opts );
	}, 1 );

	// Want argument shifting here and in _row_selector?
	inst.selector.cols = selector;
	inst.selector.opts = opts;

	return inst;
} );

_api_registerPlural( 'columns().header()', 'column().header()', function ( row ) {
	return this.iterator( 'column', function (settings, column) {
		return __column_header(settings, column, row);
	}, 1 );
} );

_api_registerPlural( 'columns().footer()', 'column().footer()', function ( row ) {
	return this.iterator( 'column', function ( settings, column ) {
		var footer = settings.aoFooter;

		if (! footer.length) {
			return null;
		}

		return settings.aoFooter[row !== undefined ? row : 0][column].cell;
	}, 1 );
} );

_api_registerPlural( 'columns().data()', 'column().data()', function () {
	return this.iterator( 'column-rows', __columnData, 1 );
} );

_api_registerPlural( 'columns().render()', 'column().render()', function ( type ) {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return __columnData( settings, column, i, j, rows, type );
	}, 1 );
} );

_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings.aoColumns[column].mData;
	}, 1 );
} );

_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return _pluck_order( settings.aoData, rows,
			type === 'search' ? '_aFilterData' : '_aSortData', column
		);
	}, 1 );
} );

_api_registerPlural( 'columns().init()', 'column().init()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings.aoColumns[column];
	}, 1 );
} );

_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
	}, 1 );
} );

_api_registerPlural( 'columns().titles()', 'column().title()', function (title, row) {
	return this.iterator( 'column', function ( settings, column ) {
		// Argument shifting
		if (typeof title === 'number') {
			row = title;
			title = undefined;
		}

		var span = $('span.dt-column-title', this.column(column).header(row));

		if (title !== undefined) {
			span.html(title);
			return this;
		}

		return span.html();
	}, 1 );
} );

_api_registerPlural( 'columns().types()', 'column().type()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		var type = settings.aoColumns[column].sType;

		// If the type was invalidated, then resolve it. This actually does
		// all columns at the moment. Would only happen once if getting all
		// column's data types.
		if (! type) {
			_fnColumnTypes(settings);
		}

		return type;
	}, 1 );
} );

_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
	var that = this;
	var changed = [];
	var ret = this.iterator( 'column', function ( settings, column ) {
		if ( vis === undefined ) {
			return settings.aoColumns[ column ].bVisible;
		} // else
		
		if (__setColumnVis( settings, column, vis )) {
			changed.push(column);
		}
	} );

	// Group the column visibility changes
	if ( vis !== undefined ) {
		this.iterator( 'table', function ( settings ) {
			// Redraw the header after changes
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
	
			// Update colspan for no records display. Child rows and extensions will use their own
			// listeners to do this - only need to update the empty table item here
			if ( ! settings.aiDisplay.length ) {
				$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
			}
	
			_fnSaveState( settings );

			// Second loop once the first is done for events
			that.iterator( 'column', function ( settings, column ) {
				if (changed.includes(column)) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				}
			} );

			if ( changed.length && (calc === undefined || calc) ) {
				that.columns.adjust();
			}
		});
	}

	return ret;
} );

_api_registerPlural( 'columns().widths()', 'column().width()', function () {
	// Injects a fake row into the table for just a moment so the widths can
	// be read, regardless of colspan in the header and rows being present in
	// the body
	var columns = this.columns(':visible').count();
	var row = $('<tr>').html('<td>' + Array(columns).join('</td><td>') + '</td>');

	$(this.table().body()).append(row);

	var widths = row.children().map(function () {
		return $(this).outerWidth();
	});

	row.remove();
	
	return this.iterator( 'column', function ( settings, column ) {
		var visIdx = _fnColumnIndexToVisible( settings, column );

		return visIdx !== null ? widths[visIdx] : 0;
	}, 1);
} );

_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
	return this.iterator( 'column', function ( settings, column ) {
		return type === 'visible' ?
			_fnColumnIndexToVisible( settings, column ) :
			column;
	}, 1 );
} );

_api_register( 'columns.adjust()', function () {
	return this.iterator( 'table', function ( settings ) {
		// Force a column sizing to happen with a manual call - otherwise it can skip
		// if the size hasn't changed
		settings.containerWidth = -1;

		_fnAdjustColumnSizing( settings );
	}, 1 );
} );

_api_register( 'column.index()', function ( type, idx ) {
	if ( this.context.length !== 0 ) {
		var ctx = this.context[0];

		if ( type === 'fromVisible' || type === 'toData' ) {
			return _fnVisibleToColumnIndex( ctx, idx );
		}
		else if ( type === 'fromData' || type === 'toVisible' ) {
			return _fnColumnIndexToVisible( ctx, idx );
		}
	}
} );

_api_register( 'column()', function ( selector, opts ) {
	return _selector_first( this.columns( selector, opts ) );
} );

var __cell_selector = function ( settings, selector, opts )
{
	var data = settings.aoData;
	var rows = _selector_row_indexes( settings, opts );
	var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
	var allCells = $(_flatten( [], cells ));
	var row;
	var columns = settings.aoColumns.length;
	var a, i, ien, j, o, host;

	var run = function ( s ) {
		var fnSelector = typeof s === 'function';

		if ( s === null || s === undefined || fnSelector ) {
			// All cells and function selectors
			a = [];

			for ( i=0, ien=rows.length ; i<ien ; i++ ) {
				row = rows[i];

				for ( j=0 ; j<columns ; j++ ) {
					o = {
						row: row,
						column: j
					};

					if ( fnSelector ) {
						// Selector - function
						host = data[ row ];

						if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
							a.push( o );
						}
					}
					else {
						// Selector - all
						a.push( o );
					}
				}
			}

			return a;
		}
		
		// Selector - index
		if ( $.isPlainObject( s ) ) {
			// Valid cell index and its in the array of selectable rows
			return s.column !== undefined && s.row !== undefined && rows.indexOf(s.row) !== -1 ?
				[s] :
				[];
		}

		// Selector - jQuery filtered cells
		var jqResult = allCells
			.filter( s )
			.map( function (i, el) {
				return { // use a new object, in case someone changes the values
					row:    el._DT_CellIndex.row,
					column: el._DT_CellIndex.column
				};
			} )
			.toArray();

		if ( jqResult.length || ! s.nodeName ) {
			return jqResult;
		}

		// Otherwise the selector is a node, and there is one last option - the
		// element might be a child of an element which has dt-row and dt-column
		// data attributes
		host = $(s).closest('*[data-dt-row]');
		return host.length ?
			[ {
				row: host.data('dt-row'),
				column: host.data('dt-column')
			} ] :
			[];
	};

	return _selector_run( 'cell', selector, run, settings, opts );
};




_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
	// Argument shifting
	if ( $.isPlainObject( rowSelector ) ) {
		// Indexes
		if ( rowSelector.row === undefined ) {
			// Selector options in first parameter
			opts = rowSelector;
			rowSelector = null;
		}
		else {
			// Cell index objects in first parameter
			opts = columnSelector;
			columnSelector = null;
		}
	}
	if ( $.isPlainObject( columnSelector ) ) {
		opts = columnSelector;
		columnSelector = null;
	}

	// Cell selector
	if ( columnSelector === null || columnSelector === undefined ) {
		return this.iterator( 'table', function ( settings ) {
			return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
		} );
	}

	// The default built in options need to apply to row and columns
	var internalOpts = opts ? {
		page: opts.page,
		order: opts.order,
		search: opts.search
	} : {};

	// Row + column selector
	var columns = this.columns( columnSelector, internalOpts );
	var rows = this.rows( rowSelector, internalOpts );
	var i, ien, j, jen;

	var cellsNoOpts = this.iterator( 'table', function ( settings, idx ) {
		var a = [];

		for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
			for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
				a.push( {
					row:    rows[idx][i],
					column: columns[idx][j]
				} );
			}
		}

		return a;
	}, 1 );

	// There is currently only one extension which uses a cell selector extension
	// It is a _major_ performance drag to run this if it isn't needed, so this is
	// an extension specific check at the moment
	var cells = opts && opts.selected ?
		this.cells( cellsNoOpts, opts ) :
		cellsNoOpts;

	$.extend( cells.selector, {
		cols: columnSelector,
		rows: rowSelector,
		opts: opts
	} );

	return cells;
} );


_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		var data = settings.aoData[ row ];

		return data && data.anCells ?
			data.anCells[ column ] :
			undefined;
	}, 1 );
} );


_api_register( 'cells().data()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return _fnGetCellData( settings, row, column );
	}, 1 );
} );


_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
	type = type === 'search' ? '_aFilterData' : '_aSortData';

	return this.iterator( 'cell', function ( settings, row, column ) {
		return settings.aoData[ row ][ type ][ column ];
	}, 1 );
} );


_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return _fnGetCellData( settings, row, column, type );
	}, 1 );
} );


_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return {
			row: row,
			column: column,
			columnVisible: _fnColumnIndexToVisible( settings, column )
		};
	}, 1 );
} );


_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
	return this.iterator( 'cell', function ( settings, row, column ) {
		_fnInvalidate( settings, row, src, column );
	} );
} );



_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
	return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
} );


_api_register( 'cell().data()', function ( data ) {
	var ctx = this.context;
	var cell = this[0];

	if ( data === undefined ) {
		// Get
		return ctx.length && cell.length ?
			_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
			undefined;
	}

	// Set
	_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
	_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );

	return this;
} );



/**
 * Get current ordering (sorting) that has been applied to the table.
 *
 * @returns {array} 2D array containing the sorting information for the first
 *   table in the current context. Each element in the parent array represents
 *   a column being sorted upon (i.e. multi-sorting with two columns would have
 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
 *   the column index that the sorting condition applies to, the second is the
 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
 *   index of the sorting order from the `column.sorting` initialisation array.
 *//**
 * Set the ordering for the table.
 *
 * @param {integer} order Column index to sort upon.
 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
 * @returns {DataTables.Api} this
 *//**
 * Set the ordering for the table.
 *
 * @param {array} order 1D array of sorting information to be applied.
 * @param {array} [...] Optional additional sorting conditions
 * @returns {DataTables.Api} this
 *//**
 * Set the ordering for the table.
 *
 * @param {array} order 2D array of sorting information to be applied.
 * @returns {DataTables.Api} this
 */
_api_register( 'order()', function ( order, dir ) {
	var ctx = this.context;
	var args = Array.prototype.slice.call( arguments );

	if ( order === undefined ) {
		// get
		return ctx.length !== 0 ?
			ctx[0].aaSorting :
			undefined;
	}

	// set
	if ( typeof order === 'number' ) {
		// Simple column / direction passed in
		order = [ [ order, dir ] ];
	}
	else if ( args.length > 1 ) {
		// Arguments passed in (list of 1D arrays)
		order = args;
	}
	// otherwise a 2D array was passed in

	return this.iterator( 'table', function ( settings ) {
		settings.aaSorting = Array.isArray(order) ? order.slice() : order;
	} );
} );


/**
 * Attach a sort listener to an element for a given column
 *
 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
 *   listener to. This can take the form of a single DOM node, a jQuery
 *   collection of nodes or a jQuery selector which will identify the node(s).
 * @param {integer} column the column that a click on this node will sort on
 * @param {function} [callback] callback function when sort is run
 * @returns {DataTables.Api} this
 */
_api_register( 'order.listener()', function ( node, column, callback ) {
	return this.iterator( 'table', function ( settings ) {
		_fnSortAttachListener(settings, node, {}, column, callback);
	} );
} );


_api_register( 'order.fixed()', function ( set ) {
	if ( ! set ) {
		var ctx = this.context;
		var fixed = ctx.length ?
			ctx[0].aaSortingFixed :
			undefined;

		return Array.isArray( fixed ) ?
			{ pre: fixed } :
			fixed;
	}

	return this.iterator( 'table', function ( settings ) {
		settings.aaSortingFixed = $.extend( true, {}, set );
	} );
} );


// Order by the selected column(s)
_api_register( [
	'columns().order()',
	'column().order()'
], function ( dir ) {
	var that = this;

	if ( ! dir ) {
		return this.iterator( 'column', function ( settings, idx ) {
			var sort = _fnSortFlatten( settings );

			for ( var i=0, ien=sort.length ; i<ien ; i++ ) {
				if ( sort[i].col === idx ) {
					return sort[i].dir;
				}
			}

			return null;
		}, 1 );
	}
	else {
		return this.iterator( 'table', function ( settings, i ) {
			settings.aaSorting = that[i].map( function (col) {
				return [ col, dir ];
			} );
		} );
	}
} );

_api_registerPlural('columns().orderable()', 'column().orderable()', function ( directions ) {
	return this.iterator( 'column', function ( settings, idx ) {
		var col = settings.aoColumns[idx];

		return directions ?
			col.asSorting :
			col.bSortable;
	}, 1 );
} );


_api_register( 'processing()', function ( show ) {
	return this.iterator( 'table', function ( ctx ) {
		_fnProcessingDisplay( ctx, show );
	} );
} );


_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
	var ctx = this.context;

	if ( input === undefined ) {
		// get
		return ctx.length !== 0 ?
			ctx[0].oPreviousSearch.search :
			undefined;
	}

	// set
	return this.iterator( 'table', function ( settings ) {
		if ( ! settings.oFeatures.bFilter ) {
			return;
		}

		if (typeof regex === 'object') {
			// New style options to pass to the search builder
			_fnFilterComplete( settings, $.extend( settings.oPreviousSearch, regex, {
				search: input
			} ) );
		}
		else {
			// Compat for the old options
			_fnFilterComplete( settings, $.extend( settings.oPreviousSearch, {
				search: input,
				regex:  regex === null ? false : regex,
				smart:  smart === null ? true  : smart,
				caseInsensitive: caseInsen === null ? true : caseInsen
			} ) );
		}
	} );
} );

_api_register( 'search.fixed()', function ( name, search ) {
	var ret = this.iterator( true, 'table', function ( settings ) {
		var fixed = settings.searchFixed;

		if (! name) {
			return Object.keys(fixed)
		}
		else if (search === undefined) {
			return fixed[name];
		}
		else if (search === null) {
			delete fixed[name];
		}
		else {
			fixed[name] = search;
		}

		return this;
	} );

	return name !== undefined && search === undefined
		? ret[0]
		: ret;
} );

_api_registerPlural(
	'columns().search()',
	'column().search()',
	function ( input, regex, smart, caseInsen ) {
		return this.iterator( 'column', function ( settings, column ) {
			var preSearch = settings.aoPreSearchCols;

			if ( input === undefined ) {
				// get
				return preSearch[ column ].search;
			}

			// set
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}

			if (typeof regex === 'object') {
				// New style options to pass to the search builder
				$.extend( preSearch[ column ], regex, {
					search: input
				} );
			}
			else {
				// Old style (with not all options available)
				$.extend( preSearch[ column ], {
					search: input,
					regex:  regex === null ? false : regex,
					smart:  smart === null ? true  : smart,
					caseInsensitive: caseInsen === null ? true : caseInsen
				} );
			}

			_fnFilterComplete( settings, settings.oPreviousSearch );
		} );
	}
);

_api_register([
		'columns().search.fixed()',
		'column().search.fixed()'
	],
	function ( name, search ) {
		var ret = this.iterator( true, 'column', function ( settings, colIdx ) {
			var fixed = settings.aoColumns[colIdx].searchFixed;

			if (! name) {
				return Object.keys(fixed)
			}
			else if (search === undefined) {
				return fixed[name];
			}
			else if (search === null) {
				delete fixed[name];
			}
			else {
				fixed[name] = search;
			}

			return this;
		} );

		return name !== undefined && search === undefined
			? ret[0]
			: ret;
	}
);
/*
 * State API methods
 */

_api_register( 'state()', function ( set, ignoreTime ) {
	// getter
	if ( ! set ) {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	}

	var setMutate = $.extend( true, {}, set );

	// setter
	return this.iterator( 'table', function ( settings ) {
		if ( ignoreTime !== false ) {
			setMutate.time = +new Date() + 100;
		}

		_fnImplementState( settings, setMutate, function(){} );
	} );
} );


_api_register( 'state.clear()', function () {
	return this.iterator( 'table', function ( settings ) {
		// Save an empty object
		settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
	} );
} );


_api_register( 'state.loaded()', function () {
	return this.context.length ?
		this.context[0].oLoadedState :
		null;
} );


_api_register( 'state.save()', function () {
	return this.iterator( 'table', function ( settings ) {
		_fnSaveState( settings );
	} );
} );

// Can be assigned in DateTable.use() - note luxon and moment vars are in helpers.js
var __bootstrap;
var __foundation;

/**
 * Set the libraries that DataTables uses, or the global objects.
 * Note that the arguments can be either way around (legacy support)
 * and the second is optional. See docs.
 */
DataTable.use = function (arg1, arg2) {
	// Reverse arguments for legacy support
	var module = typeof arg1 === 'string'
		? arg2
		: arg1;
	var type = typeof arg2 === 'string'
		? arg2
		: arg1;

	// Getter
	if (module === undefined && typeof type === 'string') {
		switch (type) {
			case 'lib':
			case 'jq':
				return $;

			case 'win':
				return window;

			case 'datetime':
				return DataTable.DateTime;

			case 'luxon':
				return __luxon;

			case 'moment':
				return __moment;

			case 'bootstrap':
				// Use local if set, otherwise try window, which could be undefined
				return __bootstrap || window.bootstrap;

			case 'foundation':
				// Ditto
				return __foundation || window.Foundation;

			default:
				return null;
		}
	}

	// Setter
	if (type === 'lib' || type === 'jq' || (module && module.fn && module.fn.jquery)) {
		$ = module;
	}
	else if (type === 'win' || (module && module.document)) {
		window = module;
		document = module.document;
	}
	else if (type === 'datetime' || (module && module.type === 'DateTime')) {
		DataTable.DateTime = module;
	}
	else if (type === 'luxon' || (module && module.FixedOffsetZone)) {
		__luxon = module;
	}
	else if (type === 'moment' || (module && module.isMoment)) {
		__moment = module;
	}
	else if (type === 'bootstrap' || (module && module.Modal && module.Modal.NAME === 'modal'))
	{
		// This is currently for BS5 only. BS3/4 attach to jQuery, so no need to use `.use()`
		__bootstrap = module;
	}
	else if (type === 'foundation' || (module && module.Reveal)) {
		__foundation = module;
	}
}

/**
 * CommonJS factory function pass through. This will check if the arguments
 * given are a window object or a jQuery object. If so they are set
 * accordingly.
 * @param {*} root Window
 * @param {*} jq jQUery
 * @returns {boolean} Indicator
 */
DataTable.factory = function (root, jq) {
	var is = false;

	// Test if the first parameter is a window object
	if (root && root.document) {
		window = root;
		document = root.document;
	}

	// Test if the second parameter is a jQuery object
	if (jq && jq.fn && jq.fn.jquery) {
		$ = jq;
		is = true;
	}

	return is;
}

/**
 * Provide a common method for plug-ins to check the version of DataTables being
 * used, in order to ensure compatibility.
 *
 *  @param {string} version Version string to check for, in the format "X.Y.Z".
 *    Note that the formats "X" and "X.Y" are also acceptable.
 *  @param {string} [version2=current DataTables version] As above, but optional.
 *   If not given the current DataTables version will be used.
 *  @returns {boolean} true if this version of DataTables is greater or equal to
 *    the required version, or false if this version of DataTales is not
 *    suitable
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
 */
DataTable.versionCheck = function( version, version2 )
{
	var aThis = version2 ?
		version2.split('.') :
		DataTable.version.split('.');
	var aThat = version.split('.');
	var iThis, iThat;

	for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
		iThis = parseInt( aThis[i], 10 ) || 0;
		iThat = parseInt( aThat[i], 10 ) || 0;

		// Parts are the same, keep comparing
		if (iThis === iThat) {
			continue;
		}

		// Parts are different, return immediately
		return iThis > iThat;
	}

	return true;
};


/**
 * Check if a `<table>` node is a DataTable table already or not.
 *
 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
 *      selector for the table to test. Note that if more than more than one
 *      table is passed on, only the first will be checked
 *  @returns {boolean} true the table given is a DataTable, or false otherwise
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
 *      $('#example').dataTable();
 *    }
 */
DataTable.isDataTable = function ( table )
{
	var t = $(table).get(0);
	var is = false;

	if ( table instanceof DataTable.Api ) {
		return true;
	}

	$.each( DataTable.settings, function (i, o) {
		var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
		var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

		if ( o.nTable === t || head === t || foot === t ) {
			is = true;
		}
	} );

	return is;
};


/**
 * Get all DataTable tables that have been initialised - optionally you can
 * select to get only currently visible tables.
 *
 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
 *    or visible tables only.
 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
 *    DataTables
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    $.each( $.fn.dataTable.tables(true), function () {
 *      $(table).DataTable().columns.adjust();
 *    } );
 */
DataTable.tables = function ( visible )
{
	var api = false;

	if ( $.isPlainObject( visible ) ) {
		api = visible.api;
		visible = visible.visible;
	}

	var a = DataTable.settings
		.filter( function (o) {
			return !visible || (visible && $(o.nTable).is(':visible')) 
				? true
				: false;
		} )
		.map( function (o) {
			return o.nTable;
		});

	return api ?
		new _Api( a ) :
		a;
};


/**
 * Convert from camel case parameters to Hungarian notation. This is made public
 * for the extensions to provide the same ability as DataTables core to accept
 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
 * parameters.
 *
 *  @param {object} src The model object which holds all parameters that can be
 *    mapped.
 *  @param {object} user The object to convert from camel case to Hungarian.
 *  @param {boolean} force When set to `true`, properties which already have a
 *    Hungarian value in the `user` object will be overwritten. Otherwise they
 *    won't be.
 */
DataTable.camelToHungarian = _fnCamelToHungarian;



/**
 *
 */
_api_register( '$()', function ( selector, opts ) {
	var
		rows   = this.rows( opts ).nodes(), // Get all rows
		jqRows = $(rows);

	return $( [].concat(
		jqRows.filter( selector ).toArray(),
		jqRows.find( selector ).toArray()
	) );
} );


// jQuery functions to operate on the tables
$.each( [ 'on', 'one', 'off' ], function (i, key) {
	_api_register( key+'()', function ( /* event, handler */ ) {
		var args = Array.prototype.slice.call(arguments);

		// Add the `dt` namespace automatically if it isn't already present
		args[0] = args[0].split( /\s/ ).map( function ( e ) {
			return ! e.match(/\.dt\b/) ?
				e+'.dt' :
				e;
			} ).join( ' ' );

		var inst = $( this.tables().nodes() );
		inst[key].apply( inst, args );
		return this;
	} );
} );


_api_register( 'clear()', function () {
	return this.iterator( 'table', function ( settings ) {
		_fnClearTable( settings );
	} );
} );


_api_register( 'error()', function (msg) {
	return this.iterator( 'table', function ( settings ) {
		_fnLog( settings, 0, msg );
	} );
} );


_api_register( 'settings()', function () {
	return new _Api( this.context, this.context );
} );


_api_register( 'init()', function () {
	var ctx = this.context;
	return ctx.length ? ctx[0].oInit : null;
} );


_api_register( 'data()', function () {
	return this.iterator( 'table', function ( settings ) {
		return _pluck( settings.aoData, '_aData' );
	} ).flatten();
} );


_api_register( 'trigger()', function ( name, args, bubbles ) {
	return this.iterator( 'table', function ( settings ) {
		return _fnCallbackFire( settings, null, name, args, bubbles );
	} ).flatten();
} );


_api_register( 'ready()', function ( fn ) {
	var ctx = this.context;

	// Get status of first table
	if (! fn) {
		return ctx.length
			? (ctx[0]._bInitComplete || false)
			: null;
	}

	// Function to run either once the table becomes ready or
	// immediately if it is already ready.
	return this.tables().every(function () {
		var api = this;

		if (this.context[0]._bInitComplete) {
			fn.call(api);
		}
		else {
			this.on('init.dt.DT', function () {
				fn.call(api);
			});
		}
	} );
} );


_api_register( 'destroy()', function ( remove ) {
	remove = remove || false;

	return this.iterator( 'table', function ( settings ) {
		var classes   = settings.oClasses;
		var table     = settings.nTable;
		var tbody     = settings.nTBody;
		var thead     = settings.nTHead;
		var tfoot     = settings.nTFoot;
		var jqTable   = $(table);
		var jqTbody   = $(tbody);
		var jqWrapper = $(settings.nTableWrapper);
		var rows      = settings.aoData.map( function (r) { return r ? r.nTr : null; } );
		var orderClasses = classes.order;

		// Flag to note that the table is currently being destroyed - no action
		// should be taken
		settings.bDestroying = true;

		// Fire off the destroy callbacks for plug-ins etc
		_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings], true );

		// If not being removed from the document, make all columns visible
		if ( ! remove ) {
			new _Api( settings ).columns().visible( true );
		}

		// Container width change listener
		if (settings.resizeObserver) {
			settings.resizeObserver.disconnect();
		}

		// Blitz all `DT` namespaced events (these are internal events, the
		// lowercase, `dt` events are user subscribed and they are responsible
		// for removing them
		jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
		$(window).off('.DT-'+settings.sInstance);

		// When scrolling we had to break the table up - restore it
		if ( table != thead.parentNode ) {
			jqTable.children('thead').detach();
			jqTable.append( thead );
		}

		if ( tfoot && table != tfoot.parentNode ) {
			jqTable.children('tfoot').detach();
			jqTable.append( tfoot );
		}

		// Clean up the header
		$(thead).find('span.dt-column-order').remove();
		$(thead).find('span.dt-column-title').each(function () {
			var title = $(this).html();
			$(this).parent().append(title);
			$(this).remove();
		});

		settings.colgroup.remove();

		settings.aaSorting = [];
		settings.aaSortingFixed = [];
		_fnSortingClasses( settings );

		$(jqTable).find('th, td').removeClass(
			$.map(DataTable.ext.type.className, function (v) {
				return v;
			}).join(' ')
		);

		$('th, td', thead)
			.removeClass(
				orderClasses.none + ' ' +
				orderClasses.canAsc + ' ' +
				orderClasses.canDesc + ' ' +
				orderClasses.isAsc + ' ' +
				orderClasses.isDesc
			)
			.css('width', '')
			.removeAttr('data-dt-column')
			.removeAttr('aria-sort');

		// Add the TR elements back into the table in their original order
		jqTbody.children().detach();
		jqTbody.append( rows );

		var orig = settings.nTableWrapper.parentNode;
		var insertBefore = settings.nTableWrapper.nextSibling;

		// Remove the DataTables generated nodes, events and classes
		var removedMethod = remove ? 'remove' : 'detach';
		jqTable[ removedMethod ]();
		jqWrapper[ removedMethod ]();

		// If we need to reattach the table to the document
		if ( ! remove && orig ) {
			// insertBefore acts like appendChild if !arg[1]
			orig.insertBefore( table, insertBefore );

			// Restore the width of the original table - was read from the style property,
			// so we can restore directly to that
			jqTable
				.css( 'width', settings.sDestroyWidth )
				.removeClass( classes.table );
		}

		/* Remove the settings object from the settings array */
		var idx = DataTable.settings.indexOf(settings);
		if ( idx !== -1 ) {
			DataTable.settings.splice( idx, 1 );
		}
	} );
} );


// Add the `every()` method for rows, columns and cells in a compact form
$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
	_api_register( type+'s().every()', function ( fn ) {
		var opts = this.selector.opts;
		var api = this;
		var inst;
		var counter = 0;

		return this.iterator( 'every', function ( settings, selectedIdx, tableIdx ) {
			inst = api[ type ](selectedIdx, opts);

			if (type === 'cell') {
				fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
			}
			else {
				fn.call(inst, selectedIdx, tableIdx, counter);
			}

			counter++;
		} );
	} );
} );


// i18n method for extensions to be able to use the language object from the
// DataTable
_api_register( 'i18n()', function ( token, def, plural ) {
	var ctx = this.context[0];
	var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );

	if ( resolved === undefined ) {
		resolved = def;
	}

	if ( $.isPlainObject( resolved ) ) {
		resolved = plural !== undefined && resolved[ plural ] !== undefined ?
			resolved[ plural ] :
			resolved._;
	}

	return typeof resolved === 'string'
		? resolved.replace( '%d', plural ) // nb: plural might be undefined,
		: resolved;
} );

/**
 * Version string for plug-ins to check compatibility. Allowed format is
 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
 * only for non-release builds. See https://semver.org/ for more information.
 *  @member
 *  @type string
 *  @default Version number
 */
DataTable.version = "2.2.2";

/**
 * Private data store, containing all of the settings objects that are
 * created for the tables on a given page.
 *
 * Note that the `DataTable.settings` object is aliased to
 * `jQuery.fn.dataTableExt` through which it may be accessed and
 * manipulated, or `jQuery.fn.dataTable.settings`.
 *  @member
 *  @type array
 *  @default []
 *  @private
 */
DataTable.settings = [];

/**
 * Object models container, for the various models that DataTables has
 * available to it. These models define the objects that are used to hold
 * the active state and configuration of the table.
 *  @namespace
 */
DataTable.models = {};



/**
 * Template object for the way in which DataTables holds information about
 * search information for the global filter and individual column filters.
 *  @namespace
 */
DataTable.models.oSearch = {
	/**
	 * Flag to indicate if the filtering should be case insensitive or not
	 */
	"caseInsensitive": true,

	/**
	 * Applied search term
	 */
	"search": "",

	/**
	 * Flag to indicate if the search term should be interpreted as a
	 * regular expression (true) or not (false) and therefore and special
	 * regex characters escaped.
	 */
	"regex": false,

	/**
	 * Flag to indicate if DataTables is to use its smart filtering or not.
	 */
	"smart": true,

	/**
	 * Flag to indicate if DataTables should only trigger a search when
	 * the return key is pressed.
	 */
	"return": false
};




/**
 * Template object for the way in which DataTables holds information about
 * each individual row. This is the object format used for the settings
 * aoData array.
 *  @namespace
 */
DataTable.models.oRow = {
	/**
	 * TR element for the row
	 */
	"nTr": null,

	/**
	 * Array of TD elements for each row. This is null until the row has been
	 * created.
	 */
	"anCells": null,

	/**
	 * Data object from the original data source for the row. This is either
	 * an array if using the traditional form of DataTables, or an object if
	 * using mData options. The exact type will depend on the passed in
	 * data from the data source, or will be an array if using DOM a data
	 * source.
	 */
	"_aData": [],

	/**
	 * Sorting data cache - this array is ostensibly the same length as the
	 * number of columns (although each index is generated only as it is
	 * needed), and holds the data that is used for sorting each column in the
	 * row. We do this cache generation at the start of the sort in order that
	 * the formatting of the sort data need be done only once for each cell
	 * per sort. This array should not be read from or written to by anything
	 * other than the master sorting methods.
	 */
	"_aSortData": null,

	/**
	 * Per cell filtering data cache. As per the sort data cache, used to
	 * increase the performance of the filtering in DataTables
	 */
	"_aFilterData": null,

	/**
	 * Filtering data cache. This is the same as the cell filtering cache, but
	 * in this case a string rather than an array. This is easily computed with
	 * a join on `_aFilterData`, but is provided as a cache so the join isn't
	 * needed on every search (memory traded for performance)
	 */
	"_sFilterRow": null,

	/**
	 * Denote if the original data source was from the DOM, or the data source
	 * object. This is used for invalidating data, so DataTables can
	 * automatically read data from the original source, unless uninstructed
	 * otherwise.
	 */
	"src": null,

	/**
	 * Index in the aoData array. This saves an indexOf lookup when we have the
	 * object, but want to know the index
	 */
	"idx": -1,

	/**
	 * Cached display value
	 */
	displayData: null
};


/**
 * Template object for the column information object in DataTables. This object
 * is held in the settings aoColumns array and contains all the information that
 * DataTables needs about each individual column.
 *
 * Note that this object is related to {@link DataTable.defaults.column}
 * but this one is the internal data store for DataTables's cache of columns.
 * It should NOT be manipulated outside of DataTables. Any configuration should
 * be done through the initialisation options.
 *  @namespace
 */
DataTable.models.oColumn = {
	/**
	 * Column index.
	 */
	"idx": null,

	/**
	 * A list of the columns that sorting should occur on when this column
	 * is sorted. That this property is an array allows multi-column sorting
	 * to be defined for a column (for example first name / last name columns
	 * would benefit from this). The values are integers pointing to the
	 * columns to be sorted on (typically it will be a single integer pointing
	 * at itself, but that doesn't need to be the case).
	 */
	"aDataSort": null,

	/**
	 * Define the sorting directions that are applied to the column, in sequence
	 * as the column is repeatedly sorted upon - i.e. the first value is used
	 * as the sorting direction when the column if first sorted (clicked on).
	 * Sort it again (click again) and it will move on to the next index.
	 * Repeat until loop.
	 */
	"asSorting": null,

	/**
	 * Flag to indicate if the column is searchable, and thus should be included
	 * in the filtering or not.
	 */
	"bSearchable": null,

	/**
	 * Flag to indicate if the column is sortable or not.
	 */
	"bSortable": null,

	/**
	 * Flag to indicate if the column is currently visible in the table or not
	 */
	"bVisible": null,

	/**
	 * Store for manual type assignment using the `column.type` option. This
	 * is held in store so we can manipulate the column's `sType` property.
	 */
	"_sManualType": null,

	/**
	 * Flag to indicate if HTML5 data attributes should be used as the data
	 * source for filtering or sorting. True is either are.
	 */
	"_bAttrSrc": false,

	/**
	 * Developer definable function that is called whenever a cell is created (Ajax source,
	 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	 * allowing you to modify the DOM element (add background colour for example) when the
	 * element is available.
	 */
	"fnCreatedCell": null,

	/**
	 * Function to get data from a cell in a column. You should <b>never</b>
	 * access data directly through _aData internally in DataTables - always use
	 * the method attached to this property. It allows mData to function as
	 * required. This function is automatically assigned by the column
	 * initialisation method
	 */
	"fnGetData": null,

	/**
	 * Function to set data for a cell in the column. You should <b>never</b>
	 * set the data directly to _aData internally in DataTables - always use
	 * this method. It allows mData to function as required. This function
	 * is automatically assigned by the column initialisation method
	 */
	"fnSetData": null,

	/**
	 * Property to read the value for the cells in the column from the data
	 * source array / object. If null, then the default content is used, if a
	 * function is given then the return from the function is used.
	 */
	"mData": null,

	/**
	 * Partner property to mData which is used (only when defined) to get
	 * the data - i.e. it is basically the same as mData, but without the
	 * 'set' option, and also the data fed to it is the result from mData.
	 * This is the rendering method to match the data method of mData.
	 */
	"mRender": null,

	/**
	 * The class to apply to all TD elements in the table's TBODY for the column
	 */
	"sClass": null,

	/**
	 * When DataTables calculates the column widths to assign to each column,
	 * it finds the longest string in each column and then constructs a
	 * temporary table and reads the widths from that. The problem with this
	 * is that "mmm" is much wider then "iiii", but the latter is a longer
	 * string - thus the calculation can go wrong (doing it properly and putting
	 * it into an DOM object and measuring that is horribly(!) slow). Thus as
	 * a "work around" we provide this option. It will append its value to the
	 * text that is found to be the longest string for the column - i.e. padding.
	 */
	"sContentPadding": null,

	/**
	 * Allows a default value to be given for a column's data, and will be used
	 * whenever a null data source is encountered (this can be because mData
	 * is set to null, or because the data source itself is null).
	 */
	"sDefaultContent": null,

	/**
	 * Name for the column, allowing reference to the column by name as well as
	 * by index (needs a lookup to work by name).
	 */
	"sName": null,

	/**
	 * Custom sorting data type - defines which of the available plug-ins in
	 * afnSortData the custom sorting will use - if any is defined.
	 */
	"sSortDataType": 'std',

	/**
	 * Class to be applied to the header element when sorting on this column
	 */
	"sSortingClass": null,

	/**
	 * Title of the column - what is seen in the TH element (nTh).
	 */
	"sTitle": null,

	/**
	 * Column sorting and filtering type
	 */
	"sType": null,

	/**
	 * Width of the column
	 */
	"sWidth": null,

	/**
	 * Width of the column when it was first "encountered"
	 */
	"sWidthOrig": null,

	/** Cached string which is the longest in the column */
	maxLenString: null,

	/**
	 * Store for named searches
	 */
	searchFixed: null
};


/*
 * Developer note: The properties of the object below are given in Hungarian
 * notation, that was used as the interface for DataTables prior to v1.10, however
 * from v1.10 onwards the primary interface is camel case. In order to avoid
 * breaking backwards compatibility utterly with this change, the Hungarian
 * version is still, internally the primary interface, but is is not documented
 * - hence the @name tags in each doc comment. This allows a Javascript function
 * to create a map from Hungarian notation to camel case (going the other direction
 * would require each property to be listed, which would add around 3K to the size
 * of DataTables, while this method is about a 0.5K hit).
 *
 * Ultimately this does pave the way for Hungarian notation to be dropped
 * completely, but that is a massive amount of work and will break current
 * installs (therefore is on-hold until v2).
 */

/**
 * Initialisation options that can be given to DataTables at initialisation
 * time.
 *  @namespace
 */
DataTable.defaults = {
	/**
	 * An array of data to use for the table, passed in at initialisation which
	 * will be used in preference to any data which is already in the DOM. This is
	 * particularly useful for constructing tables purely in Javascript, for
	 * example with a custom Ajax call.
	 */
	"aaData": null,


	/**
	 * If ordering is enabled, then DataTables will perform a first pass sort on
	 * initialisation. You can define which column(s) the sort is performed
	 * upon, and the sorting direction, with this variable. The `sorting` array
	 * should contain an array for each column to be sorted initially containing
	 * the column's index and a direction string ('asc' or 'desc').
	 */
	"aaSorting": [[0,'asc']],


	/**
	 * This parameter is basically identical to the `sorting` parameter, but
	 * cannot be overridden by user interaction with the table. What this means
	 * is that you could have a column (visible or hidden) which the sorting
	 * will always be forced on first - any sorting after that (from the user)
	 * will then be performed as required. This can be useful for grouping rows
	 * together.
	 */
	"aaSortingFixed": [],


	/**
	 * DataTables can be instructed to load data to display in the table from a
	 * Ajax source. This option defines how that Ajax call is made and where to.
	 *
	 * The `ajax` property has three different modes of operation, depending on
	 * how it is defined. These are:
	 *
	 * * `string` - Set the URL from where the data should be loaded from.
	 * * `object` - Define properties for `jQuery.ajax`.
	 * * `function` - Custom data get function
	 *
	 * `string`
	 * --------
	 *
	 * As a string, the `ajax` property simply defines the URL from which
	 * DataTables will load data.
	 *
	 * `object`
	 * --------
	 *
	 * As an object, the parameters in the object are passed to
	 * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
	 * of the Ajax request. DataTables has a number of default parameters which
	 * you can override using this option. Please refer to the jQuery
	 * documentation for a full description of the options available, although
	 * the following parameters provide additional options in DataTables or
	 * require special consideration:
	 *
	 * * `data` - As with jQuery, `data` can be provided as an object, but it
	 *   can also be used as a function to manipulate the data DataTables sends
	 *   to the server. The function takes a single parameter, an object of
	 *   parameters with the values that DataTables has readied for sending. An
	 *   object may be returned which will be merged into the DataTables
	 *   defaults, or you can add the items to the object that was passed in and
	 *   not return anything from the function. This supersedes `fnServerParams`
	 *   from DataTables 1.9-.
	 *
	 * * `dataSrc` - By default DataTables will look for the property `data` (or
	 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
	 *   from an Ajax source or for server-side processing - this parameter
	 *   allows that property to be changed. You can use Javascript dotted
	 *   object notation to get a data source for multiple levels of nesting, or
	 *   it my be used as a function. As a function it takes a single parameter,
	 *   the JSON returned from the server, which can be manipulated as
	 *   required, with the returned value being that used by DataTables as the
	 *   data source for the table.
	 *
	 * * `success` - Should not be overridden it is used internally in
	 *   DataTables. To manipulate / transform the data returned by the server
	 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
	 *
	 * `function`
	 * ----------
	 *
	 * As a function, making the Ajax call is left up to yourself allowing
	 * complete control of the Ajax request. Indeed, if desired, a method other
	 * than Ajax could be used to obtain the required data, such as Web storage
	 * or an AIR database.
	 *
	 * The function is given four parameters and no return is required. The
	 * parameters are:
	 *
	 * 1. _object_ - Data to send to the server
	 * 2. _function_ - Callback function that must be executed when the required
	 *    data has been obtained. That data should be passed into the callback
	 *    as the only parameter
	 * 3. _object_ - DataTables settings object for the table
	 */
	"ajax": null,


	/**
	 * This parameter allows you to readily specify the entries in the length drop
	 * down menu that DataTables shows when pagination is enabled. It can be
	 * either a 1D array of options which will be used for both the displayed
	 * option and the value, or a 2D array which will use the array in the first
	 * position as the value, and the array in the second position as the
	 * displayed options (useful for language strings such as 'All').
	 *
	 * Note that the `pageLength` property will be automatically set to the
	 * first value given in this array, unless `pageLength` is also provided.
	 */
	"aLengthMenu": [ 10, 25, 50, 100 ],


	/**
	 * The `columns` option in the initialisation parameter allows you to define
	 * details about the way individual columns behave. For a full list of
	 * column options that can be set, please see
	 * {@link DataTable.defaults.column}. Note that if you use `columns` to
	 * define your columns, you must have an entry in the array for every single
	 * column that you have in your table (these can be null if you don't which
	 * to specify any options).
	 */
	"aoColumns": null,

	/**
	 * Very similar to `columns`, `columnDefs` allows you to target a specific
	 * column, multiple columns, or all columns, using the `targets` property of
	 * each object in the array. This allows great flexibility when creating
	 * tables, as the `columnDefs` arrays can be of any length, targeting the
	 * columns you specifically want. `columnDefs` may use any of the column
	 * options available: {@link DataTable.defaults.column}, but it _must_
	 * have `targets` defined in each object in the array. Values in the `targets`
	 * array may be:
	 *   <ul>
	 *     <li>a string - class name will be matched on the TH for the column</li>
	 *     <li>0 or a positive integer - column index counting from the left</li>
	 *     <li>a negative integer - column index counting from the right</li>
	 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
	 *   </ul>
	 */
	"aoColumnDefs": null,


	/**
	 * Basically the same as `search`, this parameter defines the individual column
	 * filtering state at initialisation time. The array must be of the same size
	 * as the number of columns, and each element be an object with the parameters
	 * `search` and `escapeRegex` (the latter is optional). 'null' is also
	 * accepted and the default will be used.
	 */
	"aoSearchCols": [],


	/**
	 * Enable or disable automatic column width calculation. This can be disabled
	 * as an optimisation (it takes some time to calculate the widths) if the
	 * tables widths are passed in using `columns`.
	 */
	"bAutoWidth": true,


	/**
	 * Deferred rendering can provide DataTables with a huge speed boost when you
	 * are using an Ajax or JS data source for the table. This option, when set to
	 * true, will cause DataTables to defer the creation of the table elements for
	 * each row until they are needed for a draw - saving a significant amount of
	 * time.
	 */
	"bDeferRender": true,


	/**
	 * Replace a DataTable which matches the given selector and replace it with
	 * one which has the properties of the new initialisation object passed. If no
	 * table matches the selector, then the new DataTable will be constructed as
	 * per normal.
	 */
	"bDestroy": false,


	/**
	 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
	 * that it allows the end user to input multiple words (space separated) and
	 * will match a row containing those words, even if not in the order that was
	 * specified (this allow matching across multiple columns). Note that if you
	 * wish to use filtering in DataTables this must remain 'true' - to remove the
	 * default filtering input box and retain filtering abilities, please use
	 * {@link DataTable.defaults.dom}.
	 */
	"bFilter": true,

	/**
	 * Used only for compatiblity with DT1
	 * @deprecated
	 */
	"bInfo": true,

	/**
	 * Used only for compatiblity with DT1
	 * @deprecated
	 */
	"bLengthChange": true,

	/**
	 * Enable or disable pagination.
	 */
	"bPaginate": true,


	/**
	 * Enable or disable the display of a 'processing' indicator when the table is
	 * being processed (e.g. a sort). This is particularly useful for tables with
	 * large amounts of data where it can take a noticeable amount of time to sort
	 * the entries.
	 */
	"bProcessing": false,


	/**
	 * Retrieve the DataTables object for the given selector. Note that if the
	 * table has already been initialised, this parameter will cause DataTables
	 * to simply return the object that has already been set up - it will not take
	 * account of any changes you might have made to the initialisation object
	 * passed to DataTables (setting this parameter to true is an acknowledgement
	 * that you understand this). `destroy` can be used to reinitialise a table if
	 * you need.
	 */
	"bRetrieve": false,


	/**
	 * When vertical (y) scrolling is enabled, DataTables will force the height of
	 * the table's viewport to the given height at all times (useful for layout).
	 * However, this can look odd when filtering data down to a small data set,
	 * and the footer is left "floating" further down. This parameter (when
	 * enabled) will cause DataTables to collapse the table's viewport down when
	 * the result set will fit within the given Y height.
	 */
	"bScrollCollapse": false,


	/**
	 * Configure DataTables to use server-side processing. Note that the
	 * `ajax` parameter must also be given in order to give DataTables a
	 * source to obtain the required data for each draw.
	 */
	"bServerSide": false,


	/**
	 * Enable or disable sorting of columns. Sorting of individual columns can be
	 * disabled by the `sortable` option for each column.
	 */
	"bSort": true,


	/**
	 * Enable or display DataTables' ability to sort multiple columns at the
	 * same time (activated by shift-click by the user).
	 */
	"bSortMulti": true,


	/**
	 * Allows control over whether DataTables should use the top (true) unique
	 * cell that is found for a single column, or the bottom (false - default).
	 * This is useful when using complex headers.
	 */
	"bSortCellsTop": null,


	/**
	 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
	 * `sorting\_3` to the columns which are currently being sorted on. This is
	 * presented as a feature switch as it can increase processing time (while
	 * classes are removed and added) so for large data sets you might want to
	 * turn this off.
	 */
	"bSortClasses": true,


	/**
	 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
	 * used to save table display information such as pagination information,
	 * display length, filtering and sorting. As such when the end user reloads
	 * the page the display display will match what thy had previously set up.
	 */
	"bStateSave": false,


	/**
	 * This function is called when a TR element is created (and all TD child
	 * elements have been inserted), or registered if using a DOM source, allowing
	 * manipulation of the TR element (adding classes etc).
	 */
	"fnCreatedRow": null,


	/**
	 * This function is called on every 'draw' event, and allows you to
	 * dynamically modify any aspect you want about the created DOM.
	 */
	"fnDrawCallback": null,


	/**
	 * Identical to fnHeaderCallback() but for the table footer this function
	 * allows you to modify the table footer on every 'draw' event.
	 */
	"fnFooterCallback": null,


	/**
	 * When rendering large numbers in the information element for the table
	 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
	 * to have a comma separator for the 'thousands' units (e.g. 1 million is
	 * rendered as "1,000,000") to help readability for the end user. This
	 * function will override the default method DataTables uses.
	 */
	"fnFormatNumber": function ( toFormat ) {
		return toFormat.toString().replace(
			/\B(?=(\d{3})+(?!\d))/g,
			this.oLanguage.sThousands
		);
	},


	/**
	 * This function is called on every 'draw' event, and allows you to
	 * dynamically modify the header row. This can be used to calculate and
	 * display useful information about the table.
	 */
	"fnHeaderCallback": null,


	/**
	 * The information element can be used to convey information about the current
	 * state of the table. Although the internationalisation options presented by
	 * DataTables are quite capable of dealing with most customisations, there may
	 * be times where you wish to customise the string further. This callback
	 * allows you to do exactly that.
	 */
	"fnInfoCallback": null,


	/**
	 * Called when the table has been initialised. Normally DataTables will
	 * initialise sequentially and there will be no need for this function,
	 * however, this does not hold true when using external language information
	 * since that is obtained using an async XHR call.
	 */
	"fnInitComplete": null,


	/**
	 * Called at the very start of each table draw and can be used to cancel the
	 * draw by returning false, any other return (including undefined) results in
	 * the full draw occurring).
	 */
	"fnPreDrawCallback": null,


	/**
	 * This function allows you to 'post process' each row after it have been
	 * generated for each table draw, but before it is rendered on screen. This
	 * function might be used for setting the row class name etc.
	 */
	"fnRowCallback": null,


	/**
	 * Load the table state. With this function you can define from where, and how, the
	 * state of a table is loaded. By default DataTables will load from `localStorage`
	 * but you might wish to use a server-side database or cookies.
	 */
	"fnStateLoadCallback": function ( settings ) {
		try {
			return JSON.parse(
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
					'DataTables_'+settings.sInstance+'_'+location.pathname
				)
			);
		} catch (e) {
			return {};
		}
	},


	/**
	 * Callback which allows modification of the saved state prior to loading that state.
	 * This callback is called when the table is loading state from the stored data, but
	 * prior to the settings object being modified by the saved state. Note that for
	 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
	 * a plug-in.
	 */
	"fnStateLoadParams": null,


	/**
	 * Callback that is called when the state has been loaded from the state saving method
	 * and the DataTables settings object has been modified as a result of the loaded state.
	 */
	"fnStateLoaded": null,


	/**
	 * Save the table state. This function allows you to define where and how the state
	 * information for the table is stored By default DataTables will use `localStorage`
	 * but you might wish to use a server-side database or cookies.
	 */
	"fnStateSaveCallback": function ( settings, data ) {
		try {
			(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
				'DataTables_'+settings.sInstance+'_'+location.pathname,
				JSON.stringify( data )
			);
		} catch (e) {
			// noop
		}
	},


	/**
	 * Callback which allows modification of the state to be saved. Called when the table
	 * has changed state a new state save is required. This method allows modification of
	 * the state saving object prior to actually doing the save, including addition or
	 * other state properties or modification. Note that for plug-in authors, you should
	 * use the `stateSaveParams` event to save parameters for a plug-in.
	 */
	"fnStateSaveParams": null,


	/**
	 * Duration for which the saved state information is considered valid. After this period
	 * has elapsed the state will be returned to the default.
	 * Value is given in seconds.
	 */
	"iStateDuration": 7200,


	/**
	 * Number of rows to display on a single page when using pagination. If
	 * feature enabled (`lengthChange`) then the end user will be able to override
	 * this to a custom setting using a pop-up menu.
	 */
	"iDisplayLength": 10,


	/**
	 * Define the starting point for data display when using DataTables with
	 * pagination. Note that this parameter is the number of records, rather than
	 * the page number, so if you have 10 records per page and want to start on
	 * the third page, it should be "20".
	 */
	"iDisplayStart": 0,


	/**
	 * By default DataTables allows keyboard navigation of the table (sorting, paging,
	 * and filtering) by adding a `tabindex` attribute to the required elements. This
	 * allows you to tab through the controls and press the enter key to activate them.
	 * The tabindex is default 0, meaning that the tab follows the flow of the document.
	 * You can overrule this using this parameter if you wish. Use a value of -1 to
	 * disable built-in keyboard navigation.
	 */
	"iTabIndex": 0,


	/**
	 * Classes that DataTables assigns to the various components and features
	 * that it adds to the HTML table. This allows classes to be configured
	 * during initialisation in addition to through the static
	 * {@link DataTable.ext.oStdClasses} object).
	 */
	"oClasses": {},


	/**
	 * All strings that DataTables uses in the user interface that it creates
	 * are defined in this object, allowing you to modified them individually or
	 * completely replace them all as required.
	 */
	"oLanguage": {
		/**
		 * Strings that are used for WAI-ARIA labels and controls only (these are not
		 * actually visible on the page, but will be read by screenreaders, and thus
		 * must be internationalised as well).
		 */
		"oAria": {
			/**
			 * ARIA label that is added to the table headers when the column may be sorted
			 */
			"orderable": ": Activate to sort",

			/**
			 * ARIA label that is added to the table headers when the column is currently being sorted
			 */
			"orderableReverse": ": Activate to invert sorting",

			/**
			 * ARIA label that is added to the table headers when the column is currently being 
			 * sorted and next step is to remove sorting
			 */
			"orderableRemove": ": Activate to remove sorting",

			paginate: {
				first: 'First',
				last: 'Last',
				next: 'Next',
				previous: 'Previous',
				number: ''
			}
		},

		/**
		 * Pagination string used by DataTables for the built-in pagination
		 * control types.
		 */
		"oPaginate": {
			/**
			 * Label and character for first page button («)
			 */
			"sFirst": "\u00AB",

			/**
			 * Last page button (»)
			 */
			"sLast": "\u00BB",

			/**
			 * Next page button (›)
			 */
			"sNext": "\u203A",

			/**
			 * Previous page button (‹)
			 */
			"sPrevious": "\u2039",
		},

		/**
		 * Plural object for the data type the table is showing
		 */
		entries: {
			_: "entries",
			1: "entry"
		},

		/**
		 * This string is shown in preference to `zeroRecords` when the table is
		 * empty of data (regardless of filtering). Note that this is an optional
		 * parameter - if it is not given, the value of `zeroRecords` will be used
		 * instead (either the default or given value).
		 */
		"sEmptyTable": "No data available in table",


		/**
		 * This string gives information to the end user about the information
		 * that is current on display on the page. The following tokens can be
		 * used in the string and will be dynamically replaced as the table
		 * display updates. This tokens can be placed anywhere in the string, or
		 * removed as needed by the language requires:
		 *
		 * * `\_START\_` - Display index of the first record on the current page
		 * * `\_END\_` - Display index of the last record on the current page
		 * * `\_TOTAL\_` - Number of records in the table after filtering
		 * * `\_MAX\_` - Number of records in the table without filtering
		 * * `\_PAGE\_` - Current page number
		 * * `\_PAGES\_` - Total number of pages of data in the table
		 */
		"sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",


		/**
		 * Display information string for when the table is empty. Typically the
		 * format of this string should match `info`.
		 */
		"sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",


		/**
		 * When a user filters the information in a table, this string is appended
		 * to the information (`info`) to give an idea of how strong the filtering
		 * is. The variable _MAX_ is dynamically updated.
		 */
		"sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",


		/**
		 * If can be useful to append extra information to the info string at times,
		 * and this variable does exactly that. This information will be appended to
		 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
		 * being used) at all times.
		 */
		"sInfoPostFix": "",


		/**
		 * This decimal place operator is a little different from the other
		 * language options since DataTables doesn't output floating point
		 * numbers, so it won't ever use this for display of a number. Rather,
		 * what this parameter does is modify the sort methods of the table so
		 * that numbers which are in a format which has a character other than
		 * a period (`.`) as a decimal place will be sorted numerically.
		 *
		 * Note that numbers with different decimal places cannot be shown in
		 * the same table and still be sortable, the table must be consistent.
		 * However, multiple different tables on the page can use different
		 * decimal place characters.
		 */
		"sDecimal": "",


		/**
		 * DataTables has a build in number formatter (`formatNumber`) which is
		 * used to format large numbers that are used in the table information.
		 * By default a comma is used, but this can be trivially changed to any
		 * character you wish with this parameter.
		 */
		"sThousands": ",",


		/**
		 * Detail the action that will be taken when the drop down menu for the
		 * pagination length option is changed. The '_MENU_' variable is replaced
		 * with a default select list of 10, 25, 50 and 100, and can be replaced
		 * with a custom select box if required.
		 */
		"sLengthMenu": "_MENU_ _ENTRIES_ per page",


		/**
		 * When using Ajax sourced data and during the first draw when DataTables is
		 * gathering the data, this message is shown in an empty row in the table to
		 * indicate to the end user the the data is being loaded. Note that this
		 * parameter is not used when loading data by server-side processing, just
		 * Ajax sourced data with client-side processing.
		 */
		"sLoadingRecords": "Loading...",


		/**
		 * Text which is displayed when the table is processing a user action
		 * (usually a sort command or similar).
		 */
		"sProcessing": "",


		/**
		 * Details the actions that will be taken when the user types into the
		 * filtering input text box. The variable "_INPUT_", if used in the string,
		 * is replaced with the HTML text box for the filtering input allowing
		 * control over where it appears in the string. If "_INPUT_" is not given
		 * then the input box is appended to the string automatically.
		 */
		"sSearch": "Search:",


		/**
		 * Assign a `placeholder` attribute to the search `input` element
		 *  @type string
		 *  @default 
		 *
		 *  @dtopt Language
		 *  @name DataTable.defaults.language.searchPlaceholder
		 */
		"sSearchPlaceholder": "",


		/**
		 * All of the language information can be stored in a file on the
		 * server-side, which DataTables will look up if this parameter is passed.
		 * It must store the URL of the language file, which is in a JSON format,
		 * and the object has the same properties as the oLanguage object in the
		 * initialiser object (i.e. the above parameters). Please refer to one of
		 * the example language files to see how this works in action.
		 */
		"sUrl": "",


		/**
		 * Text shown inside the table records when the is no information to be
		 * displayed after filtering. `emptyTable` is shown when there is simply no
		 * information in the table at all (regardless of filtering).
		 */
		"sZeroRecords": "No matching records found"
	},


	/** The initial data order is reversed when `desc` ordering */
	orderDescReverse: true,


	/**
	 * This parameter allows you to have define the global filtering state at
	 * initialisation time. As an object the `search` parameter must be
	 * defined, but all other parameters are optional. When `regex` is true,
	 * the search string will be treated as a regular expression, when false
	 * (default) it will be treated as a straight string. When `smart`
	 * DataTables will use it's smart filtering methods (to word match at
	 * any point in the data), when false this will not be done.
	 */
	"oSearch": $.extend( {}, DataTable.models.oSearch ),


	/**
	 * Table and control layout. This replaces the legacy `dom` option.
	 */
	layout: {
		topStart: 'pageLength',
		topEnd: 'search',
		bottomStart: 'info',
		bottomEnd: 'paging'
	},


	/**
	 * Legacy DOM layout option
	 */
	"sDom": null,


	/**
	 * Search delay option. This will throttle full table searches that use the
	 * DataTables provided search input element (it does not effect calls to
	 * `dt-api search()`, providing a delay before the search is made.
	 */
	"searchDelay": null,


	/**
	 * DataTables features six different built-in options for the buttons to
	 * display for pagination control:
	 *
	 * * `numbers` - Page number buttons only
	 * * `simple` - 'Previous' and 'Next' buttons only
	 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
	 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
	 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
	 * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
	 */
	"sPaginationType": "",


	/**
	 * Enable horizontal scrolling. When a table is too wide to fit into a
	 * certain layout, or you have a large number of columns in the table, you
	 * can enable x-scrolling to show the table in a viewport, which can be
	 * scrolled. This property can be `true` which will allow the table to
	 * scroll horizontally when needed, or any CSS unit, or a number (in which
	 * case it will be treated as a pixel measurement). Setting as simply `true`
	 * is recommended.
	 */
	"sScrollX": "",


	/**
	 * This property can be used to force a DataTable to use more width than it
	 * might otherwise do when x-scrolling is enabled. For example if you have a
	 * table which requires to be well spaced, this parameter is useful for
	 * "over-sizing" the table, and thus forcing scrolling. This property can by
	 * any CSS unit, or a number (in which case it will be treated as a pixel
	 * measurement).
	 */
	"sScrollXInner": "",


	/**
	 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
	 * to the given height, and enable scrolling for any data which overflows the
	 * current viewport. This can be used as an alternative to paging to display
	 * a lot of data in a small area (although paging and scrolling can both be
	 * enabled at the same time). This property can be any CSS unit, or a number
	 * (in which case it will be treated as a pixel measurement).
	 */
	"sScrollY": "",


	/**
	 * __Deprecated__ The functionality provided by this parameter has now been
	 * superseded by that provided through `ajax`, which should be used instead.
	 *
	 * Set the HTTP method that is used to make the Ajax call for server-side
	 * processing or Ajax sourced data.
	 */
	"sServerMethod": "GET",


	/**
	 * DataTables makes use of renderers when displaying HTML elements for
	 * a table. These renderers can be added or modified by plug-ins to
	 * generate suitable mark-up for a site. For example the Bootstrap
	 * integration plug-in for DataTables uses a paging button renderer to
	 * display pagination buttons in the mark-up required by Bootstrap.
	 *
	 * For further information about the renderers available see
	 * DataTable.ext.renderer
	 */
	"renderer": null,


	/**
	 * Set the data property name that DataTables should use to get a row's id
	 * to set as the `id` property in the node.
	 */
	"rowId": "DT_RowId",


	/**
	 * Caption value
	 */
	"caption": null,


	/**
	 * For server-side processing - use the data from the DOM for the first draw
	 */
	iDeferLoading: null
};

_fnHungarianMap( DataTable.defaults );



/*
 * Developer note - See note in model.defaults.js about the use of Hungarian
 * notation and camel case.
 */

/**
 * Column options that can be given to DataTables at initialisation time.
 *  @namespace
 */
DataTable.defaults.column = {
	/**
	 * Define which column(s) an order will occur on for this column. This
	 * allows a column's ordering to take multiple columns into account when
	 * doing a sort or use the data from a different column. For example first
	 * name / last name columns make sense to do a multi-column sort over the
	 * two columns.
	 */
	"aDataSort": null,
	"iDataSort": -1,

	ariaTitle: '',


	/**
	 * You can control the default ordering direction, and even alter the
	 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
	 * using this parameter.
	 */
	"asSorting": [ 'asc', 'desc', '' ],


	/**
	 * Enable or disable filtering on the data in this column.
	 */
	"bSearchable": true,


	/**
	 * Enable or disable ordering on this column.
	 */
	"bSortable": true,


	/**
	 * Enable or disable the display of this column.
	 */
	"bVisible": true,


	/**
	 * Developer definable function that is called whenever a cell is created (Ajax source,
	 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	 * allowing you to modify the DOM element (add background colour for example) when the
	 * element is available.
	 */
	"fnCreatedCell": null,


	/**
	 * This property can be used to read data from any data source property,
	 * including deeply nested objects / properties. `data` can be given in a
	 * number of different ways which effect its behaviour:
	 *
	 * * `integer` - treated as an array index for the data source. This is the
	 *   default that DataTables uses (incrementally increased for each column).
	 * * `string` - read an object property from the data source. There are
	 *   three 'special' options that can be used in the string to alter how
	 *   DataTables reads the data from the source object:
	 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	 *      Javascript to read from nested objects, so to can the options
	 *      specified in `data`. For example: `browser.version` or
	 *      `browser.name`. If your object parameter name contains a period, use
	 *      `\\` to escape it - i.e. `first\\.name`.
	 *    * `[]` - Array notation. DataTables can automatically combine data
	 *      from and array source, joining the data with the characters provided
	 *      between the two brackets. For example: `name[, ]` would provide a
	 *      comma-space separated list from the source array. If no characters
	 *      are provided between the brackets, the original array source is
	 *      returned.
	 *    * `()` - Function notation. Adding `()` to the end of a parameter will
	 *      execute a function of the name given. For example: `browser()` for a
	 *      simple function on the data source, `browser.version()` for a
	 *      function in a nested property or even `browser().version` to get an
	 *      object property if the function called returns an object. Note that
	 *      function notation is recommended for use in `render` rather than
	 *      `data` as it is much simpler to use as a renderer.
	 * * `null` - use the original data source for the row rather than plucking
	 *   data directly from it. This action has effects on two other
	 *   initialisation options:
	 *    * `defaultContent` - When null is given as the `data` option and
	 *      `defaultContent` is specified for the column, the value defined by
	 *      `defaultContent` will be used for the cell.
	 *    * `render` - When null is used for the `data` option and the `render`
	 *      option is specified for the column, the whole data source for the
	 *      row is used for the renderer.
	 * * `function` - the function given will be executed whenever DataTables
	 *   needs to set or get the data for a cell in the column. The function
	 *   takes three parameters:
	 *    * Parameters:
	 *      * `{array|object}` The data source for the row
	 *      * `{string}` The type call data requested - this will be 'set' when
	 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
	 *        when gathering data. Note that when `undefined` is given for the
	 *        type DataTables expects to get the raw data for the object back<
	 *      * `{*}` Data to set when the second parameter is 'set'.
	 *    * Return:
	 *      * The return value from the function is not required when 'set' is
	 *        the type of call, but otherwise the return is what will be used
	 *        for the data requested.
	 *
	 * Note that `data` is a getter and setter option. If you just require
	 * formatting of data for output, you will likely want to use `render` which
	 * is simply a getter and thus simpler to use.
	 *
	 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
	 * name change reflects the flexibility of this property and is consistent
	 * with the naming of mRender. If 'mDataProp' is given, then it will still
	 * be used by DataTables, as it automatically maps the old name to the new
	 * if required.
	 */
	"mData": null,


	/**
	 * This property is the rendering partner to `data` and it is suggested that
	 * when you want to manipulate data for display (including filtering,
	 * sorting etc) without altering the underlying data for the table, use this
	 * property. `render` can be considered to be the the read only companion to
	 * `data` which is read / write (then as such more complex). Like `data`
	 * this option can be given in a number of different ways to effect its
	 * behaviour:
	 *
	 * * `integer` - treated as an array index for the data source. This is the
	 *   default that DataTables uses (incrementally increased for each column).
	 * * `string` - read an object property from the data source. There are
	 *   three 'special' options that can be used in the string to alter how
	 *   DataTables reads the data from the source object:
	 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	 *      Javascript to read from nested objects, so to can the options
	 *      specified in `data`. For example: `browser.version` or
	 *      `browser.name`. If your object parameter name contains a period, use
	 *      `\\` to escape it - i.e. `first\\.name`.
	 *    * `[]` - Array notation. DataTables can automatically combine data
	 *      from and array source, joining the data with the characters provided
	 *      between the two brackets. For example: `name[, ]` would provide a
	 *      comma-space separated list from the source array. If no characters
	 *      are provided between the brackets, the original array source is
	 *      returned.
	 *    * `()` - Function notation. Adding `()` to the end of a parameter will
	 *      execute a function of the name given. For example: `browser()` for a
	 *      simple function on the data source, `browser.version()` for a
	 *      function in a nested property or even `browser().version` to get an
	 *      object property if the function called returns an object.
	 * * `object` - use different data for the different data types requested by
	 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
	 *   of the object is the data type the property refers to and the value can
	 *   defined using an integer, string or function using the same rules as
	 *   `render` normally does. Note that an `_` option _must_ be specified.
	 *   This is the default value to use if you haven't specified a value for
	 *   the data type requested by DataTables.
	 * * `function` - the function given will be executed whenever DataTables
	 *   needs to set or get the data for a cell in the column. The function
	 *   takes three parameters:
	 *    * Parameters:
	 *      * {array|object} The data source for the row (based on `data`)
	 *      * {string} The type call data requested - this will be 'filter',
	 *        'display', 'type' or 'sort'.
	 *      * {array|object} The full data source for the row (not based on
	 *        `data`)
	 *    * Return:
	 *      * The return value from the function is what will be used for the
	 *        data requested.
	 */
	"mRender": null,


	/**
	 * Change the cell type created for the column - either TD cells or TH cells. This
	 * can be useful as TH cells have semantic meaning in the table body, allowing them
	 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
	 */
	"sCellType": "td",


	/**
	 * Class to give to each cell in this column.
	 */
	"sClass": "",

	/**
	 * When DataTables calculates the column widths to assign to each column,
	 * it finds the longest string in each column and then constructs a
	 * temporary table and reads the widths from that. The problem with this
	 * is that "mmm" is much wider then "iiii", but the latter is a longer
	 * string - thus the calculation can go wrong (doing it properly and putting
	 * it into an DOM object and measuring that is horribly(!) slow). Thus as
	 * a "work around" we provide this option. It will append its value to the
	 * text that is found to be the longest string for the column - i.e. padding.
	 * Generally you shouldn't need this!
	 */
	"sContentPadding": "",


	/**
	 * Allows a default value to be given for a column's data, and will be used
	 * whenever a null data source is encountered (this can be because `data`
	 * is set to null, or because the data source itself is null).
	 */
	"sDefaultContent": null,


	/**
	 * This parameter is only used in DataTables' server-side processing. It can
	 * be exceptionally useful to know what columns are being displayed on the
	 * client side, and to map these to database fields. When defined, the names
	 * also allow DataTables to reorder information from the server if it comes
	 * back in an unexpected order (i.e. if you switch your columns around on the
	 * client-side, your server-side code does not also need updating).
	 */
	"sName": "",


	/**
	 * Defines a data source type for the ordering which can be used to read
	 * real-time information from the table (updating the internally cached
	 * version) prior to ordering. This allows ordering to occur on user
	 * editable elements such as form inputs.
	 */
	"sSortDataType": "std",


	/**
	 * The title of this column.
	 */
	"sTitle": null,


	/**
	 * The type allows you to specify how the data for this column will be
	 * ordered. Four types (string, numeric, date and html (which will strip
	 * HTML tags before ordering)) are currently available. Note that only date
	 * formats understood by Javascript's Date() object will be accepted as type
	 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
	 * 'numeric', 'date' or 'html' (by default). Further types can be adding
	 * through plug-ins.
	 */
	"sType": null,


	/**
	 * Defining the width of the column, this parameter may take any CSS value
	 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
	 * been given a specific width through this interface ensuring that the table
	 * remains readable.
	 */
	"sWidth": null
};

_fnHungarianMap( DataTable.defaults.column );



/**
 * DataTables settings object - this holds all the information needed for a
 * given table, including configuration, data and current application of the
 * table options. DataTables does not have a single instance for each DataTable
 * with the settings attached to that instance, but rather instances of the
 * DataTable "class" are created on-the-fly as needed (typically by a
 * $().dataTable() call) and the settings object is then applied to that
 * instance.
 *
 * Note that this object is related to {@link DataTable.defaults} but this
 * one is the internal data store for DataTables's cache of columns. It should
 * NOT be manipulated outside of DataTables. Any configuration should be done
 * through the initialisation options.
 */
DataTable.models.oSettings = {
	/**
	 * Primary features of DataTables and their enablement state.
	 */
	"oFeatures": {

		/**
		 * Flag to say if DataTables should automatically try to calculate the
		 * optimum table and columns widths (true) or not (false).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bAutoWidth": null,

		/**
		 * Delay the creation of TR and TD elements until they are actually
		 * needed by a driven page draw. This can give a significant speed
		 * increase for Ajax source and Javascript source data, but makes no
		 * difference at all for DOM and server-side processing tables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bDeferRender": null,

		/**
		 * Enable filtering on the table or not. Note that if this is disabled
		 * then there is no filtering at all on the table, including fnFilter.
		 * To just remove the filtering input use sDom and remove the 'f' option.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bFilter": null,

		/**
		 * Used only for compatiblity with DT1
		 * @deprecated
		 */
		"bInfo": true,

		/**
		 * Used only for compatiblity with DT1
		 * @deprecated
		 */
		"bLengthChange": true,

		/**
		 * Pagination enabled or not. Note that if this is disabled then length
		 * changing must also be disabled.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bPaginate": null,

		/**
		 * Processing indicator enable flag whenever DataTables is enacting a
		 * user request - typically an Ajax request for server-side processing.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bProcessing": null,

		/**
		 * Server-side processing enabled flag - when enabled DataTables will
		 * get all data from the server for every draw - there is no filtering,
		 * sorting or paging done on the client-side.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bServerSide": null,

		/**
		 * Sorting enablement flag.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSort": null,

		/**
		 * Multi-column sorting
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSortMulti": null,

		/**
		 * Apply a class to the columns which are being sorted to provide a
		 * visual highlight or not. This can slow things down when enabled since
		 * there is a lot of DOM interaction.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSortClasses": null,

		/**
		 * State saving enablement flag.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bStateSave": null
	},


	/**
	 * Scrolling settings for a table.
	 */
	"oScroll": {
		/**
		 * When the table is shorter in height than sScrollY, collapse the
		 * table container down to the height of the table (when true).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bCollapse": null,

		/**
		 * Width of the scrollbar for the web-browser's platform. Calculated
		 * during table initialisation.
		 */
		"iBarWidth": 0,

		/**
		 * Viewport width for horizontal scrolling. Horizontal scrolling is
		 * disabled if an empty string.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"sX": null,

		/**
		 * Width to expand the table to when using x-scrolling. Typically you
		 * should not need to use this.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @deprecated
		 */
		"sXInner": null,

		/**
		 * Viewport height for vertical scrolling. Vertical scrolling is disabled
		 * if an empty string.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"sY": null
	},

	/**
	 * Language information for the table.
	 */
	"oLanguage": {
		/**
		 * Information callback function. See
		 * {@link DataTable.defaults.fnInfoCallback}
		 */
		"fnInfoCallback": null
	},

	/**
	 * Browser support parameters
	 */
	"oBrowser": {
		/**
		 * Determine if the vertical scrollbar is on the right or left of the
		 * scrolling container - needed for rtl language layout, although not
		 * all browsers move the scrollbar (Safari).
		 */
		"bScrollbarLeft": false,

		/**
		 * Browser scrollbar width
		 */
		"barWidth": 0
	},


	"ajax": null,


	/**
	 * Array referencing the nodes which are used for the features. The
	 * parameters of this object match what is allowed by sDom - i.e.
	 *   <ul>
	 *     <li>'l' - Length changing</li>
	 *     <li>'f' - Filtering input</li>
	 *     <li>'t' - The table!</li>
	 *     <li>'i' - Information</li>
	 *     <li>'p' - Pagination</li>
	 *     <li>'r' - pRocessing</li>
	 *   </ul>
	 */
	"aanFeatures": [],

	/**
	 * Store data information - see {@link DataTable.models.oRow} for detailed
	 * information.
	 */
	"aoData": [],

	/**
	 * Array of indexes which are in the current display (after filtering etc)
	 */
	"aiDisplay": [],

	/**
	 * Array of indexes for display - no filtering
	 */
	"aiDisplayMaster": [],

	/**
	 * Map of row ids to data indexes
	 */
	"aIds": {},

	/**
	 * Store information about each column that is in use
	 */
	"aoColumns": [],

	/**
	 * Store information about the table's header
	 */
	"aoHeader": [],

	/**
	 * Store information about the table's footer
	 */
	"aoFooter": [],

	/**
	 * Store the applied global search information in case we want to force a
	 * research or compare the old search to a new one.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"oPreviousSearch": {},

	/**
	 * Store for named searches
	 */
	searchFixed: {},

	/**
	 * Store the applied search for each column - see
	 * {@link DataTable.models.oSearch} for the format that is used for the
	 * filtering information for each column.
	 */
	"aoPreSearchCols": [],

	/**
	 * Sorting that is applied to the table. Note that the inner arrays are
	 * used in the following manner:
	 * <ul>
	 *   <li>Index 0 - column number</li>
	 *   <li>Index 1 - current sorting direction</li>
	 * </ul>
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aaSorting": null,

	/**
	 * Sorting that is always applied to the table (i.e. prefixed in front of
	 * aaSorting).
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aaSortingFixed": [],

	/**
	 * If restoring a table - we should restore its width
	 */
	"sDestroyWidth": 0,

	/**
	 * Callback functions array for every time a row is inserted (i.e. on a draw).
	 */
	"aoRowCallback": [],

	/**
	 * Callback functions for the header on each draw.
	 */
	"aoHeaderCallback": [],

	/**
	 * Callback function for the footer on each draw.
	 */
	"aoFooterCallback": [],

	/**
	 * Array of callback functions for draw callback functions
	 */
	"aoDrawCallback": [],

	/**
	 * Array of callback functions for row created function
	 */
	"aoRowCreatedCallback": [],

	/**
	 * Callback functions for just before the table is redrawn. A return of
	 * false will be used to cancel the draw.
	 */
	"aoPreDrawCallback": [],

	/**
	 * Callback functions for when the table has been initialised.
	 */
	"aoInitComplete": [],


	/**
	 * Callbacks for modifying the settings to be stored for state saving, prior to
	 * saving state.
	 */
	"aoStateSaveParams": [],

	/**
	 * Callbacks for modifying the settings that have been stored for state saving
	 * prior to using the stored values to restore the state.
	 */
	"aoStateLoadParams": [],

	/**
	 * Callbacks for operating on the settings object once the saved state has been
	 * loaded
	 */
	"aoStateLoaded": [],

	/**
	 * Cache the table ID for quick access
	 */
	"sTableId": "",

	/**
	 * The TABLE node for the main table
	 */
	"nTable": null,

	/**
	 * Permanent ref to the thead element
	 */
	"nTHead": null,

	/**
	 * Permanent ref to the tfoot element - if it exists
	 */
	"nTFoot": null,

	/**
	 * Permanent ref to the tbody element
	 */
	"nTBody": null,

	/**
	 * Cache the wrapper node (contains all DataTables controlled elements)
	 */
	"nTableWrapper": null,

	/**
	 * Indicate if all required information has been read in
	 */
	"bInitialised": false,

	/**
	 * Information about open rows. Each object in the array has the parameters
	 * 'nTr' and 'nParent'
	 */
	"aoOpenRows": [],

	/**
	 * Dictate the positioning of DataTables' control elements - see
	 * {@link DataTable.model.oInit.sDom}.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sDom": null,

	/**
	 * Search delay (in mS)
	 */
	"searchDelay": null,

	/**
	 * Which type of pagination should be used.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sPaginationType": "two_button",

	/**
	 * Number of paging controls on the page. Only used for backwards compatibility
	 */
	pagingControls: 0,

	/**
	 * The state duration (for `stateSave`) in seconds.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"iStateDuration": 0,

	/**
	 * Array of callback functions for state saving. Each array element is an
	 * object with the following parameters:
	 *   <ul>
	 *     <li>function:fn - function to call. Takes two parameters, oSettings
	 *       and the JSON string to save that has been thus far created. Returns
	 *       a JSON string to be inserted into a json object
	 *       (i.e. '"param": [ 0, 1, 2]')</li>
	 *     <li>string:sName - name of callback</li>
	 *   </ul>
	 */
	"aoStateSave": [],

	/**
	 * Array of callback functions for state loading. Each array element is an
	 * object with the following parameters:
	 *   <ul>
	 *     <li>function:fn - function to call. Takes two parameters, oSettings
	 *       and the object stored. May return false to cancel state loading</li>
	 *     <li>string:sName - name of callback</li>
	 *   </ul>
	 */
	"aoStateLoad": [],

	/**
	 * State that was saved. Useful for back reference
	 */
	"oSavedState": null,

	/**
	 * State that was loaded. Useful for back reference
	 */
	"oLoadedState": null,

	/**
	 * Note if draw should be blocked while getting data
	 */
	"bAjaxDataGet": true,

	/**
	 * The last jQuery XHR object that was used for server-side data gathering.
	 * This can be used for working with the XHR information in one of the
	 * callbacks
	 */
	"jqXHR": null,

	/**
	 * JSON returned from the server in the last Ajax request
	 */
	"json": undefined,

	/**
	 * Data submitted as part of the last Ajax request
	 */
	"oAjaxData": undefined,

	/**
	 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
	 * required).
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sServerMethod": null,

	/**
	 * Format numbers for display.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"fnFormatNumber": null,

	/**
	 * List of options that can be used for the user selectable length menu.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aLengthMenu": null,

	/**
	 * Counter for the draws that the table does. Also used as a tracker for
	 * server-side processing
	 */
	"iDraw": 0,

	/**
	 * Indicate if a redraw is being done - useful for Ajax
	 */
	"bDrawing": false,

	/**
	 * Draw index (iDraw) of the last error when parsing the returned data
	 */
	"iDrawError": -1,

	/**
	 * Paging display length
	 */
	"_iDisplayLength": 10,

	/**
	 * Paging start point - aiDisplay index
	 */
	"_iDisplayStart": 0,

	/**
	 * Server-side processing - number of records in the result set
	 * (i.e. before filtering), Use fnRecordsTotal rather than
	 * this property to get the value of the number of records, regardless of
	 * the server-side processing setting.
	 */
	"_iRecordsTotal": 0,

	/**
	 * Server-side processing - number of records in the current display set
	 * (i.e. after filtering). Use fnRecordsDisplay rather than
	 * this property to get the value of the number of records, regardless of
	 * the server-side processing setting.
	 */
	"_iRecordsDisplay": 0,

	/**
	 * The classes to use for the table
	 */
	"oClasses": {},

	/**
	 * Flag attached to the settings object so you can check in the draw
	 * callback if filtering has been done in the draw. Deprecated in favour of
	 * events.
	 *  @deprecated
	 */
	"bFiltered": false,

	/**
	 * Flag attached to the settings object so you can check in the draw
	 * callback if sorting has been done in the draw. Deprecated in favour of
	 * events.
	 *  @deprecated
	 */
	"bSorted": false,

	/**
	 * Indicate that if multiple rows are in the header and there is more than
	 * one unique cell per column, if the top one (true) or bottom one (false)
	 * should be used for sorting / title by DataTables.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"bSortCellsTop": null,

	/**
	 * Initialisation object that is used for the table
	 */
	"oInit": null,

	/**
	 * Destroy callback functions - for plug-ins to attach themselves to the
	 * destroy so they can clean up markup and events.
	 */
	"aoDestroyCallback": [],


	/**
	 * Get the number of records in the current record set, before filtering
	 */
	"fnRecordsTotal": function ()
	{
		return _fnDataSource( this ) == 'ssp' ?
			this._iRecordsTotal * 1 :
			this.aiDisplayMaster.length;
	},

	/**
	 * Get the number of records in the current record set, after filtering
	 */
	"fnRecordsDisplay": function ()
	{
		return _fnDataSource( this ) == 'ssp' ?
			this._iRecordsDisplay * 1 :
			this.aiDisplay.length;
	},

	/**
	 * Get the display end point - aiDisplay index
	 */
	"fnDisplayEnd": function ()
	{
		var
			len      = this._iDisplayLength,
			start    = this._iDisplayStart,
			calc     = start + len,
			records  = this.aiDisplay.length,
			features = this.oFeatures,
			paginate = features.bPaginate;

		if ( features.bServerSide ) {
			return paginate === false || len === -1 ?
				start + records :
				Math.min( start+len, this._iRecordsDisplay );
		}
		else {
			return ! paginate || calc>records || len===-1 ?
				records :
				calc;
		}
	},

	/**
	 * The DataTables object for this table
	 */
	"oInstance": null,

	/**
	 * Unique identifier for each instance of the DataTables object. If there
	 * is an ID on the table node, then it takes that value, otherwise an
	 * incrementing internal counter is used.
	 */
	"sInstance": null,

	/**
	 * tabindex attribute value that is added to DataTables control elements, allowing
	 * keyboard navigation of the table and its controls.
	 */
	"iTabIndex": 0,

	/**
	 * DIV container for the footer scrolling table if scrolling
	 */
	"nScrollHead": null,

	/**
	 * DIV container for the footer scrolling table if scrolling
	 */
	"nScrollFoot": null,

	/**
	 * Last applied sort
	 */
	"aLastSort": [],

	/**
	 * Stored plug-in instances
	 */
	"oPlugins": {},

	/**
	 * Function used to get a row's id from the row's data
	 */
	"rowIdFn": null,

	/**
	 * Data location where to store a row's id
	 */
	"rowId": null,

	caption: '',

	captionNode: null,

	colgroup: null,

	/** Delay loading of data */
	deferLoading: null,

	/** Allow auto type detection */
	typeDetect: true,

	/** ResizeObserver for the container div */
	resizeObserver: null,

	/** Keep a record of the last size of the container, so we can skip duplicates */
	containerWidth: -1
};

/**
 * Extension object for DataTables that is used to provide all extension
 * options.
 *
 * Note that the `DataTable.ext` object is available through
 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
 *  @namespace
 *  @extends DataTable.models.ext
 */


var extPagination = DataTable.ext.pager;

// Paging buttons configuration
$.extend( extPagination, {
	simple: function () {
		return [ 'previous', 'next' ];
	},

	full: function () {
		return [ 'first', 'previous', 'next', 'last' ];
	},

	numbers: function () {
		return [ 'numbers' ];
	},

	simple_numbers: function () {
		return [ 'previous', 'numbers', 'next' ];
	},

	full_numbers: function () {
		return [ 'first', 'previous', 'numbers', 'next', 'last' ];
	},

	first_last: function () {
		return ['first', 'last'];
	},

	first_last_numbers: function () {
		return ['first', 'numbers', 'last'];
	},

	// For testing and plug-ins to use
	_numbers: _pagingNumbers,

	// Number of number buttons - legacy, use `numbers` option for paging feature
	numbers_length: 7
} );


$.extend( true, DataTable.ext.renderer, {
	pagingButton: {
		_: function (settings, buttonType, content, active, disabled) {
			var classes = settings.oClasses.paging;
			var btnClasses = [classes.button];
			var btn;

			if (active) {
				btnClasses.push(classes.active);
			}

			if (disabled) {
				btnClasses.push(classes.disabled)
			}

			if (buttonType === 'ellipsis') {
				btn = $('<span class="ellipsis"></span>').html(content)[0];
			}
			else {
				btn = $('<button>', {
					class: btnClasses.join(' '),
					role: 'link',
					type: 'button'
				}).html(content);
			}

			return {
				display: btn,
				clicker: btn
			}
		}
	},

	pagingContainer: {
		_: function (settings, buttons) {
			// No wrapping element - just append directly to the host
			return buttons;
		}
	}
} );

// Common function to remove new lines, strip HTML and diacritic control
var _filterString = function (stripHtml, normalize) {
	return function (str) {
		if (_empty(str) || typeof str !== 'string') {
			return str;
		}

		str = str.replace( _re_new_lines, " " );

		if (stripHtml) {
			str = _stripHtml(str);
		}

		if (normalize) {
			str = _normalize(str, false);
		}

		return str;
	};
}

/*
 * Public helper functions. These aren't used internally by DataTables, or
 * called by any of the options passed into DataTables, but they can be used
 * externally by developers working with DataTables. They are helper functions
 * to make working with DataTables a little bit easier.
 */

/**
 * Common logic for moment, luxon or a date action.
 *
 * Happens after __mldObj, so don't need to call `resolveWindowsLibs` again
 */
function __mld( dtLib, momentFn, luxonFn, dateFn, arg1 ) {
	if (__moment) {
		return dtLib[momentFn]( arg1 );
	}
	else if (__luxon) {
		return dtLib[luxonFn]( arg1 );
	}
	
	return dateFn ? dtLib[dateFn]( arg1 ) : dtLib;
}


var __mlWarning = false;
var __luxon; // Can be assigned in DateTable.use()
var __moment; // Can be assigned in DateTable.use()

/**
 * 
 */
function resolveWindowLibs() {
	if (window.luxon && ! __luxon) {
		__luxon = window.luxon;
	}
	
	if (window.moment && ! __moment) {
		__moment = window.moment;
	}
}

function __mldObj (d, format, locale) {
	var dt;

	resolveWindowLibs();

	if (__moment) {
		dt = __moment.utc( d, format, locale, true );

		if (! dt.isValid()) {
			return null;
		}
	}
	else if (__luxon) {
		dt = format && typeof d === 'string'
			? __luxon.DateTime.fromFormat( d, format )
			: __luxon.DateTime.fromISO( d );

		if (! dt.isValid) {
			return null;
		}

		dt = dt.setLocale(locale);
	}
	else if (! format) {
		// No format given, must be ISO
		dt = new Date(d);
	}
	else {
		if (! __mlWarning) {
			alert('DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17');
		}

		__mlWarning = true;
	}

	return dt;
}

// Wrapper for date, datetime and time which all operate the same way with the exception of
// the output string for auto locale support
function __mlHelper (localeString) {
	return function ( from, to, locale, def ) {
		// Luxon and Moment support
		// Argument shifting
		if ( arguments.length === 0 ) {
			locale = 'en';
			to = null; // means toLocaleString
			from = null; // means iso8601
		}
		else if ( arguments.length === 1 ) {
			locale = 'en';
			to = from;
			from = null;
		}
		else if ( arguments.length === 2 ) {
			locale = to;
			to = from;
			from = null;
		}

		var typeName = 'datetime' + (to ? '-' + to : '');

		// Add type detection and sorting specific to this date format - we need to be able to identify
		// date type columns as such, rather than as numbers in extensions. Hence the need for this.
		if (! DataTable.ext.type.order[typeName + '-pre']) {
			DataTable.type(typeName, {
				detect: function (d) {
					// The renderer will give the value to type detect as the type!
					return d === typeName ? typeName : false;
				},
				order: {
					pre: function (d) {
						// The renderer gives us Moment, Luxon or Date obects for the sorting, all of which have a
						// `valueOf` which gives milliseconds epoch
						return d.valueOf();
					}
				},
				className: 'dt-right'
			});
		}
	
		return function ( d, type ) {
			// Allow for a default value
			if (d === null || d === undefined) {
				if (def === '--now') {
					// We treat everything as UTC further down, so no changes are
					// made, as such need to get the local date / time as if it were
					// UTC
					var local = new Date();
					d = new Date( Date.UTC(
						local.getFullYear(), local.getMonth(), local.getDate(),
						local.getHours(), local.getMinutes(), local.getSeconds()
					) );
				}
				else {
					d = '';
				}
			}

			if (type === 'type') {
				// Typing uses the type name for fast matching
				return typeName;
			}

			if (d === '') {
				return type !== 'sort'
					? ''
					: __mldObj('0000-01-01 00:00:00', null, locale);
			}

			// Shortcut. If `from` and `to` are the same, we are using the renderer to
			// format for ordering, not display - its already in the display format.
			if ( to !== null && from === to && type !== 'sort' && type !== 'type' && ! (d instanceof Date) ) {
				return d;
			}

			var dt = __mldObj(d, from, locale);

			if (dt === null) {
				return d;
			}

			if (type === 'sort') {
				return dt;
			}
			
			var formatted = to === null
				? __mld(dt, 'toDate', 'toJSDate', '')[localeString]()
				: __mld(dt, 'format', 'toFormat', 'toISOString', to);

			// XSS protection
			return type === 'display' ?
				_escapeHtml( formatted ) :
				formatted;
		};
	}
}

// Based on locale, determine standard number formatting
// Fallback for legacy browsers is US English
var __thousands = ',';
var __decimal = '.';

if (window.Intl !== undefined) {
	try {
		var num = new Intl.NumberFormat().formatToParts(100000.1);
	
		for (var i=0 ; i<num.length ; i++) {
			if (num[i].type === 'group') {
				__thousands = num[i].value;
			}
			else if (num[i].type === 'decimal') {
				__decimal = num[i].value;
			}
		}
	}
	catch (e) {
		// noop
	}
}

// Formatted date time detection - use by declaring the formats you are going to use
DataTable.datetime = function ( format, locale ) {
	var typeName = 'datetime-' + format;

	if (! locale) {
		locale = 'en';
	}

	if (! DataTable.ext.type.order[typeName]) {
		DataTable.type(typeName, {
			detect: function (d) {
				var dt = __mldObj(d, format, locale);
				return d === '' || dt ? typeName : false;
			},
			order: {
				pre: function (d) {
					return __mldObj(d, format, locale) || 0;
				}
			},
			className: 'dt-right'
		});
	}
}

/**
 * Helpers for `columns.render`.
 *
 * The options defined here can be used with the `columns.render` initialisation
 * option to provide a display renderer. The following functions are defined:
 *
 * * `moment` - Uses the MomentJS library to convert from a given format into another.
 * This renderer has three overloads:
 *   * 1 parameter:
 *     * `string` - Format to convert to (assumes input is ISO8601 and locale is `en`)
 *   * 2 parameters:
 *     * `string` - Format to convert from
 *     * `string` - Format to convert to. Assumes `en` locale
 *   * 3 parameters:
 *     * `string` - Format to convert from
 *     * `string` - Format to convert to
 *     * `string` - Locale
 * * `number` - Will format numeric data (defined by `columns.data`) for
 *   display, retaining the original unformatted data for sorting and filtering.
 *   It takes 5 parameters:
 *   * `string` - Thousands grouping separator
 *   * `string` - Decimal point indicator
 *   * `integer` - Number of decimal points to show
 *   * `string` (optional) - Prefix.
 *   * `string` (optional) - Postfix (/suffix).
 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
 *   parameters.
 *
 * @example
 *   // Column definition using the number renderer
 *   {
 *     data: "salary",
 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
 *   }
 *
 * @namespace
 */
DataTable.render = {
	date: __mlHelper('toLocaleDateString'),
	datetime: __mlHelper('toLocaleString'),
	time: __mlHelper('toLocaleTimeString'),
	number: function ( thousands, decimal, precision, prefix, postfix ) {
		// Auto locale detection
		if (thousands === null || thousands === undefined) {
			thousands = __thousands;
		}

		if (decimal === null || decimal === undefined) {
			decimal = __decimal;
		}

		return {
			display: function ( d ) {
				if ( typeof d !== 'number' && typeof d !== 'string' ) {
					return d;
				}

				if (d === '' || d === null) {
					return d;
				}

				var negative = d < 0 ? '-' : '';
				var flo = parseFloat( d );
				var abs = Math.abs(flo);

				// Scientific notation for large and small numbers
				if (abs >= 100000000000 || (abs < 0.0001 && abs !== 0) ) {
					var exp = flo.toExponential(precision).split(/e\+?/);
					return exp[0] + ' x 10<sup>' + exp[1] + '</sup>';
				}

				// If NaN then there isn't much formatting that we can do - just
				// return immediately, escaping any HTML (this was supposed to
				// be a number after all)
				if ( isNaN( flo ) ) {
					return _escapeHtml( d );
				}

				flo = flo.toFixed( precision );
				d = Math.abs( flo );

				var intPart = parseInt( d, 10 );
				var floatPart = precision ?
					decimal+(d - intPart).toFixed( precision ).substring( 2 ):
					'';

				// If zero, then can't have a negative prefix
				if (intPart === 0 && parseFloat(floatPart) === 0) {
					negative = '';
				}

				return negative + (prefix||'') +
					intPart.toString().replace(
						/\B(?=(\d{3})+(?!\d))/g, thousands
					) +
					floatPart +
					(postfix||'');
			}
		};
	},

	text: function () {
		return {
			display: _escapeHtml,
			filter: _escapeHtml
		};
	}
};


var _extTypes = DataTable.ext.type;

// Get / set type
DataTable.type = function (name, prop, val) {
	if (! prop) {
		return {
			className: _extTypes.className[name],
			detect: _extTypes.detect.find(function (fn) {
				return fn._name === name;
			}),
			order: {
				pre: _extTypes.order[name + '-pre'],
				asc: _extTypes.order[name + '-asc'],
				desc: _extTypes.order[name + '-desc']
			},
			render: _extTypes.render[name],
			search: _extTypes.search[name]
		};
	}

	var setProp = function(prop, propVal) {
		_extTypes[prop][name] = propVal;
	};
	var setDetect = function (detect) {
		// `detect` can be a function or an object - we set a name
		// property for either - that is used for the detection
		Object.defineProperty(detect, "_name", {value: name});

		var idx = _extTypes.detect.findIndex(function (item) {
			return item._name === name;
		});

		if (idx === -1) {
			_extTypes.detect.unshift(detect);
		}
		else {
			_extTypes.detect.splice(idx, 1, detect);
		}
	};
	var setOrder = function (obj) {
		_extTypes.order[name + '-pre'] = obj.pre; // can be undefined
		_extTypes.order[name + '-asc'] = obj.asc; // can be undefined
		_extTypes.order[name + '-desc'] = obj.desc; // can be undefined
	};

	// prop is optional
	if (val === undefined) {
		val = prop;
		prop = null;
	}

	if (prop === 'className') {
		setProp('className', val);
	}
	else if (prop === 'detect') {
		setDetect(val);
	}
	else if (prop === 'order') {
		setOrder(val);
	}
	else if (prop === 'render') {
		setProp('render', val);
	}
	else if (prop === 'search') {
		setProp('search', val);
	}
	else if (! prop) {
		if (val.className) {
			setProp('className', val.className);
		}

		if (val.detect !== undefined) {
			setDetect(val.detect);
		}

		if (val.order) {
			setOrder(val.order);
		}

		if (val.render !== undefined) {
			setProp('render', val.render);
		}

		if (val.search !== undefined) {
			setProp('search', val.search);
		}
	}
}

// Get a list of types
DataTable.types = function () {
	return _extTypes.detect.map(function (fn) {
		return fn._name;
	});
};

var __diacriticSort = function (a, b) {
	a = a !== null && a !== undefined ? a.toString().toLowerCase() : '';
	b = b !== null && b !== undefined ? b.toString().toLowerCase() : '';

	// Checked for `navigator.languages` support in `oneOf` so this code can't execute in old
	// Safari and thus can disable this check
	// eslint-disable-next-line compat/compat
	return a.localeCompare(b, navigator.languages[0] || navigator.language, {
		numeric: true,
		ignorePunctuation: true,
	});
}

var __diacriticHtmlSort = function (a, b) {
	a = _stripHtml(a);
	b = _stripHtml(b);

	return __diacriticSort(a, b);
}

//
// Built in data types
//

DataTable.type('string', {
	detect: function () {
		return 'string';
	},
	order: {
		pre: function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) && typeof a !== 'boolean' ?
				'' :
				typeof a === 'string' ?
					a.toLowerCase() :
					! a.toString ?
						'' :
						a.toString();
		}
	},
	search: _filterString(false, true)
});

DataTable.type('string-utf8', {
	detect: {
		allOf: function ( d ) {
			return true;
		},
		oneOf: function ( d ) {
			// At least one data point must contain a non-ASCII character
			// This line will also check if navigator.languages is supported or not. If not (Safari 10.0-)
			// this data type won't be supported.
			// eslint-disable-next-line compat/compat
			return ! _empty( d ) && navigator.languages && typeof d === 'string' && d.match(/[^\x00-\x7F]/);
		}
	},
	order: {
		asc: __diacriticSort,
		desc: function (a, b) {
			return __diacriticSort(a, b) * -1;
		}
	},
	search: _filterString(false, true)
});


DataTable.type('html', {
	detect: {
		allOf: function ( d ) {
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1);
		},
		oneOf: function ( d ) {
			// At least one data point must contain a `<`
			return ! _empty( d ) && typeof d === 'string' && d.indexOf('<') !== -1;
		}
	},
	order: {
		pre: function ( a ) {
			return _empty(a) ?
				'' :
				a.replace ?
					_stripHtml(a).trim().toLowerCase() :
					a+'';
		}
	},
	search: _filterString(true, true)
});


DataTable.type('html-utf8', {
	detect: {
		allOf: function ( d ) {
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1);
		},
		oneOf: function ( d ) {
			// At least one data point must contain a `<` and a non-ASCII character
			// eslint-disable-next-line compat/compat
			return navigator.languages &&
				! _empty( d ) &&
				typeof d === 'string' &&
				d.indexOf('<') !== -1 &&
				typeof d === 'string' && d.match(/[^\x00-\x7F]/);
		}
	},
	order: {
		asc: __diacriticHtmlSort,
		desc: function (a, b) {
			return __diacriticHtmlSort(a, b) * -1;
		}
	},
	search: _filterString(true, true)
});


DataTable.type('date', {
	className: 'dt-type-date',
	detect: {
		allOf: function ( d ) {
			// V8 tries _very_ hard to make a string passed into `Date.parse()`
			// valid, so we need to use a regex to restrict date formats. Use a
			// plug-in for anything other than ISO8601 style strings
			if ( d && !(d instanceof Date) && ! _re_date.test(d) ) {
				return null;
			}
			var parsed = Date.parse(d);
			return (parsed !== null && !isNaN(parsed)) || _empty(d);
		},
		oneOf: function ( d ) {
			// At least one entry must be a date or a string with a date
			return (d instanceof Date) || (typeof d === 'string' && _re_date.test(d));
		}
	},
	order: {
		pre: function ( d ) {
			var ts = Date.parse( d );
			return isNaN(ts) ? -Infinity : ts;
		}
	}
});


DataTable.type('html-num-fmt', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true, false );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true, false );
		}
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_html, _re_formatted_numeric );
		}
	},
	search: _filterString(true, true)
});


DataTable.type('html-num', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, false, true );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, false, false );
		}
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_html );
		}
	},
	search: _filterString(true, true)
});


DataTable.type('num-fmt', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true, true );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true, false );
		}
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_formatted_numeric );
		}
	}
});


DataTable.type('num', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, false, true );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, false, false );
		}
	},
	order: {
		pre: function (d, s) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp );
		}
	}
});




var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
	if ( d !== 0 && (!d || d === '-') ) {
		return -Infinity;
	}
	
	var type = typeof d;

	if (type === 'number' || type === 'bigint') {
		return d;
	}

	// If a decimal place other than `.` is used, it needs to be given to the
	// function so we can detect it and replace with a `.` which is the only
	// decimal place Javascript recognises - it is not locale aware.
	if ( decimalPlace ) {
		d = _numToDecimal( d, decimalPlace );
	}

	if ( d.replace ) {
		if ( re1 ) {
			d = d.replace( re1, '' );
		}

		if ( re2 ) {
			d = d.replace( re2, '' );
		}
	}

	return d * 1;
};


$.extend( true, DataTable.ext.renderer, {
	footer: {
		_: function ( settings, cell, classes ) {
			cell.addClass(classes.tfoot.cell);
		}
	},

	header: {
		_: function ( settings, cell, classes ) {
			cell.addClass(classes.thead.cell);

			if (! settings.oFeatures.bSort) {
				cell.addClass(classes.order.none);
			}

			var legacyTop = settings.bSortCellsTop;
			var headerRows = cell.closest('thead').find('tr');
			var rowIdx = cell.parent().index();

			// Conditions to not apply the ordering icons
			if (
				// Cells and rows which have the attribute to disable the icons
				cell.attr('data-dt-order') === 'disable' ||
				cell.parent().attr('data-dt-order') === 'disable' ||

				// Legacy support for `orderCellsTop`. If it is set, then cells
				// which are not in the top or bottom row of the header (depending
				// on the value) do not get the sorting classes applied to them
				(legacyTop === true && rowIdx !== 0) ||
				(legacyTop === false && rowIdx !== headerRows.length - 1)
			) {
				return;
			}

			// No additional mark-up required
			// Attach a sort listener to update on sort - note that using the
			// `DT` namespace will allow the event to be removed automatically
			// on destroy, while the `dt` namespaced event is the one we are
			// listening for
			$(settings.nTable).on( 'order.dt.DT column-visibility.dt.DT', function ( e, ctx ) {
				if ( settings !== ctx ) { // need to check this this is the host
					return;               // table, not a nested one
				}

				var sorting = ctx.sortDetails;

				if (! sorting) {
					return;
				}

				var i;
				var orderClasses = classes.order;
				var columns = ctx.api.columns( cell );
				var col = settings.aoColumns[columns.flatten()[0]];
				var orderable = columns.orderable().includes(true);
				var ariaType = '';
				var indexes = columns.indexes();
				var sortDirs = columns.orderable(true).flatten();
				var orderedColumns = _pluck(sorting, 'col');
				var tabIndex = settings.iTabIndex;

				cell
					.removeClass(
						orderClasses.isAsc +' '+
						orderClasses.isDesc
					)
					.toggleClass( orderClasses.none, ! orderable )
					.toggleClass( orderClasses.canAsc, orderable && sortDirs.includes('asc') )
					.toggleClass( orderClasses.canDesc, orderable && sortDirs.includes('desc') );

				// Determine if all of the columns that this cell covers are included in the
				// current ordering
				var isOrdering = true;
				
				for (i=0; i<indexes.length; i++) {
					if (! orderedColumns.includes(indexes[i])) {
						isOrdering = false;
					}
				}

				if ( isOrdering ) {
					// Get the ordering direction for the columns under this cell
					// Note that it is possible for a cell to be asc and desc sorting
					// (column spanning cells)
					var orderDirs = columns.order();

					cell.addClass(
						orderDirs.includes('asc') ? orderClasses.isAsc : '' +
						orderDirs.includes('desc') ? orderClasses.isDesc : ''
					);
				}

				// Find the first visible column that has ordering applied to it - it get's
				// the aria information, as the ARIA spec says that only one column should
				// be marked with aria-sort
				var firstVis = -1; // column index

				for (i=0; i<orderedColumns.length; i++) {
					if (settings.aoColumns[orderedColumns[i]].bVisible) {
						firstVis = orderedColumns[i];
						break;
					}
				}

				if (indexes[0] == firstVis) {
					var firstSort = sorting[0];
					var sortOrder = col.asSorting;

					cell.attr('aria-sort', firstSort.dir === 'asc' ? 'ascending' : 'descending');

					// Determine if the next click will remove sorting or change the sort
					ariaType = ! sortOrder[firstSort.index + 1] ? 'Remove' : 'Reverse';
				}
				else {
					cell.removeAttr('aria-sort');
				}

				// Make the headers tab-able for keyboard navigation
				if (orderable) {
					var orderSpan = cell.find('.dt-column-order');
					
					orderSpan
						.attr('role', 'button')
						.attr('aria-label', orderable
							? col.ariaTitle + ctx.api.i18n('oAria.orderable' + ariaType)
							: col.ariaTitle
						);

					if (tabIndex !== -1) {
						orderSpan.attr('tabindex', tabIndex);
					}
				}
			} );
		}
	},

	layout: {
		_: function ( settings, container, items ) {
			var classes = settings.oClasses.layout;
			var row = $('<div/>')
				.attr('id', items.id || null)
				.addClass(items.className || classes.row)
				.appendTo( container );

			DataTable.ext.renderer.layout._forLayoutRow(items, function (key, val) {
				if (key === 'id' || key === 'className') {
					return;
				}

				var klass = '';

				if (val.table) {
					row.addClass(classes.tableRow);
					klass += classes.tableCell + ' ';
				}

				if (key === 'start') {
					klass += classes.start;
				}
				else if (key === 'end') {
					klass += classes.end;
				}
				else {
					klass += classes.full;
				}

				$('<div/>')
					.attr({
						id: val.id || null,
						"class": val.className
							? val.className
							: classes.cell + ' ' + klass
					})
					.append( val.contents )
					.appendTo( row );
			});
		},

		// Shared for use by the styling frameworks
		_forLayoutRow: function (items, fn) {
			// As we are inserting dom elements, we need start / end in a
			// specific order, this function is used for sorting the layout
			// keys.
			var layoutEnum = function (x) {
				switch (x) {
					case '': return 0;
					case 'start': return 1;
					case 'end': return 2;
					default: return 3;
				}
			};

			Object
				.keys(items)
				.sort(function (a, b) {
					return layoutEnum(a) - layoutEnum(b);
				})
				.forEach(function (key) {
					fn(key, items[key]);
				});
		}
	}
} );


DataTable.feature = {};

// Third parameter is internal only!
DataTable.feature.register = function ( name, cb, legacy ) {
	DataTable.ext.features[ name ] = cb;

	if (legacy) {
		_ext.feature.push({
			cFeature: legacy,
			fnInit: cb
		});
	}
};

function _divProp(el, prop, val) {
	if (val) {
		el[prop] = val;
	}
}

DataTable.feature.register( 'div', function ( settings, opts ) {
	var n = $('<div>')[0];

	if (opts) {
		_divProp(n, 'className', opts.className);
		_divProp(n, 'id', opts.id);
		_divProp(n, 'innerHTML', opts.html);
		_divProp(n, 'textContent', opts.text);
	}

	return n;
} );

DataTable.feature.register( 'info', function ( settings, opts ) {
	// For compatibility with the legacy `info` top level option
	if (! settings.oFeatures.bInfo) {
		return null;
	}

	var
		lang  = settings.oLanguage,
		tid = settings.sTableId,
		n = $('<div/>', {
			'class': settings.oClasses.info.container,
		} );

	opts = $.extend({
		callback: lang.fnInfoCallback,
		empty: lang.sInfoEmpty,
		postfix: lang.sInfoPostFix,
		search: lang.sInfoFiltered,
		text: lang.sInfo,
	}, opts);


	// Update display on each draw
	settings.aoDrawCallback.push(function (s) {
		_fnUpdateInfo(s, opts, n);
	});

	// For the first info display in the table, we add a callback and aria information.
	if (! settings._infoEl) {
		n.attr({
			'aria-live': 'polite',
			id: tid+'_info',
			role: 'status'
		});

		// Table is described by our info div
		$(settings.nTable).attr( 'aria-describedby', tid+'_info' );

		settings._infoEl = n;
	}

	return n;
}, 'i' );

/**
 * Update the information elements in the display
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnUpdateInfo ( settings, opts, node )
{
	var
		start = settings._iDisplayStart+1,
		end   = settings.fnDisplayEnd(),
		max   = settings.fnRecordsTotal(),
		total = settings.fnRecordsDisplay(),
		out   = total
			? opts.text
			: opts.empty;

	if ( total !== max ) {
		// Record set after filtering
		out += ' ' + opts.search;
	}

	// Convert the macros
	out += opts.postfix;
	out = _fnMacros( settings, out );

	if ( opts.callback ) {
		out = opts.callback.call( settings.oInstance,
			settings, start, end, max, total, out
		);
	}

	node.html( out );

	_fnCallbackFire(settings, null, 'info', [settings, node[0], out]);
}

var __searchCounter = 0;

// opts
// - text
// - placeholder
DataTable.feature.register( 'search', function ( settings, opts ) {
	// Don't show the input if filtering isn't available on the table
	if (! settings.oFeatures.bFilter) {
		return null;
	}

	var classes = settings.oClasses.search;
	var tableId = settings.sTableId;
	var language = settings.oLanguage;
	var previousSearch = settings.oPreviousSearch;
	var input = '<input type="search" class="'+classes.input+'"/>';

	opts = $.extend({
		placeholder: language.sSearchPlaceholder,
		processing: false,
		text: language.sSearch
	}, opts);

	// The _INPUT_ is optional - is appended if not present
	if (opts.text.indexOf('_INPUT_') === -1) {
		opts.text += '_INPUT_';
	}

	opts.text = _fnMacros(settings, opts.text);

	// We can put the <input> outside of the label if it is at the start or end
	// which helps improve accessability (not all screen readers like implicit
	// for elements).
	var end = opts.text.match(/_INPUT_$/);
	var start = opts.text.match(/^_INPUT_/);
	var removed = opts.text.replace(/_INPUT_/, '');
	var str = '<label>' + opts.text + '</label>';

	if (start) {
		str = '_INPUT_<label>' + removed + '</label>';
	}
	else if (end) {
		str = '<label>' + removed + '</label>_INPUT_';
	}

	var filter = $('<div>')
		.addClass(classes.container)
		.append(str.replace(/_INPUT_/, input));

	// add for and id to label and input
	filter.find('label').attr('for', 'dt-search-' + __searchCounter);
	filter.find('input').attr('id', 'dt-search-' + __searchCounter);
	__searchCounter++;

	var searchFn = function(event) {
		var val = this.value;

		if(previousSearch.return && event.key !== "Enter") {
			return;
		}

		/* Now do the filter */
		if ( val != previousSearch.search ) {
			_fnProcessingRun(settings, opts.processing, function () {
				previousSearch.search = val;
		
				_fnFilterComplete( settings, previousSearch );
		
				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw( settings );
			});
		}
	};

	var searchDelay = settings.searchDelay !== null ?
		settings.searchDelay :
		0;

	var jqFilter = $('input', filter)
		.val( previousSearch.search )
		.attr( 'placeholder', opts.placeholder )
		.on(
			'keyup.DT search.DT input.DT paste.DT cut.DT',
			searchDelay ?
				DataTable.util.debounce( searchFn, searchDelay ) :
				searchFn
		)
		.on( 'mouseup.DT', function(e) {
			// Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
			// on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
			// checks the value to see if it has changed. In other browsers it won't have.
			setTimeout( function () {
				searchFn.call(jqFilter[0], e);
			}, 10);
		} )
		.on( 'keypress.DT', function(e) {
			/* Prevent form submission */
			if ( e.keyCode == 13 ) {
				return false;
			}
		} )
		.attr('aria-controls', tableId);

	// Update the input elements whenever the table is filtered
	$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
		if ( settings === s && jqFilter[0] !== document.activeElement ) {
			jqFilter.val( typeof previousSearch.search !== 'function'
				? previousSearch.search
				: ''
			);
		}
	} );

	return filter;
}, 'f' );

// opts
// - type - button configuration
// - buttons - number of buttons to show - must be odd
DataTable.feature.register( 'paging', function ( settings, opts ) {
	// Don't show the paging input if the table doesn't have paging enabled
	if (! settings.oFeatures.bPaginate) {
		return null;
	}

	opts = $.extend({
		buttons: DataTable.ext.pager.numbers_length,
		type: settings.sPaginationType,
		boundaryNumbers: true,
		firstLast: true,
		previousNext: true,
		numbers: true
	}, opts);

	var host = $('<div/>')
		.addClass(settings.oClasses.paging.container + (opts.type ? ' paging_' + opts.type : ''))
		.append(
			$('<nav>')
				.attr('aria-label', 'pagination')
				.addClass(settings.oClasses.paging.nav)
		);
	var draw = function () {
		_pagingDraw(settings, host.children(), opts);
	};

	settings.aoDrawCallback.push(draw);

	// Responsive redraw of paging control
	$(settings.nTable).on('column-sizing.dt.DT', draw);

	return host;
}, 'p' );

/**
 * Dynamically create the button type array based on the configuration options.
 * This will only happen if the paging type is not defined.
 */
function _pagingDynamic(opts) {
	var out = [];

	if (opts.numbers) {
		out.push('numbers');
	}

	if (opts.previousNext) {
		out.unshift('previous');
		out.push('next');
	}

	if (opts.firstLast) {
		out.unshift('first');
		out.push('last');
	}

	return out;
}

function _pagingDraw(settings, host, opts) {
	if (! settings._bInitComplete) {
		return;
	}

	var
		plugin = opts.type
			? DataTable.ext.pager[ opts.type ]
			: _pagingDynamic,
		aria = settings.oLanguage.oAria.paginate || {},
		start      = settings._iDisplayStart,
		len        = settings._iDisplayLength,
		visRecords = settings.fnRecordsDisplay(),
		all        = len === -1,
		page = all ? 0 : Math.ceil( start / len ),
		pages = all ? 1 : Math.ceil( visRecords / len ),
		buttons = [],
		buttonEls = [],
		buttonsNested = plugin(opts)
			.map(function (val) {
				return val === 'numbers'
					? _pagingNumbers(page, pages, opts.buttons, opts.boundaryNumbers)
					: val;
			});

	// .flat() would be better, but not supported in old Safari
	buttons = buttons.concat.apply(buttons, buttonsNested);

	for (var i=0 ; i<buttons.length ; i++) {
		var button = buttons[i];

		var btnInfo = _pagingButtonInfo(settings, button, page, pages);
		var btn = _fnRenderer( settings, 'pagingButton' )(
			settings,
			button,
			btnInfo.display,
			btnInfo.active,
			btnInfo.disabled
		);

		var ariaLabel = typeof button === 'string'
			? aria[ button ]
			: aria.number
				? aria.number + (button+1)
				: null;

		// Common attributes
		$(btn.clicker).attr({
			'aria-controls': settings.sTableId,
			'aria-disabled': btnInfo.disabled ? 'true' : null,
			'aria-current': btnInfo.active ? 'page' : null,
			'aria-label': ariaLabel,
			'data-dt-idx': button,
			'tabIndex': btnInfo.disabled
				? -1
				: settings.iTabIndex && btn.clicker[0].nodeName.toLowerCase() !== 'span'
					? settings.iTabIndex
					: null, // `0` doesn't need a tabIndex since it is the default
		});

		if (typeof button !== 'number') {
			$(btn.clicker).addClass(button);
		}

		_fnBindAction(
			btn.clicker, {action: button}, function(e) {
				e.preventDefault();

				_fnPageChange( settings, e.data.action, true );
			}
		);

		buttonEls.push(btn.display);
	}

	var wrapped = _fnRenderer(settings, 'pagingContainer')(
		settings, buttonEls
	);

	var activeEl = host.find(document.activeElement).data('dt-idx');

	host.empty().append(wrapped);

	if ( activeEl !== undefined ) {
		host.find( '[data-dt-idx='+activeEl+']' ).trigger('focus');
	}

	// Responsive - check if the buttons are over two lines based on the
	// height of the buttons and the container.
	if (buttonEls.length) {
		var outerHeight = $(buttonEls[0]).outerHeight();
	
		if (
			opts.buttons > 1 && // prevent infinite
			outerHeight > 0 && // will be 0 if hidden
			$(host).height() >= (outerHeight * 2) - 10
		) {
			_pagingDraw(settings, host, $.extend({}, opts, { buttons: opts.buttons - 2 }));
		}
	}
}

/**
 * Get properties for a button based on the current paging state of the table
 *
 * @param {*} settings DT settings object
 * @param {*} button The button type in question
 * @param {*} page Table's current page
 * @param {*} pages Number of pages
 * @returns Info object
 */
function _pagingButtonInfo(settings, button, page, pages) {
	var lang = settings.oLanguage.oPaginate;
	var o = {
		display: '',
		active: false,
		disabled: false
	};

	switch ( button ) {
		case 'ellipsis':
			o.display = '&#x2026;';
			break;

		case 'first':
			o.display = lang.sFirst;

			if (page === 0) {
				o.disabled = true;
			}
			break;

		case 'previous':
			o.display = lang.sPrevious;

			if ( page === 0 ) {
				o.disabled = true;
			}
			break;

		case 'next':
			o.display = lang.sNext;

			if ( pages === 0 || page === pages-1 ) {
				o.disabled = true;
			}
			break;

		case 'last':
			o.display = lang.sLast;

			if ( pages === 0 || page === pages-1 ) {
				o.disabled = true;
			}
			break;

		default:
			if ( typeof button === 'number' ) {
				o.display = settings.fnFormatNumber( button + 1 );
				
				if (page === button) {
					o.active = true;
				}
			}
			break;
	}

	return o;
}

/**
 * Compute what number buttons to show in the paging control
 *
 * @param {*} page Current page
 * @param {*} pages Total number of pages
 * @param {*} buttons Target number of number buttons
 * @param {boolean} addFirstLast Indicate if page 1 and end should be included
 * @returns Buttons to show
 */
function _pagingNumbers ( page, pages, buttons, addFirstLast ) {
	var
		numbers = [],
		half = Math.floor(buttons / 2),
		before = addFirstLast ? 2 : 1,
		after = addFirstLast ? 1 : 0;

	if ( pages <= buttons ) {
		numbers = _range(0, pages);
	}
	else if (buttons === 1) {
		// Single button - current page only
		numbers = [page];
	}
	else if (buttons === 3) {
		// Special logic for just three buttons
		if (page <= 1) {
			numbers = [0, 1, 'ellipsis'];
		}
		else if (page >= pages - 2) {
			numbers = _range(pages-2, pages);
			numbers.unshift('ellipsis');
		}
		else {
			numbers = ['ellipsis', page, 'ellipsis'];
		}
	}
	else if ( page <= half ) {
		numbers = _range(0, buttons-before);
		numbers.push('ellipsis');

		if (addFirstLast) {
			numbers.push(pages-1);
		}
	}
	else if ( page >= pages - 1 - half ) {
		numbers = _range(pages-(buttons-before), pages);
		numbers.unshift('ellipsis');

		if (addFirstLast) {
			numbers.unshift(0);
		}
	}
	else {
		numbers = _range(page-half+before, page+half-after);
		numbers.push('ellipsis');
		numbers.unshift('ellipsis');

		if (addFirstLast) {
			numbers.push(pages-1);
			numbers.unshift(0);
		}
	}

	return numbers;
}

var __lengthCounter = 0;

// opts
// - menu
// - text
DataTable.feature.register( 'pageLength', function ( settings, opts ) {
	var features = settings.oFeatures;

	// For compatibility with the legacy `pageLength` top level option
	if (! features.bPaginate || ! features.bLengthChange) {
		return null;
	}

	opts = $.extend({
		menu: settings.aLengthMenu,
		text: settings.oLanguage.sLengthMenu
	}, opts);

	var
		classes  = settings.oClasses.length,
		tableId  = settings.sTableId,
		menu     = opts.menu,
		lengths  = [],
		language = [],
		i;

	// Options can be given in a number of ways
	if (Array.isArray( menu[0] )) {
		// Old 1.x style - 2D array
		lengths = menu[0];
		language = menu[1];
	}
	else {
		for ( i=0 ; i<menu.length ; i++ ) {
			// An object with different label and value
			if ($.isPlainObject(menu[i])) {
				lengths.push(menu[i].value);
				language.push(menu[i].label);
			}
			else {
				// Or just a number to display and use
				lengths.push(menu[i]);
				language.push(menu[i]);
			}
		}
	}

	// We can put the <select> outside of the label if it is at the start or
	// end which helps improve accessability (not all screen readers like
	// implicit for elements).
	var end = opts.text.match(/_MENU_$/);
	var start = opts.text.match(/^_MENU_/);
	var removed = opts.text.replace(/_MENU_/, '');
	var str = '<label>' + opts.text + '</label>';

	if (start) {
		str = '_MENU_<label>' + removed + '</label>';
	}
	else if (end) {
		str = '<label>' + removed + '</label>_MENU_';
	}

	// Wrapper element - use a span as a holder for where the select will go
	var tmpId = 'tmp-' + (+new Date())
	var div = $('<div/>')
		.addClass( classes.container )
		.append(
			str.replace( '_MENU_', '<span id="'+tmpId+'"></span>' )
		);

	// Save text node content for macro updating
	var textNodes = [];
	Array.prototype.slice.call(div.find('label')[0].childNodes).forEach(function (el) {
		if (el.nodeType === Node.TEXT_NODE) {
			textNodes.push({
				el: el,
				text: el.textContent
			});
		}
	});

	// Update the label text in case it has an entries value
	var updateEntries = function (len) {
		textNodes.forEach(function (node) {
			node.el.textContent = _fnMacros(settings, node.text, len);
		});
	}

	// Next, the select itself, along with the options
	var select = $('<select/>', {
		'aria-controls': tableId,
		'class':         classes.select
	} );

	for ( i=0 ; i<lengths.length ; i++ ) {
		select[0][ i ] = new Option(
			typeof language[i] === 'number' ?
				settings.fnFormatNumber( language[i] ) :
				language[i],
			lengths[i]
		);
	}

	// add for and id to label and input
	div.find('label').attr('for', 'dt-length-' + __lengthCounter);
	select.attr('id', 'dt-length-' + __lengthCounter);
	__lengthCounter++;

	// Swap in the select list
	div.find('#' + tmpId).replaceWith(select);

	// Can't use `select` variable as user might provide their own and the
	// reference is broken by the use of outerHTML
	$('select', div)
		.val( settings._iDisplayLength )
		.on( 'change.DT', function() {
			_fnLengthChange( settings, $(this).val() );
			_fnDraw( settings );
		} );

	// Update node value whenever anything changes the table's length
	$(settings.nTable).on( 'length.dt.DT', function (e, s, len) {
		if ( settings === s ) {
			$('select', div).val( len );

			// Resolve plurals in the text for the new length
			updateEntries(len);
		}
	} );

	updateEntries(settings._iDisplayLength);

	return div;
}, 'l' );

// jQuery access
$.fn.dataTable = DataTable;

// Provide access to the host jQuery object (circular reference)
DataTable.$ = $;

// Legacy aliases
$.fn.dataTableSettings = DataTable.settings;
$.fn.dataTableExt = DataTable.ext;

// With a capital `D` we return a DataTables API instance rather than a
// jQuery object
$.fn.DataTable = function ( opts ) {
	return $(this).dataTable( opts ).api();
};

// All properties that are available to $.fn.dataTable should also be
// available on $.fn.DataTable
$.each( DataTable, function ( prop, val ) {
	$.fn.DataTable[ prop ] = val;
} );

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTable);


/***/ }),

/***/ "./node_modules/dbgate-query-splitter/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/dbgate-query-splitter/lib/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replaceQueryParameters = exports.extractQueryParameters = exports.splitQuery = void 0;
var splitQuery_1 = __webpack_require__(/*! ./splitQuery */ "./node_modules/dbgate-query-splitter/lib/splitQuery.js");
Object.defineProperty(exports, "splitQuery", ({ enumerable: true, get: function () { return splitQuery_1.splitQuery; } }));
var queryParamHandler_1 = __webpack_require__(/*! ./queryParamHandler */ "./node_modules/dbgate-query-splitter/lib/queryParamHandler.js");
Object.defineProperty(exports, "extractQueryParameters", ({ enumerable: true, get: function () { return queryParamHandler_1.extractQueryParameters; } }));
Object.defineProperty(exports, "replaceQueryParameters", ({ enumerable: true, get: function () { return queryParamHandler_1.replaceQueryParameters; } }));
__exportStar(__webpack_require__(/*! ./options */ "./node_modules/dbgate-query-splitter/lib/options.js"), exports);


/***/ }),

/***/ "./node_modules/dbgate-query-splitter/lib/options.js":
/*!***********************************************************!*\
  !*** ./node_modules/dbgate-query-splitter/lib/options.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oracleSplitterOptions = exports.redisSplitterOptions = exports.noSplitSplitterOptions = exports.mongoSplitterOptions = exports.sqliteSplitterOptions = exports.postgreSplitterOptions = exports.mssqlSplitterOptions = exports.mysqlSplitterOptions = exports.defaultSplitterOptions = void 0;
exports.defaultSplitterOptions = {
    stringsBegins: ["'"],
    stringsEnds: { "'": "'" },
    stringEscapes: { "'": "'" },
    allowSemicolon: true,
    allowCustomDelimiter: false,
    allowCustomSqlTerminator: false,
    allowGoDelimiter: false,
    allowSlashDelimiter: false,
    allowDollarDollarString: false,
    noSplit: false,
    skipSeparatorBeginEnd: false,
    doubleDashComments: true,
    multilineComments: true,
    javaScriptComments: false,
    returnRichInfo: false,
    splitByLines: false,
    splitByEmptyLine: false,
    preventSingleLineSplit: false,
    adaptiveGoSplit: false,
    ignoreComments: false,
    copyFromStdin: false,
    queryParameterStyle: null,
};
exports.mysqlSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { allowCustomDelimiter: true, stringsBegins: ["'", '`'], stringsEnds: { "'": "'", '`': '`' }, stringEscapes: { "'": '\\', '`': '`' } });
exports.mssqlSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { allowSemicolon: false, allowGoDelimiter: true, stringsBegins: ["'", '['], stringsEnds: { "'": "'", '[': ']' }, stringEscapes: { "'": "'" } });
exports.postgreSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { allowDollarDollarString: true, stringsBegins: ["'", '"'], stringsEnds: { "'": "'", '"': '"' }, stringEscapes: { "'": "'", '"': '"' } });
exports.sqliteSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { skipSeparatorBeginEnd: true, stringsBegins: ["'", '"'], stringsEnds: { "'": "'", '"': '"' }, stringEscapes: { "'": "'", '"': '"' } });
exports.mongoSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { stringsBegins: ["'", '"'], stringsEnds: { "'": "'", '"': '"' }, stringEscapes: { "'": '\\', '"': '\\' } });
exports.noSplitSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { noSplit: true });
exports.redisSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { splitByLines: true });
exports.oracleSplitterOptions = Object.assign(Object.assign({}, exports.defaultSplitterOptions), { allowCustomSqlTerminator: true, allowSlashDelimiter: true, stringsBegins: ["'", '"'], stringsEnds: { "'": "'", '"': '"' }, stringEscapes: { "'": "'", '"': '"' } });


/***/ }),

/***/ "./node_modules/dbgate-query-splitter/lib/queryParamHandler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/dbgate-query-splitter/lib/queryParamHandler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replaceQueryParameters = exports.extractQueryParameters = void 0;
const splitQuery_1 = __webpack_require__(/*! ./splitQuery */ "./node_modules/dbgate-query-splitter/lib/splitQuery.js");
function createParameterizerContext(sql, options) {
    return {
        options,
        source: sql,
        position: 0,
        currentDelimiter: (0, splitQuery_1.getInitialDelimiter)(options),
        end: sql.length,
        wasDataOnLine: false,
        isCopyFromStdin: false,
        isCopyFromStdinCandidate: false,
        beginEndIdentLevel: 0,
    };
}
function extractQueryParameters(sql, options) {
    if (!sql || !options) {
        return [];
    }
    const context = createParameterizerContext(sql, options);
    const res = new Set();
    while (context.position < context.end) {
        const token = (0, splitQuery_1.scanToken)(context);
        if (token === null) {
            break;
        }
        if (token.type === 'parameter') {
            if (token.value == '?') {
                res.add(`?${res.size + 1}`);
            }
            else {
                res.add(token.value);
            }
        }
        context.position += token.length;
    }
    return Array.from(res);
}
exports.extractQueryParameters = extractQueryParameters;
function replaceQueryParameters(sql, params, options) {
    if (!sql || !options) {
        return sql;
    }
    const context = createParameterizerContext(sql, options);
    let res = '';
    let questionParamCounter = 0;
    while (context.position < context.end) {
        const token = (0, splitQuery_1.scanToken)(context);
        if (token === null) {
            break;
        }
        if (token.type === 'parameter') {
            const paramName = token.value == '?' ? `?${++questionParamCounter}` : token.value;
            if (params[paramName]) {
                res += params[paramName];
            }
            else {
                res += sql.substring(context.position, context.position + token.length);
            }
        }
        else {
            res += sql.substring(context.position, context.position + token.length);
        }
        context.position += token.length;
    }
    return res;
}
exports.replaceQueryParameters = replaceQueryParameters;


/***/ }),

/***/ "./node_modules/dbgate-query-splitter/lib/splitQuery.js":
/*!**************************************************************!*\
  !*** ./node_modules/dbgate-query-splitter/lib/splitQuery.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitQuery = exports.finishSplitStream = exports.getInitialDelimiter = exports.splitQueryLine = exports.scanToken = void 0;
const options_1 = __webpack_require__(/*! ./options */ "./node_modules/dbgate-query-splitter/lib/options.js");
const SEMICOLON = ';';
const BEGIN_EXTRA_KEYWORDS = ['DEFERRED', 'IMMEDIATE', 'EXCLUSIVE', 'TRANSACTION'];
const BEGIN_EXTRA_KEYWORDS_REGEX = new RegExp(`^(?:${BEGIN_EXTRA_KEYWORDS.join('|')})`, 'i');
const END_EXTRA_KEYWORDS = ['TRANSACTION', 'IF'];
const END_EXTRA_KEYWORDS_REGEX = new RegExp(`^(?:${END_EXTRA_KEYWORDS.join('|')})`, 'i');
function movePosition(context, count, isWhite) {
    let { source, position, line, column, streamPosition } = context;
    while (count > 0) {
        if (source[position] == '\n') {
            line += 1;
            column = 0;
        }
        else {
            column += 1;
        }
        position += 1;
        streamPosition += 1;
        count -= 1;
    }
    context.position = position;
    context.streamPosition = streamPosition;
    context.line = line;
    context.column = column;
    if (!context.wasDataInCommand) {
        if (isWhite) {
            context.trimCommandStartPosition = streamPosition;
            context.trimCommandStartLine = line;
            context.trimCommandStartColumn = column;
        }
        else {
            context.wasDataInCommand = true;
        }
    }
    if (!isWhite) {
        context.noWhitePosition = streamPosition;
        context.noWhiteLine = line;
        context.noWhiteColumn = column;
    }
}
const WHITESPACE_TOKEN = {
    type: 'whitespace',
    length: 1,
};
const EOLN_TOKEN = {
    type: 'eoln',
    length: 1,
};
const DATA_TOKEN = {
    type: 'data',
    length: 1,
};
function scanDollarQuotedString(context) {
    if (!context.options.allowDollarDollarString)
        return null;
    let pos = context.position;
    const s = context.source;
    const match = /^(\$[a-zA-Z0-9_]*\$)/.exec(s.slice(pos));
    if (!match)
        return null;
    const label = match[1];
    pos += label.length;
    while (pos < context.end) {
        if (s.slice(pos).startsWith(label)) {
            return {
                type: 'string',
                length: pos + label.length - context.position,
            };
        }
        pos++;
    }
    return null;
}
function scanToken(context) {
    var _a;
    let pos = context.position;
    const s = context.source;
    const ch = s[pos];
    if (context.isCopyFromStdin) {
        if (s.slice(pos).startsWith('\\.') && !context.wasDataOnLine) {
            return {
                type: 'copy_stdin_end',
                length: 2,
            };
        }
        let pos2 = pos;
        while (pos2 < context.end && s[pos2] != '\n')
            pos2++;
        if (pos2 < context.end && s[pos2] == '\n')
            pos2++;
        return {
            type: 'copy_stdin_line',
            length: pos2 - pos,
        };
    }
    if (context.options.stringsBegins.includes(ch)) {
        pos++;
        const endch = context.options.stringsEnds[ch];
        const escapech = context.options.stringEscapes[ch];
        while (pos < context.end) {
            if (s[pos] == endch) {
                break;
            }
            if (escapech && s[pos] == escapech) {
                pos += 2;
            }
            else {
                pos++;
            }
        }
        return {
            type: 'string',
            length: pos - context.position + 1,
        };
    }
    if (context.options.queryParameterStyle &&
        ((_a = context.options.queryParameterStyle) === null || _a === void 0 ? void 0 : _a.length) == 1 &&
        ch == context.options.queryParameterStyle &&
        (context.options.queryParameterStyle == '?' || /[a-zA-Z0-9_]/.test(s[pos + 1]))) {
        pos++;
        if (context.options.queryParameterStyle != '?') {
            while (pos < context.end && /[a-zA-Z0-9_]/.test(s[pos]))
                pos++;
        }
        return {
            type: 'parameter',
            value: s.slice(context.position, pos),
            length: pos - context.position,
        };
    }
    const isInBeginEnd = context.options.skipSeparatorBeginEnd && context.beginEndIdentLevel > 0;
    if (context.currentDelimiter && s.slice(pos).startsWith(context.currentDelimiter) && !isInBeginEnd) {
        return {
            type: 'delimiter',
            length: context.currentDelimiter.length,
        };
    }
    if (ch == ' ' || ch == '\t' || ch == '\r') {
        return WHITESPACE_TOKEN;
    }
    if (ch == '\n') {
        return EOLN_TOKEN;
    }
    if (context.options.doubleDashComments && ch == '-' && s[pos + 1] == '-') {
        while (pos < context.end && s[pos] != '\n')
            pos++;
        return {
            type: 'comment',
            length: pos - context.position,
        };
    }
    if (context.options.multilineComments && ch == '/' && s[pos + 1] == '*') {
        pos += 2;
        while (pos < context.end) {
            if (s[pos] == '*' && s[pos + 1] == '/')
                break;
            pos++;
        }
        return {
            type: 'comment',
            length: pos - context.position + 2,
        };
    }
    if (context.options.allowCustomDelimiter && !context.wasDataOnLine) {
        const m = s.slice(pos).match(/^DELIMITER[ \t]+([^\n]+)/i);
        if (m) {
            return {
                type: 'set_delimiter',
                value: m[1].trim(),
                length: m[0].length,
            };
        }
    }
    if (context.options.allowCustomSqlTerminator) {
        const m = s.slice(pos).match(/^SET[ \t]+SQLT(ERMINATOR)?[ \t]+(ON|OFF|".")/i);
        if (m) {
            if (m[2].toUpperCase() == 'OFF') {
                return {
                    type: 'set_sqlterminator',
                    value: null,
                    length: m[0].length,
                };
            }
            if (m[2].toUpperCase() == 'ON') {
                return {
                    type: 'set_sqlterminator',
                    value: SEMICOLON,
                    length: m[0].length,
                };
            }
            if (m[2].startsWith('"')) {
                return {
                    type: 'set_sqlterminator',
                    value: m[2].slice(1, -1),
                    length: m[0].length,
                };
            }
        }
    }
    if ((context.options.allowGoDelimiter || context.options.adaptiveGoSplit) && !context.wasDataOnLine) {
        const m = s.slice(pos).match(/^GO[\t\r ]*(\n|$)/i);
        if (m) {
            return {
                type: 'go_delimiter',
                length: m[0].endsWith('\n') ? m[0].length - 1 : m[0].length,
            };
        }
    }
    if (context.options.allowSlashDelimiter && !context.wasDataOnLine) {
        const m = s.slice(pos).match(/^\/[\t\r ]*(\n|$)/i);
        if (m) {
            return {
                type: 'slash_delimiter',
                length: m[0].endsWith('\n') ? m[0].length - 1 : m[0].length,
            };
        }
    }
    if (context.options.adaptiveGoSplit) {
        const m = s.slice(pos).match(/^(CREATE|ALTER)\s*(PROCEDURE|FUNCTION|TRIGGER)/i);
        if (m) {
            return {
                type: 'create_routine',
                length: m[0].length,
            };
        }
    }
    if (context.options.copyFromStdin && !context.wasDataOnLine && s.slice(pos).startsWith('COPY ')) {
        return {
            type: 'copy',
            length: 5,
        };
    }
    if (context.isCopyFromStdinCandidate && s.slice(pos).startsWith('FROM stdin;')) {
        let pos2 = pos + 'FROM stdin;'.length;
        const pos0 = pos2 - 1;
        while (pos2 < context.end && s[pos2] != '\n')
            pos2++;
        if (s[pos2] == '\n')
            pos2++;
        return {
            type: 'copy_stdin_start',
            length: pos2 - pos,
            lengthWithoutWhitespace: pos0 - pos,
        };
    }
    if (context.options.skipSeparatorBeginEnd && s.slice(pos).match(/^begin/i)) {
        let pos2 = pos + 'BEGIN'.length;
        let pos0 = pos2;
        while (pos0 < context.end && /[^a-zA-Z0-9]/.test(s[pos0]))
            pos0++;
        if (!BEGIN_EXTRA_KEYWORDS_REGEX.test(s.slice(pos0))) {
            return {
                type: 'begin',
                length: pos2 - pos,
                lengthWithoutWhitespace: pos0 - pos,
            };
        }
    }
    if (context.options.skipSeparatorBeginEnd && s.slice(pos).match(/^end/i)) {
        let pos2 = pos + 'END'.length;
        let pos0 = pos2;
        while (pos0 < context.end && /[^a-zA-Z0-9]/.test(s[pos0]))
            pos0++;
        if (!END_EXTRA_KEYWORDS_REGEX.test(s.slice(pos0))) {
            return {
                type: 'end',
                length: pos2 - pos,
            };
        }
    }
    const dollarString = scanDollarQuotedString(context);
    if (dollarString)
        return dollarString;
    return DATA_TOKEN;
}
exports.scanToken = scanToken;
function containsDataAfterDelimiterOnLine(context, delimiter) {
    var _a;
    const cloned = {
        options: context.options,
        source: context.source,
        position: context.position,
        currentDelimiter: context.currentDelimiter,
        end: context.end,
        wasDataOnLine: context.wasDataOnLine,
        isCopyFromStdinCandidate: context.isCopyFromStdinCandidate,
        isCopyFromStdin: context.isCopyFromStdin,
        beginEndIdentLevel: context.beginEndIdentLevel,
    };
    cloned.position += delimiter.length;
    while (cloned.position < cloned.end) {
        const token = scanToken(cloned);
        if (!token) {
            cloned.position += 1;
            continue;
        }
        switch (token.type) {
            case 'whitespace':
                cloned.position += token.length;
                continue;
            case 'eoln':
                return false;
            case 'comment':
                if ((_a = token.value) === null || _a === void 0 ? void 0 : _a.includes('\n'))
                    return true;
                cloned.position += token.length;
                continue;
            default:
                return true;
        }
    }
}
function pushQuery(context, specialMarker) {
    context.commandPart += context.source.slice(context.currentCommandStart, context.position);
    pushCurrentQueryPart(context, specialMarker);
}
function pushCurrentQueryPart(context, specialMarker) {
    const trimmed = context.commandPart.substring(context.trimCommandStartPosition - context.commandStartPosition, context.noWhitePosition - context.commandStartPosition);
    if (trimmed.trim()) {
        if (context.options.returnRichInfo) {
            context.pushOutput({
                text: trimmed,
                start: {
                    position: context.commandStartPosition,
                    line: context.commandStartLine,
                    column: context.commandStartColumn,
                },
                end: {
                    position: context.streamPosition,
                    line: context.line,
                    column: context.column,
                },
                trimStart: {
                    position: context.trimCommandStartPosition,
                    line: context.trimCommandStartLine,
                    column: context.trimCommandStartColumn,
                },
                trimEnd: {
                    position: context.noWhitePosition,
                    line: context.noWhiteLine,
                    column: context.noWhiteColumn,
                },
                specialMarker,
            });
        }
        else {
            context.pushOutput(trimmed);
        }
    }
}
function markStartCommand(context) {
    context.commandStartPosition = context.streamPosition;
    context.commandStartLine = context.line;
    context.commandStartColumn = context.column;
    context.trimCommandStartPosition = context.streamPosition;
    context.trimCommandStartLine = context.line;
    context.trimCommandStartColumn = context.column;
    context.wasDataInCommand = false;
}
function splitByLines(context) {
    while (context.position < context.end) {
        if (context.source[context.position] == '\n') {
            pushQuery(context);
            context.commandPart = '';
            movePosition(context, 1, true);
            context.currentCommandStart = context.position;
            markStartCommand(context);
        }
        else {
            movePosition(context, 1, /\s/.test(context.source[context.position]));
        }
    }
    if (context.end > context.currentCommandStart) {
        context.commandPart += context.source.slice(context.currentCommandStart, context.position);
    }
}
function splitQueryLine(context) {
    if (context.options.splitByLines) {
        splitByLines(context);
        return;
    }
    while (context.position < context.end) {
        const token = scanToken(context);
        if (!token) {
            // nothing special, move forward
            movePosition(context, 1, false);
            continue;
        }
        switch (token.type) {
            case 'string':
                movePosition(context, token.length, false);
                context.wasDataOnLine = true;
                break;
            case 'comment':
                movePosition(context, token.length, !!context.options.ignoreComments);
                context.wasDataOnLine = true;
                break;
            case 'eoln':
                if (!context.wasDataOnLine && context.options.splitByEmptyLine) {
                    pushQuery(context);
                    context.commandPart = '';
                    movePosition(context, token.length, false);
                    context.currentCommandStart = context.position;
                    context.wasDataOnLine = false;
                    markStartCommand(context);
                    break;
                }
                movePosition(context, token.length, true);
                context.wasDataOnLine = false;
                break;
            case 'data':
                movePosition(context, token.length, false);
                context.wasDataOnLine = true;
                break;
            case 'parameter':
                movePosition(context, token.length, false);
                context.wasDataOnLine = true;
                break;
            case 'whitespace':
                movePosition(context, token.length, true);
                break;
            case 'set_delimiter':
            case 'set_sqlterminator':
                pushQuery(context);
                context.commandPart = '';
                context.currentDelimiter = token.value;
                movePosition(context, token.length, false);
                context.currentCommandStart = context.position;
                markStartCommand(context);
                break;
            case 'go_delimiter':
                pushQuery(context);
                context.commandPart = '';
                movePosition(context, token.length, false);
                context.currentCommandStart = context.position;
                markStartCommand(context);
                if (context.options.adaptiveGoSplit) {
                    context.currentDelimiter = SEMICOLON;
                }
                break;
            case 'slash_delimiter':
                pushQuery(context);
                context.commandPart = '';
                movePosition(context, token.length, false);
                context.currentCommandStart = context.position;
                markStartCommand(context);
                break;
            case 'create_routine':
                movePosition(context, token.length, false);
                if (context.options.adaptiveGoSplit) {
                    context.currentDelimiter = null;
                }
                break;
            case 'copy':
                movePosition(context, token.length, false);
                context.isCopyFromStdinCandidate = true;
                context.wasDataOnLine = true;
                break;
            case 'copy_stdin_start':
                movePosition(context, token.lengthWithoutWhitespace, false);
                movePosition(context, token.length - token.lengthWithoutWhitespace, true);
                context.isCopyFromStdin = true;
                context.isCopyFromStdinCandidate = false;
                context.wasDataOnLine = false;
                pushQuery(context, 'copy_stdin_start');
                context.commandPart = '';
                context.currentCommandStart = context.position;
                markStartCommand(context);
                break;
            case 'copy_stdin_line':
                movePosition(context, token.length, false);
                context.isCopyFromStdin = true;
                context.isCopyFromStdinCandidate = false;
                pushQuery(context, 'copy_stdin_line');
                context.commandPart = '';
                context.currentCommandStart = context.position;
                markStartCommand(context);
                break;
            case 'copy_stdin_end':
                movePosition(context, token.length, false);
                context.isCopyFromStdin = false;
                context.wasDataOnLine = true;
                pushQuery(context, 'copy_stdin_end');
                context.commandPart = '';
                context.currentCommandStart = context.position;
                markStartCommand(context);
                break;
            case 'delimiter':
                if (context.options.preventSingleLineSplit && containsDataAfterDelimiterOnLine(context, token)) {
                    movePosition(context, token.length, false);
                    context.wasDataOnLine = true;
                    break;
                }
                pushQuery(context);
                context.commandPart = '';
                movePosition(context, token.length, false);
                context.currentCommandStart = context.position;
                markStartCommand(context);
                context.isCopyFromStdinCandidate = false;
                break;
            case 'begin':
                if (context.options.skipSeparatorBeginEnd) {
                    context.beginEndIdentLevel++;
                }
                movePosition(context, token.length, false);
                break;
            case 'end':
                if (context.options.skipSeparatorBeginEnd && context.beginEndIdentLevel > 0) {
                    context.beginEndIdentLevel--;
                }
                movePosition(context, token.length, false);
                break;
        }
    }
    if (context.end > context.currentCommandStart) {
        context.commandPart += context.source.slice(context.currentCommandStart, context.position);
    }
}
exports.splitQueryLine = splitQueryLine;
function getInitialDelimiter(options) {
    if (options === null || options === void 0 ? void 0 : options.adaptiveGoSplit)
        return SEMICOLON;
    return (options === null || options === void 0 ? void 0 : options.allowSemicolon) === false ? null : SEMICOLON;
}
exports.getInitialDelimiter = getInitialDelimiter;
function finishSplitStream(context) {
    pushCurrentQueryPart(context);
}
exports.finishSplitStream = finishSplitStream;
function splitQuery(sql, options = null) {
    var _a;
    const usedOptions = Object.assign(Object.assign({}, options_1.defaultSplitterOptions), options);
    if (usedOptions.noSplit) {
        if (usedOptions.returnRichInfo) {
            const lines = sql.split('\n');
            return [
                {
                    text: sql,
                    start: {
                        position: 0,
                        line: 0,
                        column: 0,
                    },
                    end: {
                        position: sql.length,
                        line: lines.length,
                        column: ((_a = lines[lines.length - 1]) === null || _a === void 0 ? void 0 : _a.length) || 0,
                    },
                },
            ];
        }
        return [sql];
    }
    const output = [];
    const context = {
        source: sql,
        end: sql.length,
        currentDelimiter: getInitialDelimiter(options),
        position: 0,
        column: 0,
        line: 0,
        currentCommandStart: 0,
        commandStartLine: 0,
        commandStartColumn: 0,
        commandStartPosition: 0,
        streamPosition: 0,
        noWhiteLine: 0,
        noWhiteColumn: 0,
        noWhitePosition: 0,
        trimCommandStartPosition: 0,
        trimCommandStartLine: 0,
        trimCommandStartColumn: 0,
        beginEndIdentLevel: 0,
        wasDataInCommand: false,
        isCopyFromStdin: false,
        isCopyFromStdinCandidate: false,
        pushOutput: cmd => output.push(cmd),
        wasDataOnLine: false,
        options: usedOptions,
        commandPart: '',
    };
    splitQueryLine(context);
    finishSplitStream(context);
    return output;
}
exports.splitQuery = splitQuery;


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ "./node_modules/source-map-support/source-map-support.js":
/*!***************************************************************!*\
  !*** ./node_modules/source-map-support/source-map-support.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var SourceMapConsumer = (__webpack_require__(/*! source-map */ "./node_modules/source-map/source-map.js").SourceMapConsumer);
var path = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");

var fs;
try {
  fs = __webpack_require__(/*! fs */ "?6c30");
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {
  /* nop */
}

var bufferFrom = __webpack_require__(/*! buffer-from */ "./node_modules/buffer-from/index.js");

/**
 * Requires a module which is protected against bundler minification.
 *
 * @param {NodeModule} mod
 * @param {string} request
 */
function dynamicRequire(mod, request) {
  return mod.require(request);
}

// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser")
    return true;
  if (environment === "node")
    return false;
  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === "renderer"));
}

function hasGlobalProcessEventEmitter() {
  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));
}

function globalProcessVersion() {
  if ((typeof process === 'object') && (process !== null)) {
    return process.version;
  } else {
    return '';
  }
}

function globalProcessStderr() {
  if ((typeof process === 'object') && (process !== null)) {
    return process.stderr;
  }
}

function globalProcessExit(code) {
  if ((typeof process === 'object') && (process !== null) && (typeof process.exit === 'function')) {
    return process.exit(code);
  }
}

function handlerExec(list) {
  return function(arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function(path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (/^file:/.test(path)) {
    // existsSync/readFileSync can't handle file protocol, but once stripped, it works
    path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
      return drive ?
        '' : // file:///C:/dir/file -> C:/dir/file
        '/'; // file:///root-dir/file -> /root-dir/file
    });
  }
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = '';
  try {
    if (!fs) {
      // Use SJAX if we are in the browser
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, /** async */ false);
      xhr.send(null);
      if (xhr.readyState === 4 && xhr.status === 200) {
        contents = xhr.responseText;
      }
    } else if (fs.existsSync(path)) {
      // Otherwise, use the filesystem
      contents = fs.readFileSync(path, 'utf8');
    }
  } catch (er) {
    /* ignore any errors */
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://" or "file:///")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  var startPath = dir.slice(protocol.length);
  if (protocol && /^\/\w\:/.test(startPath)) {
    // handle file:///C:/ paths
    protocol += '/';
    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
  }
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
     try {
       var xhr = new XMLHttpRequest();
       xhr.open('GET', source, false);
       xhr.send(null);
       fileData = xhr.readyState === 4 ? xhr.responseText : null;

       // Support providing a sourceMappingURL via the SourceMap header
       var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
                             xhr.getResponseHeader("X-SourceMap");
       if (sourceMapHeader) {
         return sourceMapHeader;
       }
     } catch (e) {
     }
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = bufferFrom(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' +
      position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";  // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame, state) {
  // provides interface backward compatibility
  if (state === undefined) {
    state = { nextPosition: null, curPosition: null }
  }
  if(frame.isNative()) {
    state.curPosition = null;
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    // Header removed in node at ^10.16 || >=11.11.0
    // v11 is not an LTS candidate, we can just test the one version with it.
    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
    var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
    var headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    state.curPosition = position;
    frame = cloneCallSite(frame);
    var originalFunctionName = frame.getFunctionName;
    frame.getFunctionName = function() {
      if (state.nextPosition == null) {
        return originalFunctionName();
      }
      return state.nextPosition.name || originalFunctionName();
    };
    frame.getFileName = function() { return position.source; };
    frame.getLineNumber = function() { return position.line; };
    frame.getColumnNumber = function() { return position.column + 1; };
    frame.getScriptNameOrSourceURL = function() { return position.source; };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function() { return origin; };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// https://v8.dev/docs/stack-trace-api
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  var name = error.name || 'Error';
  var message = error.message || '';
  var errorString = name + ": " + message;

  var state = { nextPosition: null, curPosition: null };
  var processedStack = [];
  for (var i = stack.length - 1; i >= 0; i--) {
    processedStack.push('\n    at ' + wrapCallSite(stack[i], state));
    state.nextPosition = state.curPosition;
  }
  state.curPosition = state.nextPosition = null;
  return errorString + processedStack.reverse().join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' +
          new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit (error) {
  var source = getErrorSource(error);

  // Ensure error is printed synchronously and not truncated
  var stderr = globalProcessStderr();
  if (stderr && stderr._handle && stderr._handle.setBlocking) {
    stderr._handle.setBlocking(true);
  }

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  globalProcessExit(1);
}

function shimEmitUncaughtException () {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = (arguments[1] && arguments[1].stack);
      var hasListeners = (this.listeners(type).length > 0);

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}")
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    // Use dynamicRequire to avoid including in browser bundles
    var Module = dynamicRequire(module, 'module');
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function(content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
      options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ?
      options.handleUncaughtExceptions : true;

    // Do not override 'uncaughtException' with our own handler in Node.js
    // Worker threads. Workers pass the error to the main thread as an event,
    // rather than printing something to stderr and exiting.
    try {
      // We need to use `dynamicRequire` because `require` on it's own will be optimized by WebPack/Browserify.
      var worker_threads = dynamicRequire(module, 'worker_threads');
      if (worker_threads.isMainThread === false) {
        installHandler = false;
      }
    } catch(e) {}

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

exports.resetRetrieveHandlers = function() {
  retrieveFileHandlers.length = 0;
  retrieveMapHandlers.length = 0;

  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);

  retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveFile = handlerExec(retrieveFileHandlers);
}


/***/ }),

/***/ "./node_modules/source-map/lib/array-set.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map/lib/array-set.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/source-map/lib/base64-vlq.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/base64-vlq.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/source-map/lib/base64.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/lib/base64.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/source-map/lib/binary-search.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map/lib/binary-search.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/source-map/lib/mapping-list.js":
/*!*****************************************************!*\
  !*** ./node_modules/source-map/lib/mapping-list.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/source-map/lib/quick-sort.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/quick-sort.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-consumer.js":
/*!************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-consumer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/source-map/lib/binary-search.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var quickSort = (__webpack_require__(/*! ./quick-sort */ "./node_modules/source-map/lib/quick-sort.js").quickSort);

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-generator.js":
/*!*************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-generator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var MappingList = (__webpack_require__(/*! ./mapping-list */ "./node_modules/source-map/lib/mapping-list.js").MappingList);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/source-map/lib/source-node.js":
/*!****************************************************!*\
  !*** ./node_modules/source-map/lib/source-node.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator);
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/source-map/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/source-map/lib/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ "./node_modules/source-map/source-map.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/source-map.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/css/app.css":
/*!*************************!*\
  !*** ./src/css/app.css ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./app.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/app.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/js/SQLiteManager.js":
/*!*********************************!*\
  !*** ./src/js/SQLiteManager.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __dirname = "/";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sqlite_org_sqlite_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sqlite.org/sqlite-wasm */ "./node_modules/@sqlite.org/sqlite-wasm/index.mjs");
/* harmony import */ var source_map_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! source-map-support */ "./node_modules/source-map-support/source-map-support.js");
/* harmony import */ var source_map_support__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(source_map_support__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "?decb");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var dbgate_query_splitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dbgate-query-splitter */ "./node_modules/dbgate-query-splitter/lib/index.js");
/* harmony import */ var dbgate_query_splitter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(dbgate_query_splitter__WEBPACK_IMPORTED_MODULE_4__);
// SQLite モジュールをインポート






//デバッグ用のsourceMap設定
source_map_support__WEBPACK_IMPORTED_MODULE_1__.install();

class SQLiteManager {
  static async initialize(data, options = {}) {
    // SQLite モジュールを初期化
    // Ensure global.window is set to simulate browser environment for wasm
    if (typeof window === 'undefined') __webpack_require__.g.window = {};
    // Dynamically import sqlite3 wasm module on first call
    let sqlite3 = null;
    if (options.env === 'node' && typeof process !== 'undefined') { // node.js環境
      // Load sqlite3.wasm from dist or pkg output directory
      const isPkg = process.pkg !== undefined;
      const wasmPath = isPkg
        ? path__WEBPACK_IMPORTED_MODULE_2___default().join(path__WEBPACK_IMPORTED_MODULE_2___default().dirname(process.execPath), 'sqlite3.wasm')
        : path__WEBPACK_IMPORTED_MODULE_2___default().join(__dirname, 'sqlite3.wasm');
        //path.join(process.cwd(), 'dist', 'sqlite3.wasm');
      const wasmBinary = fs__WEBPACK_IMPORTED_MODULE_3__.readFileSync(wasmPath);
      // Initialize wasm module
      sqlite3 = await (0,_sqlite_org_sqlite_wasm__WEBPACK_IMPORTED_MODULE_0__["default"])({
        print: options.print || (() => { }),
        printErr: options.printErr || (() => { }),
        wasmBinary,
        instantiateWasm: (imports, successCallback) => {
          WebAssembly.instantiate(wasmBinary, imports)
            .then(({ instance, module }) => successCallback(instance, module));
          return {};
        }
      });
    } else { // ブラウザ環境
        sqlite3 = await (0,_sqlite_org_sqlite_wasm__WEBPACK_IMPORTED_MODULE_0__["default"])({
            print: options.print || (() => { }),
            printErr: options.printErr || (() => { })
        });
    }

        const sqlite3_instance = new SQLiteManager(sqlite3, options);
        await sqlite3_instance.setupEnvironment(data);
        return sqlite3_instance;
    }

    constructor(sqlite3, options = {}) {
        this.print = options.print || (() => { });
        this.printErr = options.printErr || (() => { });
        this.sqlite3 = sqlite3;
        this.original = { db: {} };
        this.db = null;
    }

    async setupEnvironment(data) {
        // ファイル名生成
        this.currentFilename = "dbfile_" + (0xffffffff * Math.random() >>> 0);
    if (data && data.length) {
            // VFSを使用してデータをインポート
            this.sqlite3.capi.sqlite3_js_vfs_create_file(
                'unix',
                this.currentFilename,
                data,
                data.length
            );
        }
        // データベースを作成
        this.db = new this.sqlite3.oo1.DB(this.currentFilename, "c");
        // sqlite3_instanceにoriginalプロパティを作成
        this.original = { db: {} };

        // 元のprepareメソッドを保存
        this.original.db.prepare = this.db.prepare;
        this.original.db.exec = this.db.exec;

        // db.prepareをオーバーライド
        this.db.prepare = (sql) => {
            // 元のprepareメソッドを呼び出し
            const stmt = this.original.db.prepare.call(this.db, sql);
            // SQLiteManagerのカスタマイズを適用
            stmt.getRowAsObject = () => this.getRowAsObject.call(this, stmt);
            stmt.getAsObject = () => this.getRowAsObject.call(this, stmt); //sql.js
            stmt._bind = stmt.bind;
            stmt.bind = (...args) => {
                return this.bind.apply(this, [stmt, ...args]);
            }

            return stmt;
        };
        // db.execをオーバーライド
        this.db.exec = (sql, bind) => {
            const results = [];
            let columnNames = [];
            try {
                this.original.db.exec.call(this.db, {
                    sql: sql,
                    bind: bind,
                    rowMode: 'object',
                    callback: (row) => {
                        columnNames = Array.from(new Set([...columnNames, ...Object.keys(row)]));
                        results.push(Object.values(row));
                    }
                });
                return [{
                    columns: columnNames,
                    values: results
                }];
            } catch (error) {
                throw error;
            }
        };
    }

  splitStatements(sql) {
    // dbgate-query-splitterでSQL文を分割
    return (0,dbgate_query_splitter__WEBPACK_IMPORTED_MODULE_4__.splitQuery)(sql, dbgate_query_splitter__WEBPACK_IMPORTED_MODULE_4__.sqliteSplitterOptions);
  }

    // ヘルパーメソッド：行データをオブジェクトとして取得
    getRowAsObject(stmt) {
        const obj = {};
        const columnNames = stmt.getColumnNames();
        for (let i = 0; i < columnNames.length; i++) {
            obj[columnNames[i]] = stmt.get(i);
        }
        return obj;
    }

    // ヘルパーメソッド：バインドオブジェクトをフィルタリングしてバインドする
    filteredBindObject(stmt, bindObject) {
        if (bindObject && typeof bindObject === 'object') {
            return Object.fromEntries(
                Object.entries(bindObject).filter(([key, _]) => 0 !== this.sqlite3.capi.sqlite3_bind_parameter_index(stmt.pointer, key))
            );
        } else {
            return bindObject;
        }
    }

    bind(stmt, ...args) {
        stmt.reset();
        if (args.length === 1 && args[0] && typeof args[0] === 'object') {
            const bindObject = this.filteredBindObject(stmt, args[0]);
            return stmt._bind.apply(stmt, [bindObject]);
        } else {
            return stmt._bind.apply(stmt, ...args);
        }
    }

  executeQuery(query) {
    const results = [];
    try {
      const statements = this.splitStatements(query);
      for (const stmtSql of statements) {
    try {
          const [result] = this.db.exec(stmtSql);
          if (result && result.columns && result.columns.length > 0) {
            const resultmap = result.values.map(vals => Object.fromEntries(result.columns.map((c, i) => [c, vals[i]])));
            results.push({ success: true, results: resultmap, columns: result.columns });
      } else {
            results.push({ success: true, info: {} });
          }
        } catch (error) {
          results.push({ success: false, error: error.message });
        }
      }
      return results;
    } catch (error) {
      results.push({ success: false, error: error.message });
      return results;
    }
  }

  getDatabaseSchema() {
    const sql = `SELECT type, name FROM sqlite_master WHERE type IN ('table','view','index','trigger') ORDER BY type,name`;
    const [rows] = this.db.exec(sql);
    const schema = { tables: [], views: [], indexes: [], triggers: [] };
    rows.values.forEach(vals => {
      const type = vals[0], name = vals[1];
      if (type === 'table') schema.tables.push(name);
      if (type === 'view') schema.views.push(name);
      if (type === 'index') schema.indexes.push(name);
      if (type === 'trigger') schema.triggers.push(name);
    });
    return schema;
  }

  getTableStructure(tableName) {
    const sql = `PRAGMA table_info(${tableName})`;
    const [rows] = this.db.exec(sql);
    return rows.values.map(vals => Object.fromEntries(rows.columns.map((c, i) => [c, vals[i]])));
  }
  
    export() {
    return this.sqlite3.capi.sqlite3_js_db_export(this.db);
    }

    async import(contents) {
        this.db.close();
        await this.setupEnvironment(contents);
    }

    close() {
        this.db.close();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SQLiteManager);

/***/ }),

/***/ "./src/js/events.js":
/*!**************************!*\
  !*** ./src/js/events.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setupEventHandlers: () => (/* binding */ setupEventHandlers)
/* harmony export */ });
/* harmony import */ var _ui_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/constants.js */ "./src/js/ui/constants.js");
/* harmony import */ var _ui_ImagesNotExists_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui/ImagesNotExists.js */ "./src/js/ui/ImagesNotExists.js");
/* harmony import */ var _ui_Results_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/Results.js */ "./src/js/ui/Results.js");
 // Updated import path


// events.js - イベントハンドラーを設定するモジュール

// イベントハンドラーのセットアップ
const setupEventHandlers = (ui, db, tabManager) => {
  // 現在のデータベースパス
  let currentDbPath = 'Untitled.db';

  // クエリ実行処理 (DBオブジェクトを使用して常に実行)
  const handleQueryExecution = () => {
    try {
      const editor = document.getElementById('sql-editor');
      if (!editor) throw new Error('SQLエディタが見つかりません');

      const query = editor.value.trim();
      if (!query) {
        ui.showError('実行するSQLクエリを入力してください');
        return;
      }

      // 既存のResultsタブ・テーブルを全てクリア（Messages以外）
      const tabs = document.querySelector('.results-tabs');
      const resultsGrid = document.getElementById(_ui_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.RESULTS_GRID);
      // 先に全て削除
      for (const tab of Array.from(tabs.querySelectorAll('.result-tab'))) {
        if (tab.textContent !== 'Messages') tab.remove();
      }
      for (const tbl of Array.from(resultsGrid.children)) {
        if (tbl.id.startsWith('results-table')) tbl.remove();
      }
      // 必要な数だけタブ・テーブルを再生成
      let hasResults = false;
      let anySuccess = false;
      let anyResult = false;
      let messages = [];

      const results = db.executeQuery(query);
      let idx = 0;
      for (const result of results) {
        const tableId = idx === 0 ? 'results-table' : `results-table-${idx+1}`;
        const tabLabel = results.length === 1 ? 'Results' : `Results${idx+1}`;

        if (result.success && result.results && result.results.length > 0) {
          hasResults = true;
          (0,_ui_ImagesNotExists_js__WEBPACK_IMPORTED_MODULE_1__.addResults)(tabLabel, tableId);
          (0,_ui_Results_js__WEBPACK_IMPORTED_MODULE_2__.updateResultsGrid)(result, tableId);
          anySuccess = true;
          anyResult = true;
          messages.push(`クエリ${idx+1}: ${result.results.length} 行の結果`);
        }
        if (result.success && (!result.results || result.results.length === 0)) {
          const msg = `クエリ${idx+1}を実行しました: ${result.info?.changes || 0} 行に影響`;
          ui.showSuccess(msg);
          messages.push(msg);
        } else if (!result.success) {
          const err = `クエリ${idx+1}エラー: ${result.error}`;
          ui.showError(err);
          messages.push(err);
        }
        idx++;
      }
      if (hasResults) {
        // --- 追加: 最初のResultタブをアクティブに ---
        const tabs = document.querySelector('.results-tabs');
        if (tabs) {
          const firstResultTab = Array.from(tabs.querySelectorAll('.result-tab')).find(tab => tab.textContent === 'Results' || tab.textContent === 'Results1');
          if (firstResultTab) {
            tabs.querySelectorAll('.result-tab').forEach(t => t.classList.remove('active'));
            firstResultTab.classList.add('active');
            const resultsGrid = document.getElementById(_ui_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.RESULTS_GRID);
            Array.from(resultsGrid.children).forEach(tbl => {
              tbl.style.display = (tbl.id === 'results-table' || tbl.id === 'results-table-1') ? '' : 'none';
            });
          }
        }
        // --- 追加ここまで ---
      }
      // Messagesタブにログ・エラーを表示
      const messagesArea = document.getElementById('messages-area');
      if (messagesArea) {
        messagesArea.innerHTML = messages.map(m => `<div>${m}</div>`).join('');
      }
      if (!anyResult) {
        // 結果が無い場合はMessagesタブをアクティブに
        const msgTab = tabs.querySelector('.result-tab:last-child');
        if (msgTab) {
          tabs.querySelectorAll('.result-tab').forEach(t => t.classList.remove('active'));
          msgTab.classList.add('active');
          resultsGrid.style.display = 'none';
          document.getElementById('messages-area').style.display = '';
        }
      } else if (anySuccess) {
        ui.showSuccess(`クエリを実行しました: ${results.length} 件`);
      }
    } catch (error) {
      ui.showError(`クエリ実行中にエラーが発生しました: ${error.message}`);
      console.error('クエリ実行エラー:', error);
    }
  };

  // 新規データベース作成ボタン
  const newDbButton = document.getElementById('new-db-button');
  if (newDbButton) {
    newDbButton.addEventListener('click', () => {
      const dbPath = handleNewDatabase(ui, db);
      if (dbPath) currentDbPath = dbPath;
    });
  }

  // "開く"ボタンでファイル選択によるDBインポート
  const openDbButton = document.getElementById('open-db-button');
  if (openDbButton) {
    openDbButton.addEventListener('click', async () => {
      try {
        const dbPath = await getFile();
        if (!dbPath) return;
        console.log('選択されたDBファイル:', dbPath.name);
        const arrayBuffer = await readFileAsArrayBuffer(dbPath);
        const data = new Uint8Array(arrayBuffer);
        await db.import(data);
        ui.showSuccess(`データベース '${dbPath.name}' を開きました`);
        currentDbPath = dbPath.name;
        const schema = db.getDatabaseSchema(currentDbPath);
        ui.updateDatabaseTree(schema);
        const dbStatusElem = document.getElementById('db-status');
        if (dbStatusElem) dbStatusElem.textContent = currentDbPath;
      } catch (error) {
        ui.showError('インポートエラー: ' + error.message);
      }
    });
  }
  // "保存"ボタンでDBエクスポート
  const saveButton = document.getElementById('save-db-button');
  if (saveButton) {
    saveButton.addEventListener('click', async () => {
      try {
        const data = await db.export();
        saveFile('exported.db', data);
        ui.showSuccess('データベースをエクスポートしました');
      } catch (error) {
        ui.showError('エクスポートエラー: ' + error.message);
      }
    });
  }
  // ツリービューへのファイルドロップでインポート
  const treeViewElem = document.getElementById(_ui_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.DB_TREE);
  if (treeViewElem) {
    treeViewElem.addEventListener('dragover', e => e.preventDefault());
    treeViewElem.addEventListener('drop', async e => {
      e.preventDefault();
      const dbPath = e.dataTransfer.files[0];
      if (!dbPath) return;
      try {
        const arrayBuffer = await readFileAsArrayBuffer(dbPath);
        const data = new Uint8Array(arrayBuffer);
        await db.import(data);
        ui.showSuccess(`データベース '${dbPath}' を開きました`);
        currentDbPath = dbPath.name;
        const schema = db.getDatabaseSchema(currentDbPath);
        ui.updateDatabaseTree(schema);
        const dbStatusElem = document.getElementById('db-status');
        if (dbStatusElem) dbStatusElem.textContent = currentDbPath;
      } catch (error) {
        ui.showError('インポートエラー: ' + error.message);
      }
    });
  }

  // クエリ実行ボタン
  const runButton = document.getElementById('run-button');
  if (runButton) {
    runButton.addEventListener('click', handleQueryExecution);
  }
  // サイドバーのテーブル選択やランイベントは既存のまま
  document.addEventListener('click', (event) => {
    const target = event.target.closest('.tree-label');
    if (target && target.textContent.includes('.db') && currentDbPath) {
      // データベースクリック時の処理
      handleDatabaseClick(ui, db, currentDbPath);
    } else if (target && target.closest('.Tables')) {
      // テーブルクリック時の処理 (currentDbPath が未設定でもデフォルトDBを使用)
      const dbPath = currentDbPath || 'sample_database';
      // currentDbPath を更新し、クエリ設定のみ行う
      currentDbPath = dbPath;
      handleTableClick(ui, db, dbPath, target.dataset.name);
    }
  });

  // リフレッシュボタンのハンドラ追加
  const refreshButton = document.getElementById('refresh-db-button');
  if (refreshButton) {
    refreshButton.addEventListener('click', () => {
      // currentDbPath に関わらずツリービューを更新
      handleDatabaseClick(ui, db, currentDbPath);
    });
  }

  // "Queryを開く"ボタン
  const openQueryButton = document.getElementById('open-query-button');
  if (openQueryButton) {
    openQueryButton.addEventListener('click', async () => {
      try {
        const sqlFile = await getSqlFile();
        if (!sqlFile) return;
        console.log('選択されたSQLファイル:', sqlFile.name);
        const sqlContent = await readFileAsText(sqlFile);
        const editor = document.getElementById('sql-editor');
        if (editor) {
          editor.value = sqlContent;
          ui.showSuccess(`SQLファイル '${sqlFile.name}' を読み込みました`);
        } else {
          throw new Error('SQLエディタが見つかりません');
        }
      } catch (error) {
        ui.showError(`SQLファイル読み込みエラー: ${error.message}`);
        console.error('SQLファイル読み込みエラー:', error);
      }
    });
  }

  // "Queryを保存"ボタン
  const saveQueryButton = document.getElementById('save-query-button');
  if (saveQueryButton) {
    saveQueryButton.addEventListener('click', () => {
      try {
        const editor = document.getElementById('sql-editor');
        if (!editor) throw new Error('SQLエディタが見つかりません');

        const query = editor.value;
        if (!query.trim()) {
          ui.showError('保存するSQLクエリがありません');
          return;
        }

        saveTextFile('query.sql', query, 'application/sql');
        ui.showSuccess('クエリを query.sql として保存しました');
      } catch (error) {
        ui.showError(`クエリ保存エラー: ${error.message}`);
        console.error('クエリ保存エラー:', error);
      }
    });
  }
};

// 新規データベースを作成する処理
const handleNewDatabase = (ui, db) => {
  try {
    // ブラウザ環境
    let dbPath = 'new_database.db';
    // 新しいデータベースを作成して接続
    db.import(null);

    // サンプルテーブルを作成（複数SQLをそれぞれ実行）
    db.executeQuery(`CREATE TABLE IF NOT EXISTS test (col1 INTEGER PRIMARY KEY, col2 TEXT)`);
    db.executeQuery(`INSERT OR IGNORE INTO test (col1, col2) VALUES (1, '111')`);
    db.executeQuery(`INSERT OR IGNORE INTO test (col1, col2) VALUES (2, '222')`);

    ui.showSuccess(`新しいデータベース '${dbPath}' を作成しました`);

    // データベースツリービューを更新
    const schema = db.getDatabaseSchema(dbPath);
    ui.updateDatabaseTree(schema);

    const dbStatusElem = document.getElementById('db-status');
    if (dbStatusElem) {
      dbStatusElem.textContent = dbPath;
    }

    return dbPath;
  } catch (error) {
    ui.showError(`データベース作成エラー: ${error.message}`);
    console.error('データベース作成エラー:', error);
    return null;
  }
};

// データベースクリック時の処理
const handleDatabaseClick = (ui, db, dbPath) => {
  try {
    // データベーススキーマ情報を取得
    const schema = db.getDatabaseSchema(dbPath);
    const dbStatusElem = document.getElementById('db-status');
    if (dbStatusElem) dbStatusElem.textContent = dbPath;
    ui.updateDatabaseTree(schema);
  } catch (error) {
    ui.showError(`データベース情報の取得に失敗しました: ${error.message}`);
  }
};

// テーブルクリック時の処理
const handleTableClick = (ui, db, dbPath, tableName) => {
  try {
    // テーブルのSELECT文をエディタに設定
    const editor = document.getElementById('sql-editor');
    if (editor) {
      editor.value = `SELECT * FROM ${tableName} LIMIT 100`;
    }
  } catch (error) {
    ui.showError(`テーブル情報の取得に失敗しました: ${error.message}`);
  }
};

// ヘルパー: ファイル保存 (DB用)
function saveFile(filename, contents) {
  const blob = new Blob([contents], { type: 'application/sqlite.db' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}
// ヘルパー: ファイル選択ダイアログ
async function getFile() {
  return new Promise(resolve => {
    const input = document.createElement('input'); input.type = 'file'; input.accept = '.db';
    input.onchange = () => resolve(input.files[0]); input.click();
  });
}
// ヘルパー: ファイルをArrayBufferで読み取り
async function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader(); reader.onload = () => resolve(reader.result);
    reader.onerror = reject; reader.readAsArrayBuffer(file);
  });
}
// ヘルパー: ファイル選択ダイアログ (SQL用)
async function getSqlFile() {
  return new Promise(resolve => {
    const input = document.createElement('input'); input.type = 'file'; input.accept = '.sql';
    input.onchange = () => resolve(input.files[0]); input.click();
  });
}
// ヘルパー: ファイルをテキストで読み取り
async function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader(); reader.onload = () => resolve(reader.result);
    reader.onerror = reject; reader.readAsText(file);
  });
}
// ヘルパー: テキストファイル保存
function saveTextFile(filename, contents, mimeType = 'text/plain') {
  const blob = new Blob([contents], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

/***/ }),

/***/ "./src/js/tabManager.js":
/*!******************************!*\
  !*** ./src/js/tabManager.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TabManager)
/* harmony export */ });
class TabManager {
  constructor({ containerId, editorId, resultsId, messagesId }) {
    console.log('TabManager initialized with container', containerId);
    this.tabsContainer = document.getElementById(containerId);
    this.editor = document.getElementById(editorId);
    this.resultsArea = document.getElementById(resultsId);
    this.messagesArea = document.getElementById(messagesId);
    this.states = {};
    this.activeTabId = 'query1';
    this.tabSerial = 2; // 通番カウンタ
    // 初期状態保存
    this.states['query1'] = {
      query: this.editor.value,
      results: this.resultsArea.innerHTML,
      messages: this.messagesArea.innerHTML
    };
    // 初期のresults/messages HTMLを保存
    this.defaultResultsHTML = this.states['query1'].results;
    this.defaultMessagesHTML = this.states['query1'].messages;
    // 初期タブをアクティブ
    const firstTab = this.tabsContainer.querySelector('.query-tab');
    if (firstTab) {
      firstTab.classList.add('active');
      // 初期タブのクリックで切り替え
      firstTab.addEventListener('click', () => this.switchTab('query1'));
    }
  }

  addTab(label) {
    console.log('TabManager.addTab called with', label);
    const count = this.tabsContainer.querySelectorAll('.query-tab').length;
    const tabId = `query${this.tabSerial++}`;
    // ヘッダータブ生成
    const tab = document.createElement('div');
    tab.classList.add('query-tab');
    tab.dataset.tabId = tabId;
    tab.textContent = `${label}${tabId.replace('query','')}`;
    // タブクリックで切り替え
    tab.addEventListener('click', () => this.switchTab(tabId));
    // 閉じるボタン
    const close = document.createElement('span');
    close.classList.add('close-tab');
    close.textContent = '×';
    close.addEventListener('click', e => { e.stopPropagation(); this.closeTab(tabId); });
    tab.appendChild(close);
    this.tabsContainer.appendChild(tab);
    console.log('TabManager: after append, tab count =', this.tabsContainer.querySelectorAll('.query-tab').length);
    // 状態初期化: エリアHTMLを保持しておく
    this.states[tabId] = {
      query: '',
      results: this.defaultResultsHTML,
      messages: this.defaultMessagesHTML
    };
    // 切り替え
    this.switchTab(tabId);
    // --- 追加: 新規タブ時にUIも初期化 ---
    // エディタを空に
    this.editor.value = '';
    // Resultsグリッドを空テーブルに
    if (this.resultsArea) {
      this.resultsArea.innerHTML = '';
      // results-table, results-table-2...なども全削除
      Array.from(this.resultsArea.querySelectorAll('table')).forEach(tbl => tbl.remove());
      // Resultsタブ・テーブルを必ず1つだけ再生成
      const tabs = document.querySelector('.results-tabs');
      const resultsGrid = document.getElementById('results-grid');
      // Resultsタブを全削除
      Array.from(tabs.querySelectorAll('.result-tab')).forEach(tab => {
        if (tab.textContent === 'Results') tab.remove();
      });
      // Results系テーブルを全削除
      Array.from(resultsGrid.children).forEach(tbl => {
        if (tbl.id && tbl.id.startsWith('results-table')) tbl.remove();
      });
      // Resultsタブ・テーブルを1つだけ再生成
      const { addResults } = __webpack_require__(/*! ./ui/ImagesNotExists.js */ "./src/js/ui/ImagesNotExists.js");
      addResults('Results', 'results-table');
    }
    // Messagesエリアも空に
    if (this.messagesArea) {
      this.messagesArea.innerHTML = '';
    }
    // --- 追加ここまで ---
  }

  closeTab(tabId) {
    const tab = this.tabsContainer.querySelector(`[data-tab-id="${tabId}"]`);
    if (!tab) return;
    delete this.states[tabId];
    tab.remove();
    if (this.activeTabId === tabId) {
      this.activeTabId = null;
      const first = this.tabsContainer.querySelector('.query-tab');
      if (first) this.switchTab(first.dataset.tabId);
    }
  }

  switchTab(tabId) {
    console.log('TabManager.switchTab called for', tabId);
    if (!this.states[tabId]) return;
    // 旧アクティブ保存
    if (this.activeTabId) {
      this.states[this.activeTabId].query = this.editor.value;
      // Resultsタブ・テーブル構成を保存
      const resultsTabs = document.querySelector('.results-tabs');
      const resultsGrid = document.getElementById('results-grid');
      this.states[this.activeTabId].results = JSON.stringify({
        tabs: resultsTabs ? resultsTabs.innerHTML : '',
        grid: resultsGrid ? resultsGrid.innerHTML : ''
      });
      this.states[this.activeTabId].messages = this.messagesArea.innerHTML;
    }
    // ヘッダー更新
    this.tabsContainer.querySelectorAll('.query-tab').forEach(t => t.classList.remove('active'));
    const newTab = this.tabsContainer.querySelector(`[data-tab-id="${tabId}"]`);
    if (newTab) newTab.classList.add('active');
    // コンテンツ復元
    const state = this.states[tabId];
    this.editor.value = state.query;
    // Resultsタブ・テーブルを復元
    if (state.results) {
      let parsed;
      try {
        parsed = JSON.parse(state.results);
      } catch {
        parsed = null;
      }
      if (parsed && parsed.tabs !== undefined && parsed.grid !== undefined) {
        const resultsTabs = document.querySelector('.results-tabs');
        const resultsGrid = document.getElementById('results-grid');
        if (resultsTabs && resultsGrid) {
          resultsTabs.innerHTML = parsed.tabs;
          resultsGrid.innerHTML = parsed.grid;
          // タブ切替イベント再バインド
          const { setupResultsMessagesToggle } = __webpack_require__(/*! ./ui/ImagesNotExists.js */ "./src/js/ui/ImagesNotExists.js");
          setupResultsMessagesToggle();
        }
      } else {
        // 旧形式（HTML文字列のみ）
        this.resultsArea.innerHTML = state.results;
      }
    } else {
      this.resultsArea.innerHTML = '';
    }
    // Messagesも復元
    this.messagesArea.innerHTML = state.messages;
    this.activeTabId = tabId;
  }
}

/***/ }),

/***/ "./src/js/ui.js":
/*!**********************!*\
  !*** ./src/js/ui.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUI: () => (/* binding */ createUI)
/* harmony export */ });
/* harmony import */ var _ui_Results__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/Results */ "./src/js/ui/Results.js");
/* harmony import */ var _ui_Messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui/Messages */ "./src/js/ui/Messages.js");
/* harmony import */ var _ui_Sidebar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/Sidebar */ "./src/js/ui/Sidebar.js");
/* harmony import */ var _ui_MenuBar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/MenuBar */ "./src/js/ui/MenuBar.js");
/* harmony import */ var _ui_StatusBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui/StatusBar */ "./src/js/ui/StatusBar.js");
/* harmony import */ var _ui_ImagesNotExists_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui/ImagesNotExists.js */ "./src/js/ui/ImagesNotExists.js");
/* harmony import */ var _ui_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui/constants.js */ "./src/js/ui/constants.js");
/* harmony import */ var _ui_splitter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/splitter.js */ "./src/js/ui/splitter.js");
/* harmony import */ var _ui_rowSplitter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ui/rowSplitter.js */ "./src/js/ui/rowSplitter.js");
// ui.js - UIコンポーネントを作成するモジュール


// Sidebar機能を外部モジュールからインポート

// MenuBar機能を外部モジュールからインポート



 // Import UI_IDS from the new file
 // Import createSplitter
 // Import createRowSplitter

// UIを作成する関数
const createUI = () => {
  // 重複呼び出し対策: 既にUIが生成済みなら再生成しない
  if (document.getElementById(_ui_constants_js__WEBPACK_IMPORTED_MODULE_6__.UI_IDS.APP_CONTAINER)) {
    return {
      getElement: id => document.getElementById(id),
      updateResultsGrid: (data) => (0,_ui_Results__WEBPACK_IMPORTED_MODULE_0__.updateResultsGrid)(data, document.getElementById(_ui_constants_js__WEBPACK_IMPORTED_MODULE_6__.UI_IDS.RESULTS_GRID)),
      updateDatabaseTree: _ui_Sidebar__WEBPACK_IMPORTED_MODULE_2__.updateDatabaseTree,
      showError: _ui_Messages__WEBPACK_IMPORTED_MODULE_1__.showError,
      showSuccess: _ui_Messages__WEBPACK_IMPORTED_MODULE_1__.showSuccess
    };
  }
  // HTMLのbody要素を取得
  const body = document.querySelector('body');

  // メインコンテナを作成
  const appContainer = document.createElement('div');
  appContainer.id = _ui_constants_js__WEBPACK_IMPORTED_MODULE_6__.UI_IDS.APP_CONTAINER;
  appContainer.classList.add('app-container');

  // メニューバーを作成
  const menuBar = (0,_ui_MenuBar__WEBPACK_IMPORTED_MODULE_3__.createMenuBar)();

  // メインエリアのレイアウト（サイドバーとコンテンツエリア）を作成
  const mainLayout = document.createElement('div');
  mainLayout.classList.add('main-layout');

  const sidebar = (0,_ui_Sidebar__WEBPACK_IMPORTED_MODULE_2__.createSidebar)();
  const mainArea = createMainArea();

  // サイドバーとメインエリアの間にドラッグ可能なスプリッターを追加
  // splitterの作成ロジックを外部モジュール呼び出しに変更
  const splitter = (0,_ui_splitter_js__WEBPACK_IMPORTED_MODULE_7__.createSplitter)(sidebar);

  // レイアウト要素に順番に追加
  mainLayout.appendChild(sidebar);
  mainLayout.appendChild(splitter);
  mainLayout.appendChild(mainArea);

  // ステータスバーを作成
  const statusBar = (0,_ui_StatusBar__WEBPACK_IMPORTED_MODULE_4__.createStatusBar)();

  // 要素を追加
  appContainer.appendChild(menuBar);
  appContainer.appendChild(mainLayout);
  appContainer.appendChild(statusBar);
  body.appendChild(appContainer);

  // オブジェクトを返す
  return {
    getElement: (id) => document.getElementById(id),
    updateResultsGrid: (data) => (0,_ui_Results__WEBPACK_IMPORTED_MODULE_0__.updateResultsGrid)(data, document.getElementById(_ui_constants_js__WEBPACK_IMPORTED_MODULE_6__.UI_IDS.RESULTS_GRID)),
    updateDatabaseTree: (schema) => (0,_ui_Sidebar__WEBPACK_IMPORTED_MODULE_2__.updateDatabaseTree)(schema),
    showError: (message) => (0,_ui_Messages__WEBPACK_IMPORTED_MODULE_1__.showError)(message),
    showSuccess: (message) => (0,_ui_Messages__WEBPACK_IMPORTED_MODULE_1__.showSuccess)(message)
  };
};

// メインコンテンツエリアを作成する関数
const createMainArea = () => {
  const mainArea = document.createElement('div');
  mainArea.id = _ui_constants_js__WEBPACK_IMPORTED_MODULE_6__.UI_IDS.MAIN_AREA;
  mainArea.classList.add('main-area');

  // クエリタブコンテナを作成
  const queryTabs = document.createElement('div');
  queryTabs.id = _ui_constants_js__WEBPACK_IMPORTED_MODULE_6__.UI_IDS.QUERY_TABS;
  queryTabs.classList.add('query-tabs');
  // 初期タブを追加
  const initialTab = document.createElement('div');
  initialTab.classList.add('query-tab', 'active');
  initialTab.dataset.tabId = 'query1';
  initialTab.textContent = 'Query1';
  queryTabs.appendChild(initialTab);

  const queryEditor = document.createElement('div');
  queryEditor.id = _ui_constants_js__WEBPACK_IMPORTED_MODULE_6__.UI_IDS.QUERY_EDITOR;
  queryEditor.classList.add('query-editor');
  const editorTextarea = document.createElement('textarea');
  editorTextarea.id = 'sql-editor';
  editorTextarea.placeholder = 'SQLクエリを入力してください';
  editorTextarea.value = '';
  queryEditor.appendChild(editorTextarea);

  mainArea.appendChild(queryTabs);
  mainArea.appendChild(queryEditor);

  // クエリエディタと結果表示セクション間の水平スプリッター
  // rowSplitterの作成ロジックを外部モジュール呼び出しに変更
  const rowSplitter = (0,_ui_rowSplitter_js__WEBPACK_IMPORTED_MODULE_8__.createRowSplitter)(queryEditor);
  mainArea.appendChild(rowSplitter);

  // 結果表示タブ (Results/Messages) を ImagesNotExists.js から作成
  const { resultsTabs, resultsGrid, messagesArea } = (0,_ui_ImagesNotExists_js__WEBPACK_IMPORTED_MODULE_5__.createResultsSection)();
  mainArea.appendChild(resultsTabs);
  mainArea.appendChild(resultsGrid);
  mainArea.appendChild(messagesArea);

  return mainArea;
};

// local updateResultsGrid implementation removed; using external Results module

/***/ }),

/***/ "./src/js/ui/ImagesNotExists.js":
/*!**************************************!*\
  !*** ./src/js/ui/ImagesNotExists.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addResults: () => (/* binding */ addResults),
/* harmony export */   createResultsSection: () => (/* binding */ createResultsSection),
/* harmony export */   setupResultsMessagesToggle: () => (/* binding */ setupResultsMessagesToggle)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/js/ui/constants.js");


// Results と Messages のセクションを作成
const createResultsSection = () => {
  const resultsTabs = document.createElement('div');
  resultsTabs.classList.add('results-tabs');
  const resTab = document.createElement('div');
  resTab.classList.add('result-tab', 'active');
  resTab.textContent = 'Results';
  const msgTab = document.createElement('div');
  msgTab.classList.add('result-tab');
  msgTab.textContent = 'Messages';
  resultsTabs.appendChild(resTab);
  resultsTabs.appendChild(msgTab);

  // グリッドエリア
  const resultsGrid = document.createElement('div');
  resultsGrid.id = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.RESULTS_GRID;
  resultsGrid.classList.add('results-grid');
  // DataTables 用の table 要素を常に用意
  const resultsTable = document.createElement('table');
  resultsTable.id = 'results-table';
  // DataTablesのスタイルを適用するクラスを追加
  resultsTable.classList.add('display', 'dataTable');
  // 初期状態で空のtbodyを作成しておく
  const emptyTbody = document.createElement('tbody');
  resultsTable.appendChild(emptyTbody);
  resultsGrid.appendChild(resultsTable);

  const messagesArea = document.createElement('div');
  messagesArea.id = 'messages-area';
  messagesArea.classList.add('messages-area');
  messagesArea.style.display = 'none';

  return { resultsTabs, resultsGrid, messagesArea };
};

// 複数Resultsタブ・テーブル追加用
const addResults = (label, tableId = null) => {
  const tabs = document.querySelector('.results-tabs');
  const resultsGrid = document.getElementById(_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.RESULTS_GRID);
  if (!tabs || !resultsGrid) return;

  // タブ作成
  const resTab = document.createElement('div');
  resTab.classList.add('result-tab');
  resTab.textContent = label;
  resTab.dataset.resultsId = tableId || `results-table-${label}`;
  // Messagesタブの直前に挿入
  const msgTab = tabs.querySelector('.result-tab:last-child');
  tabs.insertBefore(resTab, msgTab);

  // テーブル作成
  const resultsTable = document.createElement('table');
  resultsTable.id = resTab.dataset.resultsId;
  resultsTable.classList.add('display', 'dataTable');
  resultsTable.style.display = 'none';
  const emptyTbody = document.createElement('tbody');
  resultsTable.appendChild(emptyTbody);
  resultsGrid.appendChild(resultsTable);

  // 最初の追加時はactiveに
  if (tabs.querySelectorAll('.result-tab').length === 3) {
    tabs.querySelectorAll('.result-tab').forEach(t => t.classList.remove('active'));
    resTab.classList.add('active');
    Array.from(resultsGrid.children).forEach(tbl => tbl.style.display = 'none');
    resultsTable.style.display = '';
  }
  return resultsTable;
};

// Results/Messages タブ切り替えのイベントをセットアップ
const setupResultsMessagesToggle = () => {
  const tabs = document.querySelector('.results-tabs');
  if (!tabs) return;
  tabs.addEventListener('click', (e) => {
    const tab = e.target.closest('.result-tab');
    if (!tab) return;
    tabs.querySelectorAll('.result-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    const resultsGrid = document.getElementById(_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.RESULTS_GRID);
    const messagesArea = document.getElementById('messages-area');
    if (tab.textContent === 'Messages') {
      resultsGrid.style.display = 'none';
      messagesArea.style.display = '';
    } else {
      resultsGrid.style.display = '';
      messagesArea.style.display = 'none';
      // 複数テーブル切り替え
      Array.from(resultsGrid.children).forEach(tbl => {
        tbl.style.display = (tbl.id === tab.dataset.resultsId) ? '' : 'none';
      });
    }
  });
};

/***/ }),

/***/ "./src/js/ui/MenuBar.js":
/*!******************************!*\
  !*** ./src/js/ui/MenuBar.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMenuBar: () => (/* binding */ createMenuBar)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/js/ui/constants.js");
 // Updated import path

// メニューバーを作成する関数
const createMenuBar = () => {
  const menuBar = document.createElement('div');
  menuBar.id = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.MENU_BAR;
  menuBar.classList.add('menu-bar');

  // ファイルメニューグループ
  const fileGroup = document.createElement('div');
  fileGroup.classList.add('menu-group');

  // 新規データベースボタン
  const newDbButton = document.createElement('button');
  newDbButton.id = 'new-db-button';
  newDbButton.classList.add('menu-button');
  newDbButton.innerHTML = '<span class="material-symbols-outlined">database</span> 新規DB';

  // DBを開くボタン
  const openDbButton = document.createElement('button');
  openDbButton.id = 'open-db-button';
  openDbButton.classList.add('menu-button');
  openDbButton.innerHTML = '<span class="material-symbols-outlined">database_upload</span> 開く';

  // 保存ボタン
  const saveDbButton = document.createElement('button');
  saveDbButton.id = 'save-db-button';
  saveDbButton.classList.add('menu-button');
  saveDbButton.innerHTML = '<span class="material-symbols-outlined">save</span> 保存';

  // クエリメニューグループ
  const queryGroup = document.createElement('div');
  queryGroup.classList.add('menu-group');

  // 新規クエリボタン
  const newQueryButton = document.createElement('button');
  newQueryButton.id = 'new-query-button';
  newQueryButton.classList.add('menu-button');
  newQueryButton.innerHTML = '<span class="material-symbols-outlined">post_add</span> 新規Query';

  // クエリを開くボタン
  const openQueryButton = document.createElement('button');
  openQueryButton.id = 'open-query-button';
  openQueryButton.classList.add('menu-button');
  openQueryButton.innerHTML = '<span class="material-symbols-outlined">folder_open</span> Queryを開く';

  // 保存ボタン
  const saveQueryButton = document.createElement('button');
  saveQueryButton.id = 'save-query-button';
  saveQueryButton.classList.add('menu-button');
  saveQueryButton.innerHTML = '<span class="material-symbols-outlined">save</span> Queryを保存';

  // 実行ボタン
  const runButton = document.createElement('button');
  runButton.id = 'run-button';
  runButton.classList.add('menu-button');
  runButton.innerHTML = '<span class="material-symbols-outlined">play_arrow</span> 実行';

  // 要素を追加
  fileGroup.appendChild(newDbButton);
  fileGroup.appendChild(openDbButton);
  fileGroup.appendChild(saveDbButton);
  queryGroup.appendChild(newQueryButton);
  queryGroup.appendChild(openQueryButton);
  queryGroup.appendChild(saveQueryButton);
  queryGroup.appendChild(runButton);

  menuBar.appendChild(fileGroup);
  menuBar.appendChild(queryGroup);

  return menuBar;
};

/***/ }),

/***/ "./src/js/ui/Messages.js":
/*!*******************************!*\
  !*** ./src/js/ui/Messages.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   showError: () => (/* binding */ showError),
/* harmony export */   showSuccess: () => (/* binding */ showSuccess)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/js/ui/constants.js");
 // Updated import path

// エラーメッセージを表示する関数
const showError = (message) => {
  const statusBar = document.getElementById(_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.STATUS_BAR);
  const dbStatusEl = document.getElementById('db-status');
  const currentDbName = dbStatusEl ? dbStatusEl.textContent : '';
  statusBar.innerHTML = `<div class="status-error">${message}</div>`;

  // 5秒後にステータスバーをクリア
  setTimeout(() => {
    statusBar.innerHTML = `<div id="db-status" class="status-item">${currentDbName}</div>`;
  }, 5000);
};

// 成功メッセージを表示する関数
const showSuccess = (message) => {
  const statusBar = document.getElementById(_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.STATUS_BAR);
  const dbStatusEl = document.getElementById('db-status');
  const currentDbName = dbStatusEl ? dbStatusEl.textContent : '';
  statusBar.innerHTML = `<div class="status-success">${message}</div>`;

  // 3秒後にステータスバーをクリア
  setTimeout(() => {
    statusBar.innerHTML = `<div id="db-status" class="status-item">${currentDbName}</div>`;
  }, 3000);
};

/***/ }),

/***/ "./src/js/ui/Results.js":
/*!******************************!*\
  !*** ./src/js/ui/Results.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateResultsGrid: () => (/* binding */ updateResultsGrid)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./src/js/ui/constants.js");
/* harmony import */ var datatables_net_dt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-dt */ "./node_modules/datatables.net-dt/js/dataTables.dataTables.mjs");
/* harmony import */ var datatables_net_dt_css_dataTables_dataTables_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! datatables.net-dt/css/dataTables.dataTables.min.css */ "./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css");
/* harmony import */ var datatables_net_fixedheader_dt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! datatables.net-fixedheader-dt */ "./node_modules/datatables.net-fixedheader-dt/js/fixedHeader.dataTables.mjs");
/* harmony import */ var datatables_net_fixedheader_dt_css_fixedHeader_dataTables_min_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css */ "./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css");

 // Updated import path
// DataTablesプラグインを初期化


// FixedHeader拡張機能


const DataTable = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn).DataTable;

// 結果グリッドを更新する関数（tableId指定対応）
const updateResultsGrid = (data, tableId = 'results-table') => {
  if (!data || !data.results) return;
  // テーブルを取得して中身をクリア
  const table = document.getElementById(tableId);
  if (!table) return;
  // ヘッダーとボディを作り直し
  table.innerHTML = '';
  // thead
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  data.columns.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col;
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);
  // tbody
  const tbody = document.createElement('tbody');
  data.results.forEach(row => {
    const tr = document.createElement('tr');
    data.columns.forEach(col => {
      const td = document.createElement('td');
      td.textContent = row[col] != null ? row[col] : '';
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
};

/***/ }),

/***/ "./src/js/ui/Sidebar.js":
/*!******************************!*\
  !*** ./src/js/ui/Sidebar.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSidebar: () => (/* binding */ createSidebar),
/* harmony export */   updateDatabaseTree: () => (/* binding */ updateDatabaseTree)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/js/ui/constants.js");
 // Updated import path

// サイドバー（データベースツリービュー）を作成する関数
const createSidebar = () => {
  const sidebar = document.createElement('div');
  sidebar.id = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.SIDEBAR;
  sidebar.classList.add('sidebar');

  const treeTitle = document.createElement('div');
  treeTitle.classList.add('tree-title');
  treeTitle.textContent = 'Databases';

  // 更新ボタン
  const refreshButton = document.createElement('button');
  refreshButton.id = 'refresh-db-button';
  refreshButton.classList.add('menu-button');
  refreshButton.innerHTML = '<span class="material-symbols-outlined">refresh</span>'; // アイコン変更
  treeTitle.appendChild(refreshButton);
  sidebar.appendChild(treeTitle);

  const treeView = document.createElement('div');
  treeView.id = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.DB_TREE;
  treeView.classList.add('tree-view');
  sidebar.appendChild(treeView);

  return sidebar;
};

// データベースツリービューを更新する関数
const updateDatabaseTree = (schema) => {
  const treeView = document.getElementById(_constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.DB_TREE);
  treeView.innerHTML = '';
  if (!schema) return;

  const dbItem = document.createElement('div');
  dbItem.classList.add('tree-item', 'expanded');

  // Databaseは一つだけなので、この階層は省略
  // const dbLabel = document.createElement('div');
  // dbLabel.classList.add('tree-label');
  // // デフォルトは折り畳み(⊞)、クリックで展開
  // dbLabel.innerHTML = `<i class="toggle-icon">⊞</i><i class="icon">📂</i> Untitled.db`;
  // // クリックでグループ表示のトグル
  // dbLabel.style.cursor = 'pointer';
  // dbLabel.addEventListener('click', () => {
  //   const children = Array.from(dbItem.children).slice(1);
  //   children.forEach(node => node.style.display = node.style.display === 'none' ? '' : 'none');
  //   // トグルアイコンを更新
  //   const isCollapsed = children[0].style.display === 'none';
  //   dbLabel.querySelector('.toggle-icon').textContent = isCollapsed ? '⊞' : '⊟';
  // });
  // dbItem.appendChild(dbLabel);

  const tablesGroup = createTreeGroup('Tables', schema.tables || [], 'table'); // アイコン名変更
  const viewsGroup = createTreeGroup('Views', schema.views || [], 'dataset'); // アイコン名変更
  const indexesGroup = createTreeGroup('Indexes', schema.indexes || [], 'table_rows_narrow'); // アイコン名変更
  const triggersGroup = createTreeGroup('Triggers', schema.triggers || [], 'bolt'); // アイコン名変更

  // テストで要素を可視にするため、全グループを初期展開
  [tablesGroup, viewsGroup, indexesGroup, triggersGroup].forEach(group => {
    const items = group.querySelector('.tree-items');
    items.style.display = '';
    group.querySelector('.toggle-icon').textContent = 'expand_more'; // アイコン変更
  });

  dbItem.appendChild(tablesGroup);
  dbItem.appendChild(viewsGroup);
  dbItem.appendChild(indexesGroup);
  dbItem.appendChild(triggersGroup);

  treeView.appendChild(dbItem);
};

// ツリービューのグループを作成するヘルパー関数
const createTreeGroup = (title, items, iconName) => { // 引数名を icon -> iconName に変更
  const groupContainer = document.createElement('div');
  groupContainer.classList.add('tree-group');

  const groupLabel = document.createElement('div');
  groupLabel.classList.add('tree-label',`${title}-root`);
  // デフォルトは折り畳み(chevron_right)、クリックで展開
  groupLabel.innerHTML = `<span class="material-symbols-outlined toggle-icon">chevron_right</span><span class="material-symbols-outlined icon">${iconName}</span> ${title}`; // アイコン変更
  groupContainer.appendChild(groupLabel);

  const itemsContainer = document.createElement('div');
  itemsContainer.classList.add('tree-items');
  // 初期は折り畳み
  itemsContainer.style.display = 'none';

  items.forEach(item => {
    const itemElem = document.createElement('div');
    itemElem.classList.add('tree-item');
    itemElem.innerHTML = `<div class=\"tree-label ${title}\" data-name=\"${item}\"><span class=\"material-symbols-outlined icon\">${iconName}</span> ${item}</div>`; // アイコン変更
    itemsContainer.appendChild(itemElem);
  });

  groupContainer.appendChild(itemsContainer);
  // クリックでアイテムの表示/非表示をトグルし、アイコン切り替え
  groupLabel.style.cursor = 'pointer';
  groupLabel.addEventListener('click', () => {
    const isCollapsed = itemsContainer.style.display === 'none';
    itemsContainer.style.display = isCollapsed ? '' : 'none';
    groupLabel.querySelector('.toggle-icon').textContent = isCollapsed ? 'expand_more' : 'chevron_right'; // アイコン変更
  });
  return groupContainer;
};

/***/ }),

/***/ "./src/js/ui/StatusBar.js":
/*!********************************!*\
  !*** ./src/js/ui/StatusBar.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStatusBar: () => (/* binding */ createStatusBar)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/js/ui/constants.js");


// ステータスバーを作成する関数
const createStatusBar = () => {
  const statusBar = document.createElement('div');
  statusBar.id = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UI_IDS.STATUS_BAR;
  statusBar.classList.add('status-bar');

  const dbStatus = document.createElement('div');
  dbStatus.id = 'db-status';
  dbStatus.classList.add('status-item');
  dbStatus.textContent = 'Untitled.db';

  statusBar.appendChild(dbStatus);
  return statusBar;
};

/***/ }),

/***/ "./src/js/ui/constants.js":
/*!********************************!*\
  !*** ./src/js/ui/constants.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UI_IDS: () => (/* binding */ UI_IDS)
/* harmony export */ });
// constants.js - UI要素のIDを定義するモジュール

const UI_IDS = {
  APP_CONTAINER: 'app-container',
  MENU_BAR: 'menu-bar',
  SIDEBAR: 'sidebar',
  MAIN_AREA: 'main-area',
  QUERY_TABS: 'query-tabs',
  QUERY_EDITOR: 'query-editor',
  RESULTS_GRID: 'results-grid',
  STATUS_BAR: 'status-bar',
  DB_TREE: 'db-tree'
};


/***/ }),

/***/ "./src/js/ui/rowSplitter.js":
/*!**********************************!*\
  !*** ./src/js/ui/rowSplitter.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRowSplitter: () => (/* binding */ createRowSplitter)
/* harmony export */ });
// rowSplitter.js - 水平スプリッター要素を作成するモジュール

const createRowSplitter = (queryEditorElement) => {
  const rowSplitter = document.createElement('div');
  rowSplitter.classList.add('row-splitter');

  rowSplitter.addEventListener('mousedown', (e) => {
    e.preventDefault();
    const startY = e.clientY;
    // queryEditorElement を直接参照するように変更
    const startHeight = queryEditorElement.getBoundingClientRect().height;
    const onMouseMove = (e2) => {
      const dy = e2.clientY - startY;
      queryEditorElement.style.height = `${startHeight + dy}px`;
    };
    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  });

  return rowSplitter;
};


/***/ }),

/***/ "./src/js/ui/splitter.js":
/*!*******************************!*\
  !*** ./src/js/ui/splitter.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSplitter: () => (/* binding */ createSplitter)
/* harmony export */ });
// splitter.js - スプリッター要素を作成するモジュール

const createSplitter = (sidebarElement) => {
  const splitter = document.createElement('div');
  splitter.classList.add('splitter');

  splitter.addEventListener('mousedown', (e) => {
    e.preventDefault();
    const onMouseMove = (e2) => {
      // sidebarElement を直接参照するように変更
      sidebarElement.style.width = `${e2.clientX}px`;
    };
    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  });

  return splitter;
};


/***/ }),

/***/ "?6c30":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?decb":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "./chunk/" + chunkId + "." + {"vendors-node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-opfs-async-proxy_js":"624040443756e43f7d99","vendors-node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-worker1-bundler-friendly_mjs":"b94c6cdde3f755871c3d"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/app.css */ "./src/css/app.css");
/* harmony import */ var datatables_net_dt_css_dataTables_dataTables_min_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-dt/css/dataTables.dataTables.min.css */ "./node_modules/datatables.net-dt/css/dataTables.dataTables.min.css");
/* harmony import */ var datatables_net_fixedheader_dt_css_fixedHeader_dataTables_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css */ "./node_modules/datatables.net-fixedheader-dt/css/fixedHeader.dataTables.min.css");
/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui.js */ "./src/js/ui.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events.js */ "./src/js/events.js");
/* harmony import */ var _SQLiteManager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SQLiteManager.js */ "./src/js/SQLiteManager.js");
/* harmony import */ var _tabManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tabManager.js */ "./src/js/tabManager.js");
/* harmony import */ var _ui_ImagesNotExists_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ui/ImagesNotExists.js */ "./src/js/ui/ImagesNotExists.js");
// SQLite Sample - SQLクライアントアプリケーション


// DataTablesのスタイルをバンドル（app.cssの後に読み込む）






 // Import added

// DataTablesプラグインの初期化
window.$ = window.jQuery = (jquery__WEBPACK_IMPORTED_MODULE_0___default());
console.log('ブラウザ環境でDataTablesを初期化しました');

// アプリケーションのメインエントリポイント
const main = async () => {
  console.log('SQLite Sampleアプリケーションを起動中...');
  // ブラウザ環境でのみUIを先行して初期化
  let ui = null;
  let tabManager = null;
  ui = (0,_ui_js__WEBPACK_IMPORTED_MODULE_4__.createUI)();
  tabManager = new _tabManager_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    containerId: 'query-tabs',
    editorId: 'sql-editor',
    resultsId: 'results-grid',
    messagesId: 'messages-area'
  });

  // 即時バインド: 新規Queryボタンでタブ追加
  const newQueryBtn = document.getElementById('new-query-button');
  if (newQueryBtn) {
    newQueryBtn.addEventListener('click', () => tabManager.addTab('Query'));
  }
  // 即時バインド: Results/Messagesタブ切り替え
  (0,_ui_ImagesNotExists_js__WEBPACK_IMPORTED_MODULE_8__.setupResultsMessagesToggle)(); // Replaced the event listener block with this function call

  // データベース機能を SQLiteManager でセットアップ (print, printErr を指定)
  const db = await _SQLiteManager_js__WEBPACK_IMPORTED_MODULE_6__["default"].initialize(null, { print: console.log, printErr: console.error });
  // ブラウザ環境ではイベントハンドラと初期DB表示をセットアップ
  (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.setupEventHandlers)(ui, db, tabManager);
  db.executeQuery(`CREATE TABLE IF NOT EXISTS test (col1 INTEGER PRIMARY KEY, col2 TEXT)`);
  db.executeQuery(`INSERT OR IGNORE INTO test (col1, col2) VALUES (1, '111')`);
  db.executeQuery(`INSERT OR IGNORE INTO test (col1, col2) VALUES (2, '222')`);
  // スキーマ取得とツリービュー更新
  const schema = db.getDatabaseSchema();
  ui.updateDatabaseTree(schema);

  console.log('SQLite Sampleの起動が完了しました！');
};

// アプリケーションを実行
(async () => {
  await main();
})();
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWaUc7QUFDdEI7O0FBRTNFOztBQUVBLGlFQUFlLHdGQUFpQixFQUFDO0FBQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUNObEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsMklBQWU7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxNQUFLO0FBQ3hDLFFBQVEsQ0FBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0JBQStCLDJKQUErQjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0QkFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0QkFBNEI7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUIsdURBQXVEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELHFCQUFxQjs7QUFFeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaURBQWlELHFCQUFxQjs7QUFFdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXOztBQUVYLDZCQUE2QjtBQUM3QixVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakIsa0VBQWtFOztBQUVsRSwrQ0FBK0M7QUFDL0MsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFDLEVBQUUsRUFLTixDQUFDO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELDRCQUE0QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxLQUFDLEVBQUUsRUFnQk47O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLEtBQTBELEVBQUUsRUFNL0Q7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFDLEdBQUcsQ0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsWUFBWTtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSx1REFBdUQ7QUFDdkQsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBQztBQUNuQixnQkFBZ0IsRUFLRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTLFFBQVEsU0FBUztBQUMxQixPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBQyxpQ0FBaUMsQ0FBSzs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0xBQThDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFLDZCQUE2QiwyQ0FBMkM7QUFDeEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxFQUFFLEdBQUcsSUFBSSxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxFQUFFLEdBQUcsRUFBRSxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCLEVBQUUsTUFBTTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0NBQXNDO0FBQ3pELFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDLGdDQUFnQywwQkFBMEI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdCQUF3QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUE0QixFQUFFLEVBRWpDO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFDLEVBQUUsRUFTTjtBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUVBQWUsaUJBQWlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUM1bmNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0xBQXVEO0FBQ3JFO0FBQ0EsY0FBYyxTQUFRO0FBQ3RCLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEpBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDZ0c7QUFDakI7QUFDL0UsOEJBQThCLHNFQUEyQixDQUFDLCtFQUFxQztBQUMvRjtBQUNBLGdEQUFnRCxnQ0FBZ0Msc0NBQXNDLGtDQUFrQyx5QkFBeUIsd0JBQXdCLDhCQUE4Qiw0QkFBNEIsV0FBVyxzQ0FBc0MsOEJBQThCLGtCQUFrQixlQUFlLHFDQUFxQyxxQkFBcUIsc0JBQXNCLFdBQVcsaUNBQWlDLDBDQUEwQyxvQ0FBb0MsbUNBQW1DLG9EQUFvRCx5Q0FBeUMsa0NBQWtDLG9DQUFvQyxtQ0FBbUMsNEJBQTRCLGFBQWEsMEtBQTBLLDJDQUEyQyx1TkFBdU4sMENBQTBDLDhCQUE4QixjQUFjLFdBQVcsd0RBQXdELFNBQVMsNEhBQTRILG9CQUFvQiwyQkFBMkIsOEJBQThCLGdDQUFnQyxtQ0FBbUMsZ05BQWdOLG9CQUFvQiwyQkFBMkIsc0VBQXNFLGFBQWEsa1NBQWtTLGtCQUFrQixjQUFjLFdBQVcsWUFBWSxlQUFlLGtTQUFrUyxrQkFBa0IsY0FBYyxRQUFRLFlBQVksZUFBZSx3V0FBd1csa0JBQWtCLG1CQUFtQixnaEJBQWdoQixrQkFBa0IsV0FBVyxNQUFNLFNBQVMsV0FBVyx3b0NBQXdvQyxPQUFPLGFBQWEsZ0JBQWdCLGVBQWUsc0xBQXNMLGVBQWUsOE1BQThNLHNDQUFzQyxvQkFBb0IsZ1NBQWdTLFdBQVcsb1RBQW9ULGFBQWEsc0VBQXNFLGFBQWEsOEZBQThGLGdCQUFnQixnakJBQWdqQiw0Q0FBNEMsa0JBQWtCLGtCQUFrQixRQUFRLFNBQVMsWUFBWSxtQkFBbUIsaUJBQWlCLGtCQUFrQixZQUFZLFdBQVcsaUNBQWlDLGtCQUFrQixXQUFXLFlBQVksZ0JBQWdCLHFDQUFxQyxrQkFBa0IsTUFBTSxXQUFXLFlBQVksa0JBQWtCLDZCQUE2Qix1Q0FBdUMsbURBQW1ELGtEQUFrRCxTQUFTLDJDQUEyQyxrREFBa0QsU0FBUywyQ0FBMkMsa0RBQWtELFVBQVUsMkNBQTJDLGtEQUFrRCxVQUFVLDJDQUEyQywrQkFBK0IsR0FBRyxtQkFBbUIsS0FBSyxvQkFBb0IsK0JBQStCLEdBQUcsbUJBQW1CLEtBQUssb0JBQW9CLCtCQUErQixHQUFHLDBCQUEwQixLQUFLLDhCQUE4QixvREFBb0QsbUJBQW1CLHNDQUFzQyxzQkFBc0Isc0lBQXNJLGlCQUFpQixzREFBc0QsZ0JBQWdCLDBEQUEwRCxrQkFBa0Isd0RBQXdELGlCQUFpQiw0REFBNEQsbUJBQW1CLDBEQUEwRCxtQkFBbUIsd0RBQXdELGtCQUFrQixtQkFBbUIsb0dBQW9HLGdCQUFnQix3SkFBd0osZ0JBQWdCLGdLQUFnSyxrQkFBa0IsNEpBQTRKLGlCQUFpQixvS0FBb0ssbUJBQW1CLGdLQUFnSyxtQkFBbUIsNEVBQTRFLGdCQUFnQixnRkFBZ0Ysa0JBQWtCLDhFQUE4RSxpQkFBaUIsa0ZBQWtGLG1CQUFtQixnRkFBZ0YsbUJBQW1CLE1BQU0sNEJBQTRCLDZCQUE2QixrQ0FBa0Msc0NBQXNDLCtDQUErQyxnQkFBZ0IsV0FBVyxjQUFjLGlCQUFpQixrREFBa0QsaUJBQWlCLHdEQUF3RCxhQUFhLDJDQUEyQyxzRUFBc0UsYUFBYSx3REFBd0Qsd0NBQXdDLDJCQUEyQix5QkFBeUIsNkJBQTZCLHVDQUF1QyxnQkFBZ0Isc0NBQXNDLG1CQUFtQixvQ0FBb0Msc0RBQXNELGdFQUFnRSx5QkFBeUIsdUNBQXVDLG9DQUFvQyxxQkFBcUIsdUNBQXVDLHdEQUF3RCxpQkFBaUIseUVBQXlFLHlDQUF5QyxpR0FBaUcsZ0JBQWdCLHFIQUFxSCwwQ0FBMEMsb0RBQW9ELHVDQUF1Qyx5Q0FBeUMsMkNBQTJDLG1EQUFtRCwwQ0FBMEMsbURBQW1ELHdDQUF3QyxtR0FBbUcsbURBQW1ELHFGQUFxRixxSEFBcUgsd0RBQXdELGdHQUFnRyxnRkFBZ0YsbURBQW1ELG1GQUFtRixrR0FBa0csaURBQWlELHlFQUF5RSx1UkFBdVIsbURBQW1ELCtGQUErRiw2VUFBNlUsd0RBQXdELHlHQUF5RyxrSUFBa0ksbURBQW1ELGtJQUFrSSxrSUFBa0ksbURBQW1ELDBJQUEwSSxrSUFBa0ksbURBQW1ELDBJQUEwSSxvSkFBb0osd0RBQXdELHdJQUF3SSxvSkFBb0osd0RBQXdELGdKQUFnSixvSkFBb0osd0RBQXdELGdKQUFnSiwrR0FBK0csbURBQW1ELHdKQUF3SiwrR0FBK0csbURBQW1ELGdLQUFnSywrR0FBK0csbURBQW1ELGdLQUFnSyxpSUFBaUksd0RBQXdELHdJQUF3SSxpSUFBaUksd0RBQXdELDRLQUE0SyxpSUFBaUksd0RBQXdELDRLQUE0SyxzTUFBc00sWUFBWSxtQ0FBbUMsYUFBYSw4QkFBOEIsbUJBQW1CLFdBQVcsZUFBZSxzREFBc0QsYUFBYSw4QkFBOEIsbUJBQW1CLHNFQUFzRSwyQkFBMkIsa0JBQWtCLG9FQUFvRSx5QkFBeUIsaUJBQWlCLDREQUE0RCxhQUFhLHFDQUFxQyx5REFBeUQsY0FBYyw0RUFBNEUsY0FBYyxrQkFBa0IsOEVBQThFLGNBQWMsNEZBQTRGLGVBQWUsMEZBQTBGLGVBQWUsd0RBQXdELGlCQUFpQix1REFBdUQsZ0JBQWdCLG9DQUFvQyxXQUFXLGlEQUFpRCxpQkFBaUIsa0JBQWtCLHlDQUF5Qyx5QkFBeUIscUNBQXFDLHdEQUF3RCxlQUFlLHVEQUF1RCxlQUFlLGlCQUFpQixrQkFBa0IsV0FBVyxrQ0FBa0Msc0JBQXNCLGtCQUFrQixZQUFZLDZCQUE2QixjQUFjLGdCQUFnQiwyQkFBMkIsc0JBQXNCLGtCQUFrQixZQUFZLDZCQUE2QixjQUFjLGlDQUFpQyxZQUFZLDhDQUE4QyxzQkFBc0IscUJBQXFCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGtCQUFrQixnQ0FBZ0MsZUFBZSx5QkFBeUIsNkJBQTZCLGtCQUFrQix1QkFBdUIsa0hBQWtILHlCQUF5QixvQ0FBb0MscUNBQXFDLDZJQUE2SSxnR0FBZ0csNkZBQTZGLDRGQUE0RiwyRkFBMkYsOEZBQThGLGtMQUFrTCxlQUFlLG9DQUFvQyw2QkFBNkIsdUJBQXVCLGdCQUFnQixvREFBb0QsdUJBQXVCLHNCQUFzQixzQkFBc0IsNEdBQTRHLCtEQUErRCw0REFBNEQsMkRBQTJELDBEQUEwRCw2REFBNkQscURBQXFELGFBQWEseUJBQXlCLCtHQUErRyxrRUFBa0UsK0RBQStELDhEQUE4RCw2REFBNkQsZ0VBQWdFLDhCQUE4QixzQ0FBc0MsY0FBYyw4SUFBOEksY0FBYyxvQ0FBb0MsV0FBVyx1REFBdUQsaUNBQWlDLG9TQUFvUyxzQkFBc0IsNFhBQTRYLFNBQVMsZ0JBQWdCLG9CQUFvQixxQkFBcUIsdURBQXVELDJDQUEyQyxpREFBaUQsMkNBQTJDLHVFQUF1RSxtQkFBbUIsVUFBVSw4QkFBOEIsK0JBQStCLG9DQUFvQyw0RUFBNEUsd0NBQXdDLDBGQUEwRixhQUFhLDRFQUE0RSxxQ0FBcUMsNkZBQTZGLHFDQUFxQyxxSEFBcUgsZ0JBQWdCLHlJQUF5SSwwQ0FBMEMsb0RBQW9ELG9HQUFvRyxxQ0FBcUMsdUNBQXVDLDRIQUE0SCxzQ0FBc0Msd0RBQXdELHdDQUF3QyxtRkFBbUYsMENBQTBDLDJDQUEyQyxnSUFBZ0ksaUNBQWlDLHFDQUFxQyx1TUFBdU0sc0JBQXNCLDJEQUEyRCxpQ0FBaUMsMkJBQTJCLDREQUE0RCxtQkFBbUIsZ0pBQWdKLGlCQUFpQixrTEFBa0wsZ0JBQWdCLHdEQUF3RCxpQkFBaUIsc0RBQXNELGdCQUFnQixnREFBZ0Q7QUFDeGgwQixPQUFPLHd0SkFBd3RKLGdDQUFnQyxzQ0FBc0Msa0NBQWtDLHlCQUF5Qix3QkFBd0IsOEJBQThCLDRCQUE0QixXQUFXLHNDQUFzQyw4QkFBOEIsa0JBQWtCLGVBQWUscUNBQXFDLHFCQUFxQixzQkFBc0IsYUFBYSxpQ0FBaUMsMENBQTBDLG9DQUFvQyxtQ0FBbUMsb0RBQW9ELHlDQUF5QyxrQ0FBa0Msb0NBQW9DLG1DQUFtQyw0QkFBNEIsYUFBYSwwS0FBMEssMkNBQTJDLHVOQUF1TiwwQ0FBMEMsOEJBQThCLGNBQWMsV0FBVyx3REFBd0QsU0FBUyw0SEFBNEgsb0JBQW9CLDJCQUEyQiw4QkFBOEIsZ0NBQWdDLG1DQUFtQyxnTkFBZ04sb0JBQW9CLDJCQUEyQixzRUFBc0UsYUFBYSxrU0FBa1Msa0JBQWtCLGNBQWMsV0FBVyxjQUFjLG1CQUFtQixrU0FBa1Msa0JBQWtCLGNBQWMsUUFBUSxjQUFjLG1CQUFtQix3V0FBd1csa0JBQWtCLG1CQUFtQixnaEJBQWdoQixrQkFBa0IsV0FBVyxNQUFNLFNBQVMsV0FBVyx3b0NBQXdvQyxPQUFPLGFBQWEsZ0JBQWdCLGVBQWUsc0xBQXNMLGVBQWUsOE1BQThNLHNDQUFzQyxvQkFBb0IsZ1NBQWdTLFdBQVcsb1RBQW9ULGFBQWEsc0VBQXNFLGFBQWEsOEZBQThGLGdCQUFnQixnakJBQWdqQiw0Q0FBNEMsa0JBQWtCLGtCQUFrQixRQUFRLFNBQVMsWUFBWSxtQkFBbUIsaUJBQWlCLGtCQUFrQixZQUFZLFdBQVcsaUNBQWlDLGtCQUFrQixXQUFXLFlBQVksZ0JBQWdCLHFDQUFxQyxrQkFBa0IsTUFBTSxXQUFXLFlBQVksa0JBQWtCLDZCQUE2Qix1Q0FBdUMsbURBQW1ELGtEQUFrRCxTQUFTLDJDQUEyQyxrREFBa0QsU0FBUywyQ0FBMkMsa0RBQWtELFVBQVUsMkNBQTJDLGtEQUFrRCxVQUFVLDJDQUEyQywrQkFBK0IsR0FBRyxtQkFBbUIsS0FBSyxvQkFBb0IsK0JBQStCLEdBQUcsbUJBQW1CLEtBQUssb0JBQW9CLCtCQUErQixHQUFHLDBCQUEwQixLQUFLLDhCQUE4QixvREFBb0QsbUJBQW1CLHNDQUFzQyxzQkFBc0Isc0lBQXNJLGlCQUFpQixzREFBc0QsZ0JBQWdCLDBEQUEwRCxrQkFBa0Isd0RBQXdELGlCQUFpQiw0REFBNEQsbUJBQW1CLDBEQUEwRCxtQkFBbUIsd0RBQXdELGtCQUFrQixtQkFBbUIsb0dBQW9HLGdCQUFnQix3SkFBd0osZ0JBQWdCLGdLQUFnSyxrQkFBa0IsNEpBQTRKLGlCQUFpQixvS0FBb0ssbUJBQW1CLGdLQUFnSyxtQkFBbUIsNEVBQTRFLGdCQUFnQixnRkFBZ0Ysa0JBQWtCLDhFQUE4RSxpQkFBaUIsa0ZBQWtGLG1CQUFtQixnRkFBZ0YsbUJBQW1CLE1BQU0sNEJBQTRCLDZCQUE2QixrQ0FBa0Msc0NBQXNDLCtDQUErQyxnQkFBZ0IsV0FBVyxjQUFjLGlCQUFpQixrREFBa0QsaUJBQWlCLHdEQUF3RCxhQUFhLDJDQUEyQyxzRUFBc0UsYUFBYSx3REFBd0Qsd0NBQXdDLDJCQUEyQix5QkFBeUIsNkJBQTZCLHVDQUF1QyxnQkFBZ0Isc0NBQXNDLG1CQUFtQixvQ0FBb0Msc0RBQXNELGdFQUFnRSx5QkFBeUIsdUNBQXVDLG9DQUFvQyxxQkFBcUIsdUNBQXVDLHdEQUF3RCxpQkFBaUIseUVBQXlFLHlDQUF5QyxpR0FBaUcsZ0JBQWdCLHFIQUFxSCwwQ0FBMEMsb0RBQW9ELHVDQUF1Qyx5Q0FBeUMsMkNBQTJDLG1EQUFtRCwwQ0FBMEMsbURBQW1ELHdDQUF3QyxtR0FBbUcsbURBQW1ELHFGQUFxRixxSEFBcUgsd0RBQXdELGdHQUFnRyxnRkFBZ0YsbURBQW1ELG1GQUFtRixrR0FBa0csaURBQWlELHlFQUF5RSx1UkFBdVIsbURBQW1ELCtGQUErRiw2VUFBNlUsd0RBQXdELHlHQUF5RyxrSUFBa0ksbURBQW1ELGtJQUFrSSxrSUFBa0ksbURBQW1ELDBJQUEwSSxrSUFBa0ksbURBQW1ELDBJQUEwSSxvSkFBb0osd0RBQXdELHdJQUF3SSxvSkFBb0osd0RBQXdELGdKQUFnSixvSkFBb0osd0RBQXdELGdKQUFnSiwrR0FBK0csbURBQW1ELHdKQUF3SiwrR0FBK0csbURBQW1ELGdLQUFnSywrR0FBK0csbURBQW1ELGdLQUFnSyxpSUFBaUksd0RBQXdELHdJQUF3SSxpSUFBaUksd0RBQXdELDRLQUE0SyxpSUFBaUksd0RBQXdELDRLQUE0SyxzTUFBc00sWUFBWSxtQ0FBbUMsYUFBYSw4QkFBOEIsbUJBQW1CLFdBQVcsZUFBZSxzREFBc0QsYUFBYSw4QkFBOEIsbUJBQW1CLHNFQUFzRSwyQkFBMkIsa0JBQWtCLG9FQUFvRSx5QkFBeUIsaUJBQWlCLDREQUE0RCxhQUFhLHFDQUFxQyx5REFBeUQsY0FBYyw0RUFBNEUsY0FBYyxrQkFBa0IsOEVBQThFLGNBQWMsNEZBQTRGLGVBQWUsMEZBQTBGLGVBQWUsd0RBQXdELGlCQUFpQix1REFBdUQsZ0JBQWdCLG9DQUFvQyxXQUFXLGlEQUFpRCxpQkFBaUIsa0JBQWtCLHlDQUF5Qyx5QkFBeUIscUNBQXFDLHdEQUF3RCxlQUFlLHVEQUF1RCxlQUFlLGlCQUFpQixrQkFBa0IsV0FBVyxrQ0FBa0Msc0JBQXNCLGtCQUFrQixZQUFZLDZCQUE2QixjQUFjLGdCQUFnQiwyQkFBMkIsc0JBQXNCLGtCQUFrQixZQUFZLDZCQUE2QixjQUFjLGlDQUFpQyxZQUFZLDhDQUE4QyxzQkFBc0IscUJBQXFCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGtCQUFrQixnQ0FBZ0MsZUFBZSx5QkFBeUIsNkJBQTZCLGtCQUFrQix1QkFBdUIsa0hBQWtILHlCQUF5QixvQ0FBb0MscUNBQXFDLDZJQUE2SSxnR0FBZ0csNkZBQTZGLDRGQUE0RiwyRkFBMkYsOEZBQThGLGtMQUFrTCxlQUFlLG9DQUFvQyw2QkFBNkIsdUJBQXVCLGdCQUFnQixvREFBb0QsdUJBQXVCLHNCQUFzQixzQkFBc0IsNEdBQTRHLCtEQUErRCw0REFBNEQsMkRBQTJELDBEQUEwRCw2REFBNkQscURBQXFELGFBQWEseUJBQXlCLCtHQUErRyxrRUFBa0UsK0RBQStELDhEQUE4RCw2REFBNkQsZ0VBQWdFLDhCQUE4QixzQ0FBc0MsY0FBYyw4SUFBOEksY0FBYyxvQ0FBb0MsV0FBVyx1REFBdUQsaUNBQWlDLG9TQUFvUyxzQkFBc0IsNFhBQTRYLFNBQVMsZ0JBQWdCLG9CQUFvQixxQkFBcUIsdURBQXVELDJDQUEyQyxpREFBaUQsMkNBQTJDLHVFQUF1RSxtQkFBbUIsVUFBVSw4QkFBOEIsK0JBQStCLG9DQUFvQyw0RUFBNEUsd0NBQXdDLDBGQUEwRixhQUFhLDRFQUE0RSxxQ0FBcUMsNkZBQTZGLHFDQUFxQyxxSEFBcUgsZ0JBQWdCLHlJQUF5SSwwQ0FBMEMsb0RBQW9ELG9HQUFvRyxxQ0FBcUMsdUNBQXVDLDRIQUE0SCxzQ0FBc0Msd0RBQXdELHdDQUF3QyxtRkFBbUYsMENBQTBDLDJDQUEyQyxnSUFBZ0ksaUNBQWlDLHFDQUFxQyx1TUFBdU0sc0JBQXNCLDJEQUEyRCxpQ0FBaUMsMkJBQTJCLDREQUE0RCxtQkFBbUIsZ0pBQWdKLGlCQUFpQixrTEFBa0wsZ0JBQWdCLHdEQUF3RCxpQkFBaUIsc0RBQXNELGdCQUFnQixnREFBZ0QsaUJBQWlCLHFCQUFxQjtBQUMzdjlCO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUnZDO0FBQ2dHO0FBQ2pCO0FBQy9FLDhCQUE4QixzRUFBMkIsQ0FBQywrRUFBcUM7QUFDL0Y7QUFDQSw4RkFBOEYsNkJBQTZCLDJDQUEyQywyQ0FBMkMsYUFBYSwyQkFBMkI7QUFDelAsT0FBTyx5UkFBeVIsNkJBQTZCLDJDQUEyQywyQ0FBMkMsYUFBYSwyQkFBMkIsY0FBYyxxQkFBcUI7QUFDOWQ7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSdkM7QUFDNkc7QUFDakI7QUFDNUYsOEJBQThCLG1GQUEyQixDQUFDLDRGQUFxQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLE9BQU8sa0ZBQWtGLFVBQVUsVUFBVSxZQUFZLGFBQWEsV0FBVyxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxZQUFZLFdBQVcsVUFBVSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxXQUFXLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLHFCQUFxQixPQUFPLFlBQVksTUFBTSxvQkFBb0IseUJBQXlCLE9BQU8sWUFBWSxNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLHdCQUF3QixPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxZQUFZLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxXQUFXLE9BQU8sS0FBSyxVQUFVLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxXQUFXLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLHNCQUFzQix5QkFBeUIsdUJBQXVCLGFBQWEsdUJBQXVCLHlCQUF5QixPQUFPLFlBQVksTUFBTSxvQkFBb0IsdUJBQXVCLFdBQVcsWUFBWSxPQUFPLFlBQVksTUFBTSxzQkFBc0IsT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLE9BQU8sS0FBSyxVQUFVLE9BQU8sWUFBWSxNQUFNLHNCQUFzQixPQUFPLEtBQUssWUFBWSxXQUFXLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLHFCQUFxQixPQUFPLEtBQUssWUFBWSxXQUFXLG9CQUFvQixPQUFPLEtBQUssb0JBQW9CLFdBQVcsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksT0FBTyxVQUFVLEtBQUssVUFBVSxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksT0FBTyxZQUFZLE1BQU0sVUFBVSwrQkFBK0IsY0FBYyxlQUFlLG1DQUFtQyxxQkFBcUIsa0JBQWtCLEdBQUcsb0JBQW9CLGtCQUFrQiwyQkFBMkIsa0JBQWtCLDhCQUE4QixHQUFHLGVBQWUsa0JBQWtCLHNDQUFzQyxpQkFBaUIsaUJBQWlCLEdBQUcsaUJBQWlCLGtCQUFrQix1QkFBdUIscURBQXFELHdCQUF3QixHQUFHLGtCQUFrQixxQkFBcUIsaUJBQWlCLGlCQUFpQixzQkFBc0Isb0JBQW9CLGtCQUFrQix3QkFBd0Isb0JBQW9CLEdBQUcsd0JBQXdCLCtDQUErQyxHQUFHLFdBQVcsc0JBQXNCLHVCQUF1QixHQUFHLGtCQUFrQixrQkFBa0IsWUFBWSxxQkFBcUIsR0FBRyxjQUFjLGlCQUFpQiw4QkFBOEIsaUNBQWlDLGtCQUFrQiwyQkFBMkIsR0FBRyxpQkFBaUIsa0JBQWtCLG1DQUFtQyx3QkFBd0Isc0JBQXNCLGlCQUFpQiw4QkFBOEIsa0NBQWtDLEdBQUcsZ0JBQWdCLFlBQVksbUJBQW1CLGlCQUFpQixHQUFHLGdCQUFnQixrQkFBa0Isb0JBQW9CLEdBQUcsaUJBQWlCLGlCQUFpQixrQkFBa0Isd0JBQXdCLHFCQUFxQixjQUFjLHFFQUFxRSxxQkFBcUIsb0NBQW9DLHVCQUF1Qix5REFBeUQsc0JBQXNCLEdBQUcsdUJBQXVCLDhCQUE4QixHQUFHLGlCQUFpQix1QkFBdUIsZ0NBQWdDLGdCQUFnQixZQUFZLGtCQUFrQiwyQkFBMkIscUJBQXFCLEdBQUcsaUJBQWlCLGtCQUFrQiw4QkFBOEIsa0NBQWtDLEdBQUcsZ0JBQWdCLHNCQUFzQiw4QkFBOEIsaUNBQWlDLG9CQUFvQix1QkFBdUIsb0JBQW9CLGtCQUFrQix3QkFBd0IsR0FBRyx1QkFBdUIsNEJBQTRCLEdBQUcsZ0JBQWdCLHFCQUFxQixvQkFBb0IsaUJBQWlCLEdBQUcsc0JBQXNCLGVBQWUsR0FBRyw0Q0FBNEMsOEJBQThCLEdBQUcscUJBQXFCLDRCQUE0QixHQUFHLG1CQUFtQixrQkFBa0Isa0NBQWtDLEdBQUcsNEJBQTRCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixrQkFBa0IsMENBQTBDLG9CQUFvQixHQUFHLHdCQUF3QixZQUFZLGtCQUFrQiwyQkFBMkIscUJBQXFCLEdBQUcsbUJBQW1CLGtCQUFrQixrQ0FBa0MsOEJBQThCLEdBQUcsaUJBQWlCLHNCQUFzQixvQkFBb0IsR0FBRyx3QkFBd0IscUNBQXFDLEdBQUcsbUJBQW1CLFlBQVksZ0JBQWdCLHdDQUF3QywwQ0FBMEMsd0NBQXdDLG1CQUFtQixxRUFBcUUsNEJBQTRCLDJEQUEyRCxvQkFBb0IsMEJBQTBCLG9EQUFvRCwyQkFBMkIsR0FBRyx5REFBeUQsYUFBYSxvQkFBb0IsaUJBQWlCLDhCQUE4QiwrQkFBK0Isc0JBQXNCLG9CQUFvQixnQkFBZ0IsaUJBQWlCLEdBQUcsbUJBQW1CLG1CQUFtQixHQUFHLHFCQUFxQixtQkFBbUIsR0FBRyxtREFBbUQsb0JBQW9CLDRCQUE0QixxQkFBcUIsOEJBQThCLGdCQUFnQixHQUFHLDhCQUE4Qiw4QkFBOEIsMkJBQTJCLGlCQUFpQixxQkFBcUIscUJBQXFCLGtCQUFrQiw4QkFBOEIsMkJBQTJCLGlCQUFpQixxQkFBcUIsa0JBQWtCLDRDQUE0QyxxQkFBcUIsbUNBQW1DLEdBQUcsZUFBZSxlQUFlLGVBQWUsdUJBQXVCLGtDQUFrQyxHQUFHLG1CQUFtQix5Q0FBeUMsR0FBRyxrQ0FBa0MsZ0JBQWdCLHVCQUF1QixrQ0FBa0MsR0FBRyx1QkFBdUIseUNBQXlDLEdBQUcsc0VBQXNFLGlCQUFpQixHQUFHLG1CQUFtQjtBQUNod087QUFDQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7O0FDcFMxQjs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0ZBQXNGLHFCQUFxQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BGYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkQSxNQUFxRjtBQUNyRixNQUEyRTtBQUMzRSxNQUFrRjtBQUNsRixNQUFxRztBQUNyRyxNQUE4RjtBQUM5RixNQUE4RjtBQUM5RixNQUE2RztBQUM3RztBQUNBOztBQUVBOztBQUVBLDRCQUE0Qix3RkFBbUI7QUFDL0Msd0JBQXdCLHFHQUFhO0FBQ3JDLGlCQUFpQiwwRkFBYTtBQUM5QixpQkFBaUIsa0ZBQU07QUFDdkIsNkJBQTZCLHlGQUFrQjs7QUFFL0MsYUFBYSw2RkFBRyxDQUFDLDZGQUFPOzs7O0FBSXVEO0FBQy9FLE9BQU8saUVBQWUsNkZBQU8sSUFBSSw2RkFBTyxVQUFVLDZGQUFPLG1CQUFtQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QjdFO0FBQ0E7QUFDQTs7QUFFNEI7QUFDVzs7QUFFdkM7QUFDQSxRQUFRLG1DQUFNOzs7OztBQUtkLGlFQUFlLHNEQUFTLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1p6QixNQUFxRjtBQUNyRixNQUEyRTtBQUMzRSxNQUFrRjtBQUNsRixNQUFxRztBQUNyRyxNQUE4RjtBQUM5RixNQUE4RjtBQUM5RixNQUE4RztBQUM5RztBQUNBOztBQUVBOztBQUVBLDRCQUE0Qix3RkFBbUI7QUFDL0Msd0JBQXdCLHFHQUFhO0FBQ3JDLGlCQUFpQiwwRkFBYTtBQUM5QixpQkFBaUIsa0ZBQU07QUFDdkIsNkJBQTZCLHlGQUFrQjs7QUFFL0MsYUFBYSw2RkFBRyxDQUFDLDhGQUFPOzs7O0FBSXdEO0FBQ2hGLE9BQU8saUVBQWUsOEZBQU8sSUFBSSw4RkFBTyxVQUFVLDhGQUFPLG1CQUFtQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEI3RTtBQUNBO0FBQ0E7O0FBRTRCO0FBQ2M7QUFDVzs7QUFFckQ7QUFDQSxRQUFRLG1DQUFNOzs7O0FBSWQsaUVBQWUseURBQVMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYnpCO0FBQ0E7QUFDQTs7QUFFNEI7QUFDVzs7QUFFdkM7QUFDQSxRQUFRLG1DQUFNOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLHNEQUFTO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHNEQUFTOztBQUVuQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJLHNEQUFTO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0RBQVM7O0FBRXpCO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxzREFBUyw4Q0FBOEM7O0FBRXZELHNEQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRCxzREFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRCxzREFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELHNEQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBLENBQUMsc0RBQVM7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRixDQUFDOzs7QUFHRCxpRUFBZSxzREFBUyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JtQ3pCO0FBQ0E7QUFDQTs7QUFFNEI7O0FBRTVCO0FBQ0E7QUFDQSxRQUFRLG1DQUFNOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQixRQUFRO0FBQ1IsU0FBUyxhQUFhO0FBQ3RCO0FBQ0E7QUFDQSxTQUFTLElBQUksY0FBYyx3Q0FBd0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGVBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx3Q0FBd0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZCxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1osUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLFFBQVE7QUFDUixTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2QsU0FBUyxLQUFLO0FBQ2QsU0FBUyxLQUFLO0FBQ2Q7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRCxPQUFPLEtBQUssWUFBWSxLQUFLO0FBQzdCLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sS0FBSztBQUNaO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYO0FBQ0EsT0FBTyxLQUFLLFlBQVksS0FBSztBQUM3QjtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksT0FBTyxFQUFFLFFBQVEsRUFBRTs7QUFFbEY7QUFDQSxpR0FBaUcsS0FBSzs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsUUFBUTtBQUN2QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1Qjs7QUFFQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksU0FBUztBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFNBQVM7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLEdBQUc7QUFDZixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLEtBQUs7QUFDakIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLG1CQUFtQjtBQUMvQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQW1CO0FBQ2xDLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsNEJBQTRCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBLG1EQUFtRDtBQUNuRCxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25ELEdBQUc7O0FBRUg7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0NBQXNDO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdCQUF3QjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksS0FBSztBQUNqQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksTUFBTTtBQUNsQixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksU0FBUztBQUNyQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksUUFBUTtBQUNwQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLGVBQWU7QUFDM0I7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsUUFBUTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7OztBQUlGO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsUUFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYSxrQkFBa0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7Ozs7QUFNRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGO0FBQ0E7QUFDQTtBQUNBLElBQUksbUJBQW1CO0FBQ3ZCLEtBQUssUUFBUTtBQUNiLEtBQUssUUFBUSx1QkFBdUIsUUFBUTtBQUM1QyxLQUFLLE9BQU87QUFDWixLQUFLLE9BQU87QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFFBQVE7QUFDeEM7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1Qyx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLGFBQWE7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QyxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZELEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMkJBQTJCO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0NBQWdDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpQ0FBaUM7QUFDdEM7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOzs7QUFHeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwQkFBMEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBLEtBQUssZ0NBQWdDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssaUNBQWlDO0FBQ3RDO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYTtBQUNiLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTs7QUFFdEQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQW1CO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSwyQkFBMkI7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGlFQUFlLFNBQVMsRUFBQzs7Ozs7Ozs7Ozs7O0FDOSthWjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRyxrQkFBa0I7QUFDcEYsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWM7QUFDekMsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILDBCQUEwQixtQkFBTyxDQUFDLDBGQUFxQjtBQUN2RCwwREFBeUQsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDdkosMERBQXlELEVBQUUscUNBQXFDLHNEQUFzRCxFQUFDO0FBQ3ZKLGFBQWEsbUJBQU8sQ0FBQyxzRUFBVzs7Ozs7Ozs7Ozs7O0FDdEJuQjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEIsR0FBRyw0QkFBNEIsR0FBRyw2QkFBNkIsR0FBRyw4QkFBOEIsR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEI7QUFDNVIsOEJBQThCO0FBQzlCO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUMscUNBQXFDLHNFQUFzRSxvQkFBb0IsbUJBQW1CLHVCQUF1QjtBQUN0Tyw0QkFBNEIsaUNBQWlDLHFDQUFxQyx5RkFBeUYsb0JBQW9CLG1CQUFtQixZQUFZO0FBQzlPLDhCQUE4QixpQ0FBaUMscUNBQXFDLHlFQUF5RSxvQkFBb0IsbUJBQW1CLHNCQUFzQjtBQUMxTyw2QkFBNkIsaUNBQWlDLHFDQUFxQyx1RUFBdUUsb0JBQW9CLG1CQUFtQixzQkFBc0I7QUFDdk8sNEJBQTRCLGlDQUFpQyxxQ0FBcUMsMENBQTBDLG9CQUFvQixtQkFBbUIsd0JBQXdCO0FBQzNNLDhCQUE4QixpQ0FBaUMscUNBQXFDLGVBQWU7QUFDbkgsNEJBQTRCLGlDQUFpQyxxQ0FBcUMsb0JBQW9CO0FBQ3RILDZCQUE2QixpQ0FBaUMscUNBQXFDLHFHQUFxRyxvQkFBb0IsbUJBQW1CLHNCQUFzQjs7Ozs7Ozs7Ozs7O0FDbEN4UDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDL0QscUJBQXFCLG1CQUFPLENBQUMsNEVBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx1QkFBdUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7Ozs7Ozs7Ozs7O0FDckVqQjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUI7QUFDekgsa0JBQWtCLG1CQUFPLENBQUMsc0VBQVc7QUFDckMsb0JBQW9CO0FBQ3BCO0FBQ0EscURBQXFELCtCQUErQjtBQUNwRjtBQUNBLG1EQUFtRCw2QkFBNkI7QUFDaEY7QUFDQSxVQUFVLGlEQUFpRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7Ozs7Ozs7Ozs7QUM1a0JsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sS0FBMEI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxZQUFZOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUyw2QkFBNkI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxTQUFTLGdDQUFnQztBQUN6QyxTQUFTLG1CQUFtQjtBQUM1QixTQUFTLHFDQUFxQztBQUM5QyxTQUFTO0FBQ1QsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFLFVBQVU7QUFDNUUsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLHVFQUF1RTtBQUNwRjtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixpREFBaUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLDJCQUEyQix3QkFBd0I7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDJDQUEyQztBQUMzQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMscUNBQXFDO0FBQzlFLHFDQUFxQyxzQ0FBc0M7QUFDM0UscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckMsc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQyxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGNBQWM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUNBQXVDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBdUQ7QUFDL0U7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0NBQStDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGVBQWUsb0NBQW9DOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsK0JBQStCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDhCQUE4QjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsV0FBVztBQUN4RSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHNCQUFzQixjQUFjLHNCQUFzQixnQkFBZ0I7QUFDMUUsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsY0FBYztBQUMzRCwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4REFBOEQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsMEJBQTBCO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxpQkFBaUI7QUFDN0IsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBbUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTs7QUFFQSxjQUFjOztBQUVkOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ047O0FBRUEsWUFBWTtBQUNaLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZUFBZSxxREFBcUQ7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLGtHQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7OztBQzM5VUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsOEJBQThCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLFlBQVk7QUFDWjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLE1BQU07QUFDTixnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RDs7QUFFOUQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2hoQkEsd0JBQXdCLG9HQUF1QztBQUMvRCxXQUFXLG1CQUFPLENBQUMscURBQU07O0FBRXpCO0FBQ0E7QUFDQSxPQUFPLG1CQUFPLENBQUMsaUJBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBYTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsV0FBVyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0NBQWtDO0FBQzdGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxHQUFHLHNCQUFzQixHQUFHO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx1Q0FBdUM7QUFDdkMseUNBQXlDO0FBQ3pDLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6Qix5QkFBeUI7O0FBRXpCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsb0JBQW9CO0FBQy9HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNobkJBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMscURBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7Ozs7Ozs7Ozs7O0FDeEhoQixpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5REFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNJQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckIscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckIscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckIscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEVBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQzlHQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHFEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7Ozs7Ozs7Ozs7QUM5RW5CLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7Ozs7Ozs7Ozs7O0FDakhBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMscURBQVE7QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsdUVBQWlCO0FBQzVDLGVBQWUsK0ZBQStCO0FBQzlDLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFjO0FBQ3RDLGdCQUFnQixrR0FBaUM7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7Ozs7Ozs7Ozs7O0FDeG5DaEMsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFjO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxxREFBUTtBQUMzQixlQUFlLCtGQUErQjtBQUM5QyxrQkFBa0Isd0dBQXFDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7Ozs7Ozs7Ozs7QUN4YTFCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsK0hBQW9EO0FBQzdFLFdBQVcsbUJBQU8sQ0FBQyxxREFBUTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxXQUFXO0FBQ1g7O0FBRUEsa0JBQWtCOzs7Ozs7Ozs7OztBQzVabEIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVosa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7Ozs7Ozs7Ozs7O0FDdmV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEpBQXFGO0FBQ3JGLDBKQUFrRjtBQUNsRiw0SEFBNEQ7Ozs7Ozs7Ozs7OztBQ1AvQzs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRmE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RhOztBQUViO0FBQ0E7QUFDQSxjQUFjLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVEYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQSxNQUFrRztBQUNsRyxNQUF3RjtBQUN4RixNQUErRjtBQUMvRixNQUFrSDtBQUNsSCxNQUEyRztBQUMzRyxNQUEyRztBQUMzRyxNQUFvRztBQUNwRztBQUNBOztBQUVBOztBQUVBLDRCQUE0QixxR0FBbUI7QUFDL0Msd0JBQXdCLGtIQUFhO0FBQ3JDLGlCQUFpQix1R0FBYTtBQUM5QixpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLG9GQUFPOzs7O0FBSThDO0FBQ3RFLE9BQU8saUVBQWUsb0ZBQU8sSUFBSSxvRkFBTyxVQUFVLG9GQUFPLG1CQUFtQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCN0U7QUFDMEQ7QUFDSDtBQUMvQjtBQUNDO0FBQ2lEOztBQUUxRTtBQUNBLHVEQUF3Qjs7QUFFeEI7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHVDQUF1QyxxQkFBTTtBQUM3QztBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0RBQVMsQ0FBQyxtREFBWTtBQUNoQyxVQUFVLGdEQUFTLENBQUMsU0FBUztBQUM3QjtBQUNBLHlCQUF5Qiw0Q0FBZTtBQUN4QztBQUNBLHNCQUFzQixtRUFBSTtBQUMxQiwwQ0FBMEM7QUFDMUMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLE9BQU87QUFDYix3QkFBd0IsbUVBQUk7QUFDNUIsOENBQThDO0FBQzlDLG9EQUFvRDtBQUNwRCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDLGdEQUFnRDtBQUNoRCxzREFBc0Q7QUFDdEQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUVBQVUsTUFBTSx3RUFBcUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUE0RDtBQUN2RixRQUFRO0FBQ1IsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBLFVBQVU7QUFDVix5QkFBeUIsc0NBQXNDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hOZSxDQUFDO0FBQ1M7QUFDRDtBQUNwRDs7QUFFQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxvREFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLE1BQU07QUFDN0Usc0VBQXNFLE1BQU07O0FBRTVFO0FBQ0E7QUFDQSxVQUFVLGtFQUFVO0FBQ3BCLFVBQVUsaUVBQWlCO0FBQzNCO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTSxJQUFJLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sV0FBVywyQkFBMkI7QUFDeEU7QUFDQTtBQUNBLFVBQVU7QUFDViw0QkFBNEIsTUFBTSxPQUFPLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0RBQU07QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQSxNQUFNO0FBQ04seUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0Msb0RBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUix3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUixrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLE9BQU87O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSixpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQSxJQUFJO0FBQ0osc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLCtCQUErQjtBQUNyRTtBQUNBLHlDQUF5QyxjQUFjLHVCQUF1QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RSxvREFBb0Q7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscUJBQXFCO0FBQ3hFLG9EQUFvRDtBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsNkJBQTZCO0FBQzdCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0EseUNBQXlDLGNBQWMsdUJBQXVCO0FBQzlFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3pWZTtBQUNmLGdCQUFnQiw4Q0FBOEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU0sRUFBRSwwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFCQUFxQix1QkFBdUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyxhQUFhLEVBQUUsbUJBQU8sQ0FBQywrREFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsTUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QixFQUFFLG1CQUFPLENBQUMsK0RBQXlCO0FBQ2xGO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSkE7QUFDaUQ7QUFDTTtBQUN2RDtBQUNpRTtBQUNqRTtBQUM2QztBQUNJO0FBQ2M7QUFDcEIsQ0FBQztBQUNNLENBQUM7QUFDSyxDQUFDOztBQUV6RDtBQUNPO0FBQ1A7QUFDQSw4QkFBOEIsb0RBQU07QUFDcEM7QUFDQTtBQUNBLG1DQUFtQyw4REFBaUIsK0JBQStCLG9EQUFNO0FBQ3pGLHdCQUF3QjtBQUN4QixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7O0FBRUE7QUFDQSxrQkFBa0IsMERBQWE7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsMERBQWE7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwrREFBYzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsOERBQWU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhEQUFpQiwrQkFBK0Isb0RBQU07QUFDdkYsb0NBQW9DLCtEQUFrQjtBQUN0RCw0QkFBNEIsdURBQVM7QUFDckMsOEJBQThCLHlEQUFXO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFNO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0RBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxRUFBaUI7QUFDdkM7O0FBRUE7QUFDQSxVQUFVLHlDQUF5QyxFQUFFLDRFQUFvQjtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtREFBbUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xIWDs7QUFFeEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ087QUFDUDtBQUNBLDhDQUE4QyxpREFBTTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaURBQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7OztBQzlGd0MsQ0FBQzs7QUFFekM7QUFDTztBQUNQO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkV3QyxDQUFDOztBQUV6QztBQUNPO0FBQ1AsNENBQTRDLGlEQUFNO0FBQ2xEO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTs7QUFFN0Q7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GLEdBQUc7QUFDSDs7QUFFQTtBQUNPO0FBQ1AsNENBQTRDLGlEQUFNO0FBQ2xEO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTs7QUFFL0Q7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCdUI7QUFDaUIsQ0FBQztBQUN6QztBQUMyQjtBQUNrQztBQUM3RDtBQUN1QztBQUNtQztBQUMxRSxrQkFBa0Isa0RBQUk7O0FBRXRCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDd0MsQ0FBQzs7QUFFekM7QUFDTztBQUNQO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpREFBTTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDTztBQUNQLDJDQUEyQyxpREFBTTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsK0VBQStFO0FBQy9FLDhFQUE4RTtBQUM5RSw4RkFBOEY7QUFDOUYsb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0EsaUpBQWlKLFNBQVMsVUFBVSxNQUFNLEdBQUc7QUFDN0s7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU0saUJBQWlCLEtBQUssb0RBQW9ELFNBQVMsVUFBVSxLQUFLLFNBQVM7QUFDcks7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRyxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pHd0M7O0FBRXhDO0FBQ087QUFDUDtBQUNBLGlCQUFpQixpREFBTTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2ZBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeEJBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7Ozs7OztBQ3JCQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7Ozs7V0M1QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQSxzQ0FBc0MsaVBBQWlQO1dBQ3ZSOzs7OztXQ0pBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ0pBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ2xCQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7Ozs7O1dDckJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDdUI7QUFDQztBQUN4QjtBQUM2RDtBQUNhO0FBQ3ZDO0FBQ2M7QUFDRjtBQUNOO0FBQzRCLENBQUM7O0FBRXRFO0FBQ0EsMkJBQTJCLCtDQUFDO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0RBQVE7QUFDZixtQkFBbUIsc0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0ZBQTBCLElBQUk7O0FBRWhDO0FBQ0EsbUJBQW1CLHlEQUFhLG9CQUFvQiw2Q0FBNkM7QUFDakc7QUFDQSxFQUFFLDhEQUFrQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvQHNxbGl0ZS5vcmcvc3FsaXRlLXdhc20vaW5kZXgubWpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLWJ1bmRsZXItZnJpZW5kbHkubWpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLXdvcmtlcjEtcHJvbWlzZXItYnVuZGxlci1mcmllbmRseS5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1kdC9jc3MvZGF0YVRhYmxlcy5kYXRhVGFibGVzLm1pbi5jc3MiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtZml4ZWRoZWFkZXItZHQvY3NzL2ZpeGVkSGVhZGVyLmRhdGFUYWJsZXMubWluLmNzcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9jc3MvYXBwLmNzcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1kdC9jc3MvZGF0YVRhYmxlcy5kYXRhVGFibGVzLm1pbi5jc3M/Yzg4MyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1kdC9qcy9kYXRhVGFibGVzLmRhdGFUYWJsZXMubWpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LWZpeGVkaGVhZGVyLWR0L2Nzcy9maXhlZEhlYWRlci5kYXRhVGFibGVzLm1pbi5jc3M/ZTU0MyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1maXhlZGhlYWRlci1kdC9qcy9maXhlZEhlYWRlci5kYXRhVGFibGVzLm1qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1maXhlZGhlYWRlci9qcy9kYXRhVGFibGVzLmZpeGVkSGVhZGVyLm1qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC9qcy9kYXRhVGFibGVzLm1qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYmdhdGUtcXVlcnktc3BsaXR0ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL2RiZ2F0ZS1xdWVyeS1zcGxpdHRlci9saWIvb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9kYmdhdGUtcXVlcnktc3BsaXR0ZXIvbGliL3F1ZXJ5UGFyYW1IYW5kbGVyLmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL2RiZ2F0ZS1xdWVyeS1zcGxpdHRlci9saWIvc3BsaXRRdWVyeS5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtc3VwcG9ydC9zb3VyY2UtbWFwLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2JpbmFyeS1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vc3JjL2Nzcy9hcHAuY3NzPzkyZmYiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9zcmMvanMvU1FMaXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9qcy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9zcmMvanMvdGFiTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9qcy91aS5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9qcy91aS9JbWFnZXNOb3RFeGlzdHMuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9zcmMvanMvdWkvTWVudUJhci5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9qcy91aS9NZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9qcy91aS9SZXN1bHRzLmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vc3JjL2pzL3VpL1NpZGViYXIuanMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvLi9zcmMvanMvdWkvU3RhdHVzQmFyLmpzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vc3JjL2pzL3VpL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9qcy91aS9yb3dTcGxpdHRlci5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi8uL3NyYy9qcy91aS9zcGxpdHRlci5qcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi9pZ25vcmVkfC9ob21lL3J1bm5lci93b3JrL1NRTGl0ZS1TYW1wbGUvU1FMaXRlLVNhbXBsZS9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0fGZzIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyL2lnbm9yZWR8L2hvbWUvcnVubmVyL3dvcmsvU1FMaXRlLVNhbXBsZS9TUUxpdGUtU2FtcGxlL3NyYy9qc3xmcyIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9TUUxpdGUtU2FtcGxlMi93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vU1FMaXRlLVNhbXBsZTIvd2VicGFjay9ydW50aW1lL25vbmNlIiwid2VicGFjazovL1NRTGl0ZS1TYW1wbGUyLy4vc3JjL2pzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBzcWxpdGUzSW5pdE1vZHVsZSB9IGZyb20gJy4vc3FsaXRlLXdhc20vanN3YXNtL3NxbGl0ZTMtYnVuZGxlci1mcmllbmRseS5tanMnO1xuaW1wb3J0ICcuL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLXdvcmtlcjEtcHJvbWlzZXItYnVuZGxlci1mcmllbmRseS5qcyc7XG5cbmNvbnN0IHNxbGl0ZTNXb3JrZXIxUHJvbWlzZXIgPSBzZWxmLnNxbGl0ZTNXb3JrZXIxUHJvbWlzZXI7XG5cbmV4cG9ydCBkZWZhdWx0IHNxbGl0ZTNJbml0TW9kdWxlO1xuZXhwb3J0IHsgc3FsaXRlM1dvcmtlcjFQcm9taXNlciB9O1xuIiwiLypcbiAqKiBMSUNFTlNFIGZvciB0aGUgc3FsaXRlMyBXZWJBc3NlbWJseS9KYXZhU2NyaXB0IEFQSXMuXG4gKipcbiAqKiBUaGlzIGJ1bmRsZSAodHlwaWNhbGx5IHJlbGVhc2VkIGFzIHNxbGl0ZTMuanMgb3Igc3FsaXRlMy5tanMpXG4gKiogaXMgYW4gYW1hbGdhbWF0aW9uIG9mIEphdmFTY3JpcHQgc291cmNlIGNvZGUgZnJvbSB0d28gcHJvamVjdHM6XG4gKipcbiAqKiAxKSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnOiB0aGUgRW1zY3JpcHRlbiBcImdsdWUgY29kZVwiIGlzIGNvdmVyZWQgYnlcbiAqKiAgICB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlIGFuZCBVbml2ZXJzaXR5IG9mIElsbGlub2lzL05DU0FcbiAqKiAgICBPcGVuIFNvdXJjZSBMaWNlbnNlLCBhcyBkZXNjcmliZWQgYXQ6XG4gKipcbiAqKiAgICBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvaW50cm9kdWNpbmdfZW1zY3JpcHRlbi9lbXNjcmlwdGVuX2xpY2Vuc2UuaHRtbFxuICoqXG4gKiogMikgaHR0cHM6Ly9zcWxpdGUub3JnOiBhbGwgY29kZSBhbmQgZG9jdW1lbnRhdGlvbiBsYWJlbGVkIGFzIGJlaW5nXG4gKiogICAgZnJvbSB0aGlzIHNvdXJjZSBhcmUgcmVsZWFzZWQgdW5kZXIgdGhlIHNhbWUgdGVybXMgYXMgdGhlIHNxbGl0ZTNcbiAqKiAgICBDIGxpYnJhcnk6XG4gKipcbiAqKiAyMDIyLTEwLTE2XG4gKipcbiAqKiBUaGUgYXV0aG9yIGRpc2NsYWltcyBjb3B5cmlnaHQgdG8gdGhpcyBzb3VyY2UgY29kZS4gIEluIHBsYWNlIG9mIGFcbiAqKiBsZWdhbCBub3RpY2UsIGhlcmUgaXMgYSBibGVzc2luZzpcbiAqKlxuICoqICogICBNYXkgeW91IGRvIGdvb2QgYW5kIG5vdCBldmlsLlxuICoqICogICBNYXkgeW91IGZpbmQgZm9yZ2l2ZW5lc3MgZm9yIHlvdXJzZWxmIGFuZCBmb3JnaXZlIG90aGVycy5cbiAqKiAqICAgTWF5IHlvdSBzaGFyZSBmcmVlbHksIG5ldmVyIHRha2luZyBtb3JlIHRoYW4geW91IGdpdmUuXG4gKi9cbi8qXG4gKiogVGhpcyBjb2RlIHdhcyBidWlsdCBmcm9tIHNxbGl0ZTMgdmVyc2lvbi4uLlxuICoqXG4gKiogU1FMSVRFX1ZFUlNJT04gXCIzLjQ1LjNcIlxuICoqIFNRTElURV9WRVJTSU9OX05VTUJFUiAzMDQ1MDAzXG4gKiogU1FMSVRFX1NPVVJDRV9JRCBcIjIwMjQtMDQtMTUgMTM6MzQ6MDUgODY1M2I3NTg4NzBlNmVmMGM5OGQ0NmIzYWNlMjc4NDkwNTRhZjg1ZGE4OTFlYjEyMWU5YWFhNTM3ZjFlODM1NVwiXG4gKipcbiAqKiBVc2luZyB0aGUgRW1zY3JpcHRlbiBTREsgdmVyc2lvbiAzLjEuMzAuXG4gKi9cblxudmFyIHNxbGl0ZTNJbml0TW9kdWxlID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHREaXIgPSBpbXBvcnQubWV0YS51cmw7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB2YXIgc3FsaXRlM0luaXRNb2R1bGUgPSBjb25maWcgfHwge307XG5cbiAgICB2YXIgTW9kdWxlID1cbiAgICAgIHR5cGVvZiBzcWxpdGUzSW5pdE1vZHVsZSAhPSAndW5kZWZpbmVkJyA/IHNxbGl0ZTNJbml0TW9kdWxlIDoge307XG5cbiAgICB2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSwgcmVhZHlQcm9taXNlUmVqZWN0O1xuICAgIE1vZHVsZVsncmVhZHknXSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcmVhZHlQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUgfHxcbiAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICBkZWJ1Z01vZHVsZTogKCkgPT4ge30sXG4gICAgICB9KTtcbiAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlO1xuICAgIHNxbGl0ZTNJbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoXG4gICAgICAnZ2xvYmFsVGhpcy5sb2NhdGlvbiA9JyxcbiAgICAgIGdsb2JhbFRoaXMubG9jYXRpb24sXG4gICAgKTtcblxuICAgIGNvbnN0IHhOYW1lT2ZJbnN0YW50aWF0ZVdhc20gPSBmYWxzZVxuICAgICAgPyAnaW5zdGFudGlhdGVXYXNtJ1xuICAgICAgOiAnZW1zY3JpcHRlbi1idWctMTc5NTEnO1xuICAgIE1vZHVsZVt4TmFtZU9mSW5zdGFudGlhdGVXYXNtXSA9IGZ1bmN0aW9uIGNhbGxlZShpbXBvcnRzLCBvblN1Y2Nlc3MpIHtcbiAgICAgIGltcG9ydHMuZW52LmZvbyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgY29uc3QgdXJpID0gTW9kdWxlLmxvY2F0ZUZpbGUoXG4gICAgICAgIGNhbGxlZS51cmksXG4gICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2Ygc2NyaXB0RGlyZWN0b3J5ID8gJycgOiBzY3JpcHREaXJlY3RvcnksXG4gICAgICApO1xuICAgICAgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZSgnaW5zdGFudGlhdGVXYXNtKCkgdXJpID0nLCB1cmkpO1xuICAgICAgY29uc3Qgd2ZldGNoID0gKCkgPT4gZmV0Y2godXJpLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pO1xuICAgICAgY29uc3QgbG9hZFdhc20gPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ1xuICAgICAgICA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh3ZmV0Y2goKSwgaW1wb3J0cykudGhlbihcbiAgICAgICAgICAgICAgKGFyZykgPT4gb25TdWNjZXNzKGFyZy5pbnN0YW5jZSwgYXJnLm1vZHVsZSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gd2ZldGNoKClcbiAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgICAgICAudGhlbigoYnl0ZXMpID0+IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKSlcbiAgICAgICAgICAgICAgLnRoZW4oKGFyZykgPT4gb25TdWNjZXNzKGFyZy5pbnN0YW5jZSwgYXJnLm1vZHVsZSkpO1xuICAgICAgICAgIH07XG4gICAgICBsb2FkV2FzbSgpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG5cbiAgICBNb2R1bGVbeE5hbWVPZkluc3RhbnRpYXRlV2FzbV0udXJpID0gJ3NxbGl0ZTMud2FzbSc7XG5cbiAgICB2YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcblxuICAgIHZhciBhcmd1bWVudHNfID0gW107XG4gICAgdmFyIHRoaXNQcm9ncmFtID0gJy4vdGhpcy5wcm9ncmFtJztcbiAgICB2YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gICAgICB0aHJvdyB0b1Rocm93O1xuICAgIH07XG5cbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfV0VCID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JztcbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gJ2Z1bmN0aW9uJztcblxuICAgIHZhciBFTlZJUk9OTUVOVF9JU19OT0RFID1cbiAgICAgIHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSAnc3RyaW5nJztcbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPVxuICAgICAgIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG4gICAgdmFyIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICAgIGZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xuICAgICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICAgIHJldHVybiBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG4gICAgfVxuXG4gICAgdmFyIHJlYWRfLCByZWFkQXN5bmMsIHJlYWRCaW5hcnksIHNldFdpbmRvd1RpdGxlO1xuXG4gICAgaWYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgICAgIH1cblxuICAgICAgaWYgKF9zY3JpcHREaXIpIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKCdibG9iOicpICE9PSAwKSB7XG4gICAgICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywgJycpLmxhc3RJbmRleE9mKCcvJykgKyAxLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVhZF8gPSAodXJsKSA9PiB7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICAgICAgICAgcmVhZEJpbmFyeSA9ICh1cmwpID0+IHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZEFzeW5jID0gKHVybCwgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB4aHIub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNldFdpbmRvd1RpdGxlID0gKHRpdGxlKSA9PiAoZG9jdW1lbnQudGl0bGUgPSB0aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gTW9kdWxlWydwcmludCddIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgdmFyIGVyciA9IE1vZHVsZVsncHJpbnRFcnInXSB8fCBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcblxuICAgIE9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuXG4gICAgbW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcblxuICAgIGlmIChNb2R1bGVbJ2FyZ3VtZW50cyddKSBhcmd1bWVudHNfID0gTW9kdWxlWydhcmd1bWVudHMnXTtcblxuICAgIGlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO1xuXG4gICAgaWYgKE1vZHVsZVsncXVpdCddKSBxdWl0XyA9IE1vZHVsZVsncXVpdCddO1xuXG4gICAgdmFyIFNUQUNLX0FMSUdOID0gMTY7XG4gICAgdmFyIFBPSU5URVJfU0laRSA9IDQ7XG5cbiAgICBmdW5jdGlvbiBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgIGNhc2UgJ3U4JzpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgY2FzZSAndTE2JzpcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgY2FzZSAndTMyJzpcbiAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgY2FzZSAndTY0JzpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICAgICAgICByZXR1cm4gUE9JTlRFUl9TSVpFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZVswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gTnVtYmVyKHR5cGUuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgICAgYml0cyAlIDggPT09IDAsXG4gICAgICAgICAgICAgICdnZXROYXRpdmVUeXBlU2l6ZSBpbnZhbGlkIGJpdHMgJyArIGJpdHMgKyAnLCB0eXBlICcgKyB0eXBlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBiaXRzIC8gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2FzbUJpbmFyeTtcbiAgICBpZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHdhc21CaW5hcnkgPSBNb2R1bGVbJ3dhc21CaW5hcnknXTtcbiAgICB2YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVsnbm9FeGl0UnVudGltZSddIHx8IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9ICdvYmplY3QnKSB7XG4gICAgICBhYm9ydCgnbm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIHZhciB3YXNtTWVtb3J5O1xuXG4gICAgdmFyIEFCT1JUID0gZmFsc2U7XG5cbiAgICB2YXIgRVhJVFNUQVRVUztcblxuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGFib3J0KHRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBVVEY4RGVjb2RlciA9XG4gICAgICB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuICAgIGZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXBPckFycmF5LCBpZHgsIG1heEJ5dGVzVG9SZWFkKSB7XG4gICAgICB2YXIgZW5kSWR4ID0gaWR4ICsgbWF4Qnl0ZXNUb1JlYWQ7XG4gICAgICB2YXIgZW5kUHRyID0gaWR4O1xuXG4gICAgICB3aGlsZSAoaGVhcE9yQXJyYXlbZW5kUHRyXSAmJiAhKGVuZFB0ciA+PSBlbmRJZHgpKSArK2VuZFB0cjtcblxuICAgICAgaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIGhlYXBPckFycmF5LmJ1ZmZlciAmJiBVVEY4RGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgICAgICAgdmFyIHUwID0gaGVhcE9yQXJyYXlbaWR4KytdO1xuICAgICAgICBpZiAoISh1MCAmIDB4ODApKSB7XG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1MSA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgICBpZiAoKHUwICYgMHhlMCkgPT0gMHhjMCkge1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgodTAgJiAzMSkgPDwgNikgfCB1MSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICAgIGlmICgodTAgJiAweGYwKSA9PSAweGUwKSB7XG4gICAgICAgICAgdTAgPSAoKHUwICYgMTUpIDw8IDEyKSB8ICh1MSA8PCA2KSB8IHUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHUwID1cbiAgICAgICAgICAgICgodTAgJiA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgKHUxIDw8IDEyKSB8XG4gICAgICAgICAgICAodTIgPDwgNikgfFxuICAgICAgICAgICAgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1MCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoID0gdTAgLSAweDEwMDAwO1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgMHhkODAwIHwgKGNoID4+IDEwKSxcbiAgICAgICAgICAgIDB4ZGMwMCB8IChjaCAmIDB4M2ZmKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7XG4gICAgICByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgICAgIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKSByZXR1cm4gMDtcblxuICAgICAgdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xuICAgICAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAodSA+PSAweGQ4MDAgJiYgdSA8PSAweGRmZmYpIHtcbiAgICAgICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgICAgIHUgPSAoMHgxMDAwMCArICgodSAmIDB4M2ZmKSA8PCAxMCkpIHwgKHUxICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1IDw9IDB4N2YpIHtcbiAgICAgICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSB1O1xuICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMHg3ZmYpIHtcbiAgICAgICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhjMCB8ICh1ID4+IDYpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgaWYgKG91dElkeCArIDIgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ZTAgfCAodSA+PiAxMik7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvdXRJZHggKyAzID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweGYwIHwgKHUgPj4gMTgpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhlYXBbb3V0SWR4XSA9IDA7XG4gICAgICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgICAgIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHtcbiAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMHg3Zikge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPD0gMHg3ZmYpIHtcbiAgICAgICAgICBsZW4gKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGZmZikge1xuICAgICAgICAgIGxlbiArPSA0O1xuICAgICAgICAgICsraTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW4gKz0gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9XG5cbiAgICB2YXIgSEVBUCxcbiAgICAgIEhFQVA4LFxuICAgICAgSEVBUFU4LFxuICAgICAgSEVBUDE2LFxuICAgICAgSEVBUFUxNixcbiAgICAgIEhFQVAzMixcbiAgICAgIEhFQVBVMzIsXG4gICAgICBIRUFQRjMyLFxuICAgICAgSEVBUDY0LFxuICAgICAgSEVBUFU2NCxcbiAgICAgIEhFQVBGNjQ7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpIHtcbiAgICAgIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gICAgICBNb2R1bGVbJ0hFQVA4J10gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVAxNiddID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBVMTYnXSA9IEhFQVBVMTYgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBGMzInXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQRjY0J10gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUDY0J10gPSBIRUFQNjQgPSBuZXcgQmlnSW50NjRBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUFU2NCddID0gSEVBUFU2NCA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbiAgICB9XG5cbiAgICB2YXIgU1RBQ0tfU0laRSA9IDUyNDI4ODtcblxuICAgIHZhciBJTklUSUFMX01FTU9SWSA9IE1vZHVsZVsnSU5JVElBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjtcblxuICAgIGlmIChNb2R1bGVbJ3dhc21NZW1vcnknXSkge1xuICAgICAgd2FzbU1lbW9yeSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXNtTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAgIGluaXRpYWw6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzYsXG5cbiAgICAgICAgbWF4aW11bTogMjE0NzQ4MzY0OCAvIDY1NTM2LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcblxuICAgIElOSVRJQUxfTUVNT1JZID0gd2FzbU1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aDtcblxuICAgIHZhciB3YXNtVGFibGU7XG5cbiAgICB2YXIgX19BVFBSRVJVTl9fID0gW107XG4gICAgdmFyIF9fQVRJTklUX18gPSBbXTtcbiAgICB2YXIgX19BVEVYSVRfXyA9IFtdO1xuICAgIHZhciBfX0FUUE9TVFJVTl9fID0gW107XG5cbiAgICB2YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuICAgICAgcmV0dXJuIG5vRXhpdFJ1bnRpbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUnVuKCkge1xuICAgICAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZVJ1biddID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICAgICAgd2hpbGUgKE1vZHVsZVsncHJlUnVuJ10ubGVuZ3RoKSB7XG4gICAgICAgICAgYWRkT25QcmVSdW4oTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuICAgICAgcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgaWYgKCFNb2R1bGVbJ25vRlNJbml0J10gJiYgIUZTLmluaXQuaW5pdGlhbGl6ZWQpIEZTLmluaXQoKTtcbiAgICAgIEZTLmlnbm9yZVBlcm1pc3Npb25zID0gZmFsc2U7XG5cbiAgICAgIFRUWS5pbml0KCk7XG4gICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3N0UnVuKCkge1xuICAgICAgaWYgKE1vZHVsZVsncG9zdFJ1biddKSB7XG4gICAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtNb2R1bGVbJ3Bvc3RSdW4nXV07XG4gICAgICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgICAgICBhZGRPblBvc3RSdW4oTW9kdWxlWydwb3N0UnVuJ10uc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgICAgIF9fQVRJTklUX18udW5zaGlmdChjYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT25FeGl0KGNiKSB7fVxuXG4gICAgZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gICAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xuICAgIH1cblxuICAgIHZhciBydW5EZXBlbmRlbmNpZXMgPSAwO1xuICAgIHZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG4gICAgdmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICAgICAgcnVuRGVwZW5kZW5jaWVzKys7XG5cbiAgICAgIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgICAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgICAgIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gICAgICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICAgICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gICAgICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xuICAgICAgICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcbiAgICAgIGlmIChNb2R1bGVbJ29uQWJvcnQnXSkge1xuICAgICAgICBNb2R1bGVbJ29uQWJvcnQnXSh3aGF0KTtcbiAgICAgIH1cblxuICAgICAgd2hhdCA9ICdBYm9ydGVkKCcgKyB3aGF0ICsgJyknO1xuXG4gICAgICBlcnIod2hhdCk7XG5cbiAgICAgIEFCT1JUID0gdHJ1ZTtcbiAgICAgIEVYSVRTVEFUVVMgPSAxO1xuXG4gICAgICB3aGF0ICs9ICcuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uJztcblxuICAgICAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuXG4gICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cbiAgICBmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRmlsZVVSSShmaWxlbmFtZSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcbiAgICB9XG5cbiAgICB2YXIgd2FzbUJpbmFyeUZpbGU7XG4gICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICB3YXNtQmluYXJ5RmlsZSA9ICdzcWxpdGUzLndhc20nO1xuICAgICAgaWYgKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICAgICAgIHdhc21CaW5hcnlGaWxlID0gbG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhc21CaW5hcnlGaWxlID0gbmV3IFVSTCgnc3FsaXRlMy53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkQmluYXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgJ2JvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkJztcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhYm9ydChlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKSB7XG4gICAgICBpZiAoIXdhc21CaW5hcnkgJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgICBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgd2FzbUJpbmFyeUZpbGUgKyBcIidcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICBlbnY6IGFzbUxpYnJhcnlBcmcsXG4gICAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IGFzbUxpYnJhcnlBcmcsXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgICAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG5cbiAgICAgICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7XG5cbiAgICAgICAgd2FzbVRhYmxlID0gTW9kdWxlWydhc20nXVsnX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZSddO1xuXG4gICAgICAgIGFkZE9uSW5pdChNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKTtcblxuICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICAgICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKClcbiAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4ocmVjZWl2ZXIsIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIGVycignZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJyArIHJlYXNvbik7XG5cbiAgICAgICAgICAgIGFib3J0KHJlYXNvbik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2FzbUJpbmFyeSAmJlxuICAgICAgICAgIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkgJiZcbiAgICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSkudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGluZm8pO1xuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGVycignd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICcgKyByZWFzb24pO1xuICAgICAgICAgICAgICAgIGVycignZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBleHBvcnRzID0gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyKCdNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZSk7XG5cbiAgICAgICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5zdGFudGlhdGVBc3luYygpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBEb3VibGU7XG4gICAgdmFyIHRlbXBJNjQ7XG5cbiAgICB2YXIgQVNNX0NPTlNUUyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHRoaXMubmFtZSA9ICdFeGl0U3RhdHVzJztcbiAgICAgIHRoaXMubWVzc2FnZSA9ICdQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCcgKyBzdGF0dXMgKyAnKSc7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSAnKic7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgIHJldHVybiBIRUFQOFtwdHIgPj4gMF07XG4gICAgICAgIGNhc2UgJ2k4JzpcbiAgICAgICAgICByZXR1cm4gSEVBUDhbcHRyID4+IDBdO1xuICAgICAgICBjYXNlICdpMTYnOlxuICAgICAgICAgIHJldHVybiBIRUFQMTZbcHRyID4+IDFdO1xuICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgIHJldHVybiBIRUFQMzJbcHRyID4+IDJdO1xuICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgIHJldHVybiBIRUFQNjRbcHRyID4+IDNdO1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgcmV0dXJuIEhFQVBGMzJbcHRyID4+IDJdO1xuICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgIHJldHVybiBIRUFQRjY0W3B0ciA+PiAzXTtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmV0dXJuIEhFQVBVMzJbcHRyID4+IDJdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAnICsgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gJ2k4Jykge1xuICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9ICcqJztcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpMSc6XG4gICAgICAgICAgSEVBUDhbcHRyID4+IDBdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2k4JzpcbiAgICAgICAgICBIRUFQOFtwdHIgPj4gMF0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICBIRUFQMTZbcHRyID4+IDFdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2kzMic6XG4gICAgICAgICAgSEVBUDMyW3B0ciA+PiAyXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgICAgdmFsdWUgPj4+IDAsXG4gICAgICAgICAgICAoKHRlbXBEb3VibGUgPSB2YWx1ZSksXG4gICAgICAgICAgICArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMS4wXG4gICAgICAgICAgICAgID8gdGVtcERvdWJsZSA+IDAuMFxuICAgICAgICAgICAgICAgID8gKE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5Ni4wKSxcbiAgICAgICAgICAgICAgICAgICAgNDI5NDk2NzI5NS4wLFxuICAgICAgICAgICAgICAgICAgKSB8XG4gICAgICAgICAgICAgICAgICAgIDApID4+PlxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIDogfn4rTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICAodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2LjAsXG4gICAgICAgICAgICAgICAgICApID4+PiAwXG4gICAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgICAoSEVBUDMyW3B0ciA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgICAgKEhFQVAzMlsocHRyICsgNCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgIEhFQVBGMzJbcHRyID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgSEVBUEY2NFtwdHIgPj4gM10gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgSEVBUFUzMltwdHIgPj4gMl0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhYm9ydCgnaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJyArIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQQVRIID0ge1xuICAgICAgaXNBYnM6IChwYXRoKSA9PiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgICAgc3BsaXRQYXRoOiAoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID1cbiAgICAgICAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZUFycmF5OiAocGFydHMsIGFsbG93QWJvdmVSb290KSA9PiB7XG4gICAgICAgIHZhciB1cCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGZvciAoOyB1cDsgdXAtLSkge1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZTogKHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBQQVRILmlzQWJzKHBhdGgpLFxuICAgICAgICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnN1YnN0cigtMSkgPT09ICcvJztcblxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShcbiAgICAgICAgICBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApLFxuICAgICAgICAgICFpc0Fic29sdXRlLFxuICAgICAgICApLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgICAgICAgcGF0aCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbiAgICAgIH0sXG4gICAgICBkaXJuYW1lOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgcmVzdWx0ID0gUEFUSC5zcGxpdFBhdGgocGF0aCksXG4gICAgICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgICAgICBkaXIgPSByZXN1bHRbMV07XG4gICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QgKyBkaXI7XG4gICAgICB9LFxuICAgICAgYmFzZW5hbWU6IChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gLTEpIHJldHVybiBwYXRoO1xuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoICsgMSk7XG4gICAgICB9LFxuICAgICAgam9pbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbignLycpKTtcbiAgICAgIH0sXG4gICAgICBqb2luMjogKGwsIHIpID0+IHtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFJhbmRvbURldmljZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGNyeXB0byA9PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvWydnZXRSYW5kb21WYWx1ZXMnXSA9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdmFyIHJhbmRvbUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnVmZmVyKTtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tQnVmZmVyWzBdO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHJldHVybiAoKSA9PiBhYm9ydCgncmFuZG9tRGV2aWNlJyk7XG4gICAgfVxuXG4gICAgdmFyIFBBVEhfRlMgPSB7XG4gICAgICByZXNvbHZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSBpID49IDAgPyBhcmd1bWVudHNbaV0gOiBGUy5jd2QoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IFBBVEguaXNBYnMocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlZFBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KFxuICAgICAgICAgIHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKSxcbiAgICAgICAgICAhcmVzb2x2ZWRBYnNvbHV0ZSxcbiAgICAgICAgKS5qb2luKCcvJyk7XG4gICAgICAgIHJldHVybiAocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCB8fCAnLic7XG4gICAgICB9LFxuICAgICAgcmVsYXRpdmU6IChmcm9tLCB0bykgPT4ge1xuICAgICAgICBmcm9tID0gUEFUSF9GUy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgICAgICAgdG8gPSBQQVRIX0ZTLnJlc29sdmUodG8pLnN1YnN0cigxKTtcbiAgICAgICAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICAgICAgICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksIGRvbnRBZGROdWxsLCBsZW5ndGgpIHtcbiAgICAgIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpICsgMTtcbiAgICAgIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gICAgICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoXG4gICAgICAgIHN0cmluZ3ksXG4gICAgICAgIHU4YXJyYXksXG4gICAgICAgIDAsXG4gICAgICAgIHU4YXJyYXkubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XG4gICAgICByZXR1cm4gdThhcnJheTtcbiAgICB9XG4gICAgdmFyIFRUWSA9IHtcbiAgICAgIHR0eXM6IFtdLFxuICAgICAgaW5pdDogZnVuY3Rpb24gKCkge30sXG4gICAgICBzaHV0ZG93bjogZnVuY3Rpb24gKCkge30sXG4gICAgICByZWdpc3RlcjogZnVuY3Rpb24gKGRldiwgb3BzKSB7XG4gICAgICAgIFRUWS50dHlzW2Rldl0gPSB7IGlucHV0OiBbXSwgb3V0cHV0OiBbXSwgb3BzOiBvcHMgfTtcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCBUVFkuc3RyZWFtX29wcyk7XG4gICAgICB9LFxuICAgICAgc3RyZWFtX29wczoge1xuICAgICAgICBvcGVuOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO1xuICAgICAgICAgIGlmICghdHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS50dHkgPSB0dHk7XG4gICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZzeW5jOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICBieXRlc1JlYWQrKztcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIoc3RyZWFtLnR0eSwgYnVmZmVyW29mZnNldCArIGldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRfdHR5X29wczoge1xuICAgICAgICBnZXRfY2hhcjogZnVuY3Rpb24gKHR0eSkge1xuICAgICAgICAgIGlmICghdHR5LmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdy5wcm9tcHQgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoJ0lucHV0OiAnKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGxpbmUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZWFkbGluZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR0eS5pbnB1dCA9IGludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHR5LmlucHV0LnNoaWZ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1dF9jaGFyOiBmdW5jdGlvbiAodHR5LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHtcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmc3luYzogZnVuY3Rpb24gKHR0eSkge1xuICAgICAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZGVmYXVsdF90dHkxX29wczoge1xuICAgICAgICBwdXRfY2hhcjogZnVuY3Rpb24gKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnN5bmM6IGZ1bmN0aW9uICh0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gemVyb01lbW9yeShhZGRyZXNzLCBzaXplKSB7XG4gICAgICBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLCBhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoc2l6ZSAvIGFsaWdubWVudCkgKiBhbGlnbm1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1tYXBBbGxvYyhzaXplKSB7XG4gICAgICBzaXplID0gYWxpZ25NZW1vcnkoc2l6ZSwgNjU1MzYpO1xuICAgICAgdmFyIHB0ciA9IF9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24oNjU1MzYsIHNpemUpO1xuICAgICAgaWYgKCFwdHIpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHplcm9NZW1vcnkocHRyLCBzaXplKTtcbiAgICB9XG4gICAgdmFyIE1FTUZTID0ge1xuICAgICAgb3BzX3RhYmxlOiBudWxsLFxuICAgICAgbW91bnQ6IGZ1bmN0aW9uIChtb3VudCkge1xuICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShudWxsLCAnLycsIDE2Mzg0IHwgNTExLCAwKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU1FTUZTLm9wc190YWJsZSkge1xuICAgICAgICAgIE1FTUZTLm9wc190YWJsZSA9IHtcbiAgICAgICAgICAgIGRpcjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgICAgIGxvb2t1cDogTUVNRlMubm9kZV9vcHMubG9va3VwLFxuICAgICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCxcbiAgICAgICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSxcbiAgICAgICAgICAgICAgICB1bmxpbms6IE1FTUZTLm5vZGVfb3BzLnVubGluayxcbiAgICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsXG4gICAgICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpcixcbiAgICAgICAgICAgICAgICBzeW1saW5rOiBNRU1GUy5ub2RlX29wcy5zeW1saW5rLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayxcbiAgICAgICAgICAgICAgICByZWFkOiBNRU1GUy5zdHJlYW1fb3BzLnJlYWQsXG4gICAgICAgICAgICAgICAgd3JpdGU6IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUsXG4gICAgICAgICAgICAgICAgYWxsb2NhdGU6IE1FTUZTLnN0cmVhbV9vcHMuYWxsb2NhdGUsXG4gICAgICAgICAgICAgICAgbW1hcDogTUVNRlMuc3RyZWFtX29wcy5tbWFwLFxuICAgICAgICAgICAgICAgIG1zeW5jOiBNRU1GUy5zdHJlYW1fb3BzLm1zeW5jLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgICByZWFkbGluazogTUVNRlMubm9kZV9vcHMucmVhZGxpbmssXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbToge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hyZGV2OiB7XG4gICAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIuc3RyZWFtO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLnN0cmVhbTtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG5cbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUubGluay5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLnN0cmVhbTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5jb250ZW50c1tuYW1lXSA9IG5vZGU7XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IG5vZGUudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGdldEZpbGVEYXRhQXNUeXBlZEFycmF5OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpXG4gICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobm9kZS5jb250ZW50cyk7XG4gICAgICB9LFxuICAgICAgZXhwYW5kRmlsZVN0b3JhZ2U6IGZ1bmN0aW9uIChub2RlLCBuZXdDYXBhY2l0eSkge1xuICAgICAgICB2YXIgcHJldkNhcGFjaXR5ID0gbm9kZS5jb250ZW50cyA/IG5vZGUuY29udGVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSA+PSBuZXdDYXBhY2l0eSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBDQVBBQ0lUWV9ET1VCTElOR19NQVggPSAxMDI0ICogMTAyNDtcbiAgICAgICAgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChcbiAgICAgICAgICBuZXdDYXBhY2l0eSxcbiAgICAgICAgICAocHJldkNhcGFjaXR5ICpcbiAgICAgICAgICAgIChwcmV2Q2FwYWNpdHkgPCBDQVBBQ0lUWV9ET1VCTElOR19NQVggPyAyLjAgOiAxLjEyNSkpID4+PlxuICAgICAgICAgICAgMCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSAhPSAwKSBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAyNTYpO1xuICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO1xuICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPiAwKVxuICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKSwgMCk7XG4gICAgICB9LFxuICAgICAgcmVzaXplRmlsZVN0b3JhZ2U6IGZ1bmN0aW9uIChub2RlLCBuZXdTaXplKSB7XG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA9PSBuZXdTaXplKSByZXR1cm47XG4gICAgICAgIGlmIChuZXdTaXplID09IDApIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50cztcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7XG4gICAgICAgICAgaWYgKG9sZENvbnRlbnRzKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChcbiAgICAgICAgICAgICAgb2xkQ29udGVudHMuc3ViYXJyYXkoMCwgTWF0aC5taW4obmV3U2l6ZSwgbm9kZS51c2VkQnl0ZXMpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbmV3U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vZGVfb3BzOiB7XG4gICAgICAgIGdldGF0dHI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSB7fTtcblxuICAgICAgICAgIGF0dHIuZGV2ID0gRlMuaXNDaHJkZXYobm9kZS5tb2RlKSA/IG5vZGUuaWQgOiAxO1xuICAgICAgICAgIGF0dHIuaW5vID0gbm9kZS5pZDtcbiAgICAgICAgICBhdHRyLm1vZGUgPSBub2RlLm1vZGU7XG4gICAgICAgICAgYXR0ci5ubGluayA9IDE7XG4gICAgICAgICAgYXR0ci51aWQgPSAwO1xuICAgICAgICAgIGF0dHIuZ2lkID0gMDtcbiAgICAgICAgICBhdHRyLnJkZXYgPSBub2RlLnJkZXY7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDQwOTY7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS5saW5rLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0ci5hdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBhdHRyLm10aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG5cbiAgICAgICAgICBhdHRyLmJsa3NpemUgPSA0MDk2O1xuICAgICAgICAgIGF0dHIuYmxvY2tzID0gTWF0aC5jZWlsKGF0dHIuc2l6ZSAvIGF0dHIuYmxrc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldGF0dHI6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgICAgaWYgKGF0dHIubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnRpbWVzdGFtcCA9IGF0dHIudGltZXN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE1FTUZTLnJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsIGF0dHIuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBGUy5nZW5lcmljRXJyb3JzWzQ0XTtcbiAgICAgICAgfSxcbiAgICAgICAgbWtub2Q6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikge1xuICAgICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKSB7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbmV3X25vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIGlmIChuZXdfbm9kZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG5ld19ub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIG9sZF9ub2RlLnBhcmVudC5jb250ZW50c1tvbGRfbm9kZS5uYW1lXTtcbiAgICAgICAgICBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBvbGRfbm9kZS5uYW1lID0gbmV3X25hbWU7XG4gICAgICAgICAgbmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV0gPSBvbGRfbm9kZTtcbiAgICAgICAgICBuZXdfZGlyLnRpbWVzdGFtcCA9IG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgb2xkX25vZGUucGFyZW50ID0gbmV3X2RpcjtcbiAgICAgICAgfSxcbiAgICAgICAgdW5saW5rOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm1kaXI6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG5vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGRpcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IFsnLicsICcuLiddO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAgc3ltbGluazogZnVuY3Rpb24gKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCkge1xuICAgICAgICAgIHZhciBub2RlID0gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5ld25hbWUsIDUxMSB8IDQwOTYwLCAwKTtcbiAgICAgICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuICAgICAgICByZWFkbGluazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmxpbms7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgc3RyZWFtX29wczoge1xuICAgICAgICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBzdHJlYW0ubm9kZS51c2VkQnl0ZXMpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKHNpemUgPiA4ICYmIGNvbnRlbnRzLnN1YmFycmF5KSB7XG4gICAgICAgICAgICBidWZmZXIuc2V0KGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIHNpemUpLCBvZmZzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xuICAgICAgICAgICAgY2FuT3duID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBub2RlID0gc3RyZWFtLm5vZGU7XG4gICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHtcbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnVzZWRCeXRlcyA9PT0gMCAmJiBwb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uICsgbGVuZ3RoIDw9IG5vZGUudXNlZEJ5dGVzKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KFxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5ICYmIGJ1ZmZlci5zdWJhcnJheSkge1xuICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoXG4gICAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzW3Bvc2l0aW9uICsgaV0gPSBidWZmZXJbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBsbHNlZWs6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBhbGxvY2F0ZTogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShzdHJlYW0ubm9kZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnVzZWRCeXRlcyxcbiAgICAgICAgICAgIG9mZnNldCArIGxlbmd0aCxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBtbWFwOiBmdW5jdGlvbiAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykge1xuICAgICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwdHI7XG4gICAgICAgICAgdmFyIGFsbG9jYXRlZDtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcblxuICAgICAgICAgIGlmICghKGZsYWdzICYgMikgJiYgY29udGVudHMuYnVmZmVyID09PSBIRUFQOC5idWZmZXIpIHtcbiAgICAgICAgICAgIGFsbG9jYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcHRyID0gY29udGVudHMuYnl0ZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMCB8fCBwb3NpdGlvbiArIGxlbmd0aCA8IGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoY29udGVudHMuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiArIGxlbmd0aCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQOC5zZXQoY29udGVudHMsIHB0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IGFsbG9jYXRlZCB9O1xuICAgICAgICB9LFxuICAgICAgICBtc3luYzogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgICAgTUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgMCwgbGVuZ3RoLCBvZmZzZXQsIGZhbHNlKTtcblxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYXN5bmNMb2FkKHVybCwgb25sb2FkLCBvbmVycm9yLCBub1J1bkRlcCkge1xuICAgICAgdmFyIGRlcCA9ICFub1J1bkRlcCA/IGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koJ2FsICcgKyB1cmwpIDogJyc7XG4gICAgICByZWFkQXN5bmMoXG4gICAgICAgIHVybCxcbiAgICAgICAgKGFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgYXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAnTG9hZGluZyBkYXRhIGZpbGUgXCInICsgdXJsICsgJ1wiIGZhaWxlZCAobm8gYXJyYXlCdWZmZXIpLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvbmxvYWQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgICBpZiAoZGVwKSByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgIH0sXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChvbmVycm9yKSB7XG4gICAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdMb2FkaW5nIGRhdGEgZmlsZSBcIicgKyB1cmwgKyAnXCIgZmFpbGVkLic7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIGlmIChkZXApIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICB9XG5cbiAgICB2YXIgRlMgPSB7XG4gICAgICByb290OiBudWxsLFxuICAgICAgbW91bnRzOiBbXSxcbiAgICAgIGRldmljZXM6IHt9LFxuICAgICAgc3RyZWFtczogW10sXG4gICAgICBuZXh0SW5vZGU6IDEsXG4gICAgICBuYW1lVGFibGU6IG51bGwsXG4gICAgICBjdXJyZW50UGF0aDogJy8nLFxuICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgaWdub3JlUGVybWlzc2lvbnM6IHRydWUsXG4gICAgICBFcnJub0Vycm9yOiBudWxsLFxuICAgICAgZ2VuZXJpY0Vycm9yczoge30sXG4gICAgICBmaWxlc3lzdGVtczogbnVsbCxcbiAgICAgIHN5bmNGU1JlcXVlc3RzOiAwLFxuICAgICAgbG9va3VwUGF0aDogKHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBwYXRoID0gUEFUSF9GUy5yZXNvbHZlKHBhdGgpO1xuXG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIHsgcGF0aDogJycsIG5vZGU6IG51bGwgfTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgZm9sbG93X21vdW50OiB0cnVlLFxuICAgICAgICAgIHJlY3Vyc2VfY291bnQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcblxuICAgICAgICBpZiAob3B0cy5yZWN1cnNlX2NvdW50ID4gOCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5yb290O1xuICAgICAgICB2YXIgY3VycmVudF9wYXRoID0gJy8nO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNsYXN0ID0gaSA9PT0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTtcblxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQoY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmICghaXNsYXN0IHx8IChpc2xhc3QgJiYgb3B0cy5mb2xsb3dfbW91bnQpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1vdW50ZWQucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvdykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbGluayA9IEZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG5cbiAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoY3VycmVudF9wYXRoLCB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZV9jb3VudDogb3B0cy5yZWN1cnNlX2NvdW50ICsgMSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBsb29rdXAubm9kZTtcblxuICAgICAgICAgICAgICBpZiAoY291bnQrKyA+IDQwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGF0aDogY3VycmVudF9wYXRoLCBub2RlOiBjdXJyZW50IH07XG4gICAgICB9LFxuICAgICAgZ2V0UGF0aDogKG5vZGUpID0+IHtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSkge1xuICAgICAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudC5tb3VudHBvaW50O1xuICAgICAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbW91bnQ7XG4gICAgICAgICAgICByZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoIC0gMV0gIT09ICcvJ1xuICAgICAgICAgICAgICA/IG1vdW50ICsgJy8nICsgcGF0aFxuICAgICAgICAgICAgICA6IG1vdW50ICsgcGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IHBhdGggPyBub2RlLm5hbWUgKyAnLycgKyBwYXRoIDogbm9kZS5uYW1lO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc2hOYW1lOiAocGFyZW50aWQsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZS5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgocGFyZW50aWQgKyBoYXNoKSA+Pj4gMCkgJSBGUy5uYW1lVGFibGUubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGhhc2hBZGROb2RlOiAobm9kZSkgPT4ge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBub2RlLm5hbWVfbmV4dCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZTtcbiAgICAgIH0sXG4gICAgICBoYXNoUmVtb3ZlTm9kZTogKG5vZGUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKEZTLm5hbWVUYWJsZVtoYXNoXSA9PT0gbm9kZSkge1xuICAgICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5uYW1lX25leHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5uYW1lX25leHQgPSBub2RlLm5hbWVfbmV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uYW1lX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbG9va3VwTm9kZTogKHBhcmVudCwgbmFtZSkgPT4ge1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUxvb2t1cChwYXJlbnQpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShwYXJlbnQuaWQsIG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBub2RlID0gRlMubmFtZVRhYmxlW2hhc2hdOyBub2RlOyBub2RlID0gbm9kZS5uYW1lX25leHQpIHtcbiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50LmlkID09PSBwYXJlbnQuaWQgJiYgbm9kZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGUy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlOiAocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSA9PiB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IEZTLkZTTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpO1xuXG4gICAgICAgIEZTLmhhc2hBZGROb2RlKG5vZGUpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lOb2RlOiAobm9kZSkgPT4ge1xuICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShub2RlKTtcbiAgICAgIH0sXG4gICAgICBpc1Jvb3Q6IChub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBub2RlLnBhcmVudDtcbiAgICAgIH0sXG4gICAgICBpc01vdW50cG9pbnQ6IChub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAhIW5vZGUubW91bnRlZDtcbiAgICAgIH0sXG4gICAgICBpc0ZpbGU6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMzI3Njg7XG4gICAgICB9LFxuICAgICAgaXNEaXI6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMTYzODQ7XG4gICAgICB9LFxuICAgICAgaXNMaW5rOiAobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTYwO1xuICAgICAgfSxcbiAgICAgIGlzQ2hyZGV2OiAobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDgxOTI7XG4gICAgICB9LFxuICAgICAgaXNCbGtkZXY6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMjQ1NzY7XG4gICAgICB9LFxuICAgICAgaXNGSUZPOiAobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTY7XG4gICAgICB9LFxuICAgICAgaXNTb2NrZXQ6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDQ5MTUyKSA9PT0gNDkxNTI7XG4gICAgICB9LFxuICAgICAgZmxhZ01vZGVzOiB7IHI6IDAsICdyKyc6IDIsIHc6IDU3NywgJ3crJzogNTc4LCBhOiAxMDg5LCAnYSsnOiAxMDkwIH0sXG4gICAgICBtb2RlU3RyaW5nVG9GbGFnczogKHN0cikgPT4ge1xuICAgICAgICB2YXIgZmxhZ3MgPSBGUy5mbGFnTW9kZXNbc3RyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJyArIHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfSxcbiAgICAgIGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nOiAoZmxhZykgPT4ge1xuICAgICAgICB2YXIgcGVybXMgPSBbJ3InLCAndycsICdydyddW2ZsYWcgJiAzXTtcbiAgICAgICAgaWYgKGZsYWcgJiA1MTIpIHtcbiAgICAgICAgICBwZXJtcyArPSAndyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlcm1zO1xuICAgICAgfSxcbiAgICAgIG5vZGVQZXJtaXNzaW9uczogKG5vZGUsIHBlcm1zKSA9PiB7XG4gICAgICAgIGlmIChGUy5pZ25vcmVQZXJtaXNzaW9ucykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlcm1zLmluY2x1ZGVzKCdyJykgJiYgIShub2RlLm1vZGUgJiAyOTIpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3cnKSAmJiAhKG5vZGUubW9kZSAmIDE0NikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygneCcpICYmICEobm9kZS5tb2RlICYgNzMpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgbWF5TG9va3VwOiAoZGlyKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHJldHVybiBlcnJDb2RlO1xuICAgICAgICBpZiAoIWRpci5ub2RlX29wcy5sb29rdXApIHJldHVybiAyO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBtYXlDcmVhdGU6IChkaXIsIG5hbWUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm4gMjA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKTtcbiAgICAgIH0sXG4gICAgICBtYXlEZWxldGU6IChkaXIsIG5hbWUsIGlzZGlyKSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHJldHVybiBlcnJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc2Rpcikge1xuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDU0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpIHx8IEZTLmdldFBhdGgobm9kZSkgPT09IEZTLmN3ZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gMzE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIG1heU9wZW46IChub2RlLCBmbGFncykgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gNDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBpZiAoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpICE9PSAncicgfHwgZmxhZ3MgJiA1MTIpIHtcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpO1xuICAgICAgfSxcbiAgICAgIE1BWF9PUEVOX0ZEUzogNDA5NixcbiAgICAgIG5leHRmZDogKGZkX3N0YXJ0ID0gMCwgZmRfZW5kID0gRlMuTUFYX09QRU5fRkRTKSA9PiB7XG4gICAgICAgIGZvciAodmFyIGZkID0gZmRfc3RhcnQ7IGZkIDw9IGZkX2VuZDsgZmQrKykge1xuICAgICAgICAgIGlmICghRlMuc3RyZWFtc1tmZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzMpO1xuICAgICAgfSxcbiAgICAgIGdldFN0cmVhbTogKGZkKSA9PiBGUy5zdHJlYW1zW2ZkXSxcbiAgICAgIGNyZWF0ZVN0cmVhbTogKHN0cmVhbSwgZmRfc3RhcnQsIGZkX2VuZCkgPT4ge1xuICAgICAgICBpZiAoIUZTLkZTU3RyZWFtKSB7XG4gICAgICAgICAgRlMuRlNTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZCA9IHt9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgRlMuRlNTdHJlYW0ucHJvdG90eXBlID0ge307XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlMuRlNTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUgPSB2YWw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZWFkOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAxO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzV3JpdGU6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBcHBlbmQ6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxMDI0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYXJlZC5mbGFncztcbiAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZC5mbGFncyA9IHZhbDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWQucG9zaXRpb247XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZWQucG9zaXRpb24gPSB2YWw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtID0gT2JqZWN0LmFzc2lnbihuZXcgRlMuRlNTdHJlYW0oKSwgc3RyZWFtKTtcbiAgICAgICAgdmFyIGZkID0gRlMubmV4dGZkKGZkX3N0YXJ0LCBmZF9lbmQpO1xuICAgICAgICBzdHJlYW0uZmQgPSBmZDtcbiAgICAgICAgRlMuc3RyZWFtc1tmZF0gPSBzdHJlYW07XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgY2xvc2VTdHJlYW06IChmZCkgPT4ge1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7XG4gICAgICB9LFxuICAgICAgY2hyZGV2X3N0cmVhbV9vcHM6IHtcbiAgICAgICAgb3BlbjogKHN0cmVhbSkgPT4ge1xuICAgICAgICAgIHZhciBkZXZpY2UgPSBGUy5nZXREZXZpY2Uoc3RyZWFtLm5vZGUucmRldik7XG5cbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcyA9IGRldmljZS5zdHJlYW1fb3BzO1xuXG4gICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pIHtcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxsc2VlazogKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBtYWpvcjogKGRldikgPT4gZGV2ID4+IDgsXG4gICAgICBtaW5vcjogKGRldikgPT4gZGV2ICYgMHhmZixcbiAgICAgIG1ha2VkZXY6IChtYSwgbWkpID0+IChtYSA8PCA4KSB8IG1pLFxuICAgICAgcmVnaXN0ZXJEZXZpY2U6IChkZXYsIG9wcykgPT4ge1xuICAgICAgICBGUy5kZXZpY2VzW2Rldl0gPSB7IHN0cmVhbV9vcHM6IG9wcyB9O1xuICAgICAgfSxcbiAgICAgIGdldERldmljZTogKGRldikgPT4gRlMuZGV2aWNlc1tkZXZdLFxuICAgICAgZ2V0TW91bnRzOiAobW91bnQpID0+IHtcbiAgICAgICAgdmFyIG1vdW50cyA9IFtdO1xuICAgICAgICB2YXIgY2hlY2sgPSBbbW91bnRdO1xuXG4gICAgICAgIHdoaWxlIChjaGVjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbSA9IGNoZWNrLnBvcCgpO1xuXG4gICAgICAgICAgbW91bnRzLnB1c2gobSk7XG5cbiAgICAgICAgICBjaGVjay5wdXNoLmFwcGx5KGNoZWNrLCBtLm1vdW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW91bnRzO1xuICAgICAgfSxcbiAgICAgIHN5bmNmczogKHBvcHVsYXRlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBvcHVsYXRlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IHBvcHVsYXRlO1xuICAgICAgICAgIHBvcHVsYXRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cysrO1xuXG4gICAgICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHtcbiAgICAgICAgICBlcnIoXG4gICAgICAgICAgICAnd2FybmluZzogJyArXG4gICAgICAgICAgICAgIEZTLnN5bmNGU1JlcXVlc3RzICtcbiAgICAgICAgICAgICAgJyBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhGUy5yb290Lm1vdW50KTtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9DYWxsYmFjayhlcnJDb2RlKSB7XG4gICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyckNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgaWYgKCFkb25lLmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgZG9uZS5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvQ2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2NvbXBsZXRlZCA+PSBtb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb0NhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50cy5mb3JFYWNoKChtb3VudCkgPT4ge1xuICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBtb3VudDogKHR5cGUsIG9wdHMsIG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgdmFyIHJvb3QgPSBtb3VudHBvaW50ID09PSAnLyc7XG4gICAgICAgIHZhciBwc2V1ZG8gPSAhbW91bnRwb2ludDtcbiAgICAgICAgdmFyIG5vZGU7XG5cbiAgICAgICAgaWYgKHJvb3QgJiYgRlMucm9vdCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm9vdCAmJiAhcHNldWRvKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuXG4gICAgICAgICAgbW91bnRwb2ludCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcblxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91bnQgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBvcHRzOiBvcHRzLFxuICAgICAgICAgIG1vdW50cG9pbnQ6IG1vdW50cG9pbnQsXG4gICAgICAgICAgbW91bnRzOiBbXSxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbW91bnRSb290ID0gdHlwZS5tb3VudChtb3VudCk7XG4gICAgICAgIG1vdW50Um9vdC5tb3VudCA9IG1vdW50O1xuICAgICAgICBtb3VudC5yb290ID0gbW91bnRSb290O1xuXG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgRlMucm9vdCA9IG1vdW50Um9vdDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICAgICAgbm9kZS5tb3VudGVkID0gbW91bnQ7XG5cbiAgICAgICAgICBpZiAobm9kZS5tb3VudCkge1xuICAgICAgICAgICAgbm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdW50Um9vdDtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50OiAobW91bnRwb2ludCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG5cbiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudGVkO1xuICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTtcblxuICAgICAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goKGhhc2gpID0+IHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcblxuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnQubmFtZV9uZXh0O1xuXG4gICAgICAgICAgICBpZiAobW91bnRzLmluY2x1ZGVzKGN1cnJlbnQubW91bnQpKSB7XG4gICAgICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGUubW91bnRlZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO1xuICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH0sXG4gICAgICBsb29rdXA6IChwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBta25vZDogKHBhdGgsIG1vZGUsIGRldikgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lID09PSAnLicgfHwgbmFtZSA9PT0gJy4uJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLm1rbm9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubWtub2QocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZTogKHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA0Mzg7XG4gICAgICAgIG1vZGUgJj0gNDA5NTtcbiAgICAgICAgbW9kZSB8PSAzMjc2ODtcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgfSxcbiAgICAgIG1rZGlyOiAocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDUxMTtcbiAgICAgICAgbW9kZSAmPSA1MTEgfCA1MTI7XG4gICAgICAgIG1vZGUgfD0gMTYzODQ7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgIH0sXG4gICAgICBta2RpclRyZWU6IChwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIHZhciBkaXJzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWRpcnNbaV0pIGNvbnRpbnVlO1xuICAgICAgICAgIGQgKz0gJy8nICsgZGlyc1tpXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRlMubWtkaXIoZCwgbW9kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuZXJybm8gIT0gMjApIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWtkZXY6IChwYXRoLCBtb2RlLCBkZXYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZXYgPSBtb2RlO1xuICAgICAgICAgIG1vZGUgPSA0Mzg7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSB8PSA4MTkyO1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sXG4gICAgICBzeW1saW5rOiAob2xkcGF0aCwgbmV3cGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVBBVEhfRlMucmVzb2x2ZShvbGRwYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3bmFtZSA9IFBBVEguYmFzZW5hbWUobmV3cGF0aCk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmV3bmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMuc3ltbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKTtcbiAgICAgIH0sXG4gICAgICByZW5hbWU6IChvbGRfcGF0aCwgbmV3X3BhdGgpID0+IHtcbiAgICAgICAgdmFyIG9sZF9kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG9sZF9wYXRoKTtcbiAgICAgICAgdmFyIG5ld19kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG5ld19wYXRoKTtcbiAgICAgICAgdmFyIG9sZF9uYW1lID0gUEFUSC5iYXNlbmFtZShvbGRfcGF0aCk7XG4gICAgICAgIHZhciBuZXdfbmFtZSA9IFBBVEguYmFzZW5hbWUobmV3X3BhdGgpO1xuXG4gICAgICAgIHZhciBsb29rdXAsIG9sZF9kaXIsIG5ld19kaXI7XG5cbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChvbGRfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG9sZF9kaXIgPSBsb29rdXAubm9kZTtcbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG5ld19kaXIgPSBsb29rdXAubm9kZTtcblxuICAgICAgICBpZiAoIW9sZF9kaXIgfHwgIW5ld19kaXIpIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcblxuICAgICAgICBpZiAob2xkX2Rpci5tb3VudCAhPT0gbmV3X2Rpci5tb3VudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDc1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGRfbm9kZSA9IEZTLmxvb2t1cE5vZGUob2xkX2Rpciwgb2xkX25hbWUpO1xuXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUob2xkX3BhdGgsIG5ld19kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVsYXRpdmUgPSBQQVRIX0ZTLnJlbGF0aXZlKG5ld19wYXRoLCBvbGRfZGlybmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfbm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIGlmIChvbGRfbm9kZSA9PT0gbmV3X25vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNkaXIgPSBGUy5pc0RpcihvbGRfbm9kZS5tb2RlKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUob2xkX2Rpciwgb2xkX25hbWUsIGlzZGlyKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVyckNvZGUgPSBuZXdfbm9kZVxuICAgICAgICAgID8gRlMubWF5RGVsZXRlKG5ld19kaXIsIG5ld19uYW1lLCBpc2RpcilcbiAgICAgICAgICA6IEZTLm1heUNyZWF0ZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgRlMuaXNNb3VudHBvaW50KG9sZF9ub2RlKSB8fFxuICAgICAgICAgIChuZXdfbm9kZSAmJiBGUy5pc01vdW50cG9pbnQobmV3X25vZGUpKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3X2RpciAhPT0gb2xkX2Rpcikge1xuICAgICAgICAgIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMob2xkX2RpciwgJ3cnKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUob2xkX25vZGUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRlMuaGFzaEFkZE5vZGUob2xkX25vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcm1kaXI6IChwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMucm1kaXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMucm1kaXIocGFyZW50LCBuYW1lKTtcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XG4gICAgICB9LFxuICAgICAgcmVhZGRpcjogKHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5yZWFkZGlyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSk7XG4gICAgICB9LFxuICAgICAgdW5saW5rOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy51bmxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIHJlYWRsaW5rOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcbiAgICAgICAgdmFyIGxpbmsgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluay5ub2RlX29wcy5yZWFkbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSF9GUy5yZXNvbHZlKFxuICAgICAgICAgIEZTLmdldFBhdGgobGluay5wYXJlbnQpLFxuICAgICAgICAgIGxpbmsubm9kZV9vcHMucmVhZGxpbmsobGluayksXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc3RhdDogKHBhdGgsIGRvbnRGb2xsb3cpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLmdldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZV9vcHMuZ2V0YXR0cihub2RlKTtcbiAgICAgIH0sXG4gICAgICBsc3RhdDogKHBhdGgpID0+IHtcbiAgICAgICAgcmV0dXJuIEZTLnN0YXQocGF0aCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgY2htb2Q6IChwYXRoLCBtb2RlLCBkb250Rm9sbG93KSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsY2htb2Q6IChwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIEZTLmNobW9kKHBhdGgsIG1vZGUsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGZjaG1vZDogKGZkLCBtb2RlKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNobW9kKHN0cmVhbS5ub2RlLCBtb2RlKTtcbiAgICAgIH0sXG4gICAgICBjaG93bjogKHBhdGgsIHVpZCwgZ2lkLCBkb250Rm9sbG93KSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsY2hvd246IChwYXRoLCB1aWQsIGdpZCkgPT4ge1xuICAgICAgICBGUy5jaG93bihwYXRoLCB1aWQsIGdpZCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZmNob3duOiAoZmQsIHVpZCwgZ2lkKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNob3duKHN0cmVhbS5ub2RlLCB1aWQsIGdpZCk7XG4gICAgICB9LFxuICAgICAgdHJ1bmNhdGU6IChwYXRoLCBsZW4pID0+IHtcbiAgICAgICAgaWYgKGxlbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsICd3Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICBzaXplOiBsZW4sXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmdHJ1bmNhdGU6IChmZCwgbGVuKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgRlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsIGxlbik7XG4gICAgICB9LFxuICAgICAgdXRpbWU6IChwYXRoLCBhdGltZSwgbXRpbWUpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBNYXRoLm1heChhdGltZSwgbXRpbWUpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvcGVuOiAocGF0aCwgZmxhZ3MsIG1vZGUpID0+IHtcbiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGZsYWdzID0gdHlwZW9mIGZsYWdzID09ICdzdHJpbmcnID8gRlMubW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpIDogZmxhZ3M7XG4gICAgICAgIG1vZGUgPSB0eXBlb2YgbW9kZSA9PSAndW5kZWZpbmVkJyA/IDQzOCA6IG1vZGU7XG4gICAgICAgIGlmIChmbGFncyAmIDY0KSB7XG4gICAgICAgICAgbW9kZSA9IChtb2RlICYgNDA5NSkgfCAzMjc2ODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7XG4gICAgICAgICAgICAgIGZvbGxvdzogIShmbGFncyAmIDEzMTA3MiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZsYWdzICYgNjQpIHtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgMTI4KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgZmxhZ3MgJj0gfjUxMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIDY1NTM2ICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjcmVhdGVkKSB7XG4gICAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlPcGVuKG5vZGUsIGZsYWdzKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgNTEyICYmICFjcmVhdGVkKSB7XG4gICAgICAgICAgRlMudHJ1bmNhdGUobm9kZSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbGFncyAmPSB+KDEyOCB8IDUxMiB8IDEzMTA3Mik7XG5cbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbSh7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBwYXRoOiBGUy5nZXRQYXRoKG5vZGUpLFxuICAgICAgICAgIGZsYWdzOiBmbGFncyxcbiAgICAgICAgICBzZWVrYWJsZTogdHJ1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICBzdHJlYW1fb3BzOiBub2RlLnN0cmVhbV9vcHMsXG5cbiAgICAgICAgICB1bmdvdHRlbjogW10sXG4gICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydsb2dSZWFkRmlsZXMnXSAmJiAhKGZsYWdzICYgMSkpIHtcbiAgICAgICAgICBpZiAoIUZTLnJlYWRGaWxlcykgRlMucmVhZEZpbGVzID0ge307XG4gICAgICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7XG4gICAgICAgICAgICBGUy5yZWFkRmlsZXNbcGF0aF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiAoc3RyZWFtKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cykgc3RyZWFtLmdldGRlbnRzID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2UpIHtcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5mZCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgaXNDbG9zZWQ6IChzdHJlYW0pID0+IHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5mZCA9PT0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBsbHNlZWs6IChzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc2Vla2FibGUgfHwgIXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlbmNlICE9IDAgJiYgd2hlbmNlICE9IDEgJiYgd2hlbmNlICE9IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvc2l0aW9uID0gc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgICBzdHJlYW0udW5nb3R0ZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICByZWFkOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMucmVhZCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNSZWFkID0gc3RyZWFtLnN0cmVhbV9vcHMucmVhZChcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5zZWVrYWJsZSAmJiBzdHJlYW0uZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgMCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBjYW5Pd24sXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICAgIH0sXG4gICAgICBhbGxvY2F0ZTogKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBsZW5ndGggPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMzgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIG1tYXA6IChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAocHJvdCAmIDIpICE9PSAwICYmXG4gICAgICAgICAgKGZsYWdzICYgMikgPT09IDAgJiZcbiAgICAgICAgICAoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgIT09IDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubW1hcCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKTtcbiAgICAgIH0sXG4gICAgICBtc3luYzogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSA9PiB7XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgIG1tYXBGbGFncyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBtdW5tYXA6IChzdHJlYW0pID0+IDAsXG4gICAgICBpb2N0bDogKHN0cmVhbSwgY21kLCBhcmcpID0+IHtcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwoc3RyZWFtLCBjbWQsIGFyZyk7XG4gICAgICB9LFxuICAgICAgcmVhZEZpbGU6IChwYXRoLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgMDtcbiAgICAgICAgb3B0cy5lbmNvZGluZyA9IG9wdHMuZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nICE9PSAndXRmOCcgJiYgb3B0cy5lbmNvZGluZyAhPT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSBcIicgKyBvcHRzLmVuY29kaW5nICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncyk7XG4gICAgICAgIHZhciBzdGF0ID0gRlMuc3RhdChwYXRoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIEZTLnJlYWQoc3RyZWFtLCBidWYsIDAsIGxlbmd0aCwgMCk7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICByZXQgPSBVVEY4QXJyYXlUb1N0cmluZyhidWYsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgcmV0ID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgd3JpdGVGaWxlOiAocGF0aCwgZGF0YSwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDU3NztcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncywgb3B0cy5tb2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSArIDEpO1xuICAgICAgICAgIHZhciBhY3R1YWxOdW1CeXRlcyA9IHN0cmluZ1RvVVRGOEFycmF5KGRhdGEsIGJ1ZiwgMCwgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBidWYsIDAsIGFjdHVhbE51bUJ5dGVzLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCwgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgfSxcbiAgICAgIGN3ZDogKCkgPT4gRlMuY3VycmVudFBhdGgsXG4gICAgICBjaGRpcjogKHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIGlmIChsb29rdXAubm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRGlyKGxvb2t1cC5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLCAneCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzOiAoKSA9PiB7XG4gICAgICAgIEZTLm1rZGlyKCcvdG1wJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZScpO1xuICAgICAgICBGUy5ta2RpcignL2hvbWUvd2ViX3VzZXInKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVEZWZhdWx0RGV2aWNlczogKCkgPT4ge1xuICAgICAgICBGUy5ta2RpcignL2RldicpO1xuXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKEZTLm1ha2VkZXYoMSwgMyksIHtcbiAgICAgICAgICByZWFkOiAoKSA9PiAwLFxuICAgICAgICAgIHdyaXRlOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpID0+IGxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L251bGwnLCBGUy5tYWtlZGV2KDEsIDMpKTtcblxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7XG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDYsIDApLCBUVFkuZGVmYXVsdF90dHkxX29wcyk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eScsIEZTLm1ha2VkZXYoNSwgMCkpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHkxJywgRlMubWFrZWRldig2LCAwKSk7XG5cbiAgICAgICAgdmFyIHJhbmRvbV9kZXZpY2UgPSBnZXRSYW5kb21EZXZpY2UoKTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3JhbmRvbScsIHJhbmRvbV9kZXZpY2UpO1xuICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAndXJhbmRvbScsIHJhbmRvbV9kZXZpY2UpO1xuXG4gICAgICAgIEZTLm1rZGlyKCcvZGV2L3NobScpO1xuICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0vdG1wJyk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOiAoKSA9PiB7XG4gICAgICAgIEZTLm1rZGlyKCcvcHJvYycpO1xuICAgICAgICB2YXIgcHJvY19zZWxmID0gRlMubWtkaXIoJy9wcm9jL3NlbGYnKTtcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jL3NlbGYvZmQnKTtcbiAgICAgICAgRlMubW91bnQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW91bnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHByb2Nfc2VsZiwgJ2ZkJywgMTYzODQgfCA1MTEsIDczKTtcbiAgICAgICAgICAgICAgbm9kZS5ub2RlX29wcyA9IHtcbiAgICAgICAgICAgICAgICBsb29rdXA6IChwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBmZCA9ICtuYW1lO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXN0cmVhbSkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1vdW50OiB7IG1vdW50cG9pbnQ6ICdmYWtlJyB9LFxuICAgICAgICAgICAgICAgICAgICBub2RlX29wczogeyByZWFkbGluazogKCkgPT4gc3RyZWFtLnBhdGggfSxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXQucGFyZW50ID0gcmV0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAnL3Byb2Mvc2VsZi9mZCcsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU3RhbmRhcmRTdHJlYW1zOiAoKSA9PiB7XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGluJ10pIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkaW4nLCBNb2R1bGVbJ3N0ZGluJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3RkaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydzdGRvdXQnXSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRvdXQnLCBudWxsLCBNb2R1bGVbJ3N0ZG91dCddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZG91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGVyciddKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIE1vZHVsZVsnc3RkZXJyJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0ZGluID0gRlMub3BlbignL2Rldi9zdGRpbicsIDApO1xuICAgICAgICB2YXIgc3Rkb3V0ID0gRlMub3BlbignL2Rldi9zdGRvdXQnLCAxKTtcbiAgICAgICAgdmFyIHN0ZGVyciA9IEZTLm9wZW4oJy9kZXYvc3RkZXJyJywgMSk7XG4gICAgICB9LFxuICAgICAgZW5zdXJlRXJybm9FcnJvcjogKCkgPT4ge1xuICAgICAgICBpZiAoRlMuRXJybm9FcnJvcikgcmV0dXJuO1xuICAgICAgICBGUy5FcnJub0Vycm9yID0gZnVuY3Rpb24gRXJybm9FcnJvcihlcnJubywgbm9kZSkge1xuICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyA9IGZ1bmN0aW9uIChlcnJubykge1xuICAgICAgICAgICAgdGhpcy5lcnJubyA9IGVycm5vO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyhlcnJubyk7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlID0gJ0ZTIGVycm9yJztcbiAgICAgICAgfTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGUy5FcnJub0Vycm9yO1xuXG4gICAgICAgIFs0NF0uZm9yRWFjaCgoY29kZSkgPT4ge1xuICAgICAgICAgIEZTLmdlbmVyaWNFcnJvcnNbY29kZV0gPSBuZXcgRlMuRXJybm9FcnJvcihjb2RlKTtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdLnN0YWNrID0gJzxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4nO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzdGF0aWNJbml0OiAoKSA9PiB7XG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcblxuICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7XG5cbiAgICAgICAgRlMubW91bnQoTUVNRlMsIHt9LCAnLycpO1xuXG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO1xuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGV2aWNlcygpO1xuICAgICAgICBGUy5jcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKTtcblxuICAgICAgICBGUy5maWxlc3lzdGVtcyA9IHtcbiAgICAgICAgICBNRU1GUzogTUVNRlMsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaW5pdDogKGlucHV0LCBvdXRwdXQsIGVycm9yKSA9PiB7XG4gICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcblxuICAgICAgICBNb2R1bGVbJ3N0ZGluJ10gPSBpbnB1dCB8fCBNb2R1bGVbJ3N0ZGluJ107XG4gICAgICAgIE1vZHVsZVsnc3Rkb3V0J10gPSBvdXRwdXQgfHwgTW9kdWxlWydzdGRvdXQnXTtcbiAgICAgICAgTW9kdWxlWydzdGRlcnInXSA9IGVycm9yIHx8IE1vZHVsZVsnc3RkZXJyJ107XG5cbiAgICAgICAgRlMuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCk7XG4gICAgICB9LFxuICAgICAgcXVpdDogKCkgPT4ge1xuICAgICAgICBGUy5pbml0LmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLnN0cmVhbXNbaV07XG4gICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0TW9kZTogKGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBtb2RlID0gMDtcbiAgICAgICAgaWYgKGNhblJlYWQpIG1vZGUgfD0gMjkyIHwgNzM7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfSxcbiAgICAgIGZpbmRPYmplY3Q6IChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICAgICAgaWYgKCFyZXQuZXhpc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5vYmplY3Q7XG4gICAgICB9LFxuICAgICAgYW5hbHl6ZVBhdGg6IChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgICAgIHBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLFxuICAgICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IDAsXG4gICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICAgIG9iamVjdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG51bGwsXG4gICAgICAgICAgcGFyZW50T2JqZWN0OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICAgIHJldC5wYXJlbnRFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIHJldC5wYXJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgICAgcmV0LnBhcmVudE9iamVjdCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIHJldC5uYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgICAgICByZXQuZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5vYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IGxvb2t1cC5ub2RlLm5hbWU7XG4gICAgICAgICAgcmV0LmlzUm9vdCA9IGxvb2t1cC5wYXRoID09PSAnLyc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXQuZXJyb3IgPSBlLmVycm5vO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgY3JlYXRlUGF0aDogKHBhcmVudCwgcGF0aCwgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLnJldmVyc2UoKTtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IFBBVEguam9pbjIocGFyZW50LCBwYXJ0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRlMubWtkaXIoY3VycmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICBwYXJlbnQgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUZpbGU6IChwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihcbiAgICAgICAgICB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIHJldHVybiBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGF0YUZpbGU6IChwYXJlbnQsIG5hbWUsIGRhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pID0+IHtcbiAgICAgICAgdmFyIHBhdGggPSBuYW1lO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgICBwYXRoID0gbmFtZSA/IFBBVEguam9pbjIocGFyZW50LCBuYW1lKSA6IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgICAgIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGRhdGEgPSBhcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSB8IDE0Nik7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4obm9kZSwgNTc3KTtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGV2aWNlOiAocGFyZW50LCBuYW1lLCBpbnB1dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihcbiAgICAgICAgICB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZSghIWlucHV0LCAhIW91dHB1dCk7XG4gICAgICAgIGlmICghRlMuY3JlYXRlRGV2aWNlLm1ham9yKSBGUy5jcmVhdGVEZXZpY2UubWFqb3IgPSA2NDtcbiAgICAgICAgdmFyIGRldiA9IEZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssIDApO1xuXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwge1xuICAgICAgICAgIG9wZW46IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2U6IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgb3V0cHV0LmJ1ZmZlciAmJiBvdXRwdXQuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBvdXRwdXQoMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVhZDogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlc1JlYWQpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0KGJ1ZmZlcltvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRlMubWtkZXYocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sXG4gICAgICBmb3JjZUxvYWRGaWxlOiAob2JqKSA9PiB7XG4gICAgICAgIGlmIChvYmouaXNEZXZpY2UgfHwgb2JqLmlzRm9sZGVyIHx8IG9iai5saW5rIHx8IG9iai5jb250ZW50cylcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhZF8pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqLmNvbnRlbnRzID0gaW50QXJyYXlGcm9tU3RyaW5nKHJlYWRfKG9iai51cmwpLCB0cnVlKTtcbiAgICAgICAgICAgIG9iai51c2VkQnl0ZXMgPSBvYmouY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUxhenlGaWxlOiAocGFyZW50LCBuYW1lLCB1cmwsIGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5KCkge1xuICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KSB7XG4gICAgICAgICAgaWYgKGlkeCA+IHRoaXMubGVuZ3RoIC0gMSB8fCBpZHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSB0aGlzLmNodW5rU2l6ZTtcbiAgICAgICAgICB2YXIgY2h1bmtOdW0gPSAoaWR4IC8gdGhpcy5jaHVua1NpemUpIHwgMDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoY2h1bmtOdW0pW2NodW5rT2Zmc2V0XTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLnNldERhdGFHZXR0ZXIgPVxuICAgICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjtcbiAgICAgICAgICB9O1xuICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuY2FjaGVMZW5ndGggPVxuICAgICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoKCkge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGRhdGFsZW5ndGggPSBOdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LWxlbmd0aCcpKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPVxuICAgICAgICAgICAgICAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdBY2NlcHQtUmFuZ2VzJykpICYmXG4gICAgICAgICAgICAgIGhlYWRlciA9PT0gJ2J5dGVzJztcbiAgICAgICAgICAgIHZhciB1c2VzR3ppcCA9XG4gICAgICAgICAgICAgIChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtRW5jb2RpbmcnKSkgJiZcbiAgICAgICAgICAgICAgaGVhZGVyID09PSAnZ3ppcCc7XG5cbiAgICAgICAgICAgIHZhciBjaHVua1NpemUgPSAxMDI0ICogMTAyNDtcblxuICAgICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGRvWEhSID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChmcm9tID4gdG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgcmFuZ2UgKCcgK1xuICAgICAgICAgICAgICAgICAgICBmcm9tICtcbiAgICAgICAgICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIHRvICtcbiAgICAgICAgICAgICAgICAgICAgJykgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkIScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHRvID4gZGF0YWxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ29ubHkgJyArIGRhdGFsZW5ndGggKyAnIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciEnLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmIChkYXRhbGVuZ3RoICE9PSBjaHVua1NpemUpXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBmcm9tICsgJy0nICsgdG8pO1xuXG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICBpZiAoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UgfHwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCB8fCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGxhenlBcnJheSA9IHRoaXM7XG4gICAgICAgICAgICBsYXp5QXJyYXkuc2V0RGF0YUdldHRlcigoY2h1bmtOdW0pID0+IHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtOdW0gKiBjaHVua1NpemU7XG4gICAgICAgICAgICAgIHZhciBlbmQgPSAoY2h1bmtOdW0gKyAxKSAqIGNodW5rU2l6ZSAtIDE7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgZGF0YWxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPSBkb1hIUihzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9YSFIgZmFpbGVkIScpO1xuICAgICAgICAgICAgICByZXR1cm4gbGF6eUFycmF5LmNodW5rc1tjaHVua051bV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHVzZXNHemlwIHx8ICFkYXRhbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGggPSAxO1xuICAgICAgICAgICAgICBkYXRhbGVuZ3RoID0gdGhpcy5nZXR0ZXIoMCkubGVuZ3RoO1xuICAgICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgICAgICBvdXQoXG4gICAgICAgICAgICAgICAgJ0xhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZCcsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKCFFTlZJUk9OTUVOVF9JU19XT1JLRVIpXG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyc7XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSwge1xuICAgICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNodW5rU2l6ZToge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU2l6ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgdXJsOiB1cmwgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKTtcblxuICAgICAgICBpZiAocHJvcGVydGllcy5jb250ZW50cykge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBwcm9wZXJ0aWVzLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMudXJsKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgbm9kZS51cmwgPSBwcm9wZXJ0aWVzLnVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIHtcbiAgICAgICAgICB1c2VkQnl0ZXM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdHJlYW1fb3BzID0ge307XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICB2YXIgZm4gPSBub2RlLnN0cmVhbV9vcHNba2V5XTtcbiAgICAgICAgICBzdHJlYW1fb3BzW2tleV0gPSBmdW5jdGlvbiBmb3JjZUxvYWRMYXp5RmlsZSgpIHtcbiAgICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDaHVua3Moc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjb250ZW50cy5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oY29udGVudHMubGVuZ3RoIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKGNvbnRlbnRzLnNsaWNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50cy5nZXQocG9zaXRpb24gKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW1fb3BzLnJlYWQgPSAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtzKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmVhbV9vcHMubW1hcCA9IChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICB2YXIgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3JpdGVDaHVua3Moc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICByZXR1cm4geyBwdHI6IHB0ciwgYWxsb2NhdGVkOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IHN0cmVhbV9vcHM7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVByZWxvYWRlZEZpbGU6IChcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuYW1lLFxuICAgICAgICB1cmwsXG4gICAgICAgIGNhblJlYWQsXG4gICAgICAgIGNhbldyaXRlLFxuICAgICAgICBvbmxvYWQsXG4gICAgICAgIG9uZXJyb3IsXG4gICAgICAgIGRvbnRDcmVhdGVGaWxlLFxuICAgICAgICBjYW5Pd24sXG4gICAgICAgIHByZUZpbmlzaCxcbiAgICAgICkgPT4ge1xuICAgICAgICB2YXIgZnVsbG5hbWUgPSBuYW1lXG4gICAgICAgICAgPyBQQVRIX0ZTLnJlc29sdmUoUEFUSC5qb2luMihwYXJlbnQsIG5hbWUpKVxuICAgICAgICAgIDogcGFyZW50O1xuICAgICAgICB2YXIgZGVwID0gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeSgnY3AgJyArIGZ1bGxuYW1lKTtcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KSB7XG4gICAgICAgICAgZnVuY3Rpb24gZmluaXNoKGJ5dGVBcnJheSkge1xuICAgICAgICAgICAgaWYgKHByZUZpbmlzaCkgcHJlRmluaXNoKCk7XG4gICAgICAgICAgICBpZiAoIWRvbnRDcmVhdGVGaWxlKSB7XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFxuICAgICAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGJ5dGVBcnJheSxcbiAgICAgICAgICAgICAgICBjYW5SZWFkLFxuICAgICAgICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgICAgICAgIGNhbk93bixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbmxvYWQpIG9ubG9hZCgpO1xuICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBCcm93c2VyLmhhbmRsZWRCeVByZWxvYWRQbHVnaW4oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChvbmVycm9yKSBvbmVycm9yKCk7XG4gICAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaChieXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhc3luY0xvYWQodXJsLCAoYnl0ZUFycmF5KSA9PiBwcm9jZXNzRGF0YShieXRlQXJyYXkpLCBvbmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzRGF0YSh1cmwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kZXhlZERCOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgd2luZG93LmluZGV4ZWREQiB8fFxuICAgICAgICAgIHdpbmRvdy5tb3pJbmRleGVkREIgfHxcbiAgICAgICAgICB3aW5kb3cud2Via2l0SW5kZXhlZERCIHx8XG4gICAgICAgICAgd2luZG93Lm1zSW5kZXhlZERCXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgREJfTkFNRTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gJ0VNX0ZTXycgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB9LFxuICAgICAgREJfVkVSU0lPTjogMjAsXG4gICAgICBEQl9TVE9SRV9OQU1FOiAnRklMRV9EQVRBJyxcbiAgICAgIHNhdmVGaWxlc1RvREI6IChwYXRocywgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgICAgIG9ubG9hZCA9IG9ubG9hZCB8fCAoKCkgPT4ge30pO1xuICAgICAgICBvbmVycm9yID0gb25lcnJvciB8fCAoKCkgPT4ge30pO1xuICAgICAgICB2YXIgaW5kZXhlZERCID0gRlMuaW5kZXhlZERCKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBvbmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcbiAgICAgICAgICBvdXQoJ2NyZWF0aW5nIGRiJyk7XG4gICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgIHZhciBmaWxlcyA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgICAgIHZhciBvayA9IDAsXG4gICAgICAgICAgICBmYWlsID0gMCxcbiAgICAgICAgICAgIHRvdGFsID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpO1xuICAgICAgICAgICAgZWxzZSBvbmVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHZhciBwdXRSZXF1ZXN0ID0gZmlsZXMucHV0KFxuICAgICAgICAgICAgICBGUy5hbmFseXplUGF0aChwYXRoKS5vYmplY3QuY29udGVudHMsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIG9rKys7XG4gICAgICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHB1dFJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZmFpbCsrO1xuICAgICAgICAgICAgICBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgfSxcbiAgICAgIGxvYWRGaWxlc0Zyb21EQjogKHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gb25lcnJvcjtcbiAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZG9ubHknKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvbmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgICAgICB2YXIgb2sgPSAwLFxuICAgICAgICAgICAgZmFpbCA9IDAsXG4gICAgICAgICAgICB0b3RhbCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgICAgICBpZiAoZmFpbCA9PSAwKSBvbmxvYWQoKTtcbiAgICAgICAgICAgIGVsc2Ugb25lcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IGZpbGVzLmdldChwYXRoKTtcbiAgICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoRlMuYW5hbHl6ZVBhdGgocGF0aCkuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFxuICAgICAgICAgICAgICAgIFBBVEguZGlybmFtZShwYXRoKSxcbiAgICAgICAgICAgICAgICBQQVRILmJhc2VuYW1lKHBhdGgpLFxuICAgICAgICAgICAgICAgIGdldFJlcXVlc3QucmVzdWx0LFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBvaysrO1xuICAgICAgICAgICAgICBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGZhaWwrKztcbiAgICAgICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgU1lTQ0FMTFMgPSB7XG4gICAgICBERUZBVUxUX1BPTExNQVNLOiA1LFxuICAgICAgY2FsY3VsYXRlQXQ6IGZ1bmN0aW9uIChkaXJmZCwgcGF0aCwgYWxsb3dFbXB0eSkge1xuICAgICAgICBpZiAoUEFUSC5pc0FicyhwYXRoKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpcjtcbiAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7XG4gICAgICAgICAgZGlyID0gRlMuY3dkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChkaXJmZCk7XG4gICAgICAgICAgZGlyID0gZGlyc3RyZWFtLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSC5qb2luMihkaXIsIHBhdGgpO1xuICAgICAgfSxcbiAgICAgIGRvU3RhdDogZnVuY3Rpb24gKGZ1bmMsIHBhdGgsIGJ1Zikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzdGF0ID0gZnVuYyhwYXRoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGUgJiZcbiAgICAgICAgICAgIGUubm9kZSAmJlxuICAgICAgICAgICAgUEFUSC5ub3JtYWxpemUocGF0aCkgIT09IFBBVEgubm9ybWFsaXplKEZTLmdldFBhdGgoZS5ub2RlKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAtNTQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyW2J1ZiA+PiAyXSA9IHN0YXQuZGV2O1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDgpID4+IDJdID0gc3RhdC5pbm87XG4gICAgICAgIEhFQVAzMlsoYnVmICsgMTIpID4+IDJdID0gc3RhdC5tb2RlO1xuICAgICAgICBIRUFQVTMyWyhidWYgKyAxNikgPj4gMl0gPSBzdGF0Lm5saW5rO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDIwKSA+PiAyXSA9IHN0YXQudWlkO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDI0KSA+PiAyXSA9IHN0YXQuZ2lkO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDI4KSA+PiAyXSA9IHN0YXQucmRldjtcbiAgICAgICAgKHRlbXBJNjQgPSBbXG4gICAgICAgICAgc3RhdC5zaXplID4+PiAwLFxuICAgICAgICAgICgodGVtcERvdWJsZSA9IHN0YXQuc2l6ZSksXG4gICAgICAgICAgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDEuMFxuICAgICAgICAgICAgPyB0ZW1wRG91YmxlID4gMC4wXG4gICAgICAgICAgICAgID8gKE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgK01hdGguZmxvb3IodGVtcERvdWJsZSAvIDQyOTQ5NjcyOTYuMCksXG4gICAgICAgICAgICAgICAgICA0Mjk0OTY3Mjk1LjAsXG4gICAgICAgICAgICAgICAgKSB8XG4gICAgICAgICAgICAgICAgICAwKSA+Pj5cbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgIDogfn4rTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5Ni4wLFxuICAgICAgICAgICAgICAgICkgPj4+IDBcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgIF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDQwKSA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDQ0KSA+PiAyXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDQ4KSA+PiAyXSA9IDQwOTY7XG4gICAgICAgIEhFQVAzMlsoYnVmICsgNTIpID4+IDJdID0gc3RhdC5ibG9ja3M7XG4gICAgICAgIHZhciBhdGltZSA9IHN0YXQuYXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgbXRpbWUgPSBzdGF0Lm10aW1lLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XG4gICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgIE1hdGguZmxvb3IoYXRpbWUgLyAxMDAwKSA+Pj4gMCxcbiAgICAgICAgICAoKHRlbXBEb3VibGUgPSBNYXRoLmZsb29yKGF0aW1lIC8gMTAwMCkpLFxuICAgICAgICAgICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxLjBcbiAgICAgICAgICAgID8gdGVtcERvdWJsZSA+IDAuMFxuICAgICAgICAgICAgICA/IChNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2LjApLFxuICAgICAgICAgICAgICAgICAgNDI5NDk2NzI5NS4wLFxuICAgICAgICAgICAgICAgICkgfFxuICAgICAgICAgICAgICAgICAgMCkgPj4+XG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICA6IH5+K01hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYuMCxcbiAgICAgICAgICAgICAgICApID4+PiAwXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICBdKSxcbiAgICAgICAgICAoSEVBUDMyWyhidWYgKyA1NikgPj4gMl0gPSB0ZW1wSTY0WzBdKSxcbiAgICAgICAgICAoSEVBUDMyWyhidWYgKyA2MCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUFUzMlsoYnVmICsgNjQpID4+IDJdID0gKGF0aW1lICUgMTAwMCkgKiAxMDAwO1xuICAgICAgICAodGVtcEk2NCA9IFtcbiAgICAgICAgICBNYXRoLmZsb29yKG10aW1lIC8gMTAwMCkgPj4+IDAsXG4gICAgICAgICAgKCh0ZW1wRG91YmxlID0gTWF0aC5mbG9vcihtdGltZSAvIDEwMDApKSxcbiAgICAgICAgICArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMS4wXG4gICAgICAgICAgICA/IHRlbXBEb3VibGUgPiAwLjBcbiAgICAgICAgICAgICAgPyAoTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5Ni4wKSxcbiAgICAgICAgICAgICAgICAgIDQyOTQ5NjcyOTUuMCxcbiAgICAgICAgICAgICAgICApIHxcbiAgICAgICAgICAgICAgICAgIDApID4+PlxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgOiB+fitNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2LjAsXG4gICAgICAgICAgICAgICAgKSA+Pj4gMFxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgXSksXG4gICAgICAgICAgKEhFQVAzMlsoYnVmICsgNzIpID4+IDJdID0gdGVtcEk2NFswXSksXG4gICAgICAgICAgKEhFQVAzMlsoYnVmICsgNzYpID4+IDJdID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIEhFQVBVMzJbKGJ1ZiArIDgwKSA+PiAyXSA9IChtdGltZSAlIDEwMDApICogMTAwMDtcbiAgICAgICAgKHRlbXBJNjQgPSBbXG4gICAgICAgICAgTWF0aC5mbG9vcihjdGltZSAvIDEwMDApID4+PiAwLFxuICAgICAgICAgICgodGVtcERvdWJsZSA9IE1hdGguZmxvb3IoY3RpbWUgLyAxMDAwKSksXG4gICAgICAgICAgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDEuMFxuICAgICAgICAgICAgPyB0ZW1wRG91YmxlID4gMC4wXG4gICAgICAgICAgICAgID8gKE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgK01hdGguZmxvb3IodGVtcERvdWJsZSAvIDQyOTQ5NjcyOTYuMCksXG4gICAgICAgICAgICAgICAgICA0Mjk0OTY3Mjk1LjAsXG4gICAgICAgICAgICAgICAgKSB8XG4gICAgICAgICAgICAgICAgICAwKSA+Pj5cbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgIDogfn4rTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5Ni4wLFxuICAgICAgICAgICAgICAgICkgPj4+IDBcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgIF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDg4KSA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDkyKSA+PiAyXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQVTMyWyhidWYgKyA5NikgPj4gMl0gPSAoY3RpbWUgJSAxMDAwKSAqIDEwMDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgIHN0YXQuaW5vID4+PiAwLFxuICAgICAgICAgICgodGVtcERvdWJsZSA9IHN0YXQuaW5vKSxcbiAgICAgICAgICArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMS4wXG4gICAgICAgICAgICA/IHRlbXBEb3VibGUgPiAwLjBcbiAgICAgICAgICAgICAgPyAoTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5Ni4wKSxcbiAgICAgICAgICAgICAgICAgIDQyOTQ5NjcyOTUuMCxcbiAgICAgICAgICAgICAgICApIHxcbiAgICAgICAgICAgICAgICAgIDApID4+PlxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgOiB+fitNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2LjAsXG4gICAgICAgICAgICAgICAgKSA+Pj4gMFxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgXSksXG4gICAgICAgICAgKEhFQVAzMlsoYnVmICsgMTA0KSA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDEwOCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgZG9Nc3luYzogZnVuY3Rpb24gKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KSB7XG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gSEVBUFU4LnNsaWNlKGFkZHIsIGFkZHIgKyBsZW4pO1xuICAgICAgICBGUy5tc3luYyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW4sIGZsYWdzKTtcbiAgICAgIH0sXG4gICAgICB2YXJhcmdzOiB1bmRlZmluZWQsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xuICAgICAgICB2YXIgcmV0ID0gSEVBUDMyWyhTWVNDQUxMUy52YXJhcmdzIC0gNCkgPj4gMl07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgZ2V0U3RyOiBmdW5jdGlvbiAocHRyKSB7XG4gICAgICAgIHZhciByZXQgPSBVVEY4VG9TdHJpbmcocHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICBnZXRTdHJlYW1Gcm9tRkQ6IGZ1bmN0aW9uIChmZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfY2htb2QocGF0aCwgbW9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mYWNjZXNzYXQoZGlyZmQsIHBhdGgsIGFtb2RlLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgaWYgKGFtb2RlICYgfjcpIHtcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gLTQ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJtcyA9ICcnO1xuICAgICAgICBpZiAoYW1vZGUgJiA0KSBwZXJtcyArPSAncic7XG4gICAgICAgIGlmIChhbW9kZSAmIDIpIHBlcm1zICs9ICd3JztcbiAgICAgICAgaWYgKGFtb2RlICYgMSkgcGVybXMgKz0gJ3gnO1xuICAgICAgICBpZiAocGVybXMgJiYgRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSkge1xuICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNobW9kKGZkLCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBGUy5mY2htb2QoZmQsIG1vZGUpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNob3duMzIoZmQsIG93bmVyLCBncm91cCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgRlMuZmNob3duKGZkLCBvd25lciwgZ3JvdXApO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEVyck5vKHZhbHVlKSB7XG4gICAgICBIRUFQMzJbX19fZXJybm9fbG9jYXRpb24oKSA+PiAyXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNudGw2NChmZCwgY21kLCB2YXJhcmdzKSB7XG4gICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgICAgaWYgKGFyZyA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdTdHJlYW07XG4gICAgICAgICAgICBuZXdTdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oc3RyZWFtLCBhcmcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0cmVhbS5mZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0uZmxhZ3M7XG4gICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICB2YXIgYXJnID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgICBzdHJlYW0uZmxhZ3MgfD0gYXJnO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIEhFQVAxNlsoYXJnICsgb2Zmc2V0KSA+PiAxXSA9IDI7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBzZXRFcnJObygyOCk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZnN0YXQ2NChmZCwgYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBzdHJlYW0ucGF0aCwgYnVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBNQVhfSU5UNTMgPSA5MDA3MTk5MjU0NzQwOTkyO1xuXG4gICAgdmFyIE1JTl9JTlQ1MyA9IC05MDA3MTk5MjU0NzQwOTkyO1xuICAgIGZ1bmN0aW9uIGJpZ2ludFRvSTUzQ2hlY2tlZChudW0pIHtcbiAgICAgIHJldHVybiBudW0gPCBNSU5fSU5UNTMgfHwgbnVtID4gTUFYX0lOVDUzID8gTmFOIDogTnVtYmVyKG51bSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mdHJ1bmNhdGU2NChmZCwgbGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZW5ndGggPSBiaWdpbnRUb0k1M0NoZWNrZWQobGVuZ3RoKTtcbiAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkpIHJldHVybiAtNjE7XG4gICAgICAgIEZTLmZ0cnVuY2F0ZShmZCwgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2dldGN3ZChidWYsIHNpemUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gLTI4O1xuICAgICAgICB2YXIgY3dkID0gRlMuY3dkKCk7XG4gICAgICAgIHZhciBjd2RMZW5ndGhJbkJ5dGVzID0gbGVuZ3RoQnl0ZXNVVEY4KGN3ZCkgKyAxO1xuICAgICAgICBpZiAoc2l6ZSA8IGN3ZExlbmd0aEluQnl0ZXMpIHJldHVybiAtNjg7XG4gICAgICAgIHN0cmluZ1RvVVRGOChjd2QsIGJ1Ziwgc2l6ZSk7XG4gICAgICAgIHJldHVybiBjd2RMZW5ndGhJbkJ5dGVzO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9pb2N0bChmZCwgb3AsIHZhcmFyZ3MpIHtcbiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICBjYXNlIDIxNTA5OlxuICAgICAgICAgIGNhc2UgMjE1MDU6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTEwOlxuICAgICAgICAgIGNhc2UgMjE1MTE6XG4gICAgICAgICAgY2FzZSAyMTUxMjpcbiAgICAgICAgICBjYXNlIDIxNTA2OlxuICAgICAgICAgIGNhc2UgMjE1MDc6XG4gICAgICAgICAgY2FzZSAyMTUwODoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MTk6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHZhciBhcmdwID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgICBIRUFQMzJbYXJncCA+PiAyXSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUyMDoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUzMToge1xuICAgICAgICAgICAgdmFyIGFyZ3AgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBGUy5pb2N0bChzdHJlYW0sIG9wLCBhcmdwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUyMzoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MjQ6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9sc3RhdDY0KHBhdGgsIGJ1Zikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5sc3RhdCwgcGF0aCwgYnVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtkaXJhdChkaXJmZCwgcGF0aCwgbW9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcblxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJylcbiAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgRlMubWtkaXIocGF0aCwgbW9kZSwgMCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9uZXdmc3RhdGF0KGRpcmZkLCBwYXRoLCBidWYsIGZsYWdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICB2YXIgbm9mb2xsb3cgPSBmbGFncyAmIDI1NjtcbiAgICAgICAgdmFyIGFsbG93RW1wdHkgPSBmbGFncyAmIDQwOTY7XG4gICAgICAgIGZsYWdzID0gZmxhZ3MgJiB+NjQwMDtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCBhbGxvd0VtcHR5KTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChub2ZvbGxvdyA/IEZTLmxzdGF0IDogRlMuc3RhdCwgcGF0aCwgYnVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfb3BlbmF0KGRpcmZkLCBwYXRoLCBmbGFncywgdmFyYXJncykge1xuICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgICB2YXIgbW9kZSA9IHZhcmFyZ3MgPyBTWVNDQUxMUy5nZXQoKSA6IDA7XG4gICAgICAgIHJldHVybiBGUy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlKS5mZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcmVhZGxpbmthdChkaXJmZCwgcGF0aCwgYnVmLCBidWZzaXplKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgICBpZiAoYnVmc2l6ZSA8PSAwKSByZXR1cm4gLTI4O1xuICAgICAgICB2YXIgcmV0ID0gRlMucmVhZGxpbmsocGF0aCk7XG5cbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGJ1ZnNpemUsIGxlbmd0aEJ5dGVzVVRGOChyZXQpKTtcbiAgICAgICAgdmFyIGVuZENoYXIgPSBIRUFQOFtidWYgKyBsZW5dO1xuICAgICAgICBzdHJpbmdUb1VURjgocmV0LCBidWYsIGJ1ZnNpemUgKyAxKTtcblxuICAgICAgICBIRUFQOFtidWYgKyBsZW5dID0gZW5kQ2hhcjtcbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9zdGF0NjQocGF0aCwgYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX3VubGlua2F0KGRpcmZkLCBwYXRoLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgaWYgKGZsYWdzID09PSAwKSB7XG4gICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzID09PSA1MTIpIHtcbiAgICAgICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhYm9ydCgnSW52YWxpZCBmbGFncyBwYXNzZWQgdG8gdW5saW5rYXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRJNTNGcm9tSTY0KHB0cikge1xuICAgICAgcmV0dXJuIEhFQVBVMzJbcHRyID4+IDJdICsgSEVBUDMyWyhwdHIgKyA0KSA+PiAyXSAqIDQyOTQ5NjcyOTY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF91dGltZW5zYXQoZGlyZmQsIHBhdGgsIHRpbWVzLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCB0cnVlKTtcbiAgICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICAgIHZhciBhdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgdmFyIG10aW1lID0gYXRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlY29uZHMgPSByZWFkSTUzRnJvbUk2NCh0aW1lcyk7XG4gICAgICAgICAgdmFyIG5hbm9zZWNvbmRzID0gSEVBUDMyWyh0aW1lcyArIDgpID4+IDJdO1xuICAgICAgICAgIGF0aW1lID0gc2Vjb25kcyAqIDEwMDAgKyBuYW5vc2Vjb25kcyAvICgxMDAwICogMTAwMCk7XG4gICAgICAgICAgdGltZXMgKz0gMTY7XG4gICAgICAgICAgc2Vjb25kcyA9IHJlYWRJNTNGcm9tSTY0KHRpbWVzKTtcbiAgICAgICAgICBuYW5vc2Vjb25kcyA9IEhFQVAzMlsodGltZXMgKyA4KSA+PiAyXTtcbiAgICAgICAgICBtdGltZSA9IHNlY29uZHMgKiAxMDAwICsgbmFub3NlY29uZHMgLyAoMTAwMCAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIEZTLnV0aW1lKHBhdGgsIGF0aW1lLCBtdGltZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vd0lzTW9ub3RvbmljID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMoKSB7XG4gICAgICByZXR1cm4gbm93SXNNb25vdG9uaWM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19pc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbiAgICB9XG5cbiAgICB2YXIgX19NT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA9IFtcbiAgICAgIDAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1LFxuICAgIF07XG5cbiAgICB2YXIgX19NT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRSA9IFtcbiAgICAgIDAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0LFxuICAgIF07XG4gICAgZnVuY3Rpb24gX195ZGF5X2Zyb21fZGF0ZShkYXRlKSB7XG4gICAgICB2YXIgaXNMZWFwWWVhciA9IF9faXNMZWFwWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgdmFyIG1vbnRoRGF5c0N1bXVsYXRpdmUgPSBpc0xlYXBZZWFyXG4gICAgICAgID8gX19NT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRVxuICAgICAgICA6IF9fTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkU7XG4gICAgICB2YXIgeWRheSA9IG1vbnRoRGF5c0N1bXVsYXRpdmVbZGF0ZS5nZXRNb250aCgpXSArIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcblxuICAgICAgcmV0dXJuIHlkYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHJlYWRJNTNGcm9tSTY0KHRpbWUpICogMTAwMCk7XG4gICAgICBIRUFQMzJbdG1QdHIgPj4gMl0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyA0KSA+PiAyXSA9IGRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDgpID4+IDJdID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDEyKSA+PiAyXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDE2KSA+PiAyXSA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAyMCkgPj4gMl0gPSBkYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTAwO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDI0KSA+PiAyXSA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgIHZhciB5ZGF5ID0gX195ZGF5X2Zyb21fZGF0ZShkYXRlKSB8IDA7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgMjgpID4+IDJdID0geWRheTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAzNikgPj4gMl0gPSAtKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDYsIDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBkc3QgPVxuICAgICAgICAoc3VtbWVyT2Zmc2V0ICE9IHdpbnRlck9mZnNldCAmJlxuICAgICAgICAgIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PSBNYXRoLm1pbih3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCkpIHwgMDtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAzMikgPj4gMl0gPSBkc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19tbWFwX2pzKGxlbiwgcHJvdCwgZmxhZ3MsIGZkLCBvZmYsIGFsbG9jYXRlZCwgYWRkcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHZhciByZXMgPSBGUy5tbWFwKHN0cmVhbSwgbGVuLCBvZmYsIHByb3QsIGZsYWdzKTtcbiAgICAgICAgdmFyIHB0ciA9IHJlcy5wdHI7XG4gICAgICAgIEhFQVAzMlthbGxvY2F0ZWQgPj4gMl0gPSByZXMuYWxsb2NhdGVkO1xuICAgICAgICBIRUFQVTMyW2FkZHIgPj4gMl0gPSBwdHI7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19tdW5tYXBfanMoYWRkciwgbGVuLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIGlmIChwcm90ICYgMikge1xuICAgICAgICAgIFNZU0NBTExTLmRvTXN5bmMoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIEZTLm11bm1hcChzdHJlYW0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVVVEY4KHN0cikge1xuICAgICAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gICAgICB2YXIgcmV0ID0gX21hbGxvYyhzaXplKTtcbiAgICAgIGlmIChyZXQpIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUDgsIHJldCwgc2l6ZSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfX3R6c2V0X2pzKHRpbWV6b25lLCBkYXlsaWdodCwgdHpuYW1lKSB7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgd2ludGVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDAsIDEpO1xuICAgICAgdmFyIHN1bW1lciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCA2LCAxKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSB3aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgICAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgod2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpO1xuXG4gICAgICBIRUFQVTMyW3RpbWV6b25lID4+IDJdID0gc3RkVGltZXpvbmVPZmZzZXQgKiA2MDtcblxuICAgICAgSEVBUDMyW2RheWxpZ2h0ID4+IDJdID0gTnVtYmVyKHdpbnRlck9mZnNldCAhPSBzdW1tZXJPZmZzZXQpO1xuXG4gICAgICBmdW5jdGlvbiBleHRyYWN0Wm9uZShkYXRlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRhdGUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnR01UJztcbiAgICAgIH1cbiAgICAgIHZhciB3aW50ZXJOYW1lID0gZXh0cmFjdFpvbmUod2ludGVyKTtcbiAgICAgIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyKTtcbiAgICAgIHZhciB3aW50ZXJOYW1lUHRyID0gYWxsb2NhdGVVVEY4KHdpbnRlck5hbWUpO1xuICAgICAgdmFyIHN1bW1lck5hbWVQdHIgPSBhbGxvY2F0ZVVURjgoc3VtbWVyTmFtZSk7XG4gICAgICBpZiAoc3VtbWVyT2Zmc2V0IDwgd2ludGVyT2Zmc2V0KSB7XG4gICAgICAgIEhFQVBVMzJbdHpuYW1lID4+IDJdID0gd2ludGVyTmFtZVB0cjtcbiAgICAgICAgSEVBUFUzMlsodHpuYW1lICsgNCkgPj4gMl0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSEVBUFUzMlt0em5hbWUgPj4gMl0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgICBIRUFQVTMyWyh0em5hbWUgKyA0KSA+PiAyXSA9IHdpbnRlck5hbWVQdHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZGF0ZV9ub3coKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztcbiAgICBfZW1zY3JpcHRlbl9nZXRfbm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiAgICAgIHJldHVybiAyMTQ3NDgzNjQ4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIoc2l6ZSkge1xuICAgICAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdhc21NZW1vcnkuZ3Jvdygoc2l6ZSAtIGIuYnl0ZUxlbmd0aCArIDY1NTM1KSA+Pj4gMTYpO1xuICAgICAgICB1cGRhdGVNZW1vcnlWaWV3cygpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpIHtcbiAgICAgIHZhciBvbGRTaXplID0gSEVBUFU4Lmxlbmd0aDtcbiAgICAgIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuXG4gICAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFsaWduVXAgPSAoeCwgbXVsdGlwbGUpID0+XG4gICAgICAgIHggKyAoKG11bHRpcGxlIC0gKHggJSBtdWx0aXBsZSkpICUgbXVsdGlwbGUpO1xuXG4gICAgICBmb3IgKHZhciBjdXREb3duID0gMTsgY3V0RG93biA8PSA0OyBjdXREb3duICo9IDIpIHtcbiAgICAgICAgdmFyIG92ZXJHcm93bkhlYXBTaXplID0gb2xkU2l6ZSAqICgxICsgMC4yIC8gY3V0RG93bik7XG5cbiAgICAgICAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihcbiAgICAgICAgICBvdmVyR3Jvd25IZWFwU2l6ZSxcbiAgICAgICAgICByZXF1ZXN0ZWRTaXplICsgMTAwNjYzMjk2LFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4oXG4gICAgICAgICAgbWF4SGVhcFNpemUsXG4gICAgICAgICAgYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLCBvdmVyR3Jvd25IZWFwU2l6ZSksIDY1NTM2KSxcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKG5ld1NpemUpO1xuICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBFTlYgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVOYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXNQcm9ncmFtIHx8ICcuL3RoaXMucHJvZ3JhbSc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gICAgICBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICAgICAgICB2YXIgbGFuZyA9XG4gICAgICAgICAgKFxuICAgICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJlxuICAgICAgICAgICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fFxuICAgICAgICAgICAgJ0MnXG4gICAgICAgICAgKS5yZXBsYWNlKCctJywgJ18nKSArICcuVVRGLTgnO1xuICAgICAgICB2YXIgZW52ID0ge1xuICAgICAgICAgIFVTRVI6ICd3ZWJfdXNlcicsXG4gICAgICAgICAgTE9HTkFNRTogJ3dlYl91c2VyJyxcbiAgICAgICAgICBQQVRIOiAnLycsXG4gICAgICAgICAgUFdEOiAnLycsXG4gICAgICAgICAgSE9NRTogJy9ob21lL3dlYl91c2VyJyxcbiAgICAgICAgICBMQU5HOiBsYW5nLFxuICAgICAgICAgIF86IGdldEV4ZWN1dGFibGVOYW1lKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgeCBpbiBFTlYpIHtcbiAgICAgICAgICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07XG4gICAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goeCArICc9JyArIGVudlt4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0ciwgYnVmZmVyLCBkb250QWRkTnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgSEVBUDhbYnVmZmVyKysgPj4gMF0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb250QWRkTnVsbCkgSEVBUDhbYnVmZmVyID4+IDBdID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW52aXJvbl9nZXQoX19lbnZpcm9uLCBlbnZpcm9uX2J1Zikge1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKHN0cmluZywgaSkge1xuICAgICAgICB2YXIgcHRyID0gZW52aXJvbl9idWYgKyBidWZTaXplO1xuICAgICAgICBIRUFQVTMyWyhfX2Vudmlyb24gKyBpICogNCkgPj4gMl0gPSBwdHI7XG4gICAgICAgIHdyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcsIHB0cik7XG4gICAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiAgICAgIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuICAgICAgSEVBUFUzMltwZW52aXJvbl9jb3VudCA+PiAyXSA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgSEVBUFUzMltwZW52aXJvbl9idWZfc2l6ZSA+PiAyXSA9IGJ1ZlNpemU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQsIHBidWYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuXG4gICAgICAgIHZhciB0eXBlID0gc3RyZWFtLnR0eVxuICAgICAgICAgID8gMlxuICAgICAgICAgIDogRlMuaXNEaXIoc3RyZWFtLm1vZGUpXG4gICAgICAgICAgICA/IDNcbiAgICAgICAgICAgIDogRlMuaXNMaW5rKHN0cmVhbS5tb2RlKVxuICAgICAgICAgICAgICA/IDdcbiAgICAgICAgICAgICAgOiA0O1xuICAgICAgICBIRUFQOFtwYnVmID4+IDBdID0gdHlwZTtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgICB2YXIgcHRyID0gSEVBUFUzMltpb3YgPj4gMl07XG4gICAgICAgIHZhciBsZW4gPSBIRUFQVTMyWyhpb3YgKyA0KSA+PiAyXTtcbiAgICAgICAgaW92ICs9IDg7XG4gICAgICAgIHZhciBjdXJyID0gRlMucmVhZChzdHJlYW0sIEhFQVA4LCBwdHIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGN1cnIgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIHJldCArPSBjdXJyO1xuICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWs7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mZF9yZWFkKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHZhciBudW0gPSBkb1JlYWR2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgICAgICBIRUFQVTMyW3BudW0gPj4gMl0gPSBudW07XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmRfc2VlayhmZCwgb2Zmc2V0LCB3aGVuY2UsIG5ld09mZnNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2Zmc2V0ID0gYmlnaW50VG9JNTNDaGVja2VkKG9mZnNldCk7XG4gICAgICAgIGlmIChpc05hTihvZmZzZXQpKSByZXR1cm4gNjE7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBGUy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7XG4gICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgIHN0cmVhbS5wb3NpdGlvbiA+Pj4gMCxcbiAgICAgICAgICAoKHRlbXBEb3VibGUgPSBzdHJlYW0ucG9zaXRpb24pLFxuICAgICAgICAgICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxLjBcbiAgICAgICAgICAgID8gdGVtcERvdWJsZSA+IDAuMFxuICAgICAgICAgICAgICA/IChNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2LjApLFxuICAgICAgICAgICAgICAgICAgNDI5NDk2NzI5NS4wLFxuICAgICAgICAgICAgICAgICkgfFxuICAgICAgICAgICAgICAgICAgMCkgPj4+XG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICA6IH5+K01hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYuMCxcbiAgICAgICAgICAgICAgICApID4+PiAwXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICBdKSxcbiAgICAgICAgICAoSEVBUDMyW25ld09mZnNldCA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKG5ld09mZnNldCArIDQpID4+IDJdID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMgJiYgb2Zmc2V0ID09PSAwICYmIHdoZW5jZSA9PT0gMClcbiAgICAgICAgICBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZkX3N5bmMoZmQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMgJiYgc3RyZWFtLnN0cmVhbV9vcHMuZnN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuZnN5bmMoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgcmV0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+IDJdO1xuICAgICAgICB2YXIgbGVuID0gSEVBUFUzMlsoaW92ICsgNCkgPj4gMl07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICB2YXIgY3VyciA9IEZTLndyaXRlKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgcmV0ICs9IGN1cnI7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mZF93cml0ZShmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICB2YXIgbnVtID0gZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCk7XG4gICAgICAgIEhFQVBVMzJbcG51bSA+PiAyXSA9IG51bTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBGU05vZGUgPSBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLm1vdW50ID0gcGFyZW50Lm1vdW50O1xuICAgICAgdGhpcy5tb3VudGVkID0gbnVsbDtcbiAgICAgIHRoaXMuaWQgPSBGUy5uZXh0SW5vZGUrKztcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5ub2RlX29wcyA9IHt9O1xuICAgICAgdGhpcy5zdHJlYW1fb3BzID0ge307XG4gICAgICB0aGlzLnJkZXYgPSByZGV2O1xuICAgIH07XG4gICAgdmFyIHJlYWRNb2RlID0gMjkyIHwgNzM7XG4gICAgdmFyIHdyaXRlTW9kZSA9IDE0NjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGU05vZGUucHJvdG90eXBlLCB7XG4gICAgICByZWFkOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgcmVhZE1vZGUpID09PSByZWFkTW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgdmFsID8gKHRoaXMubW9kZSB8PSByZWFkTW9kZSkgOiAodGhpcy5tb2RlICY9IH5yZWFkTW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgd3JpdGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiB3cml0ZU1vZGUpID09PSB3cml0ZU1vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHZhbCA/ICh0aGlzLm1vZGUgfD0gd3JpdGVNb2RlKSA6ICh0aGlzLm1vZGUgJj0gfndyaXRlTW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgaXNGb2xkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgaXNEZXZpY2U6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEZTLmlzQ2hyZGV2KHRoaXMubW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIEZTLkZTTm9kZSA9IEZTTm9kZTtcbiAgICBGUy5zdGF0aWNJbml0KCk7XG4gICAgdmFyIEFTU0VSVElPTlMgPSBmYWxzZTtcblxuICAgIHZhciBhc21MaWJyYXJ5QXJnID0ge1xuICAgICAgX19zeXNjYWxsX2NobW9kOiBfX19zeXNjYWxsX2NobW9kLFxuICAgICAgX19zeXNjYWxsX2ZhY2Nlc3NhdDogX19fc3lzY2FsbF9mYWNjZXNzYXQsXG4gICAgICBfX3N5c2NhbGxfZmNobW9kOiBfX19zeXNjYWxsX2ZjaG1vZCxcbiAgICAgIF9fc3lzY2FsbF9mY2hvd24zMjogX19fc3lzY2FsbF9mY2hvd24zMixcbiAgICAgIF9fc3lzY2FsbF9mY250bDY0OiBfX19zeXNjYWxsX2ZjbnRsNjQsXG4gICAgICBfX3N5c2NhbGxfZnN0YXQ2NDogX19fc3lzY2FsbF9mc3RhdDY0LFxuICAgICAgX19zeXNjYWxsX2Z0cnVuY2F0ZTY0OiBfX19zeXNjYWxsX2Z0cnVuY2F0ZTY0LFxuICAgICAgX19zeXNjYWxsX2dldGN3ZDogX19fc3lzY2FsbF9nZXRjd2QsXG4gICAgICBfX3N5c2NhbGxfaW9jdGw6IF9fX3N5c2NhbGxfaW9jdGwsXG4gICAgICBfX3N5c2NhbGxfbHN0YXQ2NDogX19fc3lzY2FsbF9sc3RhdDY0LFxuICAgICAgX19zeXNjYWxsX21rZGlyYXQ6IF9fX3N5c2NhbGxfbWtkaXJhdCxcbiAgICAgIF9fc3lzY2FsbF9uZXdmc3RhdGF0OiBfX19zeXNjYWxsX25ld2ZzdGF0YXQsXG4gICAgICBfX3N5c2NhbGxfb3BlbmF0OiBfX19zeXNjYWxsX29wZW5hdCxcbiAgICAgIF9fc3lzY2FsbF9yZWFkbGlua2F0OiBfX19zeXNjYWxsX3JlYWRsaW5rYXQsXG4gICAgICBfX3N5c2NhbGxfcm1kaXI6IF9fX3N5c2NhbGxfcm1kaXIsXG4gICAgICBfX3N5c2NhbGxfc3RhdDY0OiBfX19zeXNjYWxsX3N0YXQ2NCxcbiAgICAgIF9fc3lzY2FsbF91bmxpbmthdDogX19fc3lzY2FsbF91bmxpbmthdCxcbiAgICAgIF9fc3lzY2FsbF91dGltZW5zYXQ6IF9fX3N5c2NhbGxfdXRpbWVuc2F0LFxuICAgICAgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWM6IF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyxcbiAgICAgIF9sb2NhbHRpbWVfanM6IF9fbG9jYWx0aW1lX2pzLFxuICAgICAgX21tYXBfanM6IF9fbW1hcF9qcyxcbiAgICAgIF9tdW5tYXBfanM6IF9fbXVubWFwX2pzLFxuICAgICAgX3R6c2V0X2pzOiBfX3R6c2V0X2pzLFxuICAgICAgZW1zY3JpcHRlbl9kYXRlX25vdzogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gICAgICBlbXNjcmlwdGVuX2dldF9ub3c6IF9lbXNjcmlwdGVuX2dldF9ub3csXG4gICAgICBlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgICAgIGVudmlyb25fZ2V0OiBfZW52aXJvbl9nZXQsXG4gICAgICBlbnZpcm9uX3NpemVzX2dldDogX2Vudmlyb25fc2l6ZXNfZ2V0LFxuICAgICAgZmRfY2xvc2U6IF9mZF9jbG9zZSxcbiAgICAgIGZkX2Zkc3RhdF9nZXQ6IF9mZF9mZHN0YXRfZ2V0LFxuICAgICAgZmRfcmVhZDogX2ZkX3JlYWQsXG4gICAgICBmZF9zZWVrOiBfZmRfc2VlayxcbiAgICAgIGZkX3N5bmM6IF9mZF9zeW5jLFxuICAgICAgZmRfd3JpdGU6IF9mZF93cml0ZSxcbiAgICAgIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgICB9O1xuICAgIHZhciBhc20gPSBjcmVhdGVXYXNtKCk7XG5cbiAgICB2YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gKE1vZHVsZVsnX19fd2FzbV9jYWxsX2N0b3JzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9fX3dhc21fY2FsbF9jdG9ycyA9IE1vZHVsZVsnX19fd2FzbV9jYWxsX2N0b3JzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3N0YXR1czY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzNjQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfc3RhdHVzNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3N0YXR1czY0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0YXR1czY0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfc3RhdHVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0YXR1cyA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0YXR1cyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2RiX3N0YXR1cyA9IChNb2R1bGVbJ19zcWxpdGUzX2RiX3N0YXR1cyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19kYl9zdGF0dXMgPSBNb2R1bGVbJ19zcWxpdGUzX2RiX3N0YXR1cyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kYl9zdGF0dXMnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19tc2l6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX21zaXplJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX21zaXplID0gTW9kdWxlWydfc3FsaXRlM19tc2l6ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19tc2l6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Zmc19maW5kID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmZzX2ZpbmQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmZzX2ZpbmQgPSBNb2R1bGVbJ19zcWxpdGUzX3Zmc19maW5kJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Zmc19maW5kJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2luaXRpYWxpemUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfaW5pdGlhbGl6ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19pbml0aWFsaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfbWFsbG9jID0gKE1vZHVsZVsnX3NxbGl0ZTNfbWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX21hbGxvYyA9IE1vZHVsZVsnX3NxbGl0ZTNfbWFsbG9jJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX21hbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2ZyZWUgPSAoTW9kdWxlWydfc3FsaXRlM19mcmVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2ZyZWUgPSBNb2R1bGVbJ19zcWxpdGUzX2ZyZWUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZnJlZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Zmc19yZWdpc3RlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Zmc19yZWdpc3RlciddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM192ZnNfcmVnaXN0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Zmc19yZWdpc3RlciddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192ZnNfcmVnaXN0ZXInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192ZnNfdW5yZWdpc3RlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Zmc191bnJlZ2lzdGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Zmc191bnJlZ2lzdGVyID0gTW9kdWxlWydfc3FsaXRlM192ZnNfdW5yZWdpc3RlciddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Zmc191bnJlZ2lzdGVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19tYWxsb2M2NCA9IChNb2R1bGVbJ19zcWxpdGUzX21hbGxvYzY0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX21hbGxvYzY0ID0gTW9kdWxlWydfc3FsaXRlM19tYWxsb2M2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19tYWxsb2M2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3JlYWxsb2MgPSAoTW9kdWxlWydfc3FsaXRlM19yZWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3JlYWxsb2MgPSBNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2MnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVhbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3JlYWxsb2M2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2M2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19yZWFsbG9jNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2M2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZWFsbG9jNjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfdGV4dCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV90ZXh0ID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV90ZXh0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX3RleHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yYW5kb21uZXNzID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmFuZG9tbmVzcyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19yYW5kb21uZXNzID0gTW9kdWxlWydfc3FsaXRlM19yYW5kb21uZXNzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3JhbmRvbW5lc3MnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJpY21wID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RyaWNtcCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zdHJpY21wID0gTW9kdWxlWydfc3FsaXRlM19zdHJpY21wJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0cmljbXAnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJuaWNtcCA9IChNb2R1bGVbJ19zcWxpdGUzX3N0cm5pY21wJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0cm5pY21wID0gTW9kdWxlWydfc3FsaXRlM19zdHJuaWNtcCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zdHJuaWNtcCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSAoTW9kdWxlWydfc3FsaXRlM191cmlfcGFyYW1ldGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9wYXJhbWV0ZXInXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM191cmlfcGFyYW1ldGVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfX19lcnJub19sb2NhdGlvbiA9IChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9fX2Vycm5vX2xvY2F0aW9uID0gTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnX19lcnJub19sb2NhdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9ib29sZWFuID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXJpX2Jvb2xlYW4nXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdXJpX2Jvb2xlYW4gPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9ib29sZWFuJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3VyaV9ib29sZWFuJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfc2VyaWFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfc2VyaWFsaXplJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3NlcmlhbGl6ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfc2VyaWFsaXplJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3NlcmlhbGl6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXBhcmVfdjIgPSAoTW9kdWxlWydfc3FsaXRlM19wcmVwYXJlX3YyJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ByZXBhcmVfdjIgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXBhcmVfdjInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJlcGFyZV92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3N0ZXAgPSAoTW9kdWxlWydfc3FsaXRlM19zdGVwJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0ZXAgPSBNb2R1bGVbJ19zcWxpdGUzX3N0ZXAnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfc3RlcCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQ2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5faW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb2x1bW5faW50NjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXNldCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc2V0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc2V0ID0gTW9kdWxlWydfc3FsaXRlM19yZXNldCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXNldCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2V4ZWMgPSAoTW9kdWxlWydfc3FsaXRlM19leGVjJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2V4ZWMgPSBNb2R1bGVbJ19zcWxpdGUzX2V4ZWMnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZXhlYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5faW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2ludCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2ZpbmFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfZmluYWxpemUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZmluYWxpemUgPSBNb2R1bGVbJ19zcWxpdGUzX2ZpbmFsaXplJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2ZpbmFsaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZmlsZV9jb250cm9sID0gKE1vZHVsZVsnX3NxbGl0ZTNfZmlsZV9jb250cm9sJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2ZpbGVfY29udHJvbCA9IE1vZHVsZVsnX3NxbGl0ZTNfZmlsZV9jb250cm9sJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2ZpbGVfY29udHJvbCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9uYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX25hbWUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX25hbWUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9uYW1lJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbHVtbl9uYW1lJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX3RleHQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fdGV4dCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fdGV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX3RleHQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX3RleHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fdHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl90eXBlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl90eXBlID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fdHlwZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb2x1bW5fdHlwZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2Vycm1zZyA9IChNb2R1bGVbJ19zcWxpdGUzX2Vycm1zZyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJtc2cgPSBNb2R1bGVbJ19zcWxpdGUzX2Vycm1zZyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19lcnJtc2cnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19kZXNlcmlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2Rlc2VyaWFsaXplJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2Rlc2VyaWFsaXplID0gTW9kdWxlWydfc3FsaXRlM19kZXNlcmlhbGl6ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kZXNlcmlhbGl6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MgPSBNb2R1bGVbJ19zcWxpdGUzX2NsZWFyX2JpbmRpbmdzJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ibG9iJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2Jsb2InXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfYmxvYiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2J5dGVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfYnl0ZXMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfYnl0ZXMgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2J5dGVzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX2J5dGVzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZG91YmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZG91YmxlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZG91YmxlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX2RvdWJsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2ludCA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9pbnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludDY0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2ludDY0ID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9pbnQ2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX3N1YnR5cGUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9zdWJ0eXBlJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX3N1YnR5cGUgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3N1YnR5cGUnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9zdWJ0eXBlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfcG9pbnRlciddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9wb2ludGVyJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfcG9pbnRlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfdHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3R5cGUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfdHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfdHlwZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV90eXBlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9ub2NoYW5nZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9mcm9tYmluZCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9mcm9tYmluZCA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9mcm9tYmluZCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZHVwID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZHVwJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2R1cCA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZHVwJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX2R1cCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9mcmVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ZyZWUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfZnJlZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9ibG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Jsb2InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9ibG9iJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc3VsdF9ibG9iJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0gPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZG91YmxlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2RvdWJsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9lcnJvciA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc3VsdF9lcnJvciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfaW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2ludCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQ2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfaW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfaW50NjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfbnVsbCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9udWxsJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9udWxsID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfbnVsbCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfbnVsbCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9wb2ludGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9wb2ludGVyJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3RleHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3RleHQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF90ZXh0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc3VsdF90ZXh0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0ID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VzZXJfZGF0YSA9IChNb2R1bGVbJ19zcWxpdGUzX3VzZXJfZGF0YSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM191c2VyX2RhdGEgPSBNb2R1bGVbJ19zcWxpdGUzX3VzZXJfZGF0YSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM191c2VyX2RhdGEnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luX2ZpcnN0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW5fZmlyc3QnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192dGFiX2luX2ZpcnN0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192dGFiX2luX25leHQgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luX25leHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9pbl9uZXh0ID0gTW9kdWxlWydfc3FsaXRlM192dGFiX2luX25leHQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9pbl9uZXh0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQgPSAoTW9kdWxlWydfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2dldF9hdXhkYXRhID0gKE1vZHVsZVsnX3NxbGl0ZTNfZ2V0X2F1eGRhdGEnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZ2V0X2F1eGRhdGEgPSBNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXhkYXRhJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2dldF9hdXhkYXRhJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfc2V0X2F1eGRhdGEgPSAoTW9kdWxlWydfc3FsaXRlM19zZXRfYXV4ZGF0YSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zZXRfYXV4ZGF0YSA9IE1vZHVsZVsnX3NxbGl0ZTNfc2V0X2F1eGRhdGEnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfc2V0X2F1eGRhdGEnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fY291bnQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fY291bnQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2NvdW50ID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fY291bnQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2NvdW50J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZGF0YV9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX2RhdGFfY291bnQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZGF0YV9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfZGF0YV9jb3VudCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kYXRhX2NvdW50J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYmxvYiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fYmxvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2Jsb2InXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2Jsb2InXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fYnl0ZXMgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYnl0ZXMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2J5dGVzID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYnl0ZXMnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2J5dGVzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9kb3VibGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbHVtbl9kb3VibGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl92YWx1ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl92YWx1ZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fdmFsdWUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl92YWx1ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb2x1bW5fdmFsdWUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2Jsb2InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfYmluZF9ibG9iID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX2Jsb2InXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9ibG9iJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9kb3VibGUgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2RvdWJsZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19iaW5kX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9kb3VibGUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9kb3VibGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX2ludCA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfaW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfaW50ID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19iaW5kX2ludCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfaW50NjQgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludDY0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfaW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfaW50NjQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9pbnQ2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfbnVsbCA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfbnVsbCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19iaW5kX251bGwgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfbnVsbCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19iaW5kX251bGwnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX3BvaW50ZXIgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX3BvaW50ZXInXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfYmluZF9wb2ludGVyID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX3BvaW50ZXInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9wb2ludGVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYmluZF90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF90ZXh0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfdGV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF90ZXh0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2JpbmRfdGV4dCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50ID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50J1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXggPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZGJfaGFuZGxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfaGFuZGxlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2RiX2hhbmRsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfZGJfaGFuZGxlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2RiX2hhbmRsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3N0bXRfcmVhZG9ubHkgPSAoTW9kdWxlWydfc3FsaXRlM19zdG10X3JlYWRvbmx5J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfcmVhZG9ubHkgPSBNb2R1bGVbJ19zcWxpdGUzX3N0bXRfcmVhZG9ubHknXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zdG10X3JlYWRvbmx5J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdG10X2lzZXhwbGFpbiA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfaXNleHBsYWluJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfaXNleHBsYWluID0gTW9kdWxlWydfc3FsaXRlM19zdG10X2lzZXhwbGFpbiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0bXRfaXNleHBsYWluJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdG10X3N0YXR1cyA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfc3RhdHVzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfc3RhdHVzID0gTW9kdWxlWydfc3FsaXRlM19zdG10X3N0YXR1cyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zdG10X3N0YXR1cyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3NxbCA9IChNb2R1bGVbJ19zcWxpdGUzX3NxbCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zcWwgPSBNb2R1bGVbJ19zcWxpdGUzX3NxbCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zcWwnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19leHBhbmRlZF9zcWwgPSAoTW9kdWxlWydfc3FsaXRlM19leHBhbmRlZF9zcWwnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZXhwYW5kZWRfc3FsID0gTW9kdWxlWydfc3FsaXRlM19leHBhbmRlZF9zcWwnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZXhwYW5kZWRfc3FsJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9vbGQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX29sZCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfY291bnQgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9uZXcgPSAoTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfbmV3J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9uZXcgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9uZXcnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19wcmV1cGRhdGVfbmV3J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zZXRfYXV0aG9yaXplciA9IChNb2R1bGVbJ19zcWxpdGUzX3NldF9hdXRob3JpemVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3NldF9hdXRob3JpemVyID0gTW9kdWxlWydfc3FsaXRlM19zZXRfYXV0aG9yaXplciddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3NldF9hdXRob3JpemVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJnbG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RyZ2xvYiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zdHJnbG9iID0gTW9kdWxlWydfc3FsaXRlM19zdHJnbG9iJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0cmdsb2InXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJsaWtlID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RybGlrZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zdHJsaWtlID0gTW9kdWxlWydfc3FsaXRlM19zdHJsaWtlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0cmxpa2UnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IChNb2R1bGVbJ19zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlWydfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbidcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24nXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbidcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcHJlcGFyZV92MyA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXBhcmVfdjMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcHJlcGFyZV92MyA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJlcGFyZV92MyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19wcmVwYXJlX3YzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9tb2R1bGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV9tb2R1bGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIgPSAoTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZHJvcF9tb2R1bGVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfZHJvcF9tb2R1bGVzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2Ryb3BfbW9kdWxlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfZHJvcF9tb2R1bGVzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2Ryb3BfbW9kdWxlcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2RlY2xhcmVfdnRhYiA9IChNb2R1bGVbJ19zcWxpdGUzX2RlY2xhcmVfdnRhYiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19kZWNsYXJlX3Z0YWIgPSBNb2R1bGVbJ19zcWxpdGUzX2RlY2xhcmVfdnRhYiddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kZWNsYXJlX3Z0YWInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24gPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfY29sbGF0aW9uJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfaW4gPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfaW4gPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW4nXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9pbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfZGlzdGluY3QgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2Rpc3RpbmN0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfZGlzdGluY3QgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfZGlzdGluY3QnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192dGFiX2Rpc3RpbmN0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19rZXl3b3JkX25hbWUgPSAoTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX25hbWUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfa2V5d29yZF9uYW1lID0gTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX25hbWUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfa2V5d29yZF9uYW1lJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfY291bnQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9jb3VudCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2tleXdvcmRfY291bnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2tleXdvcmRfY2hlY2sgPSAoTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX2NoZWNrJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2tleXdvcmRfY2hlY2sgPSBNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfY2hlY2snXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19rZXl3b3JkX2NoZWNrJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb21wbGV0ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbXBsZXRlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbXBsZXRlID0gTW9kdWxlWydfc3FsaXRlM19jb21wbGV0ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb21wbGV0ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2xpYnZlcnNpb24gPSAoTW9kdWxlWydfc3FsaXRlM19saWJ2ZXJzaW9uJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2xpYnZlcnNpb24gPSBNb2R1bGVbJ19zcWxpdGUzX2xpYnZlcnNpb24nXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfbGlidmVyc2lvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zaHV0ZG93biA9IChNb2R1bGVbJ19zcWxpdGUzX3NodXRkb3duJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3NodXRkb3duID0gTW9kdWxlWydfc3FsaXRlM19zaHV0ZG93biddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zaHV0ZG93biddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkID0gKE1vZHVsZVsnX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jaGFuZ2VzNjQgPSAoTW9kdWxlWydfc3FsaXRlM19jaGFuZ2VzNjQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2hhbmdlczY0ID0gTW9kdWxlWydfc3FsaXRlM19jaGFuZ2VzNjQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY2hhbmdlczY0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY2hhbmdlcyA9IChNb2R1bGVbJ19zcWxpdGUzX2NoYW5nZXMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2hhbmdlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfY2hhbmdlcyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jaGFuZ2VzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM190b3RhbF9jaGFuZ2VzID0gKE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlcyddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM190b3RhbF9jaGFuZ2VzID0gTW9kdWxlWydfc3FsaXRlM190b3RhbF9jaGFuZ2VzJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdG90YWxfY2hhbmdlcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdHhuX3N0YXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdHhuX3N0YXRlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3R4bl9zdGF0ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdHhuX3N0YXRlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3R4bl9zdGF0ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2Nsb3NlX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2xvc2VfdjInXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2xvc2VfdjIgPSBNb2R1bGVbJ19zcWxpdGUzX2Nsb3NlX3YyJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2Nsb3NlX3YyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYnVzeV9oYW5kbGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV9oYW5kbGVyJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2J1c3lfaGFuZGxlciA9IE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV9oYW5kbGVyJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2J1c3lfaGFuZGxlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIgPSAoTW9kdWxlWydfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYnVzeV90aW1lb3V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV90aW1lb3V0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2J1c3lfdGltZW91dCA9IE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV90aW1lb3V0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2J1c3lfdGltZW91dCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbidcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbidcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiA9IChNb2R1bGVbJ19zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdHJhY2VfdjIgPSAoTW9kdWxlWydfc3FsaXRlM190cmFjZV92MiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM190cmFjZV92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfdHJhY2VfdjInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdHJhY2VfdjInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb21taXRfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbW1pdF9ob29rJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbW1pdF9ob29rID0gTW9kdWxlWydfc3FsaXRlM19jb21taXRfaG9vayddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb21taXRfaG9vayddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VwZGF0ZV9ob29rID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXBkYXRlX2hvb2snXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdXBkYXRlX2hvb2sgPSBNb2R1bGVbJ19zcWxpdGUzX3VwZGF0ZV9ob29rJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3VwZGF0ZV9ob29rJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX3JvbGxiYWNrX2hvb2snXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IE1vZHVsZVsnX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3JvbGxiYWNrX2hvb2snXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2sgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9ob29rJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2Vycm9yX29mZnNldCA9IChNb2R1bGVbJ19zcWxpdGUzX2Vycm9yX29mZnNldCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJvcl9vZmZzZXQgPSBNb2R1bGVbJ19zcWxpdGUzX2Vycm9yX29mZnNldCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19lcnJvcl9vZmZzZXQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19lcnJjb2RlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXJyY29kZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJjb2RlID0gTW9kdWxlWydfc3FsaXRlM19lcnJjb2RlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2VycmNvZGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2VycnN0ciA9IChNb2R1bGVbJ19zcWxpdGUzX2VycnN0ciddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJzdHIgPSBNb2R1bGVbJ19zcWxpdGUzX2VycnN0ciddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19lcnJzdHInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19saW1pdCA9IChNb2R1bGVbJ19zcWxpdGUzX2xpbWl0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2xpbWl0ID0gTW9kdWxlWydfc3FsaXRlM19saW1pdCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19saW1pdCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX29wZW4gPSAoTW9kdWxlWydfc3FsaXRlM19vcGVuJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX29wZW4gPSBNb2R1bGVbJ19zcWxpdGUzX29wZW4nXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfb3BlbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX29wZW5fdjIgPSAoTW9kdWxlWydfc3FsaXRlM19vcGVuX3YyJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX29wZW5fdjIgPSBNb2R1bGVbJ19zcWxpdGUzX29wZW5fdjInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfb3Blbl92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSAoTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24nXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2dldF9hdXRvY29tbWl0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQgPSBNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXRvY29tbWl0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9rZXkgPSAoTW9kdWxlWydfc3FsaXRlM191cmlfa2V5J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3VyaV9rZXkgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9rZXknXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdXJpX2tleSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3VyaV9pbnQ2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM191cmlfaW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM191cmlfaW50NjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19kYl9uYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfbmFtZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19kYl9uYW1lID0gTW9kdWxlWydfc3FsaXRlM19kYl9uYW1lJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2RiX25hbWUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19kYl9maWxlbmFtZSA9IChNb2R1bGVbJ19zcWxpdGUzX2RiX2ZpbGVuYW1lJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2RiX2ZpbGVuYW1lID0gTW9kdWxlWydfc3FsaXRlM19kYl9maWxlbmFtZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kYl9maWxlbmFtZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fZGlmZiA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kaWZmJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9kaWZmID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fZGlmZiddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fZGlmZiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fYXR0YWNoJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9hdHRhY2gnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fYXR0YWNoJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY3JlYXRlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kZWxldGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9kZWxldGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0nXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fZW5hYmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fZW5hYmxlID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fZW5hYmxlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5ID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9pc2VtcHR5J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9zdGFydCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjIgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0gPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0nXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9uZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9uZXh0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXh0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfb3AgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9vcCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9vcCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfb3AnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfb3AnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9wayA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3BrJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3BrID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9wayddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9wayddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X29sZCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X29sZCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9vbGQgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X29sZCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9vbGQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9uZXcgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXcnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfbmV3ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXcnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9hcHBseSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9hcHBseSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY29uZmlnJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jb25maWcnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fY29uZmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zb3VyY2VpZCA9IChNb2R1bGVbJ19zcWxpdGUzX3NvdXJjZWlkJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3NvdXJjZWlkID0gTW9kdWxlWydfc3FsaXRlM19zb3VyY2VpZCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zb3VyY2VpZCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19wdHIgPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fcHN0YWNrX3B0ciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3BzdGFja19hbGxvYydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmcnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX3BzdGFja19xdW90YSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19xdW90YSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2RiX2Vycm9yJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfZXJyb3InXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX2Vycm9yJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cnVjdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0ID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdGVzdF9zdHJ1Y3QnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fZW51bV9qc29uID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24gPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fZW51bV9qc29uJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fdmZzX3VubGluayA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdmZzX3VubGluayddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Zmc191bmxpbmsgPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fdmZzX3VubGluayddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdmZzX3VubGluayddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl92ZnMgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2RiX3ZmcyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX3ZmcyA9IE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9kYl92ZnMnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9kYl92ZnMnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2RiX3Jlc2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9kYl9yZXNldCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX3Jlc2V0ID0gTW9kdWxlWydfc3FsaXRlM193YXNtX2RiX3Jlc2V0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9kYl9yZXNldCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX2V4cG9ydF9jaHVua2VkID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fZGJfZXhwb3J0X2NodW5rZWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjayA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjaydcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjaydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2snXSkuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kcyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdnRhYl9jb25maWcnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Z0YWJfY29uZmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfY29uZmlnX3MnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19zJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2NvbmZpZ19pID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9jb25maWdfaSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2NvbmZpZ19pID0gTW9kdWxlWydfc3FsaXRlM193YXNtX2NvbmZpZ19pJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9jb25maWdfaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9jb25maWdfaWkgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2NvbmZpZ19paSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2NvbmZpZ19paSA9IE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9jb25maWdfaWknXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2NvbmZpZ19paSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9jb25maWdfaiA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fY29uZmlnX2onXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9jb25maWdfaiA9IE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9jb25maWdfaiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fY29uZmlnX2onXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21faW5pdF93YXNtZnMgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2luaXRfd2FzbWZzJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21faW5pdF93YXNtZnMgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX3dhc21faW5pdF93YXNtZnMnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9pbml0X3dhc21mcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0ciA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF9pbnRwdHInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0ciA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0cidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3RfaW50cHRyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0ciA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0cidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0ciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9tYXgnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWF4J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW4nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczIgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczInXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X3RpbWVzMiA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczInXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfdGltZXMyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWlubWF4ID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5tYXgnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHIgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdydcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cnXSkuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF9zdHJfaGVsbG8nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3Rfc3RyX2hlbGxvJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fU1FMVGVzdGVyX3N0cmdsb2IgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9tYWxsb2MgPSAoTW9kdWxlWydfbWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9tYWxsb2MgPSBNb2R1bGVbJ19tYWxsb2MnXSA9IE1vZHVsZVsnYXNtJ11bJ21hbGxvYyddKS5hcHBseShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXJndW1lbnRzLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHZhciBfZnJlZSA9IChNb2R1bGVbJ19mcmVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9mcmVlID0gTW9kdWxlWydfZnJlZSddID0gTW9kdWxlWydhc20nXVsnZnJlZSddKS5hcHBseShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXJndW1lbnRzLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHZhciBfcmVhbGxvYyA9IChNb2R1bGVbJ19yZWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9yZWFsbG9jID0gTW9kdWxlWydfcmVhbGxvYyddID0gTW9kdWxlWydhc20nXVsncmVhbGxvYyddKS5hcHBseShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXJndW1lbnRzLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHZhciBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID0gKE1vZHVsZVsnX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID0gTW9kdWxlW1xuICAgICAgICAgICdfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydlbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIHN0YWNrU2F2ZSA9IChNb2R1bGVbJ3N0YWNrU2F2ZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzdGFja1NhdmUgPSBNb2R1bGVbJ3N0YWNrU2F2ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3RhY2tTYXZlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgc3RhY2tSZXN0b3JlID0gKE1vZHVsZVsnc3RhY2tSZXN0b3JlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHN0YWNrUmVzdG9yZSA9IE1vZHVsZVsnc3RhY2tSZXN0b3JlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzdGFja1Jlc3RvcmUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBzdGFja0FsbG9jID0gKE1vZHVsZVsnc3RhY2tBbGxvYyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzdGFja0FsbG9jID0gTW9kdWxlWydzdGFja0FsbG9jJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzdGFja0FsbG9jJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICBNb2R1bGVbJ3dhc21NZW1vcnknXSA9IHdhc21NZW1vcnk7XG5cbiAgICB2YXIgY2FsbGVkUnVuO1xuXG4gICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuICAgICAgaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuICAgICAgaWYgKCFjYWxsZWRSdW4pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuKGFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBhcmdzIHx8IGFyZ3VtZW50c187XG5cbiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJlUnVuKCk7XG5cbiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgICAgIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgICAgICAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgICAgICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKEFCT1JUKSByZXR1cm47XG5cbiAgICAgICAgaW5pdFJ1bnRpbWUoKTtcblxuICAgICAgICByZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7XG4gICAgICAgIGlmIChNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10pIE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSgpO1xuXG4gICAgICAgIHBvc3RSdW4oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcbiAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpO1xuICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgIGRvUnVuKCk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9SdW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICAgICAgd2hpbGUgKE1vZHVsZVsncHJlSW5pdCddLmxlbmd0aCA+IDApIHtcbiAgICAgICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBydW4oKTtcblxuICAgIGlmICghTW9kdWxlLnBvc3RSdW4pIE1vZHVsZS5wb3N0UnVuID0gW107XG4gICAgTW9kdWxlLnBvc3RSdW4ucHVzaChmdW5jdGlvbiAoTW9kdWxlKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcCA9IGZ1bmN0aW9uIHNxbGl0ZTNBcGlCb290c3RyYXAoXG4gICAgICAgIGFwaUNvbmZpZyA9IGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fFxuICAgICAgICAgIHNxbGl0ZTNBcGlCb290c3RyYXAuZGVmYXVsdENvbmZpZyxcbiAgICAgICkge1xuICAgICAgICBpZiAoc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ3NxbGl0ZTNBcGlCb290c3RyYXAoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuJyxcbiAgICAgICAgICAgICdDb25maWcgYW5kIGV4dGVybmFsIGluaXRpYWxpemVycyBhcmUgaWdub3JlZCBvbiBjYWxscyBhZnRlciB0aGUgZmlyc3QuJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4cG9ydHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1lbW9yeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmlnSW50RW5hYmxlZDogKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhTW9kdWxlLkhFQVBVNjQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5CaWdJbnQ2NEFycmF5O1xuICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgIGRlYnVnOiBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICB3YXJuOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKSxcbiAgICAgICAgICAgIGVycm9yOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICBsb2c6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICB3YXNtZnNPcGZzRGlyOiAnL29wZnMnLFxuXG4gICAgICAgICAgICB1c2VTdGRBbGxvYzogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcGlDb25maWcgfHwge30sXG4gICAgICAgICk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWxsb2NFeHBvcnROYW1lOiBjb25maWcudXNlU3RkQWxsb2MgPyAnbWFsbG9jJyA6ICdzcWxpdGUzX21hbGxvYycsXG4gICAgICAgICAgICBkZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jID8gJ2ZyZWUnIDogJ3NxbGl0ZTNfZnJlZScsXG4gICAgICAgICAgICByZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jXG4gICAgICAgICAgICAgID8gJ3JlYWxsb2MnXG4gICAgICAgICAgICAgIDogJ3NxbGl0ZTNfcmVhbGxvYycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICk7XG5cbiAgICAgICAgWydleHBvcnRzJywgJ21lbW9yeScsICd3YXNtZnNPcGZzRGlyJ10uZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgY29uZmlnW2tdKSB7XG4gICAgICAgICAgICBjb25maWdba10gPSBjb25maWdba10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNhcGkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IHdhc20gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IF9fcmNTdHIgPSAocmMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGNhcGkuc3FsaXRlM19qc19yY19zdHIgJiYgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYykpIHx8XG4gICAgICAgICAgICAnVW5rbm93biByZXN1bHQgY29kZSAjJyArIHJjXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2lzSW50ID0gKG4pID0+ICdudW1iZXInID09PSB0eXBlb2YgbiAmJiBuID09PSAobiB8IDApO1xuXG4gICAgICAgIGNsYXNzIFNRTGl0ZTNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKF9faXNJbnQoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICByYyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBzdXBlcihfX3JjU3RyKGFyZ3NbMF0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmNTdHIgPSBfX3JjU3RyKHJjKTtcbiAgICAgICAgICAgICAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIocmNTdHIsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHJjU3RyICsgJzonO1xuICAgICAgICAgICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgyID09PSBhcmdzLmxlbmd0aCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdENvZGUgPSByYyB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTUUxpdGUzRXJyb3InO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFNRTGl0ZTNFcnJvci50b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgU1FMaXRlM0Vycm9yKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3NzMyA9IFNRTGl0ZTNFcnJvci50b3NzO1xuXG4gICAgICAgIGlmIChjb25maWcud2FzbWZzT3Bmc0RpciAmJiAhL15cXC9bXi9dKyQvLnRlc3QoY29uZmlnLndhc21mc09wZnNEaXIpKSB7XG4gICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICBcImNvbmZpZy53YXNtZnNPcGZzRGlyIG11c3QgYmUgZmFsc3kgb3IgaW4gdGhlIGZvcm0gJy9kaXItbmFtZScuXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzSW50MzIgPSAobikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnYmlnaW50JyAhPT0gdHlwZW9mIG4gJiZcbiAgICAgICAgICAgICEhKG4gPT09IChuIHwgMCkgJiYgbiA8PSAyMTQ3NDgzNjQ3ICYmIG4gPj0gLTIxNDc0ODM2NDgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaWdJbnRGaXRzNjQgPSBmdW5jdGlvbiBmKGIpIHtcbiAgICAgICAgICBpZiAoIWYuX21heCkge1xuICAgICAgICAgICAgZi5fbWF4ID0gQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICAgICAgICAgIGYuX21pbiA9IH5mLl9tYXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiID49IGYuX21pbiAmJiBiIDw9IGYuX21heDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaWdJbnRGaXRzMzIgPSAoYikgPT4gYiA+PSAtMHg3ZmZmZmZmZm4gLSAxbiAmJiBiIDw9IDB4N2ZmZmZmZmZuO1xuXG4gICAgICAgIGNvbnN0IGJpZ0ludEZpdHNEb3VibGUgPSBmdW5jdGlvbiBmKGIpIHtcbiAgICAgICAgICBpZiAoIWYuX21pbikge1xuICAgICAgICAgICAgZi5fbWluID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBmLl9tYXggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGIgPj0gZi5fbWluICYmIGIgPD0gZi5fbWF4O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlzVHlwZWRBcnJheSA9ICh2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHYgJiYgdi5jb25zdHJ1Y3RvciAmJiBpc0ludDMyKHYuY29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQpXG4gICAgICAgICAgICA/IHZcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19TQUIgPVxuICAgICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIDogU2hhcmVkQXJyYXlCdWZmZXI7XG5cbiAgICAgICAgY29uc3QgaXNTaGFyZWRUeXBlZEFycmF5ID0gKGFUeXBlZEFycmF5KSA9PlxuICAgICAgICAgIGFUeXBlZEFycmF5LmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCO1xuXG4gICAgICAgIGNvbnN0IHR5cGVkQXJyYXlQYXJ0ID0gKGFUeXBlZEFycmF5LCBiZWdpbiwgZW5kKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzU2hhcmVkVHlwZWRBcnJheShhVHlwZWRBcnJheSlcbiAgICAgICAgICAgID8gYVR5cGVkQXJyYXkuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgICAgIDogYVR5cGVkQXJyYXkuc3ViYXJyYXkoYmVnaW4sIGVuZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaXNCaW5kYWJsZVR5cGVkQXJyYXkgPSAodikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB2ICYmXG4gICAgICAgICAgICAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpc1NRTGFibGVUeXBlZEFycmF5ID0gKHYpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdiAmJlxuICAgICAgICAgICAgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5ID0gKHYpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNCaW5kYWJsZVR5cGVkQXJyYXkodikgfHxcbiAgICAgICAgICAgIHRvc3MzKCdWYWx1ZSBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgVHlwZWRBcnJheSB0eXBlLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcblxuICAgICAgICBjb25zdCB0eXBlZEFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAodHlwZWRBcnJheSwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodHlwZWRBcnJheVBhcnQodHlwZWRBcnJheSwgYmVnaW4sIGVuZCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZsZXhpYmxlU3RyaW5nID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBpZiAoaXNTUUxhYmxlVHlwZWRBcnJheSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlUb1N0cmluZyhcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkodikgOiB2LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiB2LmpvaW4oJycpO1xuICAgICAgICAgIGVsc2UgaWYgKHdhc20uaXNQdHIodikpIHYgPSB3YXNtLmNzdHJUb0pzKHYpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsYXNzIFdhc21BbGxvY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICgyID09PSBhcmdzLmxlbmd0aCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1cGVyKCdBbGxvY2F0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdWx0Q29kZSA9IGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1dhc21BbGxvY0Vycm9yJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgV2FzbUFsbG9jRXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjYXBpLCB7XG4gICAgICAgICAgc3FsaXRlM19iaW5kX2Jsb2I6IHVuZGVmaW5lZCxcblxuICAgICAgICAgIHNxbGl0ZTNfYmluZF90ZXh0OiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MjogKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbjogKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICApID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uOiAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgIHhJbnZlcnNlLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfcHJlcGFyZV92MzogKFxuICAgICAgICAgICAgZGJQdHIsXG4gICAgICAgICAgICBzcWwsXG4gICAgICAgICAgICBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgc3RtdFB0clB0cixcbiAgICAgICAgICAgIHN0clB0clB0cixcbiAgICAgICAgICApID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19wcmVwYXJlX3YyOiAoXG4gICAgICAgICAgICBkYlB0cixcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHNxbEJ5dGVMZW4sXG4gICAgICAgICAgICBzdG10UHRyUHRyLFxuICAgICAgICAgICAgc3RyUHRyUHRyLFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX2V4ZWM6IChwRGIsIHNxbCwgY2FsbGJhY2ssIHBWb2lkLCBwRXJyTXNnKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfcmFuZG9tbmVzczogKG4sIG91dFB0cikgPT4ge30sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHV0aWwgPSB7XG4gICAgICAgICAgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5LFxuICAgICAgICAgIGZsZXhpYmxlU3RyaW5nLFxuICAgICAgICAgIGJpZ0ludEZpdHMzMixcbiAgICAgICAgICBiaWdJbnRGaXRzNjQsXG4gICAgICAgICAgYmlnSW50Rml0c0RvdWJsZSxcbiAgICAgICAgICBpc0JpbmRhYmxlVHlwZWRBcnJheSxcbiAgICAgICAgICBpc0ludDMyLFxuICAgICAgICAgIGlzU1FMYWJsZVR5cGVkQXJyYXksXG4gICAgICAgICAgaXNUeXBlZEFycmF5LFxuICAgICAgICAgIHR5cGVkQXJyYXlUb1N0cmluZyxcbiAgICAgICAgICBpc1VJVGhyZWFkOiAoKSA9PlxuICAgICAgICAgICAgZ2xvYmFsVGhpcy53aW5kb3cgPT09IGdsb2JhbFRoaXMgJiYgISFnbG9iYWxUaGlzLmRvY3VtZW50LFxuXG4gICAgICAgICAgaXNTaGFyZWRUeXBlZEFycmF5LFxuICAgICAgICAgIHRvc3M6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9zczMsXG4gICAgICAgICAgdHlwZWRBcnJheVBhcnQsXG5cbiAgICAgICAgICBhZmZpcm1EYkhlYWRlcjogZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSAnU1FMaXRlIGZvcm1hdCAzJztcbiAgICAgICAgICAgIGlmIChoZWFkZXIubGVuZ3RoID4gYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICB0b3NzMygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXIuY2hhckNvZGVBdChpKSAhPT0gYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICB0b3NzMygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhZmZpcm1Jc0RiOiBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4gPCA1MTIgfHwgbiAlIDUxMiAhPT0gMCkge1xuICAgICAgICAgICAgICB0b3NzMygnQnl0ZSBhcnJheSBzaXplJywgbiwgJ2lzIGludmFsaWQgZm9yIGFuIFNRTGl0ZTMgZGIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGJ5dGVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24od2FzbSwge1xuICAgICAgICAgIHB0clNpemVvZjogY29uZmlnLndhc21QdHJTaXplb2YgfHwgNCxcblxuICAgICAgICAgIHB0cklSOiBjb25maWcud2FzbVB0cklSIHx8ICdpMzInLFxuXG4gICAgICAgICAgYmlnSW50RW5hYmxlZDogISFjb25maWcuYmlnSW50RW5hYmxlZCxcblxuICAgICAgICAgIGV4cG9ydHM6XG4gICAgICAgICAgICBjb25maWcuZXhwb3J0cyB8fFxuICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgQVBJIGNvbmZpZy5leHBvcnRzIChXQVNNIG1vZHVsZSBleHBvcnRzKS4nKSxcblxuICAgICAgICAgIG1lbW9yeTpcbiAgICAgICAgICAgIGNvbmZpZy5tZW1vcnkgfHxcbiAgICAgICAgICAgIGNvbmZpZy5leHBvcnRzWydtZW1vcnknXSB8fFxuICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICdBUEkgY29uZmlnIG9iamVjdCByZXF1aXJlcyBhIFdlYkFzc2VtYmx5Lk1lbW9yeSBvYmplY3QnLFxuICAgICAgICAgICAgICAnaW4gZWl0aGVyIGNvbmZpZy5leHBvcnRzLm1lbW9yeSAoZXhwb3J0ZWQpJyxcbiAgICAgICAgICAgICAgJ29yIGNvbmZpZy5tZW1vcnkgKGltcG9ydGVkKS4nLFxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICByZWFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBkZWFsbG9jOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChzcmNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgaWYgKHNyY1R5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgc3JjVHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHNyY1R5cGVkQXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXkoc3JjVHlwZWRBcnJheSk7XG4gICAgICAgICAgY29uc3QgcFJldCA9IHdhc20uYWxsb2Moc3JjVHlwZWRBcnJheS5ieXRlTGVuZ3RoIHx8IDEpO1xuICAgICAgICAgIHdhc21cbiAgICAgICAgICAgIC5oZWFwRm9yU2l6ZShzcmNUeXBlZEFycmF5LmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLnNldChzcmNUeXBlZEFycmF5LmJ5dGVMZW5ndGggPyBzcmNUeXBlZEFycmF5IDogWzBdLCBwUmV0KTtcbiAgICAgICAgICByZXR1cm4gcFJldDtcbiAgICAgICAgfTtcblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qga2V5QWxsb2MgPSBjb25maWcuYWxsb2NFeHBvcnROYW1lLFxuICAgICAgICAgICAga2V5RGVhbGxvYyA9IGNvbmZpZy5kZWFsbG9jRXhwb3J0TmFtZSxcbiAgICAgICAgICAgIGtleVJlYWxsb2MgPSBjb25maWcucmVhbGxvY0V4cG9ydE5hbWU7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgW2tleUFsbG9jLCBrZXlEZWFsbG9jLCBrZXlSZWFsbG9jXSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IHdhc20uZXhwb3J0c1trZXldO1xuICAgICAgICAgICAgaWYgKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgcmVxdWlyZWQgZXhwb3J0c1snLCBrZXksICddIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhc20uYWxsb2MgPSBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGYuaW1wbChuKSB8fFxuICAgICAgICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKCdGYWlsZWQgdG8gYWxsb2NhdGUnLCBuLCAnIGJ5dGVzLicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FzbS5hbGxvYy5pbXBsID0gd2FzbS5leHBvcnRzW2tleUFsbG9jXTtcbiAgICAgICAgICB3YXNtLnJlYWxsb2MgPSBmdW5jdGlvbiBmKG0sIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG0yID0gZi5pbXBsKG0sIG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgPyBtMiB8fCBXYXNtQWxsb2NFcnJvci50b3NzKCdGYWlsZWQgdG8gcmVhbGxvY2F0ZScsIG4sICcgYnl0ZXMuJylcbiAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FzbS5yZWFsbG9jLmltcGwgPSB3YXNtLmV4cG9ydHNba2V5UmVhbGxvY107XG4gICAgICAgICAgd2FzbS5kZWFsbG9jID0gd2FzbS5leHBvcnRzW2tleURlYWxsb2NdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FzbS5jb21waWxlT3B0aW9uVXNlZCA9IGZ1bmN0aW9uIGYob3B0TmFtZSkge1xuICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGYuX3Jlc3VsdCkgcmV0dXJuIGYuX3Jlc3VsdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFmLl9vcHQpIHtcbiAgICAgICAgICAgICAgZi5fcnggPSAvXihbXj1dKyk9KC4rKS87XG4gICAgICAgICAgICAgIGYuX3J4SW50ID0gL14tP1xcZCskLztcbiAgICAgICAgICAgICAgZi5fb3B0ID0gZnVuY3Rpb24gKG9wdCwgcnYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZi5fcnguZXhlYyhvcHQpO1xuICAgICAgICAgICAgICAgIHJ2WzBdID0gbSA/IG1bMV0gOiBvcHQ7XG4gICAgICAgICAgICAgICAgcnZbMV0gPSBtID8gKGYuX3J4SW50LnRlc3QobVsyXSkgPyArbVsyXSA6IG1bMl0pIDogdHJ1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJjID0ge30sXG4gICAgICAgICAgICAgIG92ID0gWzAsIDBdO1xuICAgICAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgICAgICBrO1xuICAgICAgICAgICAgd2hpbGUgKChrID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0KGkrKykpKSB7XG4gICAgICAgICAgICAgIGYuX29wdChrLCBvdik7XG4gICAgICAgICAgICAgIHJjW292WzBdXSA9IG92WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChmLl9yZXN1bHQgPSByYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHt9O1xuICAgICAgICAgICAgb3B0TmFtZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICAgIHJjW3ZdID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBvcHROYW1lKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHROYW1lKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgIG9wdE5hbWVba10gPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkKGspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3B0TmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdzdHJpbmcnID09PSB0eXBlb2Ygb3B0TmFtZVxuICAgICAgICAgICAgPyAhIWNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQob3B0TmFtZSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2FzbS5wc3RhY2sgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICByZXN0b3JlOiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlLFxuXG4gICAgICAgICAgYWxsb2M6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBuICYmICEobiA9IHdhc20uc2l6ZW9mSVIobikpKSB7XG4gICAgICAgICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUgZm9yIHBzdGFjay5hbGxvYygnLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgICAgICAnKScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyhuKSB8fFxuICAgICAgICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdDb3VsZCBub3QgYWxsb2NhdGUnLFxuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgJ2J5dGVzIGZyb20gdGhlIHBzdGFjay4nLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhbGxvY0NodW5rczogZnVuY3Rpb24gKG4sIHN6KSB7XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBzeiAmJiAhKHN6ID0gd2FzbS5zaXplb2ZJUihzeikpKSB7XG4gICAgICAgICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgc2l6ZSB2YWx1ZSBmb3IgYWxsb2NDaHVua3MoJyxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVtID0gd2FzbS5wc3RhY2suYWxsb2MobiAqIHN6KTtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IG47ICsraSwgb2Zmc2V0ICs9IHN6KSByYy5wdXNoKG1lbSArIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFsbG9jUHRyOiAobiA9IDEsIHNhZmVQdHJTaXplID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIDEgPT09IG5cbiAgICAgICAgICAgICAgPyB3YXNtLnBzdGFjay5hbGxvYyhzYWZlUHRyU2l6ZSA/IDggOiB3YXNtLnB0clNpemVvZilcbiAgICAgICAgICAgICAgOiB3YXNtLnBzdGFjay5hbGxvY0NodW5rcyhuLCBzYWZlUHRyU2l6ZSA/IDggOiB3YXNtLnB0clNpemVvZik7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNhbGw6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFja1BvcyA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZihzcWxpdGUzKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2tQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3YXNtLnBzdGFjaywge1xuICAgICAgICAgIHBvaW50ZXI6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3B0cixcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcXVvdGE6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByZW1haW5pbmc6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfcmFuZG9tbmVzcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgMSA9PT0gYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgIHV0aWwuaXNUeXBlZEFycmF5KGFyZ3NbMF0pICYmXG4gICAgICAgICAgICAxID09PSBhcmdzWzBdLkJZVEVTX1BFUl9FTEVNRU5UXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB0YSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoMCA9PT0gdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19yYW5kb21uZXNzKDAsIDApO1xuICAgICAgICAgICAgICByZXR1cm4gdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgbiA9IHRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgciA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX3JhbmRvbW5lc3M7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYXAgPSB3YXNtLmhlYXA4dSgpO1xuICAgICAgICAgICAgICBjb25zdCBuQWxsb2MgPSBuIDwgNTEyID8gbiA6IDUxMjtcbiAgICAgICAgICAgICAgY29uc3QgcHRyID0gd2FzbS5wc3RhY2suYWxsb2MobkFsbG9jKTtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGogPSBuID4gbkFsbG9jID8gbkFsbG9jIDogbjtcbiAgICAgICAgICAgICAgICByKGosIHB0cik7XG4gICAgICAgICAgICAgICAgdGEuc2V0KHR5cGVkQXJyYXlQYXJ0KGhlYXAsIHB0ciwgcHRyICsgaiksIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgbiAtPSBqO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBqO1xuICAgICAgICAgICAgICB9IHdoaWxlIChuID4gMCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ0hpZ2hseSB1bmV4cGVjdGVkIChhbmQgaWdub3JlZCEpICcgK1xuICAgICAgICAgICAgICAgICAgJ2V4Y2VwdGlvbiBpbiBzcWxpdGUzX3JhbmRvbW5lc3MoKTonLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmFuZG9tbmVzcyguLi5hcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgX193YXNtZnNPcGZzRGlyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM193YXNtZnNfb3Bmc19kaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gX193YXNtZnNPcGZzRGlyKSByZXR1cm4gX193YXNtZnNPcGZzRGlyO1xuXG4gICAgICAgICAgY29uc3QgcGRpciA9IGNvbmZpZy53YXNtZnNPcGZzRGlyO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFwZGlyIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChfX3dhc21mc09wZnNEaXIgPSAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHBkaXIgJiZcbiAgICAgICAgICAgICAgMCA9PT1cbiAgICAgICAgICAgICAgICB3YXNtLnhDYWxsV3JhcHBlZChcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX3dhc21faW5pdF93YXNtZnMnLFxuICAgICAgICAgICAgICAgICAgJ2kzMicsXG4gICAgICAgICAgICAgICAgICBbJ3N0cmluZyddLFxuICAgICAgICAgICAgICAgICAgcGRpcixcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChfX3dhc21mc09wZnNEaXIgPSBwZGlyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAoX193YXNtZnNPcGZzRGlyID0gJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoX193YXNtZnNPcGZzRGlyID0gJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfd2FzbWZzX2ZpbGVuYW1lX2lzX3BlcnNpc3RlbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGNvbnN0IHAgPSBjYXBpLnNxbGl0ZTNfd2FzbWZzX29wZnNfZGlyKCk7XG4gICAgICAgICAgcmV0dXJuIHAgJiYgbmFtZSA/IG5hbWUuc3RhcnRzV2l0aChwICsgJy8nKSA6IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19kYl91c2VzX3ZmcyA9IGZ1bmN0aW9uIChwRGIsIHZmc05hbWUsIGRiTmFtZSA9IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcEsgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodmZzTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXBLKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICghcERiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwSyA9PT0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKDApID8gcEsgOiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBwSyA9PT0gY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhwRGIsIGRiTmFtZSkgPyBwSyA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3Zmc19saXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICAgICAgbGV0IHBWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoMCk7XG4gICAgICAgICAgd2hpbGUgKHBWZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9WZnMgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcyhwVmZzKTtcbiAgICAgICAgICAgIHJjLnB1c2god2FzbS5jc3RyVG9KcyhvVmZzLiR6TmFtZSkpO1xuICAgICAgICAgICAgcFZmcyA9IG9WZnMuJHBOZXh0O1xuICAgICAgICAgICAgb1Zmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfZGJfZXhwb3J0ID0gZnVuY3Rpb24gKHBEYiwgc2NoZW1hID0gMCkge1xuICAgICAgICAgIHBEYiA9IHdhc20ueFdyYXAudGVzdENvbnZlcnRBcmcoJ3NxbGl0ZTMqJywgcERiKTtcbiAgICAgICAgICBpZiAoIXBEYikgdG9zczMoJ0ludmFsaWQgc3FsaXRlMyogYXJndW1lbnQuJyk7XG4gICAgICAgICAgaWYgKCF3YXNtLmJpZ0ludEVuYWJsZWQpIHRvc3MzKCdCaWdJbnQ2NCBzdXBwb3J0IGlzIG5vdCBlbmFibGVkLicpO1xuICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICBsZXQgcE91dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcFNpemUgPSB3YXNtLnNjb3BlZEFsbG9jKDggKyB3YXNtLnB0clNpemVvZik7XG4gICAgICAgICAgICBjb25zdCBwcE91dCA9IHBTaXplICsgODtcblxuICAgICAgICAgICAgY29uc3QgelNjaGVtYSA9IHNjaGVtYVxuICAgICAgICAgICAgICA/IHdhc20uaXNQdHIoc2NoZW1hKVxuICAgICAgICAgICAgICAgID8gc2NoZW1hXG4gICAgICAgICAgICAgICAgOiB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZygnJyArIHNjaGVtYSlcbiAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgbGV0IHJjID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemUoXG4gICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgelNjaGVtYSxcbiAgICAgICAgICAgICAgcHBPdXQsXG4gICAgICAgICAgICAgIHBTaXplLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYykge1xuICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAnRGF0YWJhc2Ugc2VyaWFsaXphdGlvbiBmYWlsZWQgd2l0aCBjb2RlJyxcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcE91dCA9IHdhc20ucGVla1B0cihwcE91dCk7XG4gICAgICAgICAgICBjb25zdCBuT3V0ID0gd2FzbS5wZWVrKHBTaXplLCAnaTY0Jyk7XG4gICAgICAgICAgICByYyA9IG5PdXRcbiAgICAgICAgICAgICAgPyB3YXNtLmhlYXA4dSgpLnNsaWNlKHBPdXQsIHBPdXQgKyBOdW1iZXIobk91dCkpXG4gICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHBPdXQpIHdhc20uZXhwb3J0cy5zcWxpdGUzX2ZyZWUocE91dCk7XG4gICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyA9IChkYlBvaW50ZXIsIGRiTmFtZSA9IDApID0+XG4gICAgICAgICAgd2FzbS5zcWxpdGUzX3dhc21fZGJfdmZzKGRiUG9pbnRlciwgZGJOYW1lKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfYWdncmVnYXRlX2NvbnRleHQgPSAocEN0eCwgbikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQocEN0eCwgbikgfHxcbiAgICAgICAgICAgIChuXG4gICAgICAgICAgICAgID8gV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAgICdDYW5ub3QgYWxsb2NhdGUnLFxuICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICdieXRlcyBmb3Igc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCgpJyxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogMClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZGF0YSwgZGF0YUxlbikge1xuICAgICAgICAgIGxldCBwRGF0YTtcbiAgICAgICAgICBpZiAoZGF0YSAmJiB3YXNtLmlzUHRyKGRhdGEpKSB7XG4gICAgICAgICAgICBwRGF0YSA9IGRhdGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHBEYXRhID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8ICF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbiA8IDApIHtcbiAgICAgICAgICAgICAgZGF0YUxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICdJbnZhbGlkIDJuZCBhcmd1bWVudCBmb3Igc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbiA8IDApIHtcbiAgICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgM3JkIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Bvc2l4X2NyZWF0ZV9maWxlKCkuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJjID0gd2FzbS5zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUoXG4gICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICBwRGF0YSxcbiAgICAgICAgICAgICAgZGF0YUxlbixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmMpXG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdDcmVhdGlvbiBvZiBmaWxlIGZhaWxlZCB3aXRoIHNxbGl0ZTMgcmVzdWx0IGNvZGUnLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLmRlYWxsb2MocERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHZmcyxcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRhdGFMZW4sXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbmZpZy53YXJuKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkgaXMgZGVwcmVjYXRlZCBhbmQnLFxuICAgICAgICAgICAgJ3Nob3VsZCBiZSBhdm9pZGVkIGJlY2F1c2UgaXQgY2FuIGxlYWQgdG8gQy1sZXZlbCBjcmFzaGVzLicsXG4gICAgICAgICAgICAnU2VlIGl0cyBkb2N1bWVudGF0aW9uIGZvciBhbHRlcm5hdGl2ZSBvcHRpb25zLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcERhdGE7XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGRhdGEpKSB7XG4gICAgICAgICAgICAgIHBEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICBwRGF0YSA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCA0IHx8XG4gICAgICAgICAgICAgICAgIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fFxuICAgICAgICAgICAgICAgIGRhdGFMZW4gPCAwXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRhdGFMZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBEYXRhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbiA8IDApIHtcbiAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICAgICAgICBTUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgJ0ludmFsaWQgNHRoIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSB3YXNtLnNxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUoXG4gICAgICAgICAgICAgIHZmcyxcbiAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHBEYXRhLFxuICAgICAgICAgICAgICBkYXRhTGVuLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIGZpbGUgZmFpbGVkIHdpdGggc3FsaXRlMyByZXN1bHQgY29kZScsXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYyksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19zcWxfdG9fc3RyaW5nID0gKHNxbCkgPT4ge1xuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHNxbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNxbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeCA9IGZsZXhpYmxlU3RyaW5nKHYpO1xuICAgICAgICAgIHJldHVybiB4ID09PSB2ID8gdW5kZWZpbmVkIDogeDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXRpbC5pc1VJVGhyZWFkKCkpIHtcbiAgICAgICAgICBjb25zdCBfX2t2dmZzSW5mbyA9IGZ1bmN0aW9uICh3aGljaCkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgcmMucHJlZml4ID0gJ2t2dmZzLScgKyB3aGljaDtcbiAgICAgICAgICAgIHJjLnN0b3JlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCdzZXNzaW9uJyA9PT0gd2hpY2ggfHwgJycgPT09IHdoaWNoKVxuICAgICAgICAgICAgICByYy5zdG9yZXMucHVzaChnbG9iYWxUaGlzLnNlc3Npb25TdG9yYWdlKTtcbiAgICAgICAgICAgIGlmICgnbG9jYWwnID09PSB3aGljaCB8fCAnJyA9PT0gd2hpY2gpXG4gICAgICAgICAgICAgIHJjLnN0b3Jlcy5wdXNoKGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2t2dmZzX2NsZWFyID0gZnVuY3Rpb24gKHdoaWNoID0gJycpIHtcbiAgICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgICBjb25zdCBrdmluZm8gPSBfX2t2dmZzSW5mbyh3aGljaCk7XG4gICAgICAgICAgICBrdmluZm8uc3RvcmVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9SbSA9IFtdO1xuICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gcy5rZXkoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGsuc3RhcnRzV2l0aChrdmluZm8ucHJlZml4KSkgdG9SbS5wdXNoKGspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvUm0uZm9yRWFjaCgoa2spID0+IHMucmVtb3ZlSXRlbShraykpO1xuICAgICAgICAgICAgICByYyArPSB0b1JtLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfc2l6ZSA9IGZ1bmN0aW9uICh3aGljaCA9ICcnKSB7XG4gICAgICAgICAgICBsZXQgc3ogPSAwO1xuICAgICAgICAgICAgY29uc3Qga3ZpbmZvID0gX19rdnZmc0luZm8od2hpY2gpO1xuICAgICAgICAgICAga3ZpbmZvLnN0b3Jlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBzLmtleShpKTtcbiAgICAgICAgICAgICAgICBpZiAoay5zdGFydHNXaXRoKGt2aW5mby5wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICBzeiArPSBrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHN6ICs9IHMuZ2V0SXRlbShrKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzeiAqIDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhcGkuc3FsaXRlM19kYl9jb25maWcgPSBmdW5jdGlvbiAocERiLCBvcCwgLi4uYXJncykge1xuICAgICAgICAgIGlmICghdGhpcy5zKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX3dhc21fZGJfY29uZmlnX3MnLCAnaW50JywgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0aGlzLnBpaSA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0aGlzLmlwID0gd2FzbS54V3JhcCgnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCcsICdpbnQnLCBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZLRVk6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9UUklHR0VSOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfRlRTM19UT0tFTklaRVI6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9MT0FEX0VYVEVOU0lPTjpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTk9fQ0tQVF9PTl9DTE9TRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1FQU0c6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1RSSUdHRVJfRVFQOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfREVGRU5TSVZFOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19XUklUQUJMRV9TQ0hFTUE6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9BTFRFUl9UQUJMRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RNTDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RETDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1ZJRVc6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9GSUxFX0ZPUk1BVDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfVFJVU1RFRF9TQ0hFTUE6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1NUTVRfU0NBTlNUQVRVUzpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfUkVWRVJTRV9TQ0FOT1JERVI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmlwKHBEYiwgb3AsIGFyZ3NbMF0sIGFyZ3NbMV0gfHwgMCk7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xPT0tBU0lERTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGlpKHBEYiwgb3AsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19NQUlOREJOQU1FOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zKHBEYiwgb3AsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZChPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgcFZhbCxcbiAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBhcmc7XG4gICAgICAgICAgY29uc3QgdmFsVHlwZSA9IGNhcGkuc3FsaXRlM192YWx1ZV90eXBlKHBWYWwpO1xuICAgICAgICAgIHN3aXRjaCAodmFsVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9JTlRFR0VSOlxuICAgICAgICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2ludDY0KHBWYWwpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmJpZ0ludEZpdHNEb3VibGUoYXJnKSkgYXJnID0gTnVtYmVyKGFyZyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfZG91YmxlKHBWYWwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRkxPQVQ6XG4gICAgICAgICAgICAgIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV9kb3VibGUocFZhbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9URVhUOlxuICAgICAgICAgICAgICBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfdGV4dChwVmFsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0JMT0I6IHtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IGNhcGkuc3FsaXRlM192YWx1ZV9ieXRlcyhwVmFsKTtcbiAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfYmxvYihwVmFsKTtcbiAgICAgICAgICAgICAgaWYgKG4gJiYgIXBCbG9iKVxuICAgICAgICAgICAgICAgIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAgICdDYW5ub3QgYWxsb2NhdGUgbWVtb3J5IGZvciBibG9iIGFyZ3VtZW50IG9mJyxcbiAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAnYnl0ZShzKScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYXJnID0gbiA/IHdhc20uaGVhcDh1KCkuc2xpY2UocEJsb2IsIHBCbG9iICsgTnVtYmVyKG4pKSA6IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9OVUxMOlxuICAgICAgICAgICAgICBhcmcgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0aHJvd0lmQ2Fubm90Q29udmVydCkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTTUFUQ0gsXG4gICAgICAgICAgICAgICAgICAnVW5oYW5kbGVkIHNxbGl0ZTNfdmFsdWVfdHlwZSgpOicsXG4gICAgICAgICAgICAgICAgICB2YWxUeXBlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgYXJnYyxcbiAgICAgICAgICBwQXJndixcbiAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGNvbnN0IHRndCA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgICAgICAgIHRndC5wdXNoKFxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMoXG4gICAgICAgICAgICAgICAgd2FzbS5wZWVrUHRyKHBBcmd2ICsgd2FzbS5wdHJTaXplb2YgKiBpKSxcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0Z3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyA9IGZ1bmN0aW9uIChwQ3R4LCBlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBXYXNtQWxsb2NFcnJvcikge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbShwQ3R4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcihwQ3R4LCAnJyArIGUsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcyA9IGZ1bmN0aW9uIChwQ3R4LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludChwQ3R4LCB2YWwgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuYmlnSW50Rml0czMyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfaW50KHBDdHgsIE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuYmlnSW50Rml0c0RvdWJsZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2RvdWJsZShwQ3R4LCBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmJpZ0ludEZpdHM2NCh2YWwpKVxuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludDY0KHBDdHgsIHZhbCk7XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgICAgICdCaWdJbnQgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICdpcyB0b28gQmlnSW50IGZvciBpbnQ2NC4nLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b3NzMygnQmlnSW50IHZhbHVlJywgdmFsLnRvU3RyaW5nKCksICdpcyB0b28gQmlnSW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgICAgIGxldCBmO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIodmFsKSkge1xuICAgICAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfaW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICB3YXNtLmJpZ0ludEVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsKSAmJlxuICAgICAgICAgICAgICAgICAgdXRpbC5iaWdJbnRGaXRzNjQoQmlnSW50KHZhbCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBmID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQ2NDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfZG91YmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmKHBDdHgsIHZhbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF90ZXh0KHBDdHgsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X251bGwocEN0eCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkodmFsKTtcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfYmxvYihcbiAgICAgICAgICAgICAgICAgICAgcEN0eCxcbiAgICAgICAgICAgICAgICAgICAgcEJsb2IsXG4gICAgICAgICAgICAgICAgICAgIHZhbC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICBcIkRvbid0IG5vdCBob3cgdG8gaGFuZGxlIHRoaXMgVURGIHJlc3VsdCB2YWx1ZTpcIixcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWwsXG4gICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfY29sdW1uX2pzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHBTdG10LFxuICAgICAgICAgIGlDb2wsXG4gICAgICAgICAgdGhyb3dJZkNhbm5vdENvbnZlcnQgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB2ID0gY2FwaS5zcWxpdGUzX2NvbHVtbl92YWx1ZShwU3RtdCwgaUNvbCk7XG4gICAgICAgICAgcmV0dXJuIDAgPT09IHZcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyh2LCB0aHJvd0lmQ2Fubm90Q29udmVydCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19uZXdPbGRWYWx1ZSA9IGZ1bmN0aW9uIChwT2JqLCBpQ29sLCBpbXBsKSB7XG4gICAgICAgICAgaW1wbCA9IGNhcGlbaW1wbF07XG4gICAgICAgICAgaWYgKCF0aGlzLnB0cikgdGhpcy5wdHIgPSB3YXNtLmFsbG9jUHRyKCk7XG4gICAgICAgICAgZWxzZSB3YXNtLnBva2VQdHIodGhpcy5wdHIsIDApO1xuICAgICAgICAgIGNvbnN0IHJjID0gaW1wbChwT2JqLCBpQ29sLCB0aGlzLnB0cik7XG4gICAgICAgICAgaWYgKHJjKVxuICAgICAgICAgICAgcmV0dXJuIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzJdICsgJygpIGZhaWxlZCB3aXRoIGNvZGUgJyArIHJjLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBwdiA9IHdhc20ucGVla1B0cih0aGlzLnB0cik7XG4gICAgICAgICAgcmV0dXJuIHB2ID8gY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzKHB2LCB0cnVlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfbmV3X2pzID0gKHBEYiwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX25ldycpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfb2xkX2pzID0gKHBEYiwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX29sZCcpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM2NoYW5nZXNldF9uZXdfanMgPSAocENoYW5nZXNldEl0ZXIsIGlDb2wpID0+XG4gICAgICAgICAgX19uZXdPbGRWYWx1ZShwQ2hhbmdlc2V0SXRlciwgaUNvbCwgJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3Jyk7XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzY2hhbmdlc2V0X29sZF9qcyA9IChwQ2hhbmdlc2V0SXRlciwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBDaGFuZ2VzZXRJdGVyLCBpQ29sLCAnc3FsaXRlM2NoYW5nZXNldF9vbGQnKTtcblxuICAgICAgICBjb25zdCBzcWxpdGUzID0ge1xuICAgICAgICAgIFdhc21BbGxvY0Vycm9yOiBXYXNtQWxsb2NFcnJvcixcbiAgICAgICAgICBTUUxpdGUzRXJyb3I6IFNRTGl0ZTNFcnJvcixcbiAgICAgICAgICBjYXBpLFxuICAgICAgICAgIHV0aWwsXG4gICAgICAgICAgd2FzbSxcbiAgICAgICAgICBjb25maWcsXG5cbiAgICAgICAgICB2ZXJzaW9uOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAgICAgY2xpZW50OiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBhc3luY1Bvc3RJbml0OiBhc3luYyBmdW5jdGlvbiBmZigpIHtcbiAgICAgICAgICAgIGlmIChmZi5pc1JlYWR5IGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIGZmLmlzUmVhZHk7XG4gICAgICAgICAgICBsZXQgbGlhID0gc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYztcbiAgICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVyc0FzeW5jO1xuICAgICAgICAgICAgY29uc3QgcG9zdEluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc3FsaXRlMy5fX2lzVW5kZXJUZXN0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNxbGl0ZTMudXRpbDtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzLlN0cnVjdEJpbmRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc3FsaXRlMztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYXRjaGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgY29uZmlnLmVycm9yKCdhbiBhc3luYyBzcWxpdGUzIGluaXRpYWxpemVyIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWxpYSB8fCAhbGlhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gKGZmLmlzUmVhZHkgPSBwb3N0SW5pdCgpLmNhdGNoKGNhdGNoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpYSA9IGxpYS5tYXAoKGYpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGYgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFzeW5jICh4KSA9PiBmKHNxbGl0ZTMpIDogZjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlhLnB1c2gocG9zdEluaXQpO1xuICAgICAgICAgICAgbGV0IHAgPSBQcm9taXNlLnJlc29sdmUoc3FsaXRlMyk7XG4gICAgICAgICAgICB3aGlsZSAobGlhLmxlbmd0aCkgcCA9IHAudGhlbihsaWEuc2hpZnQoKSk7XG4gICAgICAgICAgICByZXR1cm4gKGZmLmlzUmVhZHkgPSBwLmNhdGNoKGNhdGNoZXIpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2NyaXB0SW5mbzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLmZvckVhY2goKGYpID0+IHtcbiAgICAgICAgICAgIGYoc3FsaXRlMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzIGJvb3RzdHJhcCBpbml0aWFsaXplciB0aHJldzonLCBlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycztcbiAgICAgICAgc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gc3FsaXRlMztcbiAgICAgICAgcmV0dXJuIHNxbGl0ZTM7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzID0gW107XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYyA9IFtdO1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuZGVmYXVsdENvbmZpZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gdW5kZWZpbmVkO1xuXG4gICAgICBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICB0YXJnZXQuYmlnSW50RW5hYmxlZCA9ICEhZ2xvYmFsVGhpc1snQmlnSW50NjRBcnJheSddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRhcmdldC5leHBvcnRzKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ2V4cG9ydHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB0YXJnZXQuaW5zdGFuY2UgJiYgdGFyZ2V0Lmluc3RhbmNlLmV4cG9ydHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwdHJJUiA9IHRhcmdldC5wb2ludGVySVIgfHwgJ2kzMic7XG4gICAgICAgIGNvbnN0IHB0clNpemVvZiA9ICh0YXJnZXQucHRyU2l6ZW9mID1cbiAgICAgICAgICAnaTMyJyA9PT0gcHRySVJcbiAgICAgICAgICAgID8gNFxuICAgICAgICAgICAgOiAnaTY0JyA9PT0gcHRySVJcbiAgICAgICAgICAgICAgPyA4XG4gICAgICAgICAgICAgIDogdG9zcygnVW5oYW5kbGVkIHB0clNpemVvZjonLCBwdHJJUikpO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjYWNoZS5oZWFwU2l6ZSA9IDA7XG5cbiAgICAgICAgY2FjaGUubWVtb3J5ID0gbnVsbDtcblxuICAgICAgICBjYWNoZS5mcmVlRnVuY0luZGV4ZXMgPSBbXTtcblxuICAgICAgICBjYWNoZS5zY29wZWRBbGxvYyA9IFtdO1xuXG4gICAgICAgIGNhY2hlLnV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGNhY2hlLnV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG4gICAgICAgIHRhcmdldC5zaXplb2ZJUiA9IChuKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgICAgY2FzZSAnZjMyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgICAgY2FzZSAnZjY0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgIHJldHVybiBwdHJTaXplb2Y7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gKCcnICsgbikuZW5kc1dpdGgoJyonKSA/IHB0clNpemVvZiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaGVhcFdyYXBwZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghY2FjaGUubWVtb3J5KSB7XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgPVxuICAgICAgICAgICAgICB0YXJnZXQubWVtb3J5IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5XG4gICAgICAgICAgICAgICAgPyB0YXJnZXQubWVtb3J5XG4gICAgICAgICAgICAgICAgOiB0YXJnZXQuZXhwb3J0cy5tZW1vcnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYiA9IGNhY2hlLm1lbW9yeS5idWZmZXI7XG4gICAgICAgICAgY2FjaGUuSEVBUDggPSBuZXcgSW50OEFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVA4VSA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAxNlUgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDMyVSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNhY2hlLkhFQVA2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KGIpO1xuICAgICAgICAgICAgY2FjaGUuSEVBUDY0VSA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FjaGUuSEVBUDMyRiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDY0RiA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuaGVhcFNpemUgPSBiLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5oZWFwOCA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVA4O1xuXG4gICAgICAgIHRhcmdldC5oZWFwOHUgPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAxNiA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAxNjtcblxuICAgICAgICB0YXJnZXQuaGVhcDE2dSA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAxNlU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAzMiA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAzMjtcblxuICAgICAgICB0YXJnZXQuaGVhcDMydSA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAzMlU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXBGb3JTaXplID0gZnVuY3Rpb24gKG4sIHVuc2lnbmVkID0gdHJ1ZSkge1xuICAgICAgICAgIGxldCBjdG9yO1xuICAgICAgICAgIGNvbnN0IGMgPVxuICAgICAgICAgICAgY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgPyBjYWNoZVxuICAgICAgICAgICAgICA6IGhlYXBXcmFwcGVycygpO1xuICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVA4O1xuICAgICAgICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQOFU7XG4gICAgICAgICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAxNjtcbiAgICAgICAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAxNlU7XG4gICAgICAgICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAzMjtcbiAgICAgICAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAzMlU7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDhVIDogYy5IRUFQODtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDE2VSA6IGMuSEVBUDE2O1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gYy5IRUFQMzJVIDogYy5IRUFQMzI7XG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICBpZiAoYy5IRUFQNjQpIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDY0VSA6IGMuSEVBUDY0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0YXJnZXQuYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBnbG9iYWxUaGlzWydCaWdVaW50NjRBcnJheSddKSByZXR1cm4gYy5IRUFQNjRVO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4gPT09IGdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSkgcmV0dXJuIGMuSEVBUDY0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAnSW52YWxpZCBoZWFwRm9yU2l6ZSgpIHNpemU6IGV4cGVjdGluZyA4LCAxNiwgMzIsJyxcbiAgICAgICAgICAgICdvciAoaWYgQmlnSW50IGlzIGVuYWJsZWQpIDY0LicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuZnVuY3Rpb25UYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmV4cG9ydHMuX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuZnVuY3Rpb25FbnRyeSA9IGZ1bmN0aW9uIChmcHRyKSB7XG4gICAgICAgICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgICAgICAgIHJldHVybiBmcHRyIDwgZnQubGVuZ3RoID8gZnQuZ2V0KGZwdHIpIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5qc0Z1bmNUb1dhc20gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZykge1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl8gPSB7XG4gICAgICAgICAgICAgIHNpZ1R5cGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgICBpOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBwOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBQOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBzOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBqOiAnaTY0JyxcbiAgICAgICAgICAgICAgICBmOiAnZjMyJyxcbiAgICAgICAgICAgICAgICBkOiAnZjY0JyxcbiAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgdHlwZUNvZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgICBmNjQ6IDB4N2MsXG4gICAgICAgICAgICAgICAgZjMyOiAweDdkLFxuICAgICAgICAgICAgICAgIGk2NDogMHg3ZSxcbiAgICAgICAgICAgICAgICBpMzI6IDB4N2YsXG4gICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgIHVsZWIxMjhFbmNvZGU6IGZ1bmN0aW9uICh0Z3QsIG1ldGhvZCwgbikge1xuICAgICAgICAgICAgICAgIGlmIChuIDwgMTI4KSB0Z3RbbWV0aG9kXShuKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRndFttZXRob2RdKG4gJSAxMjggfCAxMjgsIG4gPj4gNyk7XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgcnhKU2lnOiAvXihcXHcpXFwoKFxcdyopXFwpJC8sXG5cbiAgICAgICAgICAgICAgc2lnUGFyYW1zOiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGYuXy5yeEpTaWcuZXhlYyhzaWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtID8gbVsyXSA6IHNpZy5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgbGV0dGVyVHlwZTogKHgpID0+XG4gICAgICAgICAgICAgICAgZi5fLnNpZ1R5cGVzW3hdIHx8IHRvc3MoJ0ludmFsaWQgc2lnbmF0dXJlIGxldHRlcjonLCB4KSxcblxuICAgICAgICAgICAgICBwdXNoU2lnVHlwZTogKGRlc3QsIGxldHRlcikgPT5cbiAgICAgICAgICAgICAgICBkZXN0LnB1c2goZi5fLnR5cGVDb2Rlc1tmLl8ubGV0dGVyVHlwZShsZXR0ZXIpXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmdW5jKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gc2lnO1xuICAgICAgICAgICAgc2lnID0gZnVuYztcbiAgICAgICAgICAgIGZ1bmMgPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaWdQYXJhbXMgPSBmLl8uc2lnUGFyYW1zKHNpZyk7XG4gICAgICAgICAgY29uc3Qgd2FzbUNvZGUgPSBbMHgwMSwgMHg2MF07XG4gICAgICAgICAgZi5fLnVsZWIxMjhFbmNvZGUod2FzbUNvZGUsICdwdXNoJywgc2lnUGFyYW1zLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChjb25zdCB4IG9mIHNpZ1BhcmFtcykgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCB4KTtcbiAgICAgICAgICBpZiAoJ3YnID09PSBzaWdbMF0pIHdhc21Db2RlLnB1c2goMCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXNtQ29kZS5wdXNoKDEpO1xuICAgICAgICAgICAgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCBzaWdbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmLl8udWxlYjEyOEVuY29kZSh3YXNtQ29kZSwgJ3Vuc2hpZnQnLCB3YXNtQ29kZS5sZW5ndGgpO1xuICAgICAgICAgIHdhc21Db2RlLnVuc2hpZnQoXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHg2MSxcbiAgICAgICAgICAgIDB4NzMsXG4gICAgICAgICAgICAweDZkLFxuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3YXNtQ29kZS5wdXNoKFxuICAgICAgICAgICAgMHgwMixcbiAgICAgICAgICAgIDB4MDcsXG5cbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHg2NSxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDY2LFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDA3LFxuICAgICAgICAgICAgMHgwNSxcblxuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDY2LFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgICAgICAgbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheSh3YXNtQ29kZSkpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlOiB7IGY6IGZ1bmMgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKS5leHBvcnRzWydmJ107XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZywgc2NvcGVkKSB7XG4gICAgICAgICAgaWYgKHNjb3BlZCAmJiAhY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3NzKCdObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGZ1bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBzaWc7XG4gICAgICAgICAgICBzaWcgPSBmdW5jO1xuICAgICAgICAgICAgZnVuYyA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNpZyB8fCAhKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50czogZXhwZWN0aW5nIChmdW5jdGlvbixzaWduYXR1cmUpICcgK1xuICAgICAgICAgICAgICAgICdvciAoc2lnbmF0dXJlLGZ1bmN0aW9uKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgICAgICAgIGNvbnN0IG9sZExlbiA9IGZ0Lmxlbmd0aDtcbiAgICAgICAgICBsZXQgcHRyO1xuICAgICAgICAgIHdoaWxlIChjYWNoZS5mcmVlRnVuY0luZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwdHIgPSBjYWNoZS5mcmVlRnVuY0luZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoZnQuZ2V0KHB0cikpIHtcbiAgICAgICAgICAgICAgcHRyID0gbnVsbDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgIHB0ciA9IG9sZExlbjtcbiAgICAgICAgICAgIGZ0Lmdyb3coMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdC5zZXQocHRyLCBmdW5jKTtcbiAgICAgICAgICAgIGlmIChzY29wZWQpIHtcbiAgICAgICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgVHlwZUVycm9yKSkge1xuICAgICAgICAgICAgICBpZiAocHRyID09PSBvbGRMZW4pIGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5wdXNoKG9sZExlbik7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZwdHIgPSB0YXJnZXQuanNGdW5jVG9XYXNtKGZ1bmMsIHNpZyk7XG4gICAgICAgICAgICBmdC5zZXQocHRyLCBmcHRyKTtcbiAgICAgICAgICAgIGlmIChzY29wZWQpIHtcbiAgICAgICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChwdHIgPT09IG9sZExlbikgY2FjaGUuZnJlZUZ1bmNJbmRleGVzLnB1c2gob2xkTGVuKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0Lmluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpID0+XG4gICAgICAgICAgX19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCBmYWxzZSk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpID0+XG4gICAgICAgICAgX19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCB0cnVlKTtcblxuICAgICAgICB0YXJnZXQudW5pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbiAocHRyKSB7XG4gICAgICAgICAgaWYgKCFwdHIgJiYgMCAhPT0gcHRyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IGZpID0gY2FjaGUuZnJlZUZ1bmNJbmRleGVzO1xuICAgICAgICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICAgICAgICBmaS5wdXNoKHB0cik7XG4gICAgICAgICAgY29uc3QgcmMgPSBmdC5nZXQocHRyKTtcbiAgICAgICAgICBmdC5zZXQocHRyLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBlZWsgPSBmdW5jdGlvbiBmKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICAgICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgICAgICAgY29uc3QgYyA9XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICA/IGNhY2hlXG4gICAgICAgICAgICAgIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkocHRyKSA/IFtdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGxldCByYztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobGlzdCkgcHRyID0gYXJndW1lbnRzWzBdLnNoaWZ0KCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgICAgcmMgPSBjLkhFQVA4W3B0ciA+PiAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICAgICAgICByYyA9IGMuSEVBUDE2W3B0ciA+PiAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgICAgICAgICByYyA9IGMuSEVBUDMyW3B0ciA+PiAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICBjYXNlICdmMzInOlxuICAgICAgICAgICAgICAgIHJjID0gYy5IRUFQMzJGW3B0ciA+PiAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnZjY0JzpcbiAgICAgICAgICAgICAgICByYyA9IE51bWJlcihjLkhFQVA2NEZbcHRyID4+IDNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJjID0gQmlnSW50KGMuSEVBUDY0W3B0ciA+PiAzXSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0b3NzKCdJbnZhbGlkIHR5cGUgZm9yIHBlZWsoKTonLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaXN0KSBsaXN0LnB1c2gocmMpO1xuICAgICAgICAgIH0gd2hpbGUgKGxpc3QgJiYgYXJndW1lbnRzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGxpc3QgfHwgcmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBva2UgPSBmdW5jdGlvbiAocHRyLCB2YWx1ZSwgdHlwZSA9ICdpOCcpIHtcbiAgICAgICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgICAgICAgY29uc3QgYyA9XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICA/IGNhY2hlXG4gICAgICAgICAgICAgIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwIG9mIEFycmF5LmlzQXJyYXkocHRyKSA/IHB0ciA6IFtwdHJdKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgICAgYy5IRUFQOFtwID4+IDBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2kxNic6XG4gICAgICAgICAgICAgICAgYy5IRUFQMTZbcCA+PiAxXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgICAgICAgIGMuSEVBUDMyW3AgPj4gMl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICBjYXNlICdmMzInOlxuICAgICAgICAgICAgICAgIGMuSEVBUDMyRltwID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Y2NCc6XG4gICAgICAgICAgICAgICAgYy5IRUFQNjRGW3AgPj4gM10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgICAgICBpZiAoYy5IRUFQNjQpIHtcbiAgICAgICAgICAgICAgICAgIGMuSEVBUDY0W3AgPj4gM10gPSBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIGZvciBwb2tlKCk6ICcgKyB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBlZWtQdHIgPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsIHB0cklSKTtcblxuICAgICAgICB0YXJnZXQucG9rZVB0ciA9IChwdHIsIHZhbHVlID0gMCkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgcHRySVIpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrOCA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2k4Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2U4ID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpOCcpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrMTYgPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsICdpMTYnKTtcblxuICAgICAgICB0YXJnZXQucG9rZTE2ID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpMTYnKTtcblxuICAgICAgICB0YXJnZXQucGVlazMyID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnaTMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2UzMiA9IChwdHIsIHZhbHVlKSA9PiB0YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBlZWs2NCA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2k2NCcpO1xuXG4gICAgICAgIHRhcmdldC5wb2tlNjQgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2k2NCcpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrMzJmID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnZjMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2UzMmYgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2YzMicpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrNjRmID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnZjY0Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2U2NGYgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2Y2NCcpO1xuXG4gICAgICAgIHRhcmdldC5nZXRNZW1WYWx1ZSA9IHRhcmdldC5wZWVrO1xuXG4gICAgICAgIHRhcmdldC5nZXRQdHJWYWx1ZSA9IHRhcmdldC5wZWVrUHRyO1xuXG4gICAgICAgIHRhcmdldC5zZXRNZW1WYWx1ZSA9IHRhcmdldC5wb2tlO1xuXG4gICAgICAgIHRhcmdldC5zZXRQdHJWYWx1ZSA9IHRhcmdldC5wb2tlUHRyO1xuXG4gICAgICAgIHRhcmdldC5pc1B0cjMyID0gKHB0cikgPT5cbiAgICAgICAgICAnbnVtYmVyJyA9PT0gdHlwZW9mIHB0ciAmJiBwdHIgPT09IChwdHIgfCAwKSAmJiBwdHIgPj0gMDtcblxuICAgICAgICB0YXJnZXQuaXNQdHIgPSB0YXJnZXQuaXNQdHIzMjtcblxuICAgICAgICB0YXJnZXQuY3N0cmxlbiA9IGZ1bmN0aW9uIChwdHIpIHtcbiAgICAgICAgICBpZiAoIXB0ciB8fCAhdGFyZ2V0LmlzUHRyKHB0cikpIHJldHVybiBudWxsO1xuICAgICAgICAgIGNvbnN0IGggPSBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG4gICAgICAgICAgbGV0IHBvcyA9IHB0cjtcbiAgICAgICAgICBmb3IgKDsgaFtwb3NdICE9PSAwOyArK3Bvcykge31cbiAgICAgICAgICByZXR1cm4gcG9zIC0gcHRyO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fU0FCID1cbiAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICA6IFNoYXJlZEFycmF5QnVmZmVyO1xuICAgICAgICBjb25zdCBfX3V0ZjhEZWNvZGUgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUudXRmOERlY29kZXIuZGVjb2RlKFxuICAgICAgICAgICAgYXJyYXlCdWZmZXIuYnVmZmVyIGluc3RhbmNlb2YgX19TQUJcbiAgICAgICAgICAgICAgPyBhcnJheUJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKVxuICAgICAgICAgICAgICA6IGFycmF5QnVmZmVyLnN1YmFycmF5KGJlZ2luLCBlbmQpLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmNzdHJUb0pzID0gZnVuY3Rpb24gKHB0cikge1xuICAgICAgICAgIGNvbnN0IG4gPSB0YXJnZXQuY3N0cmxlbihwdHIpO1xuICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICA/IF9fdXRmOERlY29kZShoZWFwV3JhcHBlcnMoKS5IRUFQOFUsIHB0ciwgcHRyICsgbilcbiAgICAgICAgICAgIDogbnVsbCA9PT0gblxuICAgICAgICAgICAgICA/IG5cbiAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuanN0cmxlbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHIpIHJldHVybiBudWxsO1xuICAgICAgICAgIGNvbnN0IG4gPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgdSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKHUgPj0gMHhkODAwICYmIHUgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIHUgPVxuICAgICAgICAgICAgICAgICgweDEwMDAwICsgKCh1ICYgMHgzZmYpIDw8IDEwKSkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1IDw9IDB4N2YpICsrbGVuO1xuICAgICAgICAgICAgZWxzZSBpZiAodSA8PSAweDdmZikgbGVuICs9IDI7XG4gICAgICAgICAgICBlbHNlIGlmICh1IDw9IDB4ZmZmZikgbGVuICs9IDM7XG4gICAgICAgICAgICBlbHNlIGxlbiArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5qc3RyY3B5ID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGpzdHIsXG4gICAgICAgICAgdGd0LFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgbWF4Qnl0ZXMgPSAtMSxcbiAgICAgICAgICBhZGROdWwgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGd0IHx8XG4gICAgICAgICAgICAoISh0Z3QgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpICYmICEodGd0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0b3NzKCdqc3RyY3B5KCkgdGFyZ2V0IG11c3QgYmUgYW4gSW50OEFycmF5IG9yIFVpbnQ4QXJyYXkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhCeXRlcyA8IDApIG1heEJ5dGVzID0gdGd0Lmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICBpZiAoIShtYXhCeXRlcyA+IDApIHx8ICEob2Zmc2V0ID49IDApKSByZXR1cm4gMDtcbiAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBtYXggPSBqc3RyLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBiZWdpbiA9IG9mZnNldCxcbiAgICAgICAgICAgIGVuZCA9IG9mZnNldCArIG1heEJ5dGVzIC0gKGFkZE51bCA/IDEgOiAwKTtcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heCAmJiBvZmZzZXQgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgbGV0IHUgPSBqc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAodSA+PSAweGQ4MDAgJiYgdSA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgdSA9XG4gICAgICAgICAgICAgICAgKDB4MTAwMDAgKyAoKHUgJiAweDNmZikgPDwgMTApKSB8XG4gICAgICAgICAgICAgICAgKGpzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUgPD0gMHg3Zikge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0ID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSB1O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N2ZmKSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAxID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweGMwIHwgKHUgPj4gNik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodSA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDIgPj0gZW5kKSBicmVhaztcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ZTAgfCAodSA+PiAxMik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgMHgzZik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAzID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweGYwIHwgKHUgPj4gMTgpO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiAweDNmKTtcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAodSAmIDB4M2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWRkTnVsKSB0Z3Rbb2Zmc2V0KytdID0gMDtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0IC0gYmVnaW47XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmNzdHJuY3B5ID0gZnVuY3Rpb24gKHRndFB0ciwgc3JjUHRyLCBuKSB7XG4gICAgICAgICAgaWYgKCF0Z3RQdHIgfHwgIXNyY1B0cilcbiAgICAgICAgICAgIHRvc3MoJ2NzdHJuY3B5KCkgZG9lcyBub3QgYWNjZXB0IE5VTEwgc3RyaW5ncy4nKTtcbiAgICAgICAgICBpZiAobiA8IDApIG4gPSB0YXJnZXQuY3N0cmxlbihzdHJQdHIpICsgMTtcbiAgICAgICAgICBlbHNlIGlmICghKG4gPiAwKSkgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgaGVhcCA9IHRhcmdldC5oZWFwOHUoKTtcbiAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBjaDtcbiAgICAgICAgICBmb3IgKDsgaSA8IG4gJiYgKGNoID0gaGVhcFtzcmNQdHIgKyBpXSk7ICsraSkge1xuICAgICAgICAgICAgaGVhcFt0Z3RQdHIgKyBpXSA9IGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA8IG4pIGhlYXBbdGd0UHRyICsgaSsrXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmpzdHJUb1VpbnRBcnJheSA9IChzdHIsIGFkZE51bCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLnV0ZjhFbmNvZGVyLmVuY29kZShhZGROdWwgPyBzdHIgKyAnXFwwJyA6IHN0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hZmZpcm1BbGxvYyA9IChvYmosIGZ1bmNOYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShvYmouYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgICEob2JqLmRlYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdPYmplY3QgaXMgbWlzc2luZyBhbGxvYygpIGFuZC9vciBkZWFsbG9jKCkgZnVuY3Rpb24ocyknLFxuICAgICAgICAgICAgICAncmVxdWlyZWQgYnknLFxuICAgICAgICAgICAgICBmdW5jTmFtZSArICcoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hbGxvY0NTdHIgPSBmdW5jdGlvbiAoXG4gICAgICAgICAganN0cixcbiAgICAgICAgICByZXR1cm5XaXRoTGVuZ3RoLFxuICAgICAgICAgIGFsbG9jYXRvcixcbiAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsIGZ1bmNOYW1lKTtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBqc3RyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoMCkge1xuICAgICAgICAgICAgY29uc3QgbiA9IHRhcmdldC5qc3RybGVuKGpzdHIpLFxuICAgICAgICAgICAgICBwdHIgPSBhbGxvY2F0b3IobiArIDEpO1xuICAgICAgICAgICAgdGFyZ2V0LmpzdHJjcHkoanN0ciwgdGFyZ2V0LmhlYXA4dSgpLCBwdHIsIG4gKyAxLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgbl0gOiBwdHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBjYWNoZS51dGY4RW5jb2Rlci5lbmNvZGUoanN0ciksXG4gICAgICAgICAgICAgIHB0ciA9IGFsbG9jYXRvcih1Lmxlbmd0aCArIDEpLFxuICAgICAgICAgICAgICBoZWFwID0gaGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuICAgICAgICAgICAgaGVhcC5zZXQodSwgcHRyKTtcbiAgICAgICAgICAgIGhlYXBbcHRyICsgdS5sZW5ndGhdID0gMDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgdS5sZW5ndGhdIDogcHRyO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuYWxsb2NDU3RyaW5nID0gKGpzdHIsIHJldHVybldpdGhMZW5ndGggPSBmYWxzZSkgPT5cbiAgICAgICAgICBfX2FsbG9jQ1N0cihqc3RyLCByZXR1cm5XaXRoTGVuZ3RoLCB0YXJnZXQuYWxsb2MsICdhbGxvY0NTdHJpbmcoKScpO1xuXG4gICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1B1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsICdzY29wZWRBbGxvY1B1c2gnKTtcbiAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2MucHVzaChhKTtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQb3AgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgJ3Njb3BlZEFsbG9jUG9wJyk7XG4gICAgICAgICAgY29uc3QgbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgID8gY2FjaGUuc2NvcGVkQWxsb2MuaW5kZXhPZihzdGF0ZSlcbiAgICAgICAgICAgIDogY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAobiA8IDApIHRvc3MoJ0ludmFsaWQgc3RhdGUgb2JqZWN0IGZvciBzY29wZWRBbGxvY1BvcCgpLicpO1xuICAgICAgICAgIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSBzdGF0ZSA9IGNhY2hlLnNjb3BlZEFsbG9jW25dO1xuICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jLnNwbGljZShuLCAxKTtcbiAgICAgICAgICBmb3IgKGxldCBwOyAocCA9IHN0YXRlLnBvcCgpKTsgKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmZ1bmN0aW9uRW50cnkocCkpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnVuaW5zdGFsbEZ1bmN0aW9uKHApO1xuICAgICAgICAgICAgfSBlbHNlIHRhcmdldC5kZWFsbG9jKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2MgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGlmICghY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3NzKCdObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHAgPSB0YXJnZXQuYWxsb2Mobik7XG4gICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwKTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LnNjb3BlZEFsbG9jLCAnbGV2ZWwnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IGNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MoXCJUaGUgJ2FjdGl2ZScgcHJvcGVydHkgaXMgcmVhZC1vbmx5LlwiKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jQ1N0cmluZyA9IChqc3RyLCByZXR1cm5XaXRoTGVuZ3RoID0gZmFsc2UpID0+XG4gICAgICAgICAgX19hbGxvY0NTdHIoXG4gICAgICAgICAgICBqc3RyLFxuICAgICAgICAgICAgcmV0dXJuV2l0aExlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvYyxcbiAgICAgICAgICAgICdzY29wZWRBbGxvY0NTdHJpbmcoKScsXG4gICAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBfX2FsbG9jTWFpbkFyZ3YgPSBmdW5jdGlvbiAoaXNTY29wZWQsIGxpc3QpIHtcbiAgICAgICAgICBjb25zdCBwTGlzdCA9IHRhcmdldFtpc1Njb3BlZCA/ICdzY29wZWRBbGxvYycgOiAnYWxsb2MnXShcbiAgICAgICAgICAgIChsaXN0Lmxlbmd0aCArIDEpICogdGFyZ2V0LnB0clNpemVvZixcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICBsaXN0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5wb2tlUHRyKFxuICAgICAgICAgICAgICBwTGlzdCArIHRhcmdldC5wdHJTaXplb2YgKiBpKyssXG4gICAgICAgICAgICAgIHRhcmdldFtpc1Njb3BlZCA/ICdzY29wZWRBbGxvY0NTdHJpbmcnIDogJ2FsbG9jQ1N0cmluZyddKCcnICsgZSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldC5wb2tlUHRyKHBMaXN0ICsgdGFyZ2V0LnB0clNpemVvZiAqIGksIDApO1xuICAgICAgICAgIHJldHVybiBwTGlzdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NNYWluQXJndiA9IChsaXN0KSA9PiBfX2FsbG9jTWFpbkFyZ3YodHJ1ZSwgbGlzdCk7XG5cbiAgICAgICAgdGFyZ2V0LmFsbG9jTWFpbkFyZ3YgPSAobGlzdCkgPT4gX19hbGxvY01haW5Bcmd2KGZhbHNlLCBsaXN0KTtcblxuICAgICAgICB0YXJnZXQuY0FyZ3ZUb0pzID0gKGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnYzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0YXJnZXQucGVla1B0cihwQXJndiArIHRhcmdldC5wdHJTaXplb2YgKiBpKTtcbiAgICAgICAgICAgIGxpc3QucHVzaChhcmcgPyB0YXJnZXQuY3N0clRvSnMoYXJnKSA6IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NDYWxsID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1BvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FsbG9jUHRyID0gZnVuY3Rpb24gKGhvd01hbnksIHNhZmVQdHJTaXplLCBtZXRob2QpIHtcbiAgICAgICAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgbWV0aG9kKTtcbiAgICAgICAgICBjb25zdCBwSXIgPSBzYWZlUHRyU2l6ZSA/ICdpNjQnIDogcHRySVI7XG4gICAgICAgICAgbGV0IG0gPSB0YXJnZXRbbWV0aG9kXShob3dNYW55ICogKHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZikpO1xuICAgICAgICAgIHRhcmdldC5wb2tlKG0sIDAsIHBJcik7XG4gICAgICAgICAgaWYgKDEgPT09IGhvd01hbnkpIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhID0gW21dO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaG93TWFueTsgKytpKSB7XG4gICAgICAgICAgICBtICs9IHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZjtcbiAgICAgICAgICAgIGFbaV0gPSBtO1xuICAgICAgICAgICAgdGFyZ2V0LnBva2UobSwgMCwgcElyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmFsbG9jUHRyID0gKGhvd01hbnkgPSAxLCBzYWZlUHRyU2l6ZSA9IHRydWUpID0+XG4gICAgICAgICAgX19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ2FsbG9jJyk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jUHRyID0gKGhvd01hbnkgPSAxLCBzYWZlUHRyU2l6ZSA9IHRydWUpID0+XG4gICAgICAgICAgX19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ3Njb3BlZEFsbG9jJyk7XG5cbiAgICAgICAgdGFyZ2V0LnhHZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0YXJnZXQuZXhwb3J0c1tuYW1lXSB8fCB0b3NzKCdDYW5ub3QgZmluZCBleHBvcnRlZCBzeW1ib2w6JywgbmFtZSlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYXJnY01pc21hdGNoID0gKGYsIG4pID0+XG4gICAgICAgICAgdG9zcyhmICsgJygpIHJlcXVpcmVzJywgbiwgJ2FyZ3VtZW50KHMpLicpO1xuXG4gICAgICAgIHRhcmdldC54Q2FsbCA9IGZ1bmN0aW9uIChmbmFtZSwgLi4uYXJncykge1xuICAgICAgICAgIGNvbnN0IGYgPSB0YXJnZXQueEdldChmbmFtZSk7XG4gICAgICAgICAgaWYgKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgICAgICAgIHRvc3MoJ0V4cG9ydGVkIHN5bWJvbCcsIGZuYW1lLCAnaXMgbm90IGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZm5hbWUsIGYubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gMiA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSlcbiAgICAgICAgICAgID8gZi5hcHBseShudWxsLCBhcmd1bWVudHNbMV0pXG4gICAgICAgICAgICA6IGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FjaGUueFdyYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0LmFyZyA9IG5ldyBNYXAoKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgeEFyZyA9IGNhY2hlLnhXcmFwLmNvbnZlcnQuYXJnLFxuICAgICAgICAgIHhSZXN1bHQgPSBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdDtcblxuICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICB4QXJnLnNldCgnaTY0JywgKGkpID0+IEJpZ0ludChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX194QXJnUHRyID1cbiAgICAgICAgICAnaTMyJyA9PT0gcHRySVIgPyAoaSkgPT4gaSB8IDAgOiAoaSkgPT4gQmlnSW50KGkpIHwgQmlnSW50KDApO1xuICAgICAgICB4QXJnXG4gICAgICAgICAgLnNldCgnaTMyJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJ2kxNicsIChpKSA9PiAoaSB8IDApICYgMHhmZmZmKVxuICAgICAgICAgIC5zZXQoJ2k4JywgKGkpID0+IChpIHwgMCkgJiAweGZmKVxuICAgICAgICAgIC5zZXQoJ2YzMicsIChpKSA9PiBOdW1iZXIoaSkudmFsdWVPZigpKVxuICAgICAgICAgIC5zZXQoJ2Zsb2F0JywgeEFyZy5nZXQoJ2YzMicpKVxuICAgICAgICAgIC5zZXQoJ2Y2NCcsIHhBcmcuZ2V0KCdmMzInKSlcbiAgICAgICAgICAuc2V0KCdkb3VibGUnLCB4QXJnLmdldCgnZjY0JykpXG4gICAgICAgICAgLnNldCgnaW50JywgeEFyZy5nZXQoJ2kzMicpKVxuICAgICAgICAgIC5zZXQoJ251bGwnLCAoaSkgPT4gaSlcbiAgICAgICAgICAuc2V0KG51bGwsIHhBcmcuZ2V0KCdudWxsJykpXG4gICAgICAgICAgLnNldCgnKionLCBfX3hBcmdQdHIpXG4gICAgICAgICAgLnNldCgnKicsIF9feEFyZ1B0cik7XG4gICAgICAgIHhSZXN1bHRcbiAgICAgICAgICAuc2V0KCcqJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJ3BvaW50ZXInLCBfX3hBcmdQdHIpXG4gICAgICAgICAgLnNldCgnbnVtYmVyJywgKHYpID0+IE51bWJlcih2KSlcbiAgICAgICAgICAuc2V0KCd2b2lkJywgKHYpID0+IHVuZGVmaW5lZClcbiAgICAgICAgICAuc2V0KCdudWxsJywgKHYpID0+IHYpXG4gICAgICAgICAgLnNldChudWxsLCB4UmVzdWx0LmdldCgnbnVsbCcpKTtcblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29weVRvUmVzdWx0ID0gW1xuICAgICAgICAgICAgJ2k4JyxcbiAgICAgICAgICAgICdpMTYnLFxuICAgICAgICAgICAgJ2kzMicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdmMzInLFxuICAgICAgICAgICAgJ2Zsb2F0JyxcbiAgICAgICAgICAgICdmNjQnLFxuICAgICAgICAgICAgJ2RvdWJsZScsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIGNvcHlUb1Jlc3VsdC5wdXNoKCdpNjQnKTtcbiAgICAgICAgICBjb25zdCBhZGFwdFB0ciA9IHhBcmcuZ2V0KHB0cklSKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgY29weVRvUmVzdWx0KSB7XG4gICAgICAgICAgICB4QXJnLnNldCh0ICsgJyonLCBhZGFwdFB0cik7XG4gICAgICAgICAgICB4UmVzdWx0LnNldCh0ICsgJyonLCBhZGFwdFB0cik7XG4gICAgICAgICAgICB4UmVzdWx0LnNldCh0LCB4QXJnLmdldCh0KSB8fCB0b3NzKCdNaXNzaW5nIGFyZyBjb252ZXJ0ZXI6JywgdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF9feEFyZ1N0cmluZyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdikgcmV0dXJuIHRhcmdldC5zY29wZWRBbGxvY0NTdHJpbmcodik7XG4gICAgICAgICAgcmV0dXJuIHYgPyBfX3hBcmdQdHIodikgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB4QXJnXG4gICAgICAgICAgLnNldCgnc3RyaW5nJywgX194QXJnU3RyaW5nKVxuICAgICAgICAgIC5zZXQoJ3V0ZjgnLCBfX3hBcmdTdHJpbmcpXG4gICAgICAgICAgLnNldCgncG9pbnRlcicsIF9feEFyZ1N0cmluZyk7XG5cbiAgICAgICAgeFJlc3VsdFxuICAgICAgICAgIC5zZXQoJ3N0cmluZycsIChpKSA9PiB0YXJnZXQuY3N0clRvSnMoaSkpXG4gICAgICAgICAgLnNldCgndXRmOCcsIHhSZXN1bHQuZ2V0KCdzdHJpbmcnKSlcbiAgICAgICAgICAuc2V0KCdzdHJpbmc6ZGVhbGxvYycsIChpKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaSA/IHRhcmdldC5jc3RyVG9KcyhpKSA6IG51bGw7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuZGVhbGxvYyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zZXQoJ3V0Zjg6ZGVhbGxvYycsIHhSZXN1bHQuZ2V0KCdzdHJpbmc6ZGVhbGxvYycpKVxuICAgICAgICAgIC5zZXQoJ2pzb24nLCAoaSkgPT4gSlNPTi5wYXJzZSh0YXJnZXQuY3N0clRvSnMoaSkpKVxuICAgICAgICAgIC5zZXQoJ2pzb246ZGVhbGxvYycsIChpKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaSA/IEpTT04ucGFyc2UodGFyZ2V0LmNzdHJUb0pzKGkpKSA6IG51bGw7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuZGVhbGxvYyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBBYnN0cmFjdEFyZ0FkYXB0ZXIgPSBjbGFzcyB7XG4gICAgICAgICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCAndW5uYW1lZCBhZGFwdGVyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb252ZXJ0QXJnKHYsIGFyZ3YsIGFyZ0luZGV4KSB7XG4gICAgICAgICAgICB0b3NzKCdBYnN0cmFjdEFyZ0FkYXB0ZXIgbXVzdCBiZSBzdWJjbGFzc2VkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyID0gY2xhc3MgRnVuY1B0ckFkYXB0ZXIgZXh0ZW5kcyBBYnN0cmFjdEFyZ0FkYXB0ZXIge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgICAgIGlmICh4QXJnLkZ1bmNQdHJBZGFwdGVyLndhcm5PblVzZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ3hBcmcuRnVuY1B0ckFkYXB0ZXIgaXMgYW4gaW50ZXJuYWwtb25seSBBUEknLFxuICAgICAgICAgICAgICAgICdhbmQgaXMgbm90IGludGVuZGVkIHRvIGJlIGludm9rZWQgZnJvbScsXG4gICAgICAgICAgICAgICAgJ2NsaWVudC1sZXZlbCBjb2RlLiBJbnZva2VkIHdpdGg6JyxcbiAgICAgICAgICAgICAgICBvcHQsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCAndW5uYW1lZCc7XG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IG9wdC5zaWduYXR1cmU7XG4gICAgICAgICAgICBpZiAob3B0LmNvbnRleHRLZXkgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkgPSBvcHQuY29udGV4dEtleTtcbiAgICAgICAgICAgICAgaWYgKCFvcHQuYmluZFNjb3BlKSBvcHQuYmluZFNjb3BlID0gJ2NvbnRleHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaW5kU2NvcGUgPVxuICAgICAgICAgICAgICBvcHQuYmluZFNjb3BlIHx8XG4gICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgJ0Z1bmNQdHJBZGFwdGVyIG9wdGlvbnMgcmVxdWlyZXMgYSBiaW5kU2NvcGUgKGV4cGxpY2l0IG9yIGltcGxpZWQpLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5pbmRleE9mKG9wdC5iaW5kU2NvcGUpIDwgMCkge1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIG9wdGlvbnMuYmluZFNjb3BlICgnICtcbiAgICAgICAgICAgICAgICAgIG9wdC5iaW5kTW9kICtcbiAgICAgICAgICAgICAgICAgICcpIGZvciBGdW5jUHRyQWRhcHRlci4gJyArXG4gICAgICAgICAgICAgICAgICAnRXhwZWN0aW5nIG9uZSBvZjogKCcgK1xuICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAgICcpJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNUcmFuc2llbnQgPSAndHJhbnNpZW50JyA9PT0gdGhpcy5iaW5kU2NvcGU7XG4gICAgICAgICAgICB0aGlzLmlzQ29udGV4dCA9ICdjb250ZXh0JyA9PT0gdGhpcy5iaW5kU2NvcGU7XG4gICAgICAgICAgICB0aGlzLmlzUGVybWFuZW50ID0gJ3Blcm1hbmVudCcgPT09IHRoaXMuYmluZFNjb3BlO1xuICAgICAgICAgICAgdGhpcy5zaW5nbGV0b24gPSAnc2luZ2xldG9uJyA9PT0gdGhpcy5iaW5kU2NvcGUgPyBbXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5jYWxsUHJveHkgPVxuICAgICAgICAgICAgICBvcHQuY2FsbFByb3h5IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvcHQuY2FsbFByb3h5IDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHRNYXAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjbSA9IHRoaXMuX19jbWFwIHx8ICh0aGlzLl9fY21hcCA9IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBsZXQgcmMgPSBjbS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHJjKSBjbS5zZXQoa2V5LCAocmMgPSBbXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnZlcnRBcmcodiwgYXJndiwgYXJnSW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gdGhpcy5zaW5nbGV0b247XG4gICAgICAgICAgICBpZiAoIXBhaXIgJiYgdGhpcy5pc0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgcGFpciA9IHRoaXMuY29udGV4dE1hcCh0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWlyICYmIHBhaXJbMF0gPT09IHYpIHJldHVybiBwYWlyWzFdO1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsUHJveHkpIHYgPSB0aGlzLmNhbGxQcm94eSh2KTtcbiAgICAgICAgICAgICAgY29uc3QgZnAgPSBfX2luc3RhbGxGdW5jdGlvbih2LCB0aGlzLnNpZ25hdHVyZSwgdGhpcy5pc1RyYW5zaWVudCk7XG4gICAgICAgICAgICAgIGlmIChGdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAnRnVuY1B0ckFkYXB0ZXIgaW5zdGFsbGVkJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgJ0AnICsgZnAsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFpclsxXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKEZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAgICAgJ0Z1bmNQdHJBZGFwdGVyIHVuaW5zdGFsbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICdAJyArIHBhaXJbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgcGFpclsxXSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhaXJbMF0gPSB2O1xuICAgICAgICAgICAgICAgIHBhaXJbMV0gPSBmcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5pc1B0cih2KSB8fCBudWxsID09PSB2IHx8IHVuZGVmaW5lZCA9PT0gdikge1xuICAgICAgICAgICAgICBpZiAocGFpciAmJiBwYWlyWzFdICYmIHBhaXJbMV0gIT09IHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCkge1xuICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAgICdGdW5jUHRyQWRhcHRlciB1bmluc3RhbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAnQCcgKyBwYWlyWzFdLFxuICAgICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2gocGFpclsxXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICBwYWlyWzBdID0gcGFpclsxXSA9IHYgfCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB2IHx8IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIEZ1bmNQdHJBZGFwdGVyIGFyZ3VtZW50IHR5cGUuICcgK1xuICAgICAgICAgICAgICAgICAgJ0V4cGVjdGluZyBhIGZ1bmN0aW9uIHBvaW50ZXIgb3IgYSAnICtcbiAgICAgICAgICAgICAgICAgICh0aGlzLm5hbWUgPyB0aGlzLm5hbWUgKyAnICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uIG1hdGNoaW5nIHNpZ25hdHVyZSAnICtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlICtcbiAgICAgICAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgeEFyZy5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSBmYWxzZTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwgPSBmYWxzZTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0ID0gY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpO1xuXG4gICAgICAgIHhBcmcuRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3BlcyA9IFtcbiAgICAgICAgICAndHJhbnNpZW50JyxcbiAgICAgICAgICAnY29udGV4dCcsXG4gICAgICAgICAgJ3NpbmdsZXRvbicsXG4gICAgICAgICAgJ3Blcm1hbmVudCcsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgX194QXJnQWRhcHRlckNoZWNrID0gKHQpID0+XG4gICAgICAgICAgeEFyZy5nZXQodCkgfHwgdG9zcygnQXJndW1lbnQgYWRhcHRlciBub3QgZm91bmQ6JywgdCk7XG5cbiAgICAgICAgY29uc3QgX194UmVzdWx0QWRhcHRlckNoZWNrID0gKHQpID0+XG4gICAgICAgICAgeFJlc3VsdC5nZXQodCkgfHwgdG9zcygnUmVzdWx0IGFkYXB0ZXIgbm90IGZvdW5kOicsIHQpO1xuXG4gICAgICAgIGNhY2hlLnhXcmFwLmNvbnZlcnRBcmcgPSAodCwgLi4uYXJncykgPT4gX194QXJnQWRhcHRlckNoZWNrKHQpKC4uLmFyZ3MpO1xuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0QXJnTm9DaGVjayA9ICh0LCAuLi5hcmdzKSA9PiB4QXJnLmdldCh0KSguLi5hcmdzKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0ID0gKHQsIHYpID0+XG4gICAgICAgICAgbnVsbCA9PT0gdCA/IHYgOiB0ID8gX194UmVzdWx0QWRhcHRlckNoZWNrKHQpKHYpIDogdW5kZWZpbmVkO1xuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0Tm9DaGVjayA9ICh0LCB2KSA9PlxuICAgICAgICAgIG51bGwgPT09IHQgPyB2IDogdCA/IHhSZXN1bHQuZ2V0KHQpKHYpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHRhcmdldC54V3JhcCA9IGZ1bmN0aW9uIChmQXJnLCByZXN1bHRUeXBlLCAuLi5hcmdUeXBlcykge1xuICAgICAgICAgIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSkge1xuICAgICAgICAgICAgYXJnVHlwZXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YXJnZXQuaXNQdHIoZkFyZykpIHtcbiAgICAgICAgICAgIGZBcmcgPVxuICAgICAgICAgICAgICB0YXJnZXQuZnVuY3Rpb25FbnRyeShmQXJnKSB8fFxuICAgICAgICAgICAgICB0b3NzKCdGdW5jdGlvbiBwb2ludGVyIG5vdCBmb3VuZCBpbiBXQVNNIGZ1bmN0aW9uIHRhYmxlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmSXNGdW5jID0gZkFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgICAgICAgIGNvbnN0IHhmID0gZklzRnVuYyA/IGZBcmcgOiB0YXJnZXQueEdldChmQXJnKTtcbiAgICAgICAgICBpZiAoZklzRnVuYykgZkFyZyA9IHhmLm5hbWUgfHwgJ3VubmFtZWQgZnVuY3Rpb24nO1xuICAgICAgICAgIGlmIChhcmdUeXBlcy5sZW5ndGggIT09IHhmLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZkFyZywgeGYubGVuZ3RoKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmVzdWx0VHlwZSAmJiAwID09PSB4Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gcmVzdWx0VHlwZSAmJiBudWxsICE9PSByZXN1bHRUeXBlKVxuICAgICAgICAgICAgX194UmVzdWx0QWRhcHRlckNoZWNrKHJlc3VsdFR5cGUpO1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBhcmdUeXBlcykge1xuICAgICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBBYnN0cmFjdEFyZ0FkYXB0ZXIpXG4gICAgICAgICAgICAgIHhBcmcuc2V0KHQsICguLi5hcmdzKSA9PiB0LmNvbnZlcnRBcmcoLi4uYXJncykpO1xuICAgICAgICAgICAgZWxzZSBfX3hBcmdBZGFwdGVyQ2hlY2sodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN4dyA9IGNhY2hlLnhXcmFwO1xuICAgICAgICAgIGlmICgwID09PSB4Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT5cbiAgICAgICAgICAgICAgYXJncy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IF9fYXJnY01pc21hdGNoKGZBcmcsIHhmLmxlbmd0aClcbiAgICAgICAgICAgICAgICA6IGN4dy5jb252ZXJ0UmVzdWx0KHJlc3VsdFR5cGUsIHhmLmNhbGwobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0geGYubGVuZ3RoKSBfX2FyZ2NNaXNtYXRjaChmQXJnLCB4Zi5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gYXJncylcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gY3h3LmNvbnZlcnRBcmdOb0NoZWNrKGFyZ1R5cGVzW2ldLCBhcmdzW2ldLCBhcmdzLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGN4dy5jb252ZXJ0UmVzdWx0Tm9DaGVjayhyZXN1bHRUeXBlLCB4Zi5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX194QWRhcHRlciA9IGZ1bmN0aW9uIChcbiAgICAgICAgICBmdW5jLFxuICAgICAgICAgIGFyZ2MsXG4gICAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICBtb2RlTmFtZSxcbiAgICAgICAgICB4Y3ZQYXJ0LFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0eXBlTmFtZSkge1xuICAgICAgICAgICAgaWYgKDEgPT09IGFyZ2MpIHJldHVybiB4Y3ZQYXJ0LmdldCh0eXBlTmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICgyID09PSBhcmdjKSB7XG4gICAgICAgICAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB4Y3ZQYXJ0LmdldCh0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIShhZGFwdGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhtb2RlTmFtZSwgJ3JlcXVpcmVzIGEgZnVuY3Rpb24gYXJndW1lbnQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeGN2UGFydC5zZXQodHlwZU5hbWUsIGFkYXB0ZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnSW52YWxpZCBhcmd1bWVudHMgdG8nLCBtb2RlTmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnhXcmFwLnJlc3VsdEFkYXB0ZXIgPSBmdW5jdGlvbiBmKHR5cGVOYW1lLCBhZGFwdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9feEFkYXB0ZXIoXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGVOYW1lLFxuICAgICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICAgICdyZXN1bHRBZGFwdGVyKCknLFxuICAgICAgICAgICAgeFJlc3VsdCxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC54V3JhcC5hcmdBZGFwdGVyID0gZnVuY3Rpb24gZih0eXBlTmFtZSwgYWRhcHRlcikge1xuICAgICAgICAgIHJldHVybiBfX3hBZGFwdGVyKFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICAnYXJnQWRhcHRlcigpJyxcbiAgICAgICAgICAgIHhBcmcsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQueFdyYXAuRnVuY1B0ckFkYXB0ZXIgPSB4QXJnLkZ1bmNQdHJBZGFwdGVyO1xuXG4gICAgICAgIHRhcmdldC54Q2FsbFdyYXBwZWQgPSBmdW5jdGlvbiAoZkFyZywgcmVzdWx0VHlwZSwgYXJnVHlwZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbM10pKSBhcmdzID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICAgIC54V3JhcChmQXJnLCByZXN1bHRUeXBlLCBhcmdUeXBlcyB8fCBbXSlcbiAgICAgICAgICAgIC5hcHBseShudWxsLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQueFdyYXAudGVzdENvbnZlcnRBcmcgPSBjYWNoZS54V3JhcC5jb252ZXJ0QXJnO1xuXG4gICAgICAgIHRhcmdldC54V3JhcC50ZXN0Q29udmVydFJlc3VsdCA9IGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlci55YXdsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25zdCB3ZmV0Y2ggPSAoKSA9PiBmZXRjaChjb25maWcudXJpLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pO1xuICAgICAgICBjb25zdCB3dWkgPSB0aGlzO1xuICAgICAgICBjb25zdCBmaW5hbFRoZW4gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy53YXNtVXRpbFRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGd0ID0gY29uZmlnLndhc21VdGlsVGFyZ2V0O1xuICAgICAgICAgICAgdGd0Lm1vZHVsZSA9IGFyZy5tb2R1bGU7XG4gICAgICAgICAgICB0Z3QuaW5zdGFuY2UgPSBhcmcuaW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGlmICghdGd0Lmluc3RhbmNlLmV4cG9ydHMubWVtb3J5KSB7XG4gICAgICAgICAgICAgIHRndC5tZW1vcnkgPVxuICAgICAgICAgICAgICAgIChjb25maWcuaW1wb3J0cyAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydHMuZW52ICYmXG4gICAgICAgICAgICAgICAgICBjb25maWcuaW1wb3J0cy5lbnYubWVtb3J5KSB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXCJNaXNzaW5nICdtZW1vcnknIG9iamVjdCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRndC5hbGxvYyAmJiBhcmcuaW5zdGFuY2UuZXhwb3J0cy5tYWxsb2MpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXhwb3J0cyA9IGFyZy5pbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICAgICAgICB0Z3QuYWxsb2MgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICBleHBvcnRzLm1hbGxvYyhuKSB8fCB0b3NzKCdBbGxvY2F0aW9uIG9mJywgbiwgJ2J5dGVzIGZhaWxlZC4nKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRndC5kZWFsbG9jID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmZyZWUobSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3dWkodGd0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbmZpZy5vbmxvYWQpIGNvbmZpZy5vbmxvYWQoYXJnLCBjb25maWcpO1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvYWRXYXNtID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdcbiAgICAgICAgICA/IGZ1bmN0aW9uIGxvYWRXYXNtU3RyZWFtaW5nKCkge1xuICAgICAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoXG4gICAgICAgICAgICAgICAgd2ZldGNoKCksXG4gICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydHMgfHwge30sXG4gICAgICAgICAgICAgICkudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24gbG9hZFdhc21PbGRTY2hvb2woKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3ZmV0Y2goKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICAgICAgICAudGhlbigoYnl0ZXMpID0+XG4gICAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgY29uZmlnLmltcG9ydHMgfHwge30pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGxvYWRXYXNtO1xuICAgICAgfS5iaW5kKGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcik7XG5cbiAgICAgICgndXNlIHN0cmljdCcpO1xuICAgICAgZ2xvYmFsVGhpcy5KYWNjd2FieXQgPSBmdW5jdGlvbiBTdHJ1Y3RCaW5kZXJGYWN0b3J5KGNvbmZpZykge1xuICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5KSAmJlxuICAgICAgICAgICEoY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICdjb25maWcuaGVhcCBtdXN0IGJlIFdlYkFzc2VtYmx5Lk1lbW9yeSBpbnN0YW5jZSBvciBhIGZ1bmN0aW9uLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBbJ2FsbG9jJywgJ2RlYWxsb2MnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgY29uZmlnW2tdIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgIHRvc3MoXCJDb25maWcgb3B0aW9uICdcIiArIGsgKyBcIicgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IFNCRiA9IFN0cnVjdEJpbmRlckZhY3Rvcnk7XG4gICAgICAgIGNvbnN0IGhlYXAgPVxuICAgICAgICAgICAgY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICA/IGNvbmZpZy5oZWFwXG4gICAgICAgICAgICAgIDogKCkgPT4gbmV3IFVpbnQ4QXJyYXkoY29uZmlnLmhlYXAuYnVmZmVyKSxcbiAgICAgICAgICBhbGxvYyA9IGNvbmZpZy5hbGxvYyxcbiAgICAgICAgICBkZWFsbG9jID0gY29uZmlnLmRlYWxsb2MsXG4gICAgICAgICAgbG9nID0gY29uZmlnLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgICAgICAgIG1lbWJlclByZWZpeCA9IGNvbmZpZy5tZW1iZXJQcmVmaXggfHwgJycsXG4gICAgICAgICAgbWVtYmVyU3VmZml4ID0gY29uZmlnLm1lbWJlclN1ZmZpeCB8fCAnJyxcbiAgICAgICAgICBiaWdJbnRFbmFibGVkID1cbiAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gY29uZmlnLmJpZ0ludEVuYWJsZWRcbiAgICAgICAgICAgICAgPyAhIWdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXVxuICAgICAgICAgICAgICA6ICEhY29uZmlnLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgQmlnSW50ID0gZ2xvYmFsVGhpc1snQmlnSW50J10sXG4gICAgICAgICAgQmlnSW50NjRBcnJheSA9IGdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSxcbiAgICAgICAgICBwdHJTaXplb2YgPSBjb25maWcucHRyU2l6ZW9mIHx8IDQsXG4gICAgICAgICAgcHRySVIgPSBjb25maWcucHRySVIgfHwgJ2kzMic7XG4gICAgICAgIGlmICghU0JGLmRlYnVnRmxhZ3MpIHtcbiAgICAgICAgICBTQkYuX19tYWtlRGVidWdGbGFncyA9IGZ1bmN0aW9uIChkZXJpdmVGcm9tID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGRlcml2ZUZyb20gJiYgZGVyaXZlRnJvbS5fX2ZsYWdzKVxuICAgICAgICAgICAgICBkZXJpdmVGcm9tID0gZGVyaXZlRnJvbS5fX2ZsYWdzO1xuICAgICAgICAgICAgY29uc3QgZiA9IGZ1bmN0aW9uIGYoZmxhZ3MpIHtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5fX2ZsYWdzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyA8IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmdldHRlcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLnNldHRlcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmFsbG9jO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmLl9fZmxhZ3MuZGVhbGxvYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmLl9fZmxhZ3MuZ2V0dGVyID0gMCAhPT0gKDB4MDEgJiBmbGFncyk7XG4gICAgICAgICAgICAgICAgZi5fX2ZsYWdzLnNldHRlciA9IDAgIT09ICgweDAyICYgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGYuX19mbGFncy5hbGxvYyA9IDAgIT09ICgweDA0ICYgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGYuX19mbGFncy5kZWFsbG9jID0gMCAhPT0gKDB4MDggJiBmbGFncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGYuX2ZsYWdzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCAnX19mbGFncycsIHtcbiAgICAgICAgICAgICAgaXRlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuY3JlYXRlKGRlcml2ZUZyb20pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWRlcml2ZUZyb20pIGYoMCk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFNCRi5kZWJ1Z0ZsYWdzID0gU0JGLl9fbWFrZURlYnVnRmxhZ3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzTGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlKTtcblxuICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpWzBdID09PSAyNTY7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgY29uc3QgaXNGdW5jU2lnID0gKHMpID0+ICcoJyA9PT0gc1sxXTtcblxuICAgICAgICBjb25zdCBpc1B0clNpZyA9IChzKSA9PiAncCcgPT09IHMgfHwgJ1AnID09PSBzO1xuICAgICAgICBjb25zdCBpc0F1dG9QdHJTaWcgPSAocykgPT4gJ1AnID09PSBzO1xuICAgICAgICBjb25zdCBzaWdMZXR0ZXIgPSAocykgPT4gKGlzRnVuY1NpZyhzKSA/ICdwJyA6IHNbMF0pO1xuXG4gICAgICAgIGNvbnN0IHNpZ0lSID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpOCc7XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpMzInO1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICByZXR1cm4gcHRySVI7XG4gICAgICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpNjQnO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgIHJldHVybiAnZG91YmxlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnVW5oYW5kbGVkIHNpZ25hdHVyZSBJUjonLCBzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1CaWdJbnRBcnJheSA9IEJpZ0ludDY0QXJyYXlcbiAgICAgICAgICA/ICgpID0+IHRydWVcbiAgICAgICAgICA6ICgpID0+IHRvc3MoJ0JpZ0ludDY0QXJyYXkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblxuICAgICAgICBjb25zdCBzaWdEVkdldHRlciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgc3dpdGNoIChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICBjYXNlICdzJzoge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHB0clNpemVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnZ2V0SW50MzInO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdnZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRJbnQzMic7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRJbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2dldFVpbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnZ2V0QmlnSW50NjQnO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2V0RmxvYXQzMic7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRGbG9hdDY0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnVW5oYW5kbGVkIERhdGFWaWV3IGdldHRlciBmb3Igc2lnbmF0dXJlOicsIHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNpZ0RWU2V0dGVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocHRyU2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdzZXRJbnQzMic7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ3NldEJpZ0ludDY0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEludDMyJztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEludDgnO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgIHJldHVybiAnc2V0VWludDgnO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgIHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdzZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdzZXRGbG9hdDMyJztcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEZsb2F0NjQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3NzKCdVbmhhbmRsZWQgRGF0YVZpZXcgc2V0dGVyIGZvciBzaWduYXR1cmU6Jywgcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc2lnRFZTZXRXcmFwcGVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcjtcbiAgICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgIHN3aXRjaCAocHRyU2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcjtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoJ1VuaGFuZGxlZCBEYXRhVmlldyBzZXQgd3JhcHBlciBmb3Igc2lnbmF0dXJlOicsIHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNQcm9wTmFtZSA9IChzLCBrKSA9PiBzICsgJzo6JyArIGs7XG5cbiAgICAgICAgY29uc3QgX19wcm9wVGhyb3dPblNldCA9IGZ1bmN0aW9uIChzdHJ1Y3ROYW1lLCBwcm9wTmFtZSkge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB0b3NzKHNQcm9wTmFtZShzdHJ1Y3ROYW1lLCBwcm9wTmFtZSksICdpcyByZWFkLW9ubHkuJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19pbnN0YW5jZVBvaW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGNvbnN0IHhQdHJQcm9wTmFtZSA9ICcocG9pbnRlci1pcy1leHRlcm5hbCknO1xuXG4gICAgICAgIGNvbnN0IF9fZnJlZVN0cnVjdCA9IGZ1bmN0aW9uIChjdG9yLCBvYmosIG0pIHtcbiAgICAgICAgICBpZiAoIW0pIG0gPSBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQob2JqKTtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgX19pbnN0YW5jZVBvaW50ZXJNYXAuZGVsZXRlKG9iaik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoub25kaXNwb3NlKSkge1xuICAgICAgICAgICAgICBsZXQgeDtcbiAgICAgICAgICAgICAgd2hpbGUgKCh4ID0gb2JqLm9uZGlzcG9zZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB4LmNhbGwob2JqKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSB4LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdudW1iZXInID09PSB0eXBlb2YgeCkgZGVhbGxvYyh4KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICdvbmRpc3Bvc2UoKSBmb3InLFxuICAgICAgICAgICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICAgICAgJ3RocmV3LiBOT1QgcHJvcGFnYXRpbmcgaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5vbmRpc3Bvc2UgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5vbmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdvbmRpc3Bvc2UoKSBmb3InLFxuICAgICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICAgICd0aHJldy4gTk9UIHByb3BhZ2F0aW5nIGl0LicsXG4gICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBvYmoub25kaXNwb3NlO1xuICAgICAgICAgICAgaWYgKGN0b3IuZGVidWdGbGFncy5fX2ZsYWdzLmRlYWxsb2MpIHtcbiAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICdkZWJ1Zy5kZWFsbG9jOicsXG4gICAgICAgICAgICAgICAgb2JqW3hQdHJQcm9wTmFtZV0gPyAnRVhURVJOQUwnIDogJycsXG4gICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICdpbnN0YW5jZTonLFxuICAgICAgICAgICAgICAgIGN0b3Iuc3RydWN0SW5mby5zaXplb2YsXG4gICAgICAgICAgICAgICAgJ2J5dGVzIEAnICsgbSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb2JqW3hQdHJQcm9wTmFtZV0pIGRlYWxsb2MobSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJvcCA9ICh2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWxsb2NTdHJ1Y3QgPSBmdW5jdGlvbiAoY3Rvciwgb2JqLCBtKSB7XG4gICAgICAgICAgbGV0IGZpbGwgPSAhbTtcbiAgICAgICAgICBpZiAobSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgeFB0clByb3BOYW1lLCByb3AobSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbSA9IGFsbG9jKGN0b3Iuc3RydWN0SW5mby5zaXplb2YpO1xuICAgICAgICAgICAgaWYgKCFtKSB0b3NzKCdBbGxvY2F0aW9uIG9mJywgY3Rvci5zdHJ1Y3ROYW1lLCAnc3RydWN0dXJlIGZhaWxlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjdG9yLmRlYnVnRmxhZ3MuX19mbGFncy5hbGxvYykge1xuICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgJ2RlYnVnLmFsbG9jOicsXG4gICAgICAgICAgICAgICAgZmlsbCA/ICcnIDogJ0VYVEVSTkFMJyxcbiAgICAgICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgJ2luc3RhbmNlOicsXG4gICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZixcbiAgICAgICAgICAgICAgICAnYnl0ZXMgQCcgKyBtLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGwpIGhlYXAoKS5maWxsKDAsIG0sIG0gKyBjdG9yLnN0cnVjdEluZm8uc2l6ZW9mKTtcbiAgICAgICAgICAgIF9faW5zdGFuY2VQb2ludGVyTWFwLnNldChvYmosIG0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF9fZnJlZVN0cnVjdChjdG9yLCBvYmosIG0pO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1vcnlEdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoaGVhcCgpLnNsaWNlKHAsIHAgKyB0aGlzLnN0cnVjdEluZm8uc2l6ZW9mKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX21lbWJlcktleSA9IChrKSA9PiBtZW1iZXJQcmVmaXggKyBrICsgbWVtYmVyU3VmZml4O1xuICAgICAgICBjb25zdCBfX21lbWJlcktleVByb3AgPSByb3AoX19tZW1iZXJLZXkpO1xuXG4gICAgICAgIGNvbnN0IF9fbG9va3VwTWVtYmVyID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHN0cnVjdEluZm8sXG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICB0b3NzSWZOb3RGb3VuZCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBtID0gc3RydWN0SW5mby5tZW1iZXJzW21lbWJlck5hbWVdO1xuICAgICAgICAgIGlmICghbSAmJiAobWVtYmVyUHJlZml4IHx8IG1lbWJlclN1ZmZpeCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHN0cnVjdEluZm8ubWVtYmVycykpIHtcbiAgICAgICAgICAgICAgaWYgKHYua2V5ID09PSBtZW1iZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgbSA9IHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbSAmJiB0b3NzSWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgIHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsIG1lbWJlck5hbWUpLFxuICAgICAgICAgICAgICAgICdpcyBub3QgYSBtYXBwZWQgc3RydWN0IG1lbWJlci4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX21lbWJlclNpZ25hdHVyZSA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgZW1zY3JpcHRlbkZvcm1hdCA9IGZhbHNlLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoIWYuXylcbiAgICAgICAgICAgIGYuXyA9ICh4KSA9PlxuICAgICAgICAgICAgICB4LnJlcGxhY2UoL1tedmlwUHNqcmRjQ10vZywgJycpLnJlcGxhY2UoL1twUHNjQ10vZywgJ2knKTtcbiAgICAgICAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgICAgICAgIHJldHVybiBlbXNjcmlwdGVuRm9ybWF0ID8gZi5fKG0uc2lnbmF0dXJlKSA6IG0uc2lnbmF0dXJlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fcHRyUHJvcERlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MoXCJDYW5ub3QgYXNzaWduIHRoZSAncG9pbnRlcicgcHJvcGVydHkgb2YgYSBzdHJ1Y3QuXCIpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fc3RydWN0TWVtYmVyS2V5cyA9IHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnN0cnVjdEluZm8ubWVtYmVycykpIHtcbiAgICAgICAgICAgIGEucHVzaCh0aGlzLm1lbWJlcktleShrKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBfX3V0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICBjb25zdCBfX3V0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgICAgICAgY29uc3QgX19TQUIgPVxuICAgICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIDogU2hhcmVkQXJyYXlCdWZmZXI7XG4gICAgICAgIGNvbnN0IF9fdXRmOERlY29kZSA9IGZ1bmN0aW9uIChhcnJheUJ1ZmZlciwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgIHJldHVybiBfX3V0ZjhEZWNvZGVyLmRlY29kZShcbiAgICAgICAgICAgIGFycmF5QnVmZmVyLmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCXG4gICAgICAgICAgICAgID8gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgICAgICAgOiBhcnJheUJ1ZmZlci5zdWJhcnJheShiZWdpbiwgZW5kKSxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbWVtYmVySXNTdHJpbmcgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgdG9zc0lmTm90Rm91bmQgPSBmYWxzZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgICAgICAgcmV0dXJuIG0gJiYgMSA9PT0gbS5zaWduYXR1cmUubGVuZ3RoICYmICdzJyA9PT0gbS5zaWduYXR1cmVbMF1cbiAgICAgICAgICAgID8gbVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FmZmlybUNTdHJpbmdTaWduYXR1cmUgPSBmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgICAgaWYgKCdzJyA9PT0gbWVtYmVyLnNpZ25hdHVyZSkgcmV0dXJuO1xuICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAnSW52YWxpZCBtZW1iZXIgdHlwZSBzaWduYXR1cmUgZm9yIEMtc3RyaW5nIHZhbHVlOicsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZW1iZXIpLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1iZXJUb0pzU3RyaW5nID0gZnVuY3Rpb24gZihvYmosIG1lbWJlck5hbWUpIHtcbiAgICAgICAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgICAgICAgIF9fYWZmaXJtQ1N0cmluZ1NpZ25hdHVyZShtKTtcbiAgICAgICAgICBjb25zdCBhZGRyID0gb2JqW20ua2V5XTtcblxuICAgICAgICAgIGlmICghYWRkcikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgbGV0IHBvcyA9IGFkZHI7XG4gICAgICAgICAgY29uc3QgbWVtID0gaGVhcCgpO1xuICAgICAgICAgIGZvciAoOyBtZW1bcG9zXSAhPT0gMDsgKytwb3MpIHt9XG5cbiAgICAgICAgICByZXR1cm4gYWRkciA9PT0gcG9zID8gJycgOiBfX3V0ZjhEZWNvZGUobWVtLCBhZGRyLCBwb3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWRkT25EaXNwb3NlID0gZnVuY3Rpb24gKG9iaiwgLi4udikge1xuICAgICAgICAgIGlmIChvYmoub25kaXNwb3NlKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqLm9uZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgb2JqLm9uZGlzcG9zZSA9IFtvYmoub25kaXNwb3NlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqLm9uZGlzcG9zZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmoub25kaXNwb3NlLnB1c2goLi4udik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hbGxvY0NTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgY29uc3QgdSA9IF9fdXRmOEVuY29kZXIuZW5jb2RlKHN0cik7XG4gICAgICAgICAgY29uc3QgbWVtID0gYWxsb2ModS5sZW5ndGggKyAxKTtcbiAgICAgICAgICBpZiAoIW1lbSkgdG9zcygnQWxsb2NhdGlvbiBlcnJvciB3aGlsZSBkdXBsaWNhdGluZyBzdHJpbmc6Jywgc3RyKTtcbiAgICAgICAgICBjb25zdCBoID0gaGVhcCgpO1xuXG4gICAgICAgICAgaC5zZXQodSwgbWVtKTtcbiAgICAgICAgICBoW21lbSArIHUubGVuZ3RoXSA9IDA7XG5cbiAgICAgICAgICByZXR1cm4gbWVtO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fc2V0TWVtYmVyQ1N0cmluZyA9IGZ1bmN0aW9uIChvYmosIG1lbWJlck5hbWUsIHN0cikge1xuICAgICAgICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgX19hZmZpcm1DU3RyaW5nU2lnbmF0dXJlKG0pO1xuXG4gICAgICAgICAgY29uc3QgbWVtID0gX19hbGxvY0NTdHJpbmcoc3RyKTtcbiAgICAgICAgICBvYmpbbS5rZXldID0gbWVtO1xuICAgICAgICAgIF9fYWRkT25EaXNwb3NlKG9iaiwgbWVtKTtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IFN0cnVjdFR5cGUgPSBmdW5jdGlvbiBjdG9yKHN0cnVjdE5hbWUsIHN0cnVjdEluZm8pIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzWzJdICE9PSByb3ApIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdEbyBub3QgY2FsbCB0aGUgU3RydWN0VHlwZSBjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICdmcm9tIGNsaWVudC1sZXZlbCBjb2RlLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSksXG4gICAgICAgICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICBkaXNwb3NlOiByb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX19mcmVlU3RydWN0KHRoaXMuY29uc3RydWN0b3IsIHRoaXMpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGxvb2t1cE1lbWJlcjogcm9wKGZ1bmN0aW9uIChtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2xvb2t1cE1lbWJlcih0aGlzLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtZW1iZXJUb0pzU3RyaW5nOiByb3AoZnVuY3Rpb24gKG1lbWJlck5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX21lbWJlclRvSnNTdHJpbmcodGhpcywgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtYmVySXNTdHJpbmc6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19tZW1iZXJJc1N0cmluZyh0aGlzLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtYmVyS2V5OiBfX21lbWJlcktleVByb3AsXG4gICAgICAgICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgICAgICAgIG1lbWJlclNpZ25hdHVyZTogcm9wKGZ1bmN0aW9uIChtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX21lbWJlclNpZ25hdHVyZSh0aGlzLCBtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtZW1vcnlEdW1wOiByb3AoX19tZW1vcnlEdW1wKSxcbiAgICAgICAgICBwb2ludGVyOiBfX3B0clByb3BEZXNjcmlwdG9yLFxuICAgICAgICAgIHNldE1lbWJlckNTdHJpbmc6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZXRNZW1iZXJDU3RyaW5nKHRoaXMsIG1lbWJlck5hbWUsIHN0cik7XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oU3RydWN0VHlwZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICBhZGRPbkRpc3Bvc2U6IGZ1bmN0aW9uICguLi52KSB7XG4gICAgICAgICAgICBfX2FkZE9uRGlzcG9zZSh0aGlzLCAuLi52KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdFR5cGUsIHtcbiAgICAgICAgICBhbGxvY0NTdHJpbmc6IHJvcChfX2FsbG9jQ1N0cmluZyksXG4gICAgICAgICAgaXNBOiByb3AoKHYpID0+IHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSxcbiAgICAgICAgICBoYXNFeHRlcm5hbFBvaW50ZXI6IHJvcChcbiAgICAgICAgICAgICh2KSA9PiB2IGluc3RhbmNlb2YgU3RydWN0VHlwZSAmJiAhIXZbeFB0clByb3BOYW1lXSxcbiAgICAgICAgICApLFxuICAgICAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBpc051bWVyaWNWYWx1ZSA9ICh2KSA9PlxuICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh2KSB8fCB2IGluc3RhbmNlb2YgKEJpZ0ludCB8fCBOdW1iZXIpO1xuXG4gICAgICAgIGNvbnN0IG1ha2VNZW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gZihjdG9yLCBuYW1lLCBkZXNjcikge1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl8gPSB7IGdldHRlcnM6IHt9LCBzZXR0ZXJzOiB7fSwgc3c6IHt9IH07XG4gICAgICAgICAgICBjb25zdCBhID0gWydpJywgJ2MnLCAnQycsICdwJywgJ1AnLCAncycsICdmJywgJ2QnLCAndigpJ107XG4gICAgICAgICAgICBpZiAoYmlnSW50RW5hYmxlZCkgYS5wdXNoKCdqJyk7XG4gICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgZi5fLmdldHRlcnNbdl0gPSBzaWdEVkdldHRlcih2KTtcbiAgICAgICAgICAgICAgZi5fLnNldHRlcnNbdl0gPSBzaWdEVlNldHRlcih2KTtcbiAgICAgICAgICAgICAgZi5fLnN3W3ZdID0gc2lnRFZTZXRXcmFwcGVyKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByeFNpZzEgPSAvXltpcFBzamZkY0NdJC8sXG4gICAgICAgICAgICAgIHJ4U2lnMiA9IC9eW3ZpcFBzamZkY0NdXFwoW2lwUHNqZmRjQ10qXFwpJC87XG4gICAgICAgICAgICBmLnNpZ0NoZWNrID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwga2V5LCBzaWcpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzKG9iai5zdHJ1Y3ROYW1lLCAnYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBuYW1lZCcsIGtleSArICcuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnhTaWcxLnRlc3Qoc2lnKSB8fFxuICAgICAgICAgICAgICAgIHJ4U2lnMi50ZXN0KHNpZykgfHxcbiAgICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICAgJ01hbGZvcm1lZCBzaWduYXR1cmUgZm9yJyxcbiAgICAgICAgICAgICAgICAgIHNQcm9wTmFtZShvYmouc3RydWN0TmFtZSwgbmFtZSkgKyAnOicsXG4gICAgICAgICAgICAgICAgICBzaWcsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGtleSA9IGN0b3IubWVtYmVyS2V5KG5hbWUpO1xuICAgICAgICAgIGYuc2lnQ2hlY2soY3Rvci5wcm90b3R5cGUsIG5hbWUsIGtleSwgZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICAgICAgICBkZXNjci5rZXkgPSBrZXk7XG4gICAgICAgICAgZGVzY3IubmFtZSA9IG5hbWU7XG4gICAgICAgICAgY29uc3Qgc2lnR2x5cGggPSBzaWdMZXR0ZXIoZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICAgICAgICBjb25zdCB4UHJvcE5hbWUgPSBzUHJvcE5hbWUoY3Rvci5wcm90b3R5cGUuc3RydWN0TmFtZSwga2V5KTtcbiAgICAgICAgICBjb25zdCBkYmcgPSBjdG9yLnByb3RvdHlwZS5kZWJ1Z0ZsYWdzLl9fZmxhZ3M7XG5cbiAgICAgICAgICBjb25zdCBwcm9wID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBwcm9wLmNvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHByb3AuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHByb3AuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRiZy5nZXR0ZXIpIHtcbiAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICdkZWJ1Zy5nZXR0ZXI6JyxcbiAgICAgICAgICAgICAgICBmLl8uZ2V0dGVyc1tzaWdHbHlwaF0sXG4gICAgICAgICAgICAgICAgJ2ZvcicsXG4gICAgICAgICAgICAgICAgc2lnSVIoc2lnR2x5cGgpLFxuICAgICAgICAgICAgICAgIHhQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgICcrJyxcbiAgICAgICAgICAgICAgICBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgJ3N6JyxcbiAgICAgICAgICAgICAgICBkZXNjci5zaXplb2YsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmMgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgIGhlYXAoKS5idWZmZXIsXG4gICAgICAgICAgICAgIHRoaXMucG9pbnRlciArIGRlc2NyLm9mZnNldCxcbiAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgKVtmLl8uZ2V0dGVyc1tzaWdHbHlwaF1dKDAsIGlzTGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIGlmIChkYmcuZ2V0dGVyKSBsb2coJ2RlYnVnLmdldHRlcjonLCB4UHJvcE5hbWUsICdyZXN1bHQgPScsIHJjKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZXNjci5yZWFkT25seSkge1xuICAgICAgICAgICAgcHJvcC5zZXQgPSBfX3Byb3BUaHJvd09uU2V0KGN0b3IucHJvdG90eXBlLnN0cnVjdE5hbWUsIGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3Auc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaWYgKGRiZy5zZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAnZGVidWcuc2V0dGVyOicsXG4gICAgICAgICAgICAgICAgICBmLl8uc2V0dGVyc1tzaWdHbHlwaF0sXG4gICAgICAgICAgICAgICAgICAnZm9yJyxcbiAgICAgICAgICAgICAgICAgIHNpZ0lSKHNpZ0dseXBoKSxcbiAgICAgICAgICAgICAgICAgIHhQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICcrJyxcbiAgICAgICAgICAgICAgICAgIGRlc2NyLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICdzeicsXG4gICAgICAgICAgICAgICAgICBkZXNjci5zaXplb2YsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdDYW5ub3Qgc2V0IHN0cnVjdCBwcm9wZXJ0eSBvbiBkaXNwb3NlZCBpbnN0YW5jZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdikgdiA9IDA7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTnVtZXJpY1ZhbHVlKHYpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0b1B0clNpZyhkZXNjci5zaWduYXR1cmUpICYmXG4gICAgICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHYucG9pbnRlciB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGJnLnNldHRlcilcbiAgICAgICAgICAgICAgICAgICAgICBsb2coJ2RlYnVnLnNldHRlcjonLCB4UHJvcE5hbWUsICdyZXNvbHZlZCB0bycsIHYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdmFsdWUgZm9yIHBvaW50ZXItdHlwZScsIHhQcm9wTmFtZSArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgICAgaGVhcCgpLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIgKyBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgICApW2YuXy5zZXR0ZXJzW3NpZ0dseXBoXV0oMCwgZi5fLnN3W3NpZ0dseXBoXSh2KSwgaXNMaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHByb3ApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IFN0cnVjdEJpbmRlciA9IGZ1bmN0aW9uIFN0cnVjdEJpbmRlcihzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvKSB7XG4gICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cnVjdEluZm8gPSBzdHJ1Y3ROYW1lO1xuICAgICAgICAgICAgc3RydWN0TmFtZSA9IHN0cnVjdEluZm8ubmFtZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJ1Y3RJbmZvLm5hbWUpIHtcbiAgICAgICAgICAgIHN0cnVjdEluZm8ubmFtZSA9IHN0cnVjdE5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RydWN0TmFtZSkgdG9zcygnU3RydWN0IG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgbGV0IGxhc3RNZW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBzdHJ1Y3RJbmZvLm1lbWJlcnNba107XG4gICAgICAgICAgICBpZiAoIW0uc2l6ZW9mKSB0b3NzKHN0cnVjdE5hbWUsICdtZW1iZXInLCBrLCAnaXMgbWlzc2luZyBzaXplb2YuJyk7XG4gICAgICAgICAgICBlbHNlIGlmIChtLnNpemVvZiA9PT0gMSkge1xuICAgICAgICAgICAgICBtLnNpZ25hdHVyZSA9PT0gJ2MnIHx8XG4gICAgICAgICAgICAgICAgbS5zaWduYXR1cmUgPT09ICdDJyB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBzaXplb2Y9PTEgbWVtYmVyJyxcbiAgICAgICAgICAgICAgICAgIHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsIGspLFxuICAgICAgICAgICAgICAgICAgJ3dpdGggc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICAgIG0uc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gbS5zaXplb2YgJSA0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgc3RydWN0IG1lbWJlciBkZXNjcmlwdGlvbiA9JyxcbiAgICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgICAnZnJvbScsXG4gICAgICAgICAgICAgICAgICBzdHJ1Y3RJbmZvLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgIHN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAnbWVtYmVyJyxcbiAgICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgICAnc2l6ZW9mIGlzIG5vdCBhbGlnbmVkLiBzaXplb2Y9JyArIG0uc2l6ZW9mLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDAgIT09IG0ub2Zmc2V0ICUgNCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHN0cnVjdCBtZW1iZXIgZGVzY3JpcHRpb24gPScsXG4gICAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgICAgJ2Zyb20nLFxuICAgICAgICAgICAgICAgICAgc3RydWN0SW5mbyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgJ21lbWJlcicsXG4gICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgJ29mZnNldCBpcyBub3QgYWxpZ25lZC4gb2Zmc2V0PScgKyBtLm9mZnNldCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhc3RNZW1iZXIgfHwgbGFzdE1lbWJlci5vZmZzZXQgPCBtLm9mZnNldCkgbGFzdE1lbWJlciA9IG07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFsYXN0TWVtYmVyKSB0b3NzKCdObyBtZW1iZXIgcHJvcGVydHkgZGVzY3JpcHRpb25zIGZvdW5kLicpO1xuICAgICAgICAgIGVsc2UgaWYgKHN0cnVjdEluZm8uc2l6ZW9mIDwgbGFzdE1lbWJlci5vZmZzZXQgKyBsYXN0TWVtYmVyLnNpemVvZikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ0ludmFsaWQgc3RydWN0IGNvbmZpZzonLFxuICAgICAgICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAnbWF4IG1lbWJlciBvZmZzZXQgKCcgKyBsYXN0TWVtYmVyLm9mZnNldCArICcpICcsXG4gICAgICAgICAgICAgICdleHRlbmRzIHBhc3QgZW5kIG9mIHN0cnVjdCAoc2l6ZW9mPScgKyBzdHJ1Y3RJbmZvLnNpemVvZiArICcpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWJ1Z0ZsYWdzID0gcm9wKFNCRi5fX21ha2VEZWJ1Z0ZsYWdzKFN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKSk7XG5cbiAgICAgICAgICBjb25zdCBTdHJ1Y3RDdG9yID0gZnVuY3Rpb24gU3RydWN0Q3RvcihleHRlcm5hbE1lbW9yeSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cnVjdEN0b3IpKSB7XG4gICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgJ1RoZScsXG4gICAgICAgICAgICAgICAgc3RydWN0TmFtZSxcbiAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yIG1heSBvbmx5IGJlIGNhbGxlZCB2aWEgJ25ldycuXCIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGV4dGVybmFsTWVtb3J5ICE9PSAoZXh0ZXJuYWxNZW1vcnkgfCAwKSB8fFxuICAgICAgICAgICAgICAgIGV4dGVybmFsTWVtb3J5IDw9IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCBwb2ludGVyIHZhbHVlIGZvcicsIHN0cnVjdE5hbWUsICdjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfX2FsbG9jU3RydWN0KFN0cnVjdEN0b3IsIHRoaXMsIGV4dGVybmFsTWVtb3J5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9fYWxsb2NTdHJ1Y3QoU3RydWN0Q3RvciwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RDdG9yLCB7XG4gICAgICAgICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgICAgICAgaXNBOiByb3AoKHYpID0+IHYgaW5zdGFuY2VvZiBTdHJ1Y3RDdG9yKSxcbiAgICAgICAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgICAgICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgICAgICAgICAgbWV0aG9kSW5mb0ZvcktleTogcm9wKGZ1bmN0aW9uIChtS2V5KSB7fSksXG4gICAgICAgICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbyksXG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgU3RydWN0Q3Rvci5wcm90b3R5cGUgPSBuZXcgU3RydWN0VHlwZShzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvLCByb3ApO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdEN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgICAgICAgY29uc3RydWN0b3I6IHJvcChTdHJ1Y3RDdG9yKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goKG5hbWUpID0+XG4gICAgICAgICAgICBtYWtlTWVtYmVyV3JhcHBlcihTdHJ1Y3RDdG9yLCBuYW1lLCBzdHJ1Y3RJbmZvLm1lbWJlcnNbbmFtZV0pLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFN0cnVjdEN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIFN0cnVjdEJpbmRlci5TdHJ1Y3RUeXBlID0gU3RydWN0VHlwZTtcbiAgICAgICAgU3RydWN0QmluZGVyLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgU3RydWN0QmluZGVyLmFsbG9jQ1N0cmluZyA9IF9fYWxsb2NDU3RyaW5nO1xuICAgICAgICBpZiAoIVN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKSB7XG4gICAgICAgICAgU3RydWN0QmluZGVyLmRlYnVnRmxhZ3MgPSBTQkYuX19tYWtlRGVidWdGbGFncyhTQkYuZGVidWdGbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cnVjdEJpbmRlcjtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvc3MzID0gc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcztcbiAgICAgICAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaSxcbiAgICAgICAgICB3YXNtID0gc3FsaXRlMy53YXNtLFxuICAgICAgICAgIHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcih3YXNtKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcjtcblxuICAgICAgICBpZiAoMCkge1xuICAgICAgICAgIGNvbnN0IGRlYWxsb2MgPSB3YXNtLmV4cG9ydHNbc3FsaXRlMy5jb25maWcuZGVhbGxvY0V4cG9ydE5hbWVdO1xuICAgICAgICAgIGNvbnN0IG5GdW5jID0gd2FzbS5mdW5jdGlvblRhYmxlKCkubGVuZ3RoO1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuRnVuYzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gd2FzbS5mdW5jdGlvbkVudHJ5KGkpO1xuICAgICAgICAgICAgaWYgKGRlYWxsb2MgPT09IGUpIHtcbiAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWFsbG9jICE9PSB3YXNtLmZ1bmN0aW9uRW50cnkoY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKSkge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ0ludGVybmFsIGVycm9yOiBjYW5ub3QgZmluZCBmdW5jdGlvbiBwb2ludGVyIGZvciBTUUxJVEVfV0FTTV9ERUFMTE9DLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMgPSBbXG4gICAgICAgICAgWydzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0JywgJ3ZvaWQqJywgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfYmluZF9kb3VibGUnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50JywgJ2Y2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19iaW5kX2ludCcsICdpbnQnLCAnc3FsaXRlM19zdG10KicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfbnVsbCcsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2JpbmRfcG9pbnRlcicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfYnVzeV9oYW5kbGVyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaSknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfYnVzeV90aW1lb3V0JywgJ2ludCcsICdzcWxpdGUzKicsICdpbnQnXSxcblxuICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jbGVhcl9iaW5kaW5ncycsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkJywgJ2ludCcsICdzcWxpdGUzKicsICcqJywgJyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX2Jsb2InLCAnKicsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fYnl0ZXMnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9jb3VudCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fZG91YmxlJywgJ2Y2NCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5faW50JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fbmFtZScsICdzdHJpbmcnLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX3RleHQnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl90eXBlJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fdmFsdWUnLCAnc3FsaXRlM192YWx1ZSonLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19jb21taXRfaG9vaycsXG4gICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfY29tbWl0X2hvb2snLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocCknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCcsICdzdHJpbmcnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCcsICdpbnQnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbXBsZXRlJywgJ2ludCcsICdzdHJpbmc6ZmxleGlibGUnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUnLCAnc3FsaXRlMyonLCAnc3FsaXRlM19jb250ZXh0KiddLFxuXG4gICAgICAgICAgWydzcWxpdGUzX2RhdGFfY291bnQnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGJfZmlsZW5hbWUnLCAnc3RyaW5nJywgJ3NxbGl0ZTMqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9oYW5kbGUnLCAnc3FsaXRlMyonLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9uYW1lJywgJ3N0cmluZycsICdzcWxpdGUzKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGJfc3RhdHVzJywgJ2ludCcsICdzcWxpdGUzKicsICdpbnQnLCAnKicsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19lcnJjb2RlJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19lcnJtc2cnLCAnc3RyaW5nJywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2Vycm9yX29mZnNldCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXJyc3RyJywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19leGVjJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnc3RyaW5nOmZsZXhpYmxlJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwcCknLFxuICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBhTmFtZXM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKHBWb2lkLCBuQ29scywgcENvbFZhbHMsIHBDb2xOYW1lcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFWYWxzID0gd2FzbS5jQXJndlRvSnMobkNvbHMsIHBDb2xWYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFOYW1lcykgYU5hbWVzID0gd2FzbS5jQXJndlRvSnMobkNvbHMsIHBDb2xOYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFWYWxzLCBhTmFtZXMpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXhwYW5kZWRfc3FsJywgJ3N0cmluZycsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcycsICdpbnQnLCAnc3FsaXRlMyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2ZpbGVfY29udHJvbCcsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJ2ludCcsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2ZpbmFsaXplJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2ZyZWUnLCB1bmRlZmluZWQsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2dldF9hdXRvY29tbWl0JywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19nZXRfYXV4ZGF0YScsICcqJywgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2luaXRpYWxpemUnLCB1bmRlZmluZWRdLFxuXG4gICAgICAgICAgWydzcWxpdGUzX2tleXdvcmRfY291bnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2tleXdvcmRfbmFtZScsICdpbnQnLCBbJ2ludCcsICcqKicsICcqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19rZXl3b3JkX2NoZWNrJywgJ2ludCcsIFsnc3RyaW5nJywgJ2ludCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbGlidmVyc2lvbicsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXInLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2xpbWl0JywgJ2ludCcsIFsnc3FsaXRlMyonLCAnaW50JywgJ2ludCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbWFsbG9jJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX29wZW4nLCAnaW50JywgJ3N0cmluZycsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX29wZW5fdjInLCAnaW50JywgJ3N0cmluZycsICcqJywgJ2ludCcsICdzdHJpbmcnXSxcblxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4UHJvZ3Jlc3NIYW5kbGVyJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHApJyxcbiAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICdjb250ZXh0JyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3JlYWxsb2MnLCAnKicsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXNldCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcmVzdWx0X2Jsb2InLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2RvdWJsZScsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConLCAnZjY0J10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9pbnQnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfbnVsbCcsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19yZXN1bHRfcG9pbnRlcicsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnc3RyaW5nOnN0YXRpYycsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnLCB1bmRlZmluZWQsICdzcWxpdGUzX3ZhbHVlKicsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19yZXN1bHRfdGV4dCcsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYicsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3FsaXRlM19zZXRfYXV0aG9yaXplcjo6eEF1dGgnLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGknICsgJ3Nzc3MpJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAocFYsIGlDb2RlLCBzMCwgczEsIHMyLCBzMykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczAgJiYgd2FzbS5jc3RyVG9KcyhzMCk7XG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBzMSAmJiB3YXNtLmNzdHJUb0pzKHMxKTtcbiAgICAgICAgICAgICAgICAgICAgICBzMiA9IHMyICYmIHdhc20uY3N0clRvSnMoczIpO1xuICAgICAgICAgICAgICAgICAgICAgIHMzID0gczMgJiYgd2FzbS5jc3RyVG9KcyhzMyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHBWLCBpQ29kZSwgczAsIHMxLCBzMiwgczMpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc2V0X2F1eGRhdGEnLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneERlc3Ryb3lBdXhEYXRhJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KCopJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19zaHV0ZG93bicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgWydzcWxpdGUzX3NvdXJjZWlkJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19zcWwnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RhdHVzJywgJ2ludCcsICdpbnQnLCAnKicsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdGVwJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0bXRfaXNleHBsYWluJywgJ2ludCcsIFsnc3FsaXRlM19zdG10KiddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RtdF9yZWFkb25seScsICdpbnQnLCBbJ3NxbGl0ZTNfc3RtdConXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3N0bXRfc3RhdHVzJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCcsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RyZ2xvYicsICdpbnQnLCAnc3RyaW5nJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdHJpY21wJywgJ2ludCcsICdzdHJpbmcnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0cmxpa2UnLCAnaW50JywgJ3N0cmluZycsICdzdHJpbmcnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0cm5pY21wJywgJ2ludCcsICdzdHJpbmcnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YScsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM190b3RhbF9jaGFuZ2VzJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3RyYWNlX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3RyYWNlX3YyOjpjYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShpcHBwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM190eG5fc3RhdGUnLCAnaW50JywgWydzcWxpdGUzKicsICdzdHJpbmcnXV0sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX2Jvb2xlYW4nLCAnaW50JywgJ3NxbGl0ZTNfZmlsZW5hbWUnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM191cmlfa2V5JywgJ3N0cmluZycsICdzcWxpdGUzX2ZpbGVuYW1lJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM191cmlfcGFyYW1ldGVyJywgJ3N0cmluZycsICdzcWxpdGUzX2ZpbGVuYW1lJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM191c2VyX2RhdGEnLCAndm9pZConLCAnc3FsaXRlM19jb250ZXh0KiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9ibG9iJywgJyonLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfYnl0ZXMnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2RvdWJsZScsICdmNjQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfZHVwJywgJ3NxbGl0ZTNfdmFsdWUqJywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2ZyZWUnLCB1bmRlZmluZWQsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9mcm9tYmluZCcsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfaW50JywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9ub2NoYW5nZScsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9wb2ludGVyJywgJyonLCAnc3FsaXRlM192YWx1ZSonLCAnc3RyaW5nOnN0YXRpYyddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9zdWJ0eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV90ZXh0JywgJ3N0cmluZycsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV90eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192ZnNfZmluZCcsICcqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM192ZnNfcmVnaXN0ZXInLCAnaW50JywgJ3NxbGl0ZTNfdmZzKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXInLCAnaW50JywgJ3NxbGl0ZTNfdmZzKiddLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChmYWxzZSAmJiB3YXNtLmNvbXBpbGVPcHRpb25Vc2VkKCdTUUxJVEVfRU5BQkxFX05PUk1BTElaRScpKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFtcbiAgICAgICAgICAgICdzcWxpdGUzX25vcm1hbGl6ZWRfc3FsJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfc3RtdConLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdhc20uZXhwb3J0cy5zcWxpdGUzX2FjdGl2YXRlX3NlZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFxuICAgICAgICAgICAgWydzcWxpdGUzX2tleScsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgICAgWydzcWxpdGUzX2tleV92MicsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJyonLCAnaW50J10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfcmVrZXknLCAnaW50JywgJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM19yZWtleV92MicsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJyonLCAnaW50J10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfYWN0aXZhdGVfc2VlJywgdW5kZWZpbmVkLCAnc3RyaW5nJ10sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQgPSBbXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfaW50NjQnLCAnaW50JywgWydzcWxpdGUzX3N0bXQqJywgJ2ludCcsICdpNjQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX2NoYW5nZXM2NCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5faW50NjQnLCAnaTY0JywgWydzcWxpdGUzX3N0bXQqJywgJ2ludCddXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfbW9kdWxlJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgWydzcWxpdGUzKicsICdzdHJpbmcnLCAnc3FsaXRlM19tb2R1bGUqJywgJyonXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdzcWxpdGUzX21vZHVsZSonLCAnKicsICcqJ10sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGVjbGFyZV92dGFiJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nOmZsZXhpYmxlJ11dLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2Rlc2VyaWFsaXplJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ2k2NCcsXG4gICAgICAgICAgICAnaTY0JyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX2Ryb3BfbW9kdWxlcycsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJyoqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19tYWxsb2M2NCcsICcqJywgJ2k2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19tc2l6ZScsICdpNjQnLCAnKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbicsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdpbnQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KHBwaXBwamopJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndikgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChwLCBkYiwgb3AsIHpEYiwgelRibCwgaUtleTEsIGlLZXkyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgIHAsXG4gICAgICAgICAgICAgICAgICAgICAgZGIsXG4gICAgICAgICAgICAgICAgICAgICAgb3AsXG4gICAgICAgICAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyh6RGIpLFxuICAgICAgICAgICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoelRibCksXG4gICAgICAgICAgICAgICAgICAgICAgaUtleTEsXG4gICAgICAgICAgICAgICAgICAgICAgaUtleTIsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9uZXcnLCAnaW50JywgWydzcWxpdGUzKicsICdpbnQnLCAnKionXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnLCAnaW50JywgWydzcWxpdGUzKicsICdpbnQnLCAnKionXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3JlYWxsb2M2NCcsICcqJywgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9pbnQ2NCcsIHVuZGVmaW5lZCwgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0JywgJ2ludCcsICcqJywgJ2k2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zZXJpYWxpemUnLCAnKicsICdzcWxpdGUzKicsICdzdHJpbmcnLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkJywgdW5kZWZpbmVkLCBbJ3NxbGl0ZTMqJywgJ2k2NCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RhdHVzNjQnLCAnaW50JywgJ2ludCcsICcqJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KGlpcHBqKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAocCwgb3AsIHowLCB6MSwgcm93aWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICAgICAgICBvcCxcbiAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHowKSxcbiAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHoxKSxcbiAgICAgICAgICAgICAgICAgICAgICByb3dpZCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX2ludDY0JywgJ2k2NCcsIFsnc3FsaXRlM19maWxlbmFtZScsICdzdHJpbmcnLCAnaTY0J11dLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9pbnQ2NCcsICdpNjQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nLCAnc3RyaW5nJywgJ3NxbGl0ZTNfaW5kZXhfaW5mbyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfZGlzdGluY3QnLCAnaW50JywgJ3NxbGl0ZTNfaW5kZXhfaW5mbyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9pbicsICdpbnQnLCAnc3FsaXRlM19pbmRleF9pbmZvKicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfaW5fZmlyc3QnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJywgJyoqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfaW5fbmV4dCcsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonLCAnKionXSxcblxuICAgICAgICAgIFsnc3FsaXRlM192dGFiX25vY2hhbmdlJywgJ2ludCcsICdzcWxpdGUzX2NvbnRleHQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlJywgJ2ludCcsICdzcWxpdGUzX2luZGV4X2luZm8qJywgJ2ludCcsICcqKiddLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQgJiYgISF3YXNtLmV4cG9ydHMuc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCkge1xuICAgICAgICAgIGNvbnN0IF9faXBzUHJveHkgPSB7XG4gICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBzKScsXG4gICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gKHAsIHMpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHAsIHdhc20uY3N0clRvSnMocykpIHwgMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQucHVzaChcbiAgICAgICAgICAgIC4uLltcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludCcsICd2b2lkKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlJyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZWdyb3VwKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnLCAnaW50JywgWycqKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludConLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjInLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICAgICAnaW50KicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICAgICAnaW50KicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ2ludCcsICd2b2lkKicsICdpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dEEnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0QicsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnaW50JywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZScsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2ludmVydCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfb3AnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnKionLCAnaW50KicsICdpbnQqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X3BrJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJyoqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0JywgJ2ludCcsIFsnKionLCAnaW50JywgJyonXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcHApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInLCAnaW50JywgWycqKicsICdpbnQnLCAnKicsICdpbnQnXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcHApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fYXR0YWNoJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdzdHJpbmcnXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jb25maWcnLCAnaW50JywgWydpbnQnLCAndm9pZConXV0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY3JlYXRlJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nJywgJyoqJ11dLFxuXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fZGlmZicsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX3Nlc3Npb24qJywgJ3N0cmluZycsICdzdHJpbmcnLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9lbmFibGUnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCddXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50J11dLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHknLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJ11dLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50JywgJ3ZvaWQqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19zZXNzaW9uKicsICcqJywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlM19zZXNzaW9uKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMud2FzbSA9IFtcbiAgICAgICAgICBbJ3NxbGl0ZTNfd2FzbV9kYl9yZXNldCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfd2FzbV9kYl92ZnMnLCAnc3FsaXRlM192ZnMqJywgJ3NxbGl0ZTMqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfdmZzKicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUnLCAnaW50JywgJ3N0cmluZycsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM193YXNtX3Zmc191bmxpbmsnLCAnaW50JywgJ3NxbGl0ZTNfdmZzKicsICdzdHJpbmcnXSxcbiAgICAgICAgXTtcblxuICAgICAgICBzcWxpdGUzLlN0cnVjdEJpbmRlciA9IGdsb2JhbFRoaXMuSmFjY3dhYnl0KHtcbiAgICAgICAgICBoZWFwOiAwID8gd2FzbS5tZW1vcnkgOiB3YXNtLmhlYXA4dSxcbiAgICAgICAgICBhbGxvYzogd2FzbS5hbGxvYyxcbiAgICAgICAgICBkZWFsbG9jOiB3YXNtLmRlYWxsb2MsXG4gICAgICAgICAgYmlnSW50RW5hYmxlZDogd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgIG1lbWJlclByZWZpeDogJyQnLFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXMuSmFjY3dhYnl0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX3hTdHJpbmcgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3N0cmluZycpO1xuICAgICAgICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcignc3RyaW5nOmZsZXhpYmxlJywgKHYpID0+XG4gICAgICAgICAgICBfX3hTdHJpbmcodXRpbC5mbGV4aWJsZVN0cmluZyh2KSksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcihcbiAgICAgICAgICAgICdzdHJpbmc6c3RhdGljJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKHYpKSByZXR1cm4gdjtcbiAgICAgICAgICAgICAgdiA9ICcnICsgdjtcbiAgICAgICAgICAgICAgbGV0IHJjID0gdGhpc1t2XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjIHx8ICh0aGlzW3ZdID0gd2FzbS5hbGxvY0NTdHJpbmcodikpO1xuICAgICAgICAgICAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBfX3hBcmdQdHIgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJyonKTtcbiAgICAgICAgICBjb25zdCBuaWxUeXBlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzX2ZpbGVuYW1lJywgX194QXJnUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgIF9feEFyZ1B0cixcbiAgICAgICAgICApKCdzcWxpdGUzX3ZhbHVlKicsIF9feEFyZ1B0cikoJ3ZvaWQqJywgX194QXJnUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgICAgICBfX3hBcmdQdHIsXG4gICAgICAgICAgKSgnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCBfX3hBcmdQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgX194QXJnUHRyLFxuICAgICAgICAgICkoJ3NxbGl0ZTNfc3RtdConLCAodikgPT5cbiAgICAgICAgICAgIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIChzcWxpdGUzPy5vbzE/LlN0bXQgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzKicsICh2KSA9PlxuICAgICAgICAgICAgX194QXJnUHRyKFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgKHNxbGl0ZTM/Lm9vMT8uREIgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzX2luZGV4X2luZm8qJywgKHYpID0+XG4gICAgICAgICAgICBfX3hBcmdQdHIoXG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX2luZGV4X2luZm8gfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzX21vZHVsZSonLCAodikgPT5cbiAgICAgICAgICAgIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIChjYXBpLnNxbGl0ZTNfbW9kdWxlIHx8IG5pbFR5cGUpID8gdi5wb2ludGVyIDogdixcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKSgnc3FsaXRlM192ZnMqJywgKHYpID0+IHtcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodikgfHxcbiAgICAgICAgICAgICAgICBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICAgICAgICAnVW5rbm93biBzcWxpdGUzX3ZmcyBuYW1lOicsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX3hBcmdQdHIoXG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX3ZmcyB8fCBuaWxUeXBlKSA/IHYucG9pbnRlciA6IHYsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgX194UmNQdHIgPSB3YXNtLnhXcmFwLnJlc3VsdEFkYXB0ZXIoJyonKTtcbiAgICAgICAgICB3YXNtLnhXcmFwLnJlc3VsdEFkYXB0ZXIoJ3NxbGl0ZTMqJywgX194UmNQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgX194UmNQdHIsXG4gICAgICAgICAgKSgnc3FsaXRlM19zdG10KicsIF9feFJjUHRyKSgnc3FsaXRlM192YWx1ZSonLCBfX3hSY1B0cikoXG4gICAgICAgICAgICAnc3FsaXRlM192ZnMqJyxcbiAgICAgICAgICAgIF9feFJjUHRyLFxuICAgICAgICAgICkoJ3ZvaWQqJywgX194UmNQdHIpO1xuXG4gICAgICAgICAgaWYgKDAgPT09IHdhc20uZXhwb3J0cy5zcWxpdGUzX3N0ZXAubGVuZ3RoKSB7XG4gICAgICAgICAgICB3YXNtLnhXcmFwLmRvQXJnY0NoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICAgICAgICAnRGlzYWJsaW5nIHNxbGl0ZTMud2FzbS54V3JhcC5kb0FyZ2NDaGVjayBkdWUgdG8gZW52aXJvbm1lbnRhbCBxdWlya3MuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBjYXBpW2VbMF1dID0gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIHdhc20uYmluZGluZ1NpZ25hdHVyZXMud2FzbSkge1xuICAgICAgICAgICAgd2FzbVtlWzBdXSA9IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZkk2NERpc2FibGVkID0gZnVuY3Rpb24gKGZuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT5cbiAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICBmbmFtZSArICcoKSBpcyB1bmF2YWlsYWJsZSBkdWUgdG8gbGFjaycsXG4gICAgICAgICAgICAgICAgJ29mIEJpZ0ludCBzdXBwb3J0IGluIHRoaXMgYnVpbGQuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0KSB7XG4gICAgICAgICAgICBjYXBpW2VbMF1dID0gd2FzbS5iaWdJbnRFbmFibGVkXG4gICAgICAgICAgICAgID8gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKVxuICAgICAgICAgICAgICA6IGZJNjREaXNhYmxlZChlWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGUgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcztcblxuICAgICAgICAgIGlmICh3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2RiX2Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBfX2RiX2VyciA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAgICdzcWxpdGUzX3dhc21fZGJfZXJyb3InLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBmdW5jdGlvbiAocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHRDb2RlIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdENvZGUgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRDb2RlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnJyArIHJlc3VsdENvZGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q29kZSA9IHJlc3VsdENvZGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcERiID8gX19kYl9lcnIocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKSA6IHJlc3VsdENvZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvciA9IGZ1bmN0aW9uIChwRGIsIGVyckNvZGUsIG1zZykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfd2FzbV9kYl9lcnJvcigpIGlzIG5vdCBleHBvcnRlZC4nLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyckNvZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjSnNvbiA9IHdhc20ueENhbGwoJ3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24nKTtcbiAgICAgICAgICBpZiAoIWNKc29uKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICBcIk1haW50ZW5hbmNlIHJlcXVpcmVkOiBpbmNyZWFzZSBzcWxpdGUzX3dhc21fZW51bV9qc29uKCknc1wiLFxuICAgICAgICAgICAgICAnc3RhdGljIGJ1ZmZlciBzaXplIScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhc20uY3R5cGUgPSBKU09OLnBhcnNlKHdhc20uY3N0clRvSnMoY0pzb24pKTtcblxuICAgICAgICAgIGNvbnN0IGRlZmluZUdyb3VwcyA9IFtcbiAgICAgICAgICAgICdhY2Nlc3MnLFxuICAgICAgICAgICAgJ2F1dGhvcml6ZXInLFxuICAgICAgICAgICAgJ2Jsb2JGaW5hbGl6ZXJzJyxcbiAgICAgICAgICAgICdjaGFuZ2VzZXQnLFxuICAgICAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICAgICAnZGF0YVR5cGVzJyxcbiAgICAgICAgICAgICdkYkNvbmZpZycsXG4gICAgICAgICAgICAnZGJTdGF0dXMnLFxuICAgICAgICAgICAgJ2VuY29kaW5ncycsXG4gICAgICAgICAgICAnZmNudGwnLFxuICAgICAgICAgICAgJ2Zsb2NrJyxcbiAgICAgICAgICAgICdpb0NhcCcsXG4gICAgICAgICAgICAnbGltaXRzJyxcbiAgICAgICAgICAgICdvcGVuRmxhZ3MnLFxuICAgICAgICAgICAgJ3ByZXBhcmVGbGFncycsXG4gICAgICAgICAgICAncmVzdWx0Q29kZXMnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNTdGF0dXMnLFxuICAgICAgICAgICAgJ3N0bXRTdGF0dXMnLFxuICAgICAgICAgICAgJ3N5bmNGbGFncycsXG4gICAgICAgICAgICAndHJhY2UnLFxuICAgICAgICAgICAgJ3R4blN0YXRlJyxcbiAgICAgICAgICAgICd1ZGZGbGFncycsXG4gICAgICAgICAgICAndmVyc2lvbicsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICBkZWZpbmVHcm91cHMucHVzaCgnc2VyaWFsaXplJywgJ3Nlc3Npb24nLCAndnRhYicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgZGVmaW5lR3JvdXBzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMod2FzbS5jdHlwZVt0XSkpIHtcbiAgICAgICAgICAgICAgY2FwaVtlWzBdXSA9IGVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FzbS5mdW5jdGlvbkVudHJ5KGNhcGkuU1FMSVRFX1dBU01fREVBTExPQykpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdJbnRlcm5hbCBlcnJvcjogY2Fubm90IHJlc29sdmUgZXhwb3J0ZWQgZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAnZW50cnkgU1FMSVRFX1dBU01fREVBTExPQyAoPT0nICsgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DICsgJykuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IF9fcmNNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBbJ3Jlc3VsdENvZGVzJ10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh3YXNtLmN0eXBlW3RdKSkge1xuICAgICAgICAgICAgICBfX3JjTWFwW2VbMV1dID0gZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyID0gKHJjKSA9PiBfX3JjTWFwW3JjXTtcblxuICAgICAgICAgIGNvbnN0IG5vdFRoZXNlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICBXYXNtVGVzdFN0cnVjdDogdHJ1ZSxcblxuICAgICAgICAgICAgc3FsaXRlM19rdnZmc19tZXRob2RzOiAhdXRpbC5pc1VJVGhyZWFkKCksXG5cbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfaW5mbzogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfY29uc3RyYWludDogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfb3JkZXJieTogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZTogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygd2FzbS5jdHlwZS5zdHJ1Y3RzKSB7XG4gICAgICAgICAgICBpZiAoIW5vdFRoZXNlW3MubmFtZV0pIHtcbiAgICAgICAgICAgICAgY2FwaVtzLm5hbWVdID0gc3FsaXRlMy5TdHJ1Y3RCaW5kZXIocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mbykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfaW5kZXhfY29uc3RyYWludCcsXG4gICAgICAgICAgICAgICdzcWxpdGUzX2luZGV4X29yZGVyYnknLFxuICAgICAgICAgICAgICAnc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlJyxcbiAgICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2luZGV4X2luZm9ba10gPSBjYXBpW2tdO1xuICAgICAgICAgICAgICBkZWxldGUgY2FwaVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM192dGFiX2NvbmZpZyA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAgICdzcWxpdGUzX3dhc21fdnRhYl9jb25maWcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF9fZGJBcmdjTWlzbWF0Y2ggPSAocERiLCBmLCBuKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgZiArICcoKSByZXF1aXJlcyAnICsgbiArICcgYXJndW1lbnQnICsgKDEgPT09IG4gPyAnJyA6ICdzJykgKyAnLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2VyckVuY29kaW5nID0gKHBEYikgPT4ge1xuICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIGNhcGkuU1FMSVRFX0ZPUk1BVCxcbiAgICAgICAgICAgICdTUUxJVEVfVVRGOCBpcyB0aGUgb25seSBzdXBwb3J0ZWQgZW5jb2RpbmcuJyxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYXJnUERiID0gKHBEYikgPT4gd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzKicpKHBEYik7XG4gICAgICAgIGNvbnN0IF9fYXJnU3RyID0gKHN0cikgPT4gKHdhc20uaXNQdHIoc3RyKSA/IHdhc20uY3N0clRvSnMoc3RyKSA6IHN0cik7XG4gICAgICAgIGNvbnN0IF9fZGJDbGVhbnVwTWFwID0gZnVuY3Rpb24gKHBEYiwgbW9kZSkge1xuICAgICAgICAgIHBEYiA9IF9fYXJnUERiKHBEYik7XG4gICAgICAgICAgbGV0IG0gPSB0aGlzLmRiTWFwLmdldChwRGIpO1xuICAgICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgICAgdGhpcy5kYk1hcC5kZWxldGUocERiKTtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW0gJiYgbW9kZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGJNYXAuc2V0KHBEYiwgKG0gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LmJpbmQoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICBkYk1hcDogbmV3IE1hcCgpLFxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZENvbGxhdGlvbiA9IGZ1bmN0aW9uIChwRGIsIG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAxKTtcbiAgICAgICAgICBpZiAoIW0uY29sbGF0aW9uKSBtLmNvbGxhdGlvbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBtLmNvbGxhdGlvbi5hZGQoX19hcmdTdHIobmFtZSkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuX2FkZFVERiA9IGZ1bmN0aW9uIChwRGIsIG5hbWUsIGFyaXR5LCBtYXApIHtcbiAgICAgICAgICBuYW1lID0gX19hcmdTdHIobmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsZXQgdSA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgaWYgKCF1KSBtYXAuc2V0KG5hbWUsICh1ID0gbmV3IFNldCgpKSk7XG4gICAgICAgICAgdS5hZGQoYXJpdHkgPCAwID8gLTEgOiBhcml0eSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkRnVuY3Rpb24gPSBmdW5jdGlvbiAocERiLCBuYW1lLCBhcml0eSkge1xuICAgICAgICAgIGNvbnN0IG0gPSBfX2RiQ2xlYW51cE1hcChwRGIsIDEpO1xuICAgICAgICAgIGlmICghbS51ZGYpIG0udWRmID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2FkZFVERihwRGIsIG5hbWUsIGFyaXR5LCBtLnVkZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyA9IGZ1bmN0aW9uIChwRGIsIG5hbWUsIGFyaXR5KSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgICAgICAgaWYgKCFtLnd1ZGYpIG0ud3VkZiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hZGRVREYocERiLCBuYW1lLCBhcml0eSwgbS53dWRmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfX2RiQ2xlYW51cE1hcC5jbGVhbnVwID0gZnVuY3Rpb24gKHBEYikge1xuICAgICAgICAgIHBEYiA9IF9fYXJnUERiKHBEYik7XG5cbiAgICAgICAgICBjb25zdCBjbG9zZUFyZ3MgPSBbcERiXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfYnVzeV9oYW5kbGVyJyxcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbW1pdF9ob29rJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAgICAgICAnc3FsaXRlM19zZXRfYXV0aG9yaXplcicsXG4gICAgICAgICAgICAnc3FsaXRlM190cmFjZV92MicsXG4gICAgICAgICAgICAnc3FsaXRlM191cGRhdGVfaG9vaycsXG4gICAgICAgICAgXSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IHdhc20uZXhwb3J0c1tuYW1lXTtcbiAgICAgICAgICAgIGNsb3NlQXJncy5sZW5ndGggPSB4Lmxlbmd0aDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNhcGlbbmFtZV0oLi4uY2xvc2VBcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdjbG9zZS10aW1lIGNhbGwgb2YnLFxuICAgICAgICAgICAgICAgIG5hbWUgKyAnKCcsXG4gICAgICAgICAgICAgICAgY2xvc2VBcmdzLFxuICAgICAgICAgICAgICAgICcpIHRocmV3OicsXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMCk7XG4gICAgICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICAgICAgaWYgKG0uY29sbGF0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbS5jb2xsYXRpb24pIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9VVEY4LFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbS5jb2xsYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtYXAgPSBpID8gbS53dWRmIDogbS51ZGY7XG4gICAgICAgICAgICBpZiAoIWZtYXApIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IGlcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblxuICAgICAgICAgICAgICA6IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjI7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZm1hcCkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZVswXSxcbiAgICAgICAgICAgICAgICBhcml0aWVzID0gZVsxXTtcbiAgICAgICAgICAgICAgY29uc3QgZmFyZ3MgPSBbcERiLCBuYW1lLCAwLCBjYXBpLlNRTElURV9VVEY4LCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgaWYgKGkpIGZhcmdzLnB1c2goMCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYXJpdHkgb2YgYXJpdGllcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmYXJnc1syXSA9IGFyaXR5O1xuICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShudWxsLCBmYXJncyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcml0aWVzLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbWFwLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBtLnVkZjtcbiAgICAgICAgICBkZWxldGUgbS53dWRmO1xuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNDbG9zZVYyID0gd2FzbS54V3JhcChcbiAgICAgICAgICAgICdzcWxpdGUzX2Nsb3NlX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNhcGkuc3FsaXRlM19jbG9zZV92MiA9IGZ1bmN0aW9uIChwRGIpIHtcbiAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2Nsb3NlX3YyJywgMSk7XG4gICAgICAgICAgICBpZiAocERiKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuY2xlYW51cChwRGIpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3FsaXRlM0Nsb3NlVjIocERiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhcGkuc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyKSB7XG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzU2Vzc2lvbkRlbGV0ZSA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fZGVsZXRlJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFsnc3FsaXRlM19zZXNzaW9uKiddLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY2FwaS5zcWxpdGUzc2Vzc2lvbl9kZWxldGUgPSBmdW5jdGlvbiAocFNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZScsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwU2Vzc2lvbikge1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcihwU2Vzc2lvbiwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX3NxbGl0ZTNTZXNzaW9uRGVsZXRlKHBTZXNzaW9uKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSAoYXJndiwgYXJnSW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdhcmd2WycgK1xuICAgICAgICAgICAgICBhcmdJbmRleCArXG4gICAgICAgICAgICAgICddOicgK1xuICAgICAgICAgICAgICBhcmd2WzBdICtcbiAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyhhcmd2WzFdKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlQ29sbGF0aW9uVjIgPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneENvbXBhcmUnLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwaXApJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RGVzdHJveScsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIHpOYW1lLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXJnLFxuICAgICAgICAgICAgeENvbXBhcmUsXG4gICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICg2ICE9PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInLCA2KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKDAgPT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FwaS5TUUxJVEVfVVRGOCAhPT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVDb2xsYXRpb25WMihcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgek5hbWUsXG4gICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgcEFyZyxcbiAgICAgICAgICAgICAgICB4Q29tcGFyZSxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHJjICYmIHhDb21wYXJlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRDb2xsYXRpb24ocERiLCB6TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IocERiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICB6TmFtZSxcbiAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgcEFyZyxcbiAgICAgICAgICAgIHhDb21wYXJlLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIDUgPT09IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIHpOYW1lLFxuICAgICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgICBwQXJnLFxuICAgICAgICAgICAgICAgICAgeENvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbicsIDUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29udGV4dEtleSA9IGZ1bmN0aW9uIChhcmd2LCBhcmdJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgYXJndlswXSArXG4gICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgIChhcmd2WzJdIDwgMCA/IC0xIDogYXJndlsyXSkgK1xuICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICBhcmdJbmRleCArXG4gICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoYXJndlsxXSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgX19jZlByb3h5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICB4SW52ZXJzZUFuZFN0ZXA6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwaXApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwQ3R4LCAuLi5jYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzKGFyZ2MsIHBBcmd2KSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4RmluYWxBbmRWYWx1ZToge1xuICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KHApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanMocEN0eCwgY2FsbGJhY2socEN0eCkpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeEZ1bmM6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwaXApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzKFxuICAgICAgICAgICAgICAgICAgICAgIHBDdHgsXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socEN0eCwgLi4uY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcyhhcmdjLCBwQXJndikpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeERlc3Ryb3k6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgIGNvbnRleHRLZXksXG5cbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBWb2lkKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwVm9pZCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VERiB4RGVzdHJveSBtZXRob2QgdGhyZXc6JywgZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNDcmVhdGVGdW5jdGlvbiA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RnVuYycsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhGdW5jLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4U3RlcCcsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneEZpbmFsJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hEZXN0cm95JyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueERlc3Ryb3ksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlV2luZG93RnVuY3Rpb24gPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hTdGVwJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEludmVyc2VBbmRTdGVwLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RmluYWwnLFxuICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54RmluYWxBbmRWYWx1ZSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneFZhbHVlJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hJbnZlcnNlJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEludmVyc2VBbmRTdGVwLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RGVzdHJveScsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhEZXN0cm95LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjInLFxuICAgICAgICAgICAgICAgIGYubGVuZ3RoLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgwID09PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgIGVUZXh0UmVwIHw9IGNhcGkuU1FMSVRFX1VURjg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNhcGkuU1FMSVRFX1VURjggIT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZXJyRW5jb2RpbmcocERiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gX19zcWxpdGUzQ3JlYXRlRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lLFxuICAgICAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgcEFwcCxcbiAgICAgICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAwID09PSByYyAmJlxuICAgICAgICAgICAgICAgICh4RnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICB4U3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICB4RmluYWwgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeERlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkRnVuY3Rpb24ocERiLCBmdW5jTmFtZSwgbkFyZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MigpIHNldHVwIHRocmV3OicsIGUpO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIFVERiB0aHJldzogJyArIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbicsIGYubGVuZ3RoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24gPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICB4VmFsdWUsXG4gICAgICAgICAgICB4SW52ZXJzZSxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2VyckVuY29kaW5nKHBEYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IF9fc3FsaXRlM0NyZWF0ZVdpbmRvd0Z1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgICAgICB4SW52ZXJzZSxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgPT09IHJjICYmXG4gICAgICAgICAgICAgICAgKHhTdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgIHhGaW5hbCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICB4VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeEludmVyc2UgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeERlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyhwRGIsIGZ1bmNOYW1lLCBuQXJnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbigpIHNldHVwIHRocmV3OicsIGUpO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIFVERiB0aHJldzogJyArIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIudWRmU2V0UmVzdWx0ID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmU2V0UmVzdWx0ID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZlNldFJlc3VsdCA9XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanM7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyLnVkZkNvbnZlcnRBcmdzID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPVxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPVxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzO1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mi51ZGZTZXRFcnJvciA9XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uLnVkZlNldEVycm9yID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZlNldEVycm9yID1cbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcztcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX2ZsZXhpU3RyaW5nID0gKHYsIG4pID0+IHtcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgbiA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgbiA9IHYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgdiA9IHV0aWwudHlwZWRBcnJheVRvU3RyaW5nKFxuICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KHYpIDogdixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICB2ID0gdi5qb2luKCcnKTtcbiAgICAgICAgICAgICAgbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt2LCBuXTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgX19wcmVwYXJlID0ge1xuICAgICAgICAgICAgYmFzaWM6IHdhc20ueFdyYXAoJ3NxbGl0ZTNfcHJlcGFyZV92MycsICdpbnQnLCBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdKSxcblxuICAgICAgICAgICAgZnVsbDogd2FzbS54V3JhcCgnc3FsaXRlM19wcmVwYXJlX3YzJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjMgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgc3FsTGVuLFxuICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgcHBTdG10LFxuICAgICAgICAgICAgcHpUYWlsLFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfcHJlcGFyZV92MycsIGYubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFt4U3FsLCB4U3FsTGVuXSA9IF9fZmxleGlTdHJpbmcoc3FsLCBzcWxMZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgeFNxbCkge1xuICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfX3ByZXBhcmUuYmFzaWMoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICB4U3FsLFxuICAgICAgICAgICAgICAgICAgeFNxbExlbixcbiAgICAgICAgICAgICAgICAgIHByZXBGbGFncyxcbiAgICAgICAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX19wcmVwYXJlLmZ1bGwoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICB4U3FsLFxuICAgICAgICAgICAgICAgICAgeFNxbExlbixcbiAgICAgICAgICAgICAgICAgIHByZXBGbGFncyxcbiAgICAgICAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIFNRTCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX3ByZXBhcmVfdjIvdjMoKS4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHNxbExlbixcbiAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19wcmVwYXJlX3YzKHBEYiwgc3FsLCBzcWxMZW4sIDAsIHBwU3RtdCwgcHpUYWlsKVxuICAgICAgICAgICAgICA6IF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM19wcmVwYXJlX3YyJywgZi5sZW5ndGgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgX19iaW5kVGV4dCA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfYmluZF90ZXh0JywgJ2ludCcsIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBjb25zdCBfX2JpbmRCbG9iID0gd2FzbS54V3JhcCgnc3FsaXRlM19iaW5kX2Jsb2InLCAnaW50JywgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc3RtdConLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19iaW5kX3RleHQgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcFN0bXQsXG4gICAgICAgICAgICBpQ29sLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIG5UZXh0LFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfYmluZF90ZXh0JyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5pc1B0cih0ZXh0KSB8fCBudWxsID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRUZXh0KHBTdG10LCBpQ29sLCB0ZXh0LCBuVGV4dCwgeERlc3Ryb3kpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IG5ldyBVaW50OEFycmF5KHRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBNZW0pKSB7XG4gICAgICAgICAgICAgIHRleHQgPSBwTWVtLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHAsIG47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSh0ZXh0KTtcbiAgICAgICAgICAgICAgICBuID0gdGV4dC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGV4dCkge1xuICAgICAgICAgICAgICAgIFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgM3JkIGFyZ3VtZW50IHR5cGUgZm9yIHNxbGl0ZTNfYmluZF90ZXh0KCkuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRUZXh0KHBTdG10LCBpQ29sLCBwLCBuLCBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB3YXNtLmRlYWxsb2MocCk7XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBTdG10LFxuICAgICAgICAgICAgaUNvbCxcbiAgICAgICAgICAgIHBNZW0sXG4gICAgICAgICAgICBuTWVtLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfYmluZF9ibG9iJyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5pc1B0cihwTWVtKSB8fCBudWxsID09PSBwTWVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRCbG9iKHBTdG10LCBpQ29sLCBwTWVtLCBuTWVtLCB4RGVzdHJveSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBNZW0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICBwTWVtID0gbmV3IFVpbnQ4QXJyYXkocE1lbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocE1lbSkpIHtcbiAgICAgICAgICAgICAgcE1lbSA9IHBNZW0uam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcCwgbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHBNZW0pKSB7XG4gICAgICAgICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShwTWVtKTtcbiAgICAgICAgICAgICAgICBuID0gbk1lbSA+PSAwID8gbk1lbSA6IHBNZW0uYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBNZW0pIHtcbiAgICAgICAgICAgICAgICBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyhwTWVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2JpbmRfYmxvYigpLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX19iaW5kQmxvYihwU3RtdCwgaUNvbCwgcCwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgd2FzbS5kZWFsbG9jKHApO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNhcGkuc3FsaXRlM19jb25maWcgPSBmdW5jdGlvbiAob3AsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfQ09WRVJJTkdfSU5ERVhfU0NBTjpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUVNU1RBVFVTOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TTUFMTF9NQUxMT0M6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NPUlRFUlJFRl9TSVpFOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TVE1USlJOTF9TUElMTDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfVVJJOlxuICAgICAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2NvbmZpZ19pKG9wLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTE9PS0FTSURFOlxuICAgICAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2NvbmZpZ19paShcbiAgICAgICAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgICAgICAgYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUVNREJfTUFYU0laRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9jb25maWdfaihvcCwgYXJnc1swXSk7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVE1BTExPQzpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUTVVURVg6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVFBDQUNIRTI6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVFBDQUNIRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfSEVBUDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTE9HOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NQUxMT0M6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01NQVBfU0laRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTVVMVElUSFJFQUQ6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01VVEVYOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQUdFQ0FDSEU6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRTI6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUENBQ0hFX0hEUlNaOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QTUFTWjpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU0VSSUFMSVpFRDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU0lOR0xFVEhSRUFEOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TUUxMT0c6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1dJTjMyX0hFQVBTSVpFOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9OT1RGT1VORDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IF9fYXV0b0V4dEZwdHIgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbiAoZlB0cikge1xuICAgICAgICAgICAgaWYgKGZQdHIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBmUHRyID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oJ2kocHBwKScsIGZQdHIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoIHx8ICF3YXNtLmlzUHRyKGZQdHIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9NSVNVU0U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYyA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uKGZQdHIpO1xuICAgICAgICAgICAgaWYgKGZQdHIgIT09IGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICBpZiAoMCA9PT0gcmMpIF9fYXV0b0V4dEZwdHIuYWRkKGZQdHIpO1xuICAgICAgICAgICAgICBlbHNlIHdhc20udW5pbnN0YWxsRnVuY3Rpb24oZlB0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbiAoZlB0cikge1xuICAgICAgICAgICAgaWYgKCFmUHRyIHx8IDEgIT09IGFyZ3VtZW50cy5sZW5ndGggfHwgIXdhc20uaXNQdHIoZlB0cikpIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbihmUHRyKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24oKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnAgb2YgX19hdXRvRXh0RnB0cikgd2FzbS51bmluc3RhbGxGdW5jdGlvbihmcCk7XG4gICAgICAgICAgICBfX2F1dG9FeHRGcHRyLmNsZWFyKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBLdnZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZCgna3Z2ZnMnKTtcbiAgICAgICAgaWYgKHBLdnZmcykge1xuICAgICAgICAgIGlmICh1dGlsLmlzVUlUaHJlYWQoKSkge1xuICAgICAgICAgICAgY29uc3Qga3Z2ZnNNZXRob2RzID0gbmV3IGNhcGkuc3FsaXRlM19rdnZmc19tZXRob2RzKFxuICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHMoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWxldGUgY2FwaS5zcWxpdGUzX2t2dmZzX21ldGhvZHM7XG5cbiAgICAgICAgICAgIGNvbnN0IGt2dmZzTWFrZUtleSA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2ssXG4gICAgICAgICAgICAgIHBzdGFjayA9IHdhc20ucHN0YWNrO1xuXG4gICAgICAgICAgICBjb25zdCBrdnZmc1N0b3JhZ2UgPSAoekNsYXNzKSA9PlxuICAgICAgICAgICAgICAxMTUgPT09IHdhc20ucGVlayh6Q2xhc3MpID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGt2dmZzSW1wbHMgPSB7XG4gICAgICAgICAgICAgIHhSZWFkOiAoekNsYXNzLCB6S2V5LCB6QnVmLCBuQnVmKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIGFzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHpYS2V5ID0ga3Z2ZnNNYWtlS2V5KHpDbGFzcywgektleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXpYS2V5KSByZXR1cm4gLTM7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqS2V5ID0gd2FzbS5jc3RyVG9Kcyh6WEtleSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqViA9IGt2dmZzU3RvcmFnZSh6Q2xhc3MpLmdldEl0ZW0oaktleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWpWKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuViA9IGpWLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGlmIChuQnVmIDw9IDApIHJldHVybiBuVjtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKDEgPT09IG5CdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzbS5wb2tlKHpCdWYsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblY7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCB6ViA9IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKGpWKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuQnVmID4gblYgKyAxKSBuQnVmID0gblYgKyAxO1xuICAgICAgICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5jb3B5V2l0aGluKHpCdWYsIHpWLCB6ViArIG5CdWYgLSAxKTtcbiAgICAgICAgICAgICAgICAgIHdhc20ucG9rZSh6QnVmICsgbkJ1ZiAtIDEsIDApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5CdWYgLSAxO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2t2c3RvcmFnZVJlYWQoKScsIGUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBwc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKGFzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4V3JpdGU6ICh6Q2xhc3MsIHpLZXksIHpEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgelhLZXkgPSBrdnZmc01ha2VLZXkoekNsYXNzLCB6S2V5KTtcbiAgICAgICAgICAgICAgICAgIGlmICghelhLZXkpIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaktleSA9IHdhc20uY3N0clRvSnMoelhLZXkpO1xuICAgICAgICAgICAgICAgICAga3Z2ZnNTdG9yYWdlKHpDbGFzcykuc2V0SXRlbShqS2V5LCB3YXNtLmNzdHJUb0pzKHpEYXRhKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdrdnN0b3JhZ2VXcml0ZSgpJywgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhEZWxldGU6ICh6Q2xhc3MsIHpLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB6WEtleSA9IGt2dmZzTWFrZUtleSh6Q2xhc3MsIHpLZXkpO1xuICAgICAgICAgICAgICAgICAgaWYgKCF6WEtleSkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICBrdnZmc1N0b3JhZ2UoekNsYXNzKS5yZW1vdmVJdGVtKHdhc20uY3N0clRvSnMoelhLZXkpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2t2c3RvcmFnZURlbGV0ZSgpJywgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKGt2dmZzSW1wbHMpKSB7XG4gICAgICAgICAgICAgIGt2dmZzTWV0aG9kc1trdnZmc01ldGhvZHMubWVtYmVyS2V5KGspXSA9IHdhc20uaW5zdGFsbEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIGt2dmZzTWV0aG9kcy5tZW1iZXJTaWduYXR1cmUoayksXG4gICAgICAgICAgICAgICAga3Z2ZnNJbXBsc1trXSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHBLdnZmcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBzcWxpdGUzLnZlcnNpb24gPSB7XG4gICAgICAgICAgbGliVmVyc2lvbjogJzMuNDUuMycsXG4gICAgICAgICAgbGliVmVyc2lvbk51bWJlcjogMzA0NTAwMyxcbiAgICAgICAgICBzb3VyY2VJZDpcbiAgICAgICAgICAgICcyMDI0LTA0LTE1IDEzOjM0OjA1IDg2NTNiNzU4ODcwZTZlZjBjOThkNDZiM2FjZTI3ODQ5MDU0YWY4NWRhODkxZWIxMjFlOWFhYTUzN2YxZTgzNTUnLFxuICAgICAgICAgIGRvd25sb2FkVmVyc2lvbjogMzQ1MDMwMCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9zczMgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBzcWxpdGUzLlNRTGl0ZTNFcnJvciguLi5hcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpLFxuICAgICAgICAgIHdhc20gPSBzcWxpdGUzLndhc20sXG4gICAgICAgICAgdXRpbCA9IHNxbGl0ZTMudXRpbDtcblxuICAgICAgICBjb25zdCBfX3B0ck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICAgICAgY29uc3QgX19zdG10TWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgICBjb25zdCBnZXRPd25PcHRpb24gPSAob3B0cywgcCwgZGZsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9wdHMsIHApO1xuICAgICAgICAgIHJldHVybiBkID8gZC52YWx1ZSA6IGRmbHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY2hlY2tTcWxpdGUzUmMgPSBmdW5jdGlvbiAoZGJQdHIsIHNxbGl0ZVJlc3VsdENvZGUpIHtcbiAgICAgICAgICBpZiAoc3FsaXRlUmVzdWx0Q29kZSkge1xuICAgICAgICAgICAgaWYgKGRiUHRyIGluc3RhbmNlb2YgREIpIGRiUHRyID0gZGJQdHIucG9pbnRlcjtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICBzcWxpdGVSZXN1bHRDb2RlLFxuICAgICAgICAgICAgICAnc3FsaXRlMyByZXN1bHQgY29kZScsXG4gICAgICAgICAgICAgIHNxbGl0ZVJlc3VsdENvZGUgKyAnOicsXG4gICAgICAgICAgICAgIGRiUHRyXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfZXJybXNnKGRiUHRyKVxuICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2VycnN0cihzcWxpdGVSZXN1bHRDb2RlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19kYlRyYWNlVG9Db25zb2xlID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgJ2koaXBwcCknLFxuICAgICAgICAgIGZ1bmN0aW9uICh0LCBjLCBwLCB4KSB7XG4gICAgICAgICAgICBpZiAoY2FwaS5TUUxJVEVfVFJBQ0VfU1RNVCA9PT0gdCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAnU1FMIFRSQUNFICMnICsgKyt0aGlzLmNvdW50ZXIgKyAnIHZpYSBzcWxpdGUzQCcgKyBjICsgJzonLFxuICAgICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoeCksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfS5iaW5kKHsgY291bnRlcjogMCB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBfX3Zmc1Bvc3RPcGVuU3FsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjb25zdCBkYkN0b3JIZWxwZXIgPSBmdW5jdGlvbiBjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoIWN0b3IuX25hbWUydmZzKSB7XG4gICAgICAgICAgICBjdG9yLl9uYW1lMnZmcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBjb25zdCBpc1dvcmtlclRocmVhZCA9XG4gICAgICAgICAgICAgICdmdW5jdGlvbicgPT09IHR5cGVvZiBpbXBvcnRTY3JpcHRzXG4gICAgICAgICAgICAgICAgPyAobikgPT5cbiAgICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICAgJ1RoZSBWRlMgZm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICAgICdpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgbWFpbiB3aW5kb3cgdGhyZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgY3Rvci5fbmFtZTJ2ZnNbJzpsb2NhbFN0b3JhZ2U6J10gPSB7XG4gICAgICAgICAgICAgIHZmczogJ2t2dmZzJyxcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IGlzV29ya2VyVGhyZWFkIHx8ICgoKSA9PiAnbG9jYWwnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdG9yLl9uYW1lMnZmc1snOnNlc3Npb25TdG9yYWdlOiddID0ge1xuICAgICAgICAgICAgICB2ZnM6ICdrdnZmcycsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBpc1dvcmtlclRocmVhZCB8fCAoKCkgPT4gJ3Nlc3Npb24nKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9wdCA9IGN0b3Iubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgICBsZXQgZm4gPSBvcHQuZmlsZW5hbWUsXG4gICAgICAgICAgICB2ZnNOYW1lID0gb3B0LnZmcyxcbiAgICAgICAgICAgIGZsYWdzU3RyID0gb3B0LmZsYWdzO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgnc3RyaW5nJyAhPT0gdHlwZW9mIGZuICYmICdudW1iZXInICE9PSB0eXBlb2YgZm4pIHx8XG4gICAgICAgICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGZsYWdzU3RyIHx8XG4gICAgICAgICAgICAodmZzTmFtZSAmJlxuICAgICAgICAgICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIHZmc05hbWUgJiZcbiAgICAgICAgICAgICAgJ251bWJlcicgIT09IHR5cGVvZiB2ZnNOYW1lKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IoJ0ludmFsaWQgREIgY3RvciBhcmdzJywgb3B0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdG9zczMoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBEQiBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZuSnMgPSAnbnVtYmVyJyA9PT0gdHlwZW9mIGZuID8gd2FzbS5jc3RyVG9KcyhmbikgOiBmbjtcbiAgICAgICAgICBjb25zdCB2ZnNDaGVjayA9IGN0b3IuX25hbWUydmZzW2ZuSnNdO1xuICAgICAgICAgIGlmICh2ZnNDaGVjaykge1xuICAgICAgICAgICAgdmZzTmFtZSA9IHZmc0NoZWNrLnZmcztcbiAgICAgICAgICAgIGZuID0gZm5KcyA9IHZmc0NoZWNrLmZpbGVuYW1lKGZuSnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcERiLFxuICAgICAgICAgICAgb2ZsYWdzID0gMDtcbiAgICAgICAgICBpZiAoZmxhZ3NTdHIuaW5kZXhPZignYycpID49IDApIHtcbiAgICAgICAgICAgIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX0NSRUFURSB8IGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxhZ3NTdHIuaW5kZXhPZigndycpID49IDApIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX1JFQURXUklURTtcbiAgICAgICAgICBpZiAoMCA9PT0gb2ZsYWdzKSBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9SRUFET05MWTtcbiAgICAgICAgICBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9FWFJFU0NPREU7XG4gICAgICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwUHRyID0gd2FzbS5wc3RhY2suYWxsb2NQdHIoKTtcbiAgICAgICAgICAgIGxldCByYyA9IGNhcGkuc3FsaXRlM19vcGVuX3YyKGZuLCBwUHRyLCBvZmxhZ3MsIHZmc05hbWUgfHwgMCk7XG4gICAgICAgICAgICBwRGIgPSB3YXNtLnBlZWtQdHIocFB0cik7XG4gICAgICAgICAgICBjaGVja1NxbGl0ZTNSYyhwRGIsIHJjKTtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMocERiLCAxKTtcbiAgICAgICAgICAgIGlmIChmbGFnc1N0ci5pbmRleE9mKCd0JykgPj0gMCkge1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdHJhY2VfdjIoXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1RSQUNFX1NUTVQsXG4gICAgICAgICAgICAgICAgX19kYlRyYWNlVG9Db25zb2xlLFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAocERiKSBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gZm5KcztcbiAgICAgICAgICBfX3B0ck1hcC5zZXQodGhpcywgcERiKTtcbiAgICAgICAgICBfX3N0bXRNYXAuc2V0KHRoaXMsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwVmZzID0gY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhwRGIpO1xuICAgICAgICAgICAgaWYgKCFwVmZzKVxuICAgICAgICAgICAgICB0b3NzMygnSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBnZXQgVkZTIGZvciBuZXcgZGIgaGFuZGxlLicpO1xuICAgICAgICAgICAgY29uc3QgcG9zdEluaXRTcWwgPSBfX3Zmc1Bvc3RPcGVuU3FsW3BWZnNdO1xuICAgICAgICAgICAgaWYgKHBvc3RJbml0U3FsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgcG9zdEluaXRTcWwodGhpcywgc3FsaXRlMyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc3RJbml0U3FsKSB7XG4gICAgICAgICAgICAgIGNoZWNrU3FsaXRlM1JjKHBEYiwgY2FwaS5zcWxpdGUzX2V4ZWMocERiLCBwb3N0SW5pdFNxbCwgMCwgMCwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlblNxbCA9IGZ1bmN0aW9uIChwVmZzLCBzcWwpIHtcbiAgICAgICAgICBfX3Zmc1Bvc3RPcGVuU3FsW3BWZnNdID0gc3FsO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGZpbGVuYW1lID0gJzptZW1vcnk6JyxcbiAgICAgICAgICBmbGFncyA9ICdjJyxcbiAgICAgICAgICB2ZnMgPSBudWxsLFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSB7fTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAxID09PSBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gJiZcbiAgICAgICAgICAgICdvYmplY3QnID09PSB0eXBlb2YgYXJndW1lbnRzWzBdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGFyZywgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGFyZy5mbGFncykgYXJnLmZsYWdzID0gJ2MnO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnLnZmcykgYXJnLnZmcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBhcmcuZmlsZW5hbWUpIGFyZy5maWxlbmFtZSA9ICc6bWVtb3J5Oic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgYXJnLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgICAgICBhcmcudmZzID0gdmZzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IERCID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBkYkN0b3JIZWxwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIERCLmRiQ3RvckhlbHBlciA9IGRiQ3RvckhlbHBlcjtcblxuICAgICAgICBjb25zdCBCaW5kVHlwZXMgPSB7XG4gICAgICAgICAgbnVsbDogMSxcbiAgICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgICAgc3RyaW5nOiAzLFxuICAgICAgICAgIGJvb2xlYW46IDQsXG4gICAgICAgICAgYmxvYjogNSxcbiAgICAgICAgfTtcbiAgICAgICAgQmluZFR5cGVzWyd1bmRlZmluZWQnXSA9PSBCaW5kVHlwZXMubnVsbDtcbiAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgIEJpbmRUeXBlcy5iaWdpbnQgPSBCaW5kVHlwZXMubnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgU3RtdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoQmluZFR5cGVzICE9PSBhcmd1bWVudHNbMl0pIHtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICdEbyBub3QgY2FsbCB0aGUgU3RtdCBjb25zdHJ1Y3RvciBkaXJlY3RseS4gVXNlIERCLnByZXBhcmUoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kYiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBfX3B0ck1hcC5zZXQodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICB0aGlzLnBhcmFtZXRlckNvdW50ID0gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50KHRoaXMucG9pbnRlcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtRGJPcGVuID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgaWYgKCFkYi5wb2ludGVyKSB0b3NzMygnREIgaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1Db2xJbmRleCA9IGZ1bmN0aW9uIChzdG10LCBuZHgpIHtcbiAgICAgICAgICBpZiAobmR4ICE9PSAobmR4IHwgMCkgfHwgbmR4IDwgMCB8fCBuZHggPj0gc3RtdC5jb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgdG9zczMoJ0NvbHVtbiBpbmRleCcsIG5keCwgJ2lzIG91dCBvZiByYW5nZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcGFyc2VFeGVjQXJncyA9IGZ1bmN0aW9uIChkYiwgYXJncykge1xuICAgICAgICAgIGNvbnN0IG91dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgb3V0Lm9wdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBhcmdzWzBdIHx8XG4gICAgICAgICAgICAgICAgdXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KGFyZ3NbMF0pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICBvdXQuc3FsID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzWzBdICYmICdvYmplY3QnID09PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBvdXQub3B0LnNxbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgb3V0LnNxbCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50IGNvdW50IGZvciBleGVjKCkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC5zcWwgPSB1dGlsLmZsZXhpYmxlU3RyaW5nKG91dC5zcWwpO1xuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIG91dC5zcWwpIHtcbiAgICAgICAgICAgIHRvc3MzKCdNaXNzaW5nIFNRTCBhcmd1bWVudCBvciB1bnN1cHBvcnRlZCBTUUwgdmFsdWUgdHlwZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3B0ID0gb3V0Lm9wdDtcbiAgICAgICAgICBzd2l0Y2ggKG9wdC5yZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAncmVzdWx0Um93cyc6XG4gICAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBvcHQucmVzdWx0Um93cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzYXZlU3FsJzpcbiAgICAgICAgICAgICAgaWYgKCFvcHQuc2F2ZVNxbCkgb3B0LnNhdmVTcWwgPSBbXTtcbiAgICAgICAgICAgICAgb3V0LnJldHVyblZhbCA9ICgpID0+IG9wdC5zYXZlU3FsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSAndGhpcyc6XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBkYjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByZXR1cm5WYWx1ZSB2YWx1ZTonLCBvcHQucmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdC5jYWxsYmFjayAmJiAhb3B0LnJldHVyblZhbHVlICYmIHVuZGVmaW5lZCAhPT0gb3B0LnJvd01vZGUpIHtcbiAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICBvdXQucmV0dXJuVmFsID0gKCkgPT4gb3B0LnJlc3VsdFJvd3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHQuY2FsbGJhY2sgfHwgb3B0LnJlc3VsdFJvd3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodW5kZWZpbmVkID09PSBvcHQucm93TW9kZSA/ICdhcnJheScgOiBvcHQucm93TW9kZSkge1xuICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10LmdldChbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3N0bXQnOlxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKSkge1xuICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICdleGVjKCk6IGludmFsaWQgcm93TW9kZSBmb3IgYSByZXN1bHRSb3dzIGFycmF5OiBtdXN0JyxcbiAgICAgICAgICAgICAgICAgICAgXCJiZSBvbmUgb2YgJ2FycmF5JywgJ29iamVjdCcsXCIsXG4gICAgICAgICAgICAgICAgICAgICdhIHJlc3VsdCBjb2x1bW4gbnVtYmVyLCBvciBjb2x1bW4gbmFtZSByZWZlcmVuY2UuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIob3B0LnJvd01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICBvdXQuY2JBcmcgPSAoc3RtdCkgPT4gc3RtdC5nZXQob3B0LnJvd01vZGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICdzdHJpbmcnID09PSB0eXBlb2Ygb3B0LnJvd01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIG9wdC5yb3dNb2RlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICckJyA9PT0gb3B0LnJvd01vZGVbMF1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0ICRjb2xOYW1lID0gb3B0LnJvd01vZGUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgb3V0LmNiQXJnID0gKHN0bXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBzdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKVskY29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQgPT09IHJjXG4gICAgICAgICAgICAgICAgICAgICAgPyB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdleGVjKCk6IHVua25vd24gcmVzdWx0IGNvbHVtbjonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAkY29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IHJjO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByb3dNb2RlOicsIG9wdC5yb3dNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEZpcnN0Um93ID0gKGRiLCBzcWwsIGJpbmQsIC4uLmdldEFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG10ID0gZGIucHJlcGFyZShzcWwpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHN0bXQuYmluZChiaW5kKS5zdGVwKClcbiAgICAgICAgICAgICAgPyBzdG10LmdldCguLi5nZXRBcmdzKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN0bXQucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEFsbCA9IChkYiwgc3FsLCBiaW5kLCByb3dNb2RlKSA9PlxuICAgICAgICAgIGRiLmV4ZWMoe1xuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgYmluZCxcbiAgICAgICAgICAgIHJvd01vZGUsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTogJ3Jlc3VsdFJvd3MnLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIERCLmNoZWNrUmMgPSAoZGIsIHJlc3VsdENvZGUpID0+IGNoZWNrU3FsaXRlM1JjKGRiLCByZXN1bHRDb2RlKTtcblxuICAgICAgICBEQi5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgaXNPcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFmZmlybU9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9uY2xvc2UgJiYgdGhpcy5vbmNsb3NlLmJlZm9yZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZS5iZWZvcmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwRGIgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9fc3RtdE1hcC5nZXQodGhpcykpLmZvckVhY2goKGssIHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocyAmJiBzLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHMuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBfX3N0bXRNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSAmJiB0aGlzLm9uY2xvc2UuYWZ0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UuYWZ0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hhbmdlczogZnVuY3Rpb24gKHRvdGFsID0gZmFsc2UsIHNpeHR5Rm91ciA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXI7XG4gICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpeHR5Rm91clxuICAgICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NChwKVxuICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXMocCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc2l4dHlGb3VyXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY2hhbmdlczY0KHApXG4gICAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfY2hhbmdlcyhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJGaWxlbmFtZTogZnVuY3Rpb24gKGRiTmFtZSA9ICdtYWluJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19kYl9maWxlbmFtZShhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlciwgZGJOYW1lKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJOYW1lOiBmdW5jdGlvbiAoZGJOdW1iZXIgPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2RiX25hbWUoYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXIsIGRiTnVtYmVyKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJWZnNOYW1lOiBmdW5jdGlvbiAoZGJOYW1lID0gMCkge1xuICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgY29uc3QgcFZmcyA9IGNhcGkuc3FsaXRlM19qc19kYl92ZnMoXG4gICAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyLFxuICAgICAgICAgICAgICBkYk5hbWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHBWZnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBWZnMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJjID0gd2FzbS5jc3RyVG9Kcyh2LiR6TmFtZSk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcHJlcGFyZTogZnVuY3Rpb24gKHNxbCkge1xuICAgICAgICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgbGV0IHBwU3RtdCwgcFN0bXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcFN0bXQgPSB3YXNtLnBzdGFjay5hbGxvYyg4KTtcbiAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyKHRoaXMucG9pbnRlciwgc3FsLCAtMSwgcHBTdG10LCBudWxsKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcFN0bXQgPSB3YXNtLnBlZWtQdHIocHBTdG10KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwU3RtdCkgdG9zczMoJ0Nhbm5vdCBwcmVwYXJlIGVtcHR5IFNRTC4nKTtcbiAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgIF9fc3RtdE1hcC5nZXQodGhpcylbcFN0bXRdID0gc3RtdDtcbiAgICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBleGVjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXJzZUV4ZWNBcmdzKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIWFyZy5zcWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRvc3MzKCdleGVjKCkgcmVxdWlyZXMgYW4gU1FMIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGFyZy5vcHQ7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9wdC5jYWxsYmFjaztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFJvd3MgPSBBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKVxuICAgICAgICAgICAgICA/IG9wdC5yZXN1bHRSb3dzXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN0bXQ7XG4gICAgICAgICAgICBsZXQgYmluZCA9IG9wdC5iaW5kO1xuICAgICAgICAgICAgbGV0IGV2YWxGaXJzdFJlc3VsdCA9ICEhKFxuICAgICAgICAgICAgICBhcmcuY2JBcmcgfHxcbiAgICAgICAgICAgICAgb3B0LmNvbHVtbk5hbWVzIHx8XG4gICAgICAgICAgICAgIHJlc3VsdFJvd3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICBjb25zdCBzYXZlU3FsID0gQXJyYXkuaXNBcnJheShvcHQuc2F2ZVNxbClcbiAgICAgICAgICAgICAgPyBvcHQuc2F2ZVNxbFxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzVEEgPSB1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkoYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGxldCBzcWxCeXRlTGVuID0gaXNUQVxuICAgICAgICAgICAgICAgID8gYXJnLnNxbC5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgOiB3YXNtLmpzdHJsZW4oYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBwU3RtdCA9IHdhc20uc2NvcGVkQWxsb2MoXG4gICAgICAgICAgICAgICAgMiAqIHdhc20ucHRyU2l6ZW9mICsgKHNxbEJ5dGVMZW4gKyAxKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgcHpUYWlsID0gcHBTdG10ICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGxldCBwU3FsID0gcHpUYWlsICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGNvbnN0IHBTcWxFbmQgPSBwU3FsICsgc3FsQnl0ZUxlbjtcbiAgICAgICAgICAgICAgaWYgKGlzVEEpIHdhc20uaGVhcDgoKS5zZXQoYXJnLnNxbCwgcFNxbCk7XG4gICAgICAgICAgICAgIGVsc2Ugd2FzbS5qc3RyY3B5KGFyZy5zcWwsIHdhc20uaGVhcDgoKSwgcFNxbCwgc3FsQnl0ZUxlbiwgZmFsc2UpO1xuICAgICAgICAgICAgICB3YXNtLnBva2UocFNxbCArIHNxbEJ5dGVMZW4sIDApO1xuICAgICAgICAgICAgICB3aGlsZSAocFNxbCAmJiB3YXNtLnBlZWsocFNxbCwgJ2k4JykpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2VQdHIoW3BwU3RtdCwgcHpUYWlsXSwgMCk7XG4gICAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICBwU3FsLFxuICAgICAgICAgICAgICAgICAgICBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBwcFN0bXQsXG4gICAgICAgICAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwU3RtdCA9IHdhc20ucGVla1B0cihwcFN0bXQpO1xuICAgICAgICAgICAgICAgIHBTcWwgPSB3YXNtLnBlZWtQdHIocHpUYWlsKTtcbiAgICAgICAgICAgICAgICBzcWxCeXRlTGVuID0gcFNxbEVuZCAtIHBTcWw7XG4gICAgICAgICAgICAgICAgaWYgKCFwU3RtdCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHNhdmVTcWwpIHNhdmVTcWwucHVzaChjYXBpLnNxbGl0ZTNfc3FsKHBTdG10KS50cmltKCkpO1xuICAgICAgICAgICAgICAgIHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZCAmJiBzdG10LnBhcmFtZXRlckNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgICAgICAgICAgICBiaW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2YWxGaXJzdFJlc3VsdCAmJiBzdG10LmNvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ290Q29sTmFtZXMgPSBBcnJheS5pc0FycmF5KG9wdC5jb2x1bW5OYW1lcykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgIGV2YWxGaXJzdFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFyZy5jYkFyZyB8fCByZXN1bHRSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBzdG10LnN0ZXAoKTsgc3RtdC5fbG9ja2VkQnlFeGVjID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gZ290Q29sTmFtZXMrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0bXQuZ2V0Q29sdW1uTmFtZXMob3B0LmNvbHVtbk5hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdG10Ll9sb2NrZWRCeUV4ZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGFyZy5jYkFyZyhzdG10KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Um93cykgcmVzdWx0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGZhbHNlID09PSBjYWxsYmFjay5jYWxsKG9wdCwgcm93LCBzdG10KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0bXQuX2xvY2tlZEJ5RXhlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGdvdENvbE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0bXQuZ2V0Q29sdW1uTmFtZXMob3B0LmNvbHVtbk5hbWVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RtdC5zdGVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0bXQucmVzZXQoKS5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHN0bXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHN0YWNrKTtcbiAgICAgICAgICAgICAgaWYgKHN0bXQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RtdC5fbG9ja2VkQnlFeGVjO1xuICAgICAgICAgICAgICAgIHN0bXQuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZy5yZXR1cm5WYWwoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY3JlYXRlRnVuY3Rpb246IGZ1bmN0aW9uIGYobmFtZSwgeEZ1bmMsIG9wdCkge1xuICAgICAgICAgICAgY29uc3QgaXNGdW5jID0gKGYpID0+IGYgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3B0ID0gbmFtZTtcbiAgICAgICAgICAgICAgICBuYW1lID0gb3B0Lm5hbWU7XG4gICAgICAgICAgICAgICAgeEZ1bmMgPSBvcHQueEZ1bmMgfHwgMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jKHhGdW5jKSkge1xuICAgICAgICAgICAgICAgICAgb3B0ID0geEZ1bmM7XG4gICAgICAgICAgICAgICAgICB4RnVuYyA9IG9wdC54RnVuYyB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHQpIG9wdCA9IHt9O1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgbmFtZSkge1xuICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCBhcmd1bWVudHM6IG1pc3NpbmcgZnVuY3Rpb24gbmFtZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB4U3RlcCA9IG9wdC54U3RlcCB8fCAwO1xuICAgICAgICAgICAgbGV0IHhGaW5hbCA9IG9wdC54RmluYWwgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHhWYWx1ZSA9IG9wdC54VmFsdWUgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHhJbnZlcnNlID0gb3B0LnhJbnZlcnNlIHx8IDA7XG4gICAgICAgICAgICBsZXQgaXNXaW5kb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXNGdW5jKHhGdW5jKSkge1xuICAgICAgICAgICAgICBpc1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jKHhTdGVwKSB8fCBpc0Z1bmMoeEZpbmFsKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKCdBbWJpZ3VvdXMgYXJndW1lbnRzOiBzY2FsYXIgb3IgYWdncmVnYXRlPycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHhTdGVwID0geEZpbmFsID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jKHhTdGVwKSkge1xuICAgICAgICAgICAgICBpZiAoIWlzRnVuYyh4RmluYWwpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgeEZpbmFsKCkgY2FsbGJhY2sgZm9yIGFnZ3JlZ2F0ZSBvciB3aW5kb3cgVURGLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHhGdW5jID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jKHhGaW5hbCkpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgeFN0ZXAoKSBjYWxsYmFjayBmb3IgYWdncmVnYXRlIG9yIHdpbmRvdyBVREYuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b3NzMygnTWlzc2luZyBmdW5jdGlvbi10eXBlIHByb3BlcnRpZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmFsc2UgPT09IGlzV2luZG93KSB7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmMoeFZhbHVlKSB8fCBpc0Z1bmMoeEludmVyc2UpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAneFZhbHVlIGFuZCB4SW52ZXJzZSBhcmUgbm90IHBlcm1pdHRlZCBmb3Igbm9uLXdpbmRvdyBVREZzLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeFZhbHVlKSkge1xuICAgICAgICAgICAgICBpZiAoIWlzRnVuYyh4SW52ZXJzZSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzMygneEludmVyc2UgbXVzdCBiZSBwcm92aWRlZCBpZiB4VmFsdWUgaXMuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXNXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeEludmVyc2UpKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCd4VmFsdWUgbXVzdCBiZSBwcm92aWRlZCBpZiB4SW52ZXJzZSBpcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBBcHAgPSBvcHQucEFwcDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdW5kZWZpbmVkICE9PSBwQXBwICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHBBcHAgJiZcbiAgICAgICAgICAgICAgKCdudW1iZXInICE9PSB0eXBlb2YgcEFwcCB8fCAhdXRpbC5pc0ludDMyKHBBcHApKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIHZhbHVlIGZvciBwQXBwIHByb3BlcnR5LiBNdXN0IGJlIGEgbGVnYWwgV0FTTSBwb2ludGVyIHZhbHVlLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB4RGVzdHJveSA9IG9wdC54RGVzdHJveSB8fCAwO1xuICAgICAgICAgICAgaWYgKHhEZXN0cm95ICYmICFpc0Z1bmMoeERlc3Ryb3kpKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCd4RGVzdHJveSBwcm9wZXJ0eSBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZkZsYWdzID0gMDtcbiAgICAgICAgICAgIGlmIChnZXRPd25PcHRpb24ob3B0LCAnZGV0ZXJtaW5pc3RpYycpKVxuICAgICAgICAgICAgICBmRmxhZ3MgfD0gY2FwaS5TUUxJVEVfREVURVJNSU5JU1RJQztcbiAgICAgICAgICAgIGlmIChnZXRPd25PcHRpb24ob3B0LCAnZGlyZWN0T25seScpKVxuICAgICAgICAgICAgICBmRmxhZ3MgfD0gY2FwaS5TUUxJVEVfRElSRUNUT05MWTtcbiAgICAgICAgICAgIGlmIChnZXRPd25PcHRpb24ob3B0LCAnaW5ub2N1b3VzJykpIGZGbGFncyB8PSBjYXBpLlNRTElURV9JTk5PQ1VPVVM7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgeEFyaXR5ID0geEZ1bmMgfHwgeFN0ZXA7XG4gICAgICAgICAgICBjb25zdCBhcml0eSA9IGdldE93bk9wdGlvbihvcHQsICdhcml0eScpO1xuICAgICAgICAgICAgY29uc3QgYXJpdHlBcmcgPVxuICAgICAgICAgICAgICAnbnVtYmVyJyA9PT0gdHlwZW9mIGFyaXR5XG4gICAgICAgICAgICAgICAgPyBhcml0eVxuICAgICAgICAgICAgICAgIDogeEFyaXR5Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyB4QXJpdHkubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgaWYgKGlzV2luZG93KSB7XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXJpdHlBcmcsXG4gICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfVVRGOCB8IGZGbGFncyxcbiAgICAgICAgICAgICAgICBwQXBwIHx8IDAsXG4gICAgICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgICAgICB4SW52ZXJzZSxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MihcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhcml0eUFyZyxcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9VVEY4IHwgZkZsYWdzLFxuICAgICAgICAgICAgICAgIHBBcHAgfHwgMCxcbiAgICAgICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEQi5jaGVja1JjKHRoaXMsIHJjKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzZWxlY3RWYWx1ZTogZnVuY3Rpb24gKHNxbCwgYmluZCwgYXNUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIDAsIGFzVHlwZSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdFZhbHVlczogZnVuY3Rpb24gKHNxbCwgYmluZCwgYXNUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBzdG10ID0gdGhpcy5wcmVwYXJlKHNxbCksXG4gICAgICAgICAgICAgIHJjID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdG10LnN0ZXAoKSkgcmMucHVzaChzdG10LmdldCgwLCBhc1R5cGUpKTtcbiAgICAgICAgICAgICAgc3RtdC5yZXNldCgpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzZWxlY3RBcnJheTogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0Rmlyc3RSb3codGhpcywgc3FsLCBiaW5kLCBbXSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdE9iamVjdDogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0Rmlyc3RSb3codGhpcywgc3FsLCBiaW5kLCB7fSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdEFycmF5czogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0QWxsKHRoaXMsIHNxbCwgYmluZCwgJ2FycmF5Jyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdE9iamVjdHM6IGZ1bmN0aW9uIChzcWwsIGJpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NlbGVjdEFsbCh0aGlzLCBzcWwsIGJpbmQsICdvYmplY3QnKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgb3BlblN0YXRlbWVudENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVyID8gT2JqZWN0LmtleXMoX19zdG10TWFwLmdldCh0aGlzKSkubGVuZ3RoIDogMDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgbGV0IG9wZW5lciA9ICdCRUdJTic7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgaWYgKC9bXmEtekEtWl0vLnRlc3QoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgZm9yIEJFR0lOIHF1YWxpZmllci4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3BlbmVyICs9ICcgJyArIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcykuZXhlYyhvcGVuZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgICAgdGhpcy5leGVjKCdDT01NSVQnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLmV4ZWMoJ1JPTExCQUNLJyk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNhdmVwb2ludDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcykuZXhlYygnU0FWRVBPSU5UIG9vMScpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgICAgdGhpcy5leGVjKCdSRUxFQVNFIG9vMScpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhlYygnUk9MTEJBQ0sgdG8gU0FWRVBPSU5UIG9vMTsgUkVMRUFTRSBTQVZFUE9JTlQgb28xJyk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNoZWNrUmM6IGZ1bmN0aW9uIChyZXN1bHRDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tTcWxpdGUzUmModGhpcywgcmVzdWx0Q29kZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1TdG10T3BlbiA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgICAgaWYgKCFzdG10LnBvaW50ZXIpIHRvc3MzKCdTdG10IGhhcyBiZWVuIGNsb3NlZC4nKTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpc1N1cHBvcnRlZEJpbmRUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBsZXQgdCA9IEJpbmRUeXBlc1tudWxsID09PSB2IHx8IHVuZGVmaW5lZCA9PT0gdiA/ICdudWxsJyA6IHR5cGVvZiB2XTtcbiAgICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udWxsOlxuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVtYmVyOlxuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJpZ2ludDpcbiAgICAgICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkgcmV0dXJuIHQ7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHYpID8gQmluZFR5cGVzLmJsb2IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTdXBwb3J0ZWRCaW5kVHlwZSh2KSB8fFxuICAgICAgICAgICAgdG9zczMoJ1Vuc3VwcG9ydGVkIGJpbmQoKSBhcmd1bWVudCB0eXBlOicsIHR5cGVvZiB2KVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtUGFyYW1JbmRleCA9IGZ1bmN0aW9uIChzdG10LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCBuID1cbiAgICAgICAgICAgICdudW1iZXInID09PSB0eXBlb2Yga2V5XG4gICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4KHN0bXQucG9pbnRlciwga2V5KTtcbiAgICAgICAgICBpZiAoMCA9PT0gbiB8fCAhdXRpbC5pc0ludDMyKG4pKSB7XG4gICAgICAgICAgICB0b3NzMygnSW52YWxpZCBiaW5kKCkgcGFyYW1ldGVyIG5hbWU6ICcgKyBrZXkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA8IDEgfHwgbiA+IHN0bXQucGFyYW1ldGVyQ291bnQpXG4gICAgICAgICAgICB0b3NzMygnQmluZCBpbmRleCcsIGtleSwgJ2lzIG91dCBvZiByYW5nZS4nKTtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMgPSBmdW5jdGlvbiAoc3RtdCwgY3VycmVudE9wTmFtZSkge1xuICAgICAgICAgIGlmIChzdG10Ll9sb2NrZWRCeUV4ZWMpIHtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAnT3BlcmF0aW9uIGlzIGlsbGVnYWwgd2hlbiBzdGF0ZW1lbnQgaXMgbG9ja2VkOicsXG4gICAgICAgICAgICAgIGN1cnJlbnRPcE5hbWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaW5kT25lID0gZnVuY3Rpb24gZihzdG10LCBuZHgsIGJpbmRUeXBlLCB2YWwpIHtcbiAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMoYWZmaXJtU3RtdE9wZW4oc3RtdCksICdiaW5kKCknKTtcbiAgICAgICAgICBpZiAoIWYuXykge1xuICAgICAgICAgICAgZi5fdG9vQmlnSW50ID0gKHYpID0+XG4gICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICdCaWdJbnQgdmFsdWUgaXMgdG9vIGJpZyB0byBzdG9yZSB3aXRob3V0IHByZWNpc2lvbiBsb3NzOicsXG4gICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGYuXyA9IHtcbiAgICAgICAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoc3RtdCwgbmR4LCB2YWwsIGFzQmxvYikge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwU3RyLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IGFzQmxvYlxuICAgICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iXG4gICAgICAgICAgICAgICAgICA6IGNhcGkuc3FsaXRlM19iaW5kX3RleHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoc3RtdC5wb2ludGVyLCBuZHgsIHBTdHIsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZSh2YWwpO1xuICAgICAgICAgIG5keCA9IGFmZmlybVBhcmFtSW5kZXgoc3RtdCwgbmR4KTtcbiAgICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICBudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwgPyBCaW5kVHlwZXMubnVsbCA6IGJpbmRUeXBlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udWxsOlxuICAgICAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX251bGwoc3RtdC5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLnN0cmluZzpcbiAgICAgICAgICAgICAgcmMgPSBmLl8uc3RyaW5nKHN0bXQsIG5keCwgdmFsLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVtYmVyOiB7XG4gICAgICAgICAgICAgIGxldCBtO1xuICAgICAgICAgICAgICBpZiAodXRpbC5pc0ludDMyKHZhbCkpIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQ7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCdiaWdpbnQnID09PSB0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmJpZ0ludEZpdHM2NCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBmLl90b29CaWdJbnQodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2ludDY0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5iaWdJbnRGaXRzRG91YmxlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2RvdWJsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZi5fdG9vQmlnSW50KHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICAgICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50NjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9kb3VibGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJjID0gbShzdG10LnBvaW50ZXIsIG5keCwgdmFsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5ib29sZWFuOlxuICAgICAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX2ludChzdG10LnBvaW50ZXIsIG5keCwgdmFsID8gMSA6IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJsb2I6IHtcbiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmMgPSBmLl8uc3RyaW5nKHN0bXQsIG5keCwgdmFsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBVaW50OEFycmF5KHZhbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgJ0JpbmRpbmcgYSB2YWx1ZSBhcyBhIGJsb2IgcmVxdWlyZXMnLFxuICAgICAgICAgICAgICAgICAgJ3RoYXQgaXQgYmUgYSBzdHJpbmcsIFVpbnQ4QXJyYXksIEludDhBcnJheSwgb3IgQXJyYXlCdWZmZXIuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHBCbG9iID0gd2FzbS5hbGxvYyh2YWwuYnl0ZUxlbmd0aCB8fCAxKTtcbiAgICAgICAgICAgICAgd2FzbS5oZWFwOCgpLnNldCh2YWwuYnl0ZUxlbmd0aCA/IHZhbCA6IFswXSwgcEJsb2IpO1xuICAgICAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX2Jsb2IoXG4gICAgICAgICAgICAgICAgc3RtdC5wb2ludGVyLFxuICAgICAgICAgICAgICAgIG5keCxcbiAgICAgICAgICAgICAgICBwQmxvYixcbiAgICAgICAgICAgICAgICB2YWwuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybignVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6JywgdmFsKTtcbiAgICAgICAgICAgICAgdG9zczMoJ1Vuc3VwcG9ydGVkIGJpbmQoKSBhcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyYykgREIuY2hlY2tSYyhzdG10LmRiLnBvaW50ZXIsIHJjKTtcbiAgICAgICAgICBzdG10Ll9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfTtcblxuICAgICAgICBTdG10LnByb3RvdHlwZSA9IHtcbiAgICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlcikge1xuICAgICAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWModGhpcywgJ2ZpbmFsaXplKCknKTtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfZmluYWxpemUodGhpcy5wb2ludGVyKTtcbiAgICAgICAgICAgICAgZGVsZXRlIF9fc3RtdE1hcC5nZXQodGhpcy5kYilbdGhpcy5wb2ludGVyXTtcbiAgICAgICAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbWF5R2V0O1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJhbWV0ZXJDb3VudDtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvY2tlZEJ5RXhlYztcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGI7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2xlYXJCaW5kaW5nczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKGFmZmlybVN0bXRPcGVuKHRoaXMpLCAnY2xlYXJCaW5kaW5ncygpJyk7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY2xlYXJfYmluZGluZ3ModGhpcy5wb2ludGVyKTtcbiAgICAgICAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoYWxzb0NsZWFyQmluZHMpIHtcbiAgICAgICAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyh0aGlzLCAncmVzZXQoKScpO1xuICAgICAgICAgICAgaWYgKGFsc29DbGVhckJpbmRzKSB0aGlzLmNsZWFyQmluZGluZ3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX3Jlc2V0KGFmZmlybVN0bXRPcGVuKHRoaXMpLnBvaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBjaGVja1NxbGl0ZTNSYyh0aGlzLmRiLCByYyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWZmaXJtU3RtdE9wZW4odGhpcyk7XG4gICAgICAgICAgICBsZXQgbmR4LCBhcmc7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5keCA9IDE7XG4gICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbmR4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCBiaW5kKCkgYXJndW1lbnRzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wYXJhbWV0ZXJDb3VudCkge1xuICAgICAgICAgICAgICB0b3NzMygnVGhpcyBzdGF0ZW1lbnQgaGFzIG5vIGJpbmRhYmxlIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBCaW5kVHlwZXMubnVsbCwgYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAnV2hlbiBiaW5kaW5nIGFuIGFycmF5LCBhbiBpbmRleCBhcmd1bWVudCBpcyBub3QgcGVybWl0dGVkLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmcuZm9yRWFjaCgodiwgaSkgPT5cbiAgICAgICAgICAgICAgICBiaW5kT25lKHRoaXMsIGkgKyAxLCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZSh2KSwgdiksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICBhcmcgPSBuZXcgVWludDhBcnJheShhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgYXJnICYmICF1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICdXaGVuIGJpbmRpbmcgYW4gb2JqZWN0LCBhbiBpbmRleCBhcmd1bWVudCBpcyBub3QgcGVybWl0dGVkLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goKGspID0+XG4gICAgICAgICAgICAgICAgYmluZE9uZSh0aGlzLCBrLCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmdba10pLCBhcmdba10pLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBiaW5kT25lKHRoaXMsIG5keCwgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUoYXJnKSwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvc3MzKCdTaG91bGQgbm90IHJlYWNoIHRoaXMgcG9pbnQuJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGJpbmRBc0Jsb2I6IGZ1bmN0aW9uIChuZHgsIGFyZykge1xuICAgICAgICAgICAgYWZmaXJtU3RtdE9wZW4odGhpcyk7XG4gICAgICAgICAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmcgPSBuZHg7XG4gICAgICAgICAgICAgIG5keCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ID0gYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUoYXJnKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgQmluZFR5cGVzLnN0cmluZyAhPT0gdCAmJlxuICAgICAgICAgICAgICBCaW5kVHlwZXMuYmxvYiAhPT0gdCAmJlxuICAgICAgICAgICAgICBCaW5kVHlwZXMubnVsbCAhPT0gdFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIHZhbHVlIHR5cGUgZm9yIGJpbmRBc0Jsb2IoKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBCaW5kVHlwZXMuYmxvYiwgYXJnKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3RlcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKHRoaXMsICdzdGVwKCknKTtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX3N0ZXAoYWZmaXJtU3RtdE9wZW4odGhpcykucG9pbnRlcik7XG4gICAgICAgICAgICBzd2l0Y2ggKHJjKSB7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRE9ORTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX21heUdldCA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9ST1c6XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9tYXlHZXQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc3RlcCgpIHJjPScsXG4gICAgICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICAgICAgJ1NRTCA9JyxcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19zcWwodGhpcy5wb2ludGVyKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIERCLmNoZWNrUmModGhpcy5kYi5wb2ludGVyLCByYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHN0ZXBSZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdGVwRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKG5keCwgYXNUeXBlKSB7XG4gICAgICAgICAgICBpZiAoIWFmZmlybVN0bXRPcGVuKHRoaXMpLl9tYXlHZXQpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ1N0bXQuc3RlcCgpIGhhcyBub3QgKHJlY2VudGx5KSByZXR1cm5lZCB0cnVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmR4KSkge1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBuZHhbaV0gPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZHg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5keCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG5keCkge1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBuZHhbY2FwaS5zcWxpdGUzX2NvbHVtbl9uYW1lKHRoaXMucG9pbnRlciwgaSldID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWZmaXJtQ29sSW5kZXgodGhpcywgbmR4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gYXNUeXBlXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY29sdW1uX3R5cGUodGhpcy5wb2ludGVyLCBuZHgpXG4gICAgICAgICAgICAgICAgOiBhc1R5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX05VTEw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfSU5URUdFUjoge1xuICAgICAgICAgICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9pbnQ2NCh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHJjID49IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSICYmXG4gICAgICAgICAgICAgICAgICAgIHJjIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihyYykudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19jb2x1bW5fZG91YmxlKHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcmMgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAgICAgICAgICAgICAgICAgICByYyA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICAgJ0ludGVnZXIgaXMgb3V0IG9mIHJhbmdlIGZvciBKUyBpbnRlZ2VyIHJhbmdlOiAnICsgcmMsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmlzSW50MzIocmMpID8gcmMgfCAwIDogcmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRkxPQVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fZG91YmxlKHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9URVhUOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX3RleHQodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0JMT0I6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9ieXRlcyh0aGlzLnBvaW50ZXIsIG5keCksXG4gICAgICAgICAgICAgICAgICBwdHIgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2Jsb2IodGhpcy5wb2ludGVyLCBuZHgpLFxuICAgICAgICAgICAgICAgICAgcmMgPSBuZXcgVWludDhBcnJheShuKTtcblxuICAgICAgICAgICAgICAgIGlmIChuKSByYy5zZXQod2FzbS5oZWFwOHUoKS5zbGljZShwdHIsIHB0ciArIG4pLCAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuICYmIHRoaXMuZGIuX2Jsb2JYZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGIuX2Jsb2JYZmVyLnB1c2gocmMuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICBcIkRvbid0IGtub3cgaG93IHRvIHRyYW5zbGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUgb2YgcmVzdWx0IGNvbHVtbiAjJyArIG5keCArICcuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9zczMoJ05vdCByZWFjaGVkLicpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRJbnQ6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZHgsIGNhcGkuU1FMSVRFX0lOVEVHRVIpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRGbG9hdDogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfRkxPQVQpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRTdHJpbmc6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZHgsIGNhcGkuU1FMSVRFX1RFWFQpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRCbG9iOiBmdW5jdGlvbiAobmR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobmR4LCBjYXBpLlNRTElURV9CTE9CKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0SlNPTjogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfU1RSSU5HKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09PSBzID8gcyA6IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldENvbHVtbk5hbWU6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUoXG4gICAgICAgICAgICAgIGFmZmlybUNvbEluZGV4KGFmZmlybVN0bXRPcGVuKHRoaXMpLCBuZHgpLnBvaW50ZXIsXG4gICAgICAgICAgICAgIG5keCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldENvbHVtbk5hbWVzOiBmdW5jdGlvbiAodGd0ID0gW10pIHtcbiAgICAgICAgICAgIGFmZmlybUNvbEluZGV4KGFmZmlybVN0bXRPcGVuKHRoaXMpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgdGd0LnB1c2goY2FwaS5zcWxpdGUzX2NvbHVtbl9uYW1lKHRoaXMucG9pbnRlciwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRndDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0UGFyYW1JbmRleDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1TdG10T3Blbih0aGlzKS5wYXJhbWV0ZXJDb3VudFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCh0aGlzLnBvaW50ZXIsIG5hbWUpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHByb3AgPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX3B0ck1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiAoKSA9PiB0b3NzMygnVGhlIHBvaW50ZXIgcHJvcGVydHkgaXMgcmVhZC1vbmx5LicpLFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0bXQucHJvdG90eXBlLCAncG9pbnRlcicsIHByb3ApO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEQi5wcm90b3R5cGUsICdwb2ludGVyJywgcHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RtdC5wcm90b3R5cGUsICdjb2x1bW5Db3VudCcsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX2NvdW50KHRoaXMucG9pbnRlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MzKCdUaGUgY29sdW1uQ291bnQgcHJvcGVydHkgaXMgcmVhZC1vbmx5LicpLFxuICAgICAgICB9KTtcblxuICAgICAgICBzcWxpdGUzLm9vMSA9IHtcbiAgICAgICAgICBEQixcbiAgICAgICAgICBTdG10LFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1dGlsLmlzVUlUaHJlYWQoKSkge1xuICAgICAgICAgIHNxbGl0ZTMub28xLkpzU3RvcmFnZURiID0gZnVuY3Rpb24gKHN0b3JhZ2VOYW1lID0gJ3Nlc3Npb24nKSB7XG4gICAgICAgICAgICBpZiAoJ3Nlc3Npb24nICE9PSBzdG9yYWdlTmFtZSAmJiAnbG9jYWwnICE9PSBzdG9yYWdlTmFtZSkge1xuICAgICAgICAgICAgICB0b3NzMyhcIkpzU3RvcmFnZURiIGRiIG5hbWUgbXVzdCBiZSBvbmUgb2YgJ3Nlc3Npb24nIG9yICdsb2NhbCcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGJDdG9ySGVscGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICBmaWxlbmFtZTogc3RvcmFnZU5hbWUsXG4gICAgICAgICAgICAgIGZsYWdzOiAnYycsXG4gICAgICAgICAgICAgIHZmczogJ2t2dmZzJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgamRiID0gc3FsaXRlMy5vbzEuSnNTdG9yYWdlRGI7XG4gICAgICAgICAgamRiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoREIucHJvdG90eXBlKTtcblxuICAgICAgICAgIGpkYi5jbGVhclN0b3JhZ2UgPSBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfY2xlYXI7XG5cbiAgICAgICAgICBqZGIucHJvdG90eXBlLmNsZWFyU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqZGIuY2xlYXJTdG9yYWdlKGFmZmlybURiT3Blbih0aGlzKS5maWxlbmFtZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGpkYi5zdG9yYWdlU2l6ZSA9IGNhcGkuc3FsaXRlM19qc19rdnZmc19zaXplO1xuXG4gICAgICAgICAgamRiLnByb3RvdHlwZS5zdG9yYWdlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqZGIuc3RvcmFnZVNpemUoYWZmaXJtRGJPcGVuKHRoaXMpLmZpbGVuYW1lKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChzcWxpdGUzKSB7XG4gICAgICAgIHNxbGl0ZTMuaW5pdFdvcmtlcjFBUEkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghKGdsb2JhbFRoaXMuV29ya2VyR2xvYmFsU2NvcGUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRvc3MoJ2luaXRXb3JrZXIxQVBJKCkgbXVzdCBiZSBydW4gZnJvbSBhIFdvcmtlciB0aHJlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNxbGl0ZTMgPSB0aGlzLnNxbGl0ZTMgfHwgdG9zcygnTWlzc2luZyB0aGlzLnNxbGl0ZTMgb2JqZWN0LicpO1xuICAgICAgICAgIGNvbnN0IERCID0gc3FsaXRlMy5vbzEuREI7XG5cbiAgICAgICAgICBjb25zdCBnZXREYklkID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSB3U3RhdGUuaWRNYXAuZ2V0KGRiKTtcbiAgICAgICAgICAgIGlmIChpZCkgcmV0dXJuIGlkO1xuICAgICAgICAgICAgaWQgPSAnZGIjJyArICsrd1N0YXRlLmlkU2VxICsgJ0AnICsgZGIucG9pbnRlcjtcblxuICAgICAgICAgICAgd1N0YXRlLmlkTWFwLnNldChkYiwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCB3U3RhdGUgPSB7XG4gICAgICAgICAgICBkYkxpc3Q6IFtdLFxuXG4gICAgICAgICAgICBpZFNlcTogMCxcblxuICAgICAgICAgICAgaWRNYXA6IG5ldyBXZWFrTWFwKCksXG5cbiAgICAgICAgICAgIHhmZXI6IFtdLFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IG5ldyBEQihvcHQpO1xuICAgICAgICAgICAgICB0aGlzLmRic1tnZXREYklkKGRiKV0gPSBkYjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpIDwgMCkgdGhpcy5kYkxpc3QucHVzaChkYik7XG4gICAgICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKGRiLCBhbHNvVW5saW5rKSB7XG4gICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRic1tnZXREYklkKGRiKV07XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwVmZzID0gc3FsaXRlMy53YXNtLnNxbGl0ZTNfd2FzbV9kYl92ZnMoZGIucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZE5keCA9IHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpO1xuICAgICAgICAgICAgICAgIGlmIChkZE5keCA+PSAwKSB0aGlzLmRiTGlzdC5zcGxpY2UoZGROZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhbHNvVW5saW5rICYmIGZpbGVuYW1lICYmIHBWZnMpIHtcbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMud2FzbS5zcWxpdGUzX3dhc21fdmZzX3VubGluayhwVmZzLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAobXNnLCB4ZmVyTGlzdCkge1xuICAgICAgICAgICAgICBpZiAoeGZlckxpc3QgJiYgeGZlckxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZShtc2csIEFycmF5LmZyb20oeGZlckxpc3QpKTtcbiAgICAgICAgICAgICAgICB4ZmVyTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAgICAgICBnZXREYjogZnVuY3Rpb24gKGlkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuZGJzW2lkXSB8fFxuICAgICAgICAgICAgICAgIChyZXF1aXJlID8gdG9zcygnVW5rbm93biAob3IgY2xvc2VkKSBEQiBJRDonLCBpZCkgOiB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBhZmZpcm1EYk9wZW4gPSBmdW5jdGlvbiAoZGIgPSB3U3RhdGUuZGJMaXN0WzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIgJiYgZGIucG9pbnRlciA/IGRiIDogdG9zcygnREIgaXMgbm90IG9wZW5lZC4nKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZ2V0TXNnRGIgPSBmdW5jdGlvbiAobXNnRGF0YSwgYWZmaXJtRXhpc3RzID0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgZGIgPSB3U3RhdGUuZ2V0RGIobXNnRGF0YS5kYklkLCBmYWxzZSkgfHwgd1N0YXRlLmRiTGlzdFswXTtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1FeGlzdHMgPyBhZmZpcm1EYk9wZW4oZGIpIDogZGI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGdldERlZmF1bHREYklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdTdGF0ZS5kYkxpc3RbMF0gJiYgZ2V0RGJJZCh3U3RhdGUuZGJMaXN0WzBdKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZ3Vlc3NWZnMgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAvXmZpbGU6LisodmZzPShcXHcrKSkvLmV4ZWMoZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX3Zmc19maW5kKG0gPyBtWzJdIDogMCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGlzU3BlY2lhbERiRmlsZW5hbWUgPSAobikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICcnID09PSBuIHx8ICc6JyA9PT0gblswXTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3Qgd01zZ0hhbmRsZXIgPSB7XG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2FyZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBldi5hcmdzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGlmIChhcmdzLnNpbXVsYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdUaHJvd2luZyBiZWNhdXNlIG9mIHNpbXVsYXRlRXJyb3IgZmxhZy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGxldCBieXRlQXJyYXksIHBWZnM7XG4gICAgICAgICAgICAgIG9hcmdzLnZmcyA9IGFyZ3MudmZzO1xuICAgICAgICAgICAgICBpZiAoaXNTcGVjaWFsRGJGaWxlbmFtZShhcmdzLmZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9hcmdzLmZpbGVuYW1lID0gYXJncy5maWxlbmFtZSB8fCAnJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYXJncy5maWxlbmFtZSA9IGFyZ3MuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5ID0gYXJncy5ieXRlQXJyYXk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVBcnJheSkgcFZmcyA9IGd1ZXNzVmZzKGFyZ3MuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwVmZzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBNZW07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHBNZW0gPSBzcWxpdGUzLndhc20uYWxsb2NGcm9tVHlwZWRBcnJheShieXRlQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBzcWxpdGUzLndhc20uc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZShcbiAgICAgICAgICAgICAgICAgICAgcFZmcyxcbiAgICAgICAgICAgICAgICAgICAgb2FyZ3MuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBNZW0sXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyYykgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhyYyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNxbGl0ZTMuU1FMaXRlM0Vycm9yKFxuICAgICAgICAgICAgICAgICAgICBlLm5hbWUgKyAnIGNyZWF0aW5nICcgKyBhcmdzLmZpbGVuYW1lICsgJzogJyArIGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBNZW0pIHNxbGl0ZTMud2FzbS5kZWFsbG9jKHBNZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkYiA9IHdTdGF0ZS5vcGVuKG9hcmdzKTtcbiAgICAgICAgICAgICAgcmMuZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgICAgICAgICAgcmMucGVyc2lzdGVudCA9ICEhc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfZGJfdXNlc192ZnMoXG4gICAgICAgICAgICAgICAgZGIucG9pbnRlcixcbiAgICAgICAgICAgICAgICAnb3BmcycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJjLmRiSWQgPSBnZXREYklkKGRiKTtcbiAgICAgICAgICAgICAgcmMudmZzID0gZGIuZGJWZnNOYW1lKCk7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldiwgZmFsc2UpO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZGIgJiYgZGIuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvVW5saW5rID1cbiAgICAgICAgICAgICAgICAgIGV2LmFyZ3MgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICAgID8gISFldi5hcmdzLnVubGlua1xuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdTdGF0ZS5jbG9zZShkYiwgZG9VbmxpbmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCByYyA9XG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICA/IHsgc3FsOiBldi5hcmdzIH1cbiAgICAgICAgICAgICAgICAgIDogZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBpZiAoJ3N0bXQnID09PSByYy5yb3dNb2RlKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCByb3dNb2RlIGZvciAnZXhlYyc6IHN0bXQgbW9kZVwiLFxuICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IHdvcmsgaW4gdGhlIFdvcmtlciBBUEkuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyYy5zcWwpIHtcbiAgICAgICAgICAgICAgICB0b3NzKFwiJ2V4ZWMnIHJlcXVpcmVzIGlucHV0IFNRTC5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldik7XG4gICAgICAgICAgICAgIGlmIChyYy5jYWxsYmFjayB8fCBBcnJheS5pc0FycmF5KHJjLnJlc3VsdFJvd3MpKSB7XG4gICAgICAgICAgICAgICAgZGIuX2Jsb2JYZmVyID0gd1N0YXRlLnhmZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdGhlQ2FsbGJhY2sgPSByYy5jYWxsYmFjaztcbiAgICAgICAgICAgICAgbGV0IHJvd051bWJlciA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGhhZENvbE5hbWVzID0gISFyYy5jb2x1bW5OYW1lcztcbiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhZENvbE5hbWVzKSByYy5jb2x1bW5OYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSBmdW5jdGlvbiAocm93LCBzdG10KSB7XG4gICAgICAgICAgICAgICAgICB3U3RhdGUucG9zdChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoZUNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzOiByYy5jb2x1bW5OYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6ICsrcm93TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3U3RhdGUueGZlcixcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZUNvdW50ID0gISFyYy5jb3VudENoYW5nZXNcbiAgICAgICAgICAgICAgICAgID8gZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKVxuICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGIuZXhlYyhyYyk7XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gY2hhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgIHJjLmNoYW5nZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKSAtIGNoYW5nZUNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSB0aGVDYWxsYmFjaztcblxuICAgICAgICAgICAgICAgICAgd1N0YXRlLnBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGVDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZXM6IHJjLmNvbHVtbk5hbWVzLFxuICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYi5fYmxvYlhmZXI7XG4gICAgICAgICAgICAgICAgaWYgKHJjLmNhbGxiYWNrKSByYy5jYWxsYmFjayA9IHRoZUNhbGxiYWNrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdjb25maWctZ2V0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgc3JjID0gc3FsaXRlMy5jb25maWc7XG4gICAgICAgICAgICAgIFsnYmlnSW50RW5hYmxlZCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGspKSByY1trXSA9IHNyY1trXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJjLnZlcnNpb24gPSBzcWxpdGUzLnZlcnNpb247XG4gICAgICAgICAgICAgIHJjLnZmc0xpc3QgPSBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc192ZnNfbGlzdCgpO1xuICAgICAgICAgICAgICByYy5vcGZzRW5hYmxlZCA9ICEhc3FsaXRlMy5vcGZzO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBleHBvcnQ6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IGdldE1zZ0RiKGV2KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5OiBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19kYl9leHBvcnQoZGIucG9pbnRlciksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGRiLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG1pbWV0eXBlOiAnYXBwbGljYXRpb24veC1zcWxpdGUzJyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgd1N0YXRlLnhmZXIucHVzaChyZXNwb25zZS5ieXRlQXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9zczogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1Rlc3Rpbmcgd29ya2VyIGV4Y2VwdGlvbicpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ29wZnMtdHJlZSc6IGFzeW5jIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBpZiAoIXNxbGl0ZTMub3BmcykgdG9zcygnT1BGUyBzdXBwb3J0IGlzIHVuYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNxbGl0ZTMub3Bmcy50cmVlTGlzdCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGFzeW5jIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgZXYgPSBldi5kYXRhO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCxcbiAgICAgICAgICAgICAgZGJJZCA9IGV2LmRiSWQsXG4gICAgICAgICAgICAgIGV2VHlwZSA9IGV2LnR5cGU7XG4gICAgICAgICAgICBjb25zdCBhcnJpdmFsVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdNc2dIYW5kbGVyLmhhc093blByb3BlcnR5KGV2VHlwZSkgJiZcbiAgICAgICAgICAgICAgICB3TXNnSGFuZGxlcltldlR5cGVdIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgd01zZ0hhbmRsZXJbZXZUeXBlXShldik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9zcygnVW5rbm93biBkYiB3b3JrZXIgbWVzc2FnZSB0eXBlOicsIGV2LnR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgZXZUeXBlID0gJ2Vycm9yJztcbiAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogZXYudHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBlcnJvckNsYXNzOiBlcnIubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogZXYsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhY2sgPVxuICAgICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBlcnIuc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgPyBlcnIuc3RhY2suc3BsaXQoL1xcblxccyovKVxuICAgICAgICAgICAgICAgICAgICA6IGVyci5zdGFjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoMClcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICAgICAgICAgICAgJ1dvcmtlciBpcyBwcm9wYWdhdGluZyBhbiBleGNlcHRpb24gdG8gbWFpbiB0aHJlYWQuJyxcbiAgICAgICAgICAgICAgICAgICdSZXBvcnRpbmcgaXQgX2hlcmVfIGZvciB0aGUgc3RhY2sgdHJhY2U6JyxcbiAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYklkKSB7XG4gICAgICAgICAgICAgIGRiSWQgPSByZXN1bHQuZGJJZCB8fCBnZXREZWZhdWx0RGJJZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3U3RhdGUucG9zdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2VHlwZSxcbiAgICAgICAgICAgICAgICBkYklkOiBkYklkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogZXYubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHdvcmtlclJlY2VpdmVkVGltZTogYXJyaXZhbFRpbWUsXG4gICAgICAgICAgICAgICAgd29ya2VyUmVzcG9uZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgICAgIGRlcGFydHVyZVRpbWU6IGV2LmRlcGFydHVyZVRpbWUsXG5cbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgd1N0YXRlLnhmZXIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnc3FsaXRlMy1hcGknLFxuICAgICAgICAgICAgcmVzdWx0OiAnd29ya2VyMS1yZWFkeScsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh7IHNxbGl0ZTMgfSk7XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgY29uc3Qgd2FzbSA9IHNxbGl0ZTMud2FzbSxcbiAgICAgICAgICBjYXBpID0gc3FsaXRlMy5jYXBpLFxuICAgICAgICAgIHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gICAgICAgIGNvbnN0IHZmcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgdnRhYiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgU3RydWN0QmluZGVyID0gc3FsaXRlMy5TdHJ1Y3RCaW5kZXI7XG4gICAgICAgIHNxbGl0ZTMudmZzID0gdmZzO1xuICAgICAgICBzcWxpdGUzLnZ0YWIgPSB2dGFiO1xuXG4gICAgICAgIGNvbnN0IHNpaSA9IGNhcGkuc3FsaXRlM19pbmRleF9pbmZvO1xuXG4gICAgICAgIHNpaS5wcm90b3R5cGUubnRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChuLCBhc1B0ciA9IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy4kbkNvbnN0cmFpbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwdHIgPVxuICAgICAgICAgICAgdGhpcy4kYUNvbnN0cmFpbnQgK1xuICAgICAgICAgICAgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludC5zdHJ1Y3RJbmZvLnNpemVvZiAqIG47XG4gICAgICAgICAgcmV0dXJuIGFzUHRyID8gcHRyIDogbmV3IHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQocHRyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaWkucHJvdG90eXBlLm50aENvbnN0cmFpbnRVc2FnZSA9IGZ1bmN0aW9uIChuLCBhc1B0ciA9IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy4kbkNvbnN0cmFpbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwdHIgPVxuICAgICAgICAgICAgdGhpcy4kYUNvbnN0cmFpbnRVc2FnZSArXG4gICAgICAgICAgICBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlLnN0cnVjdEluZm8uc2l6ZW9mICogbjtcbiAgICAgICAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZShwdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpaS5wcm90b3R5cGUubnRoT3JkZXJCeSA9IGZ1bmN0aW9uIChuLCBhc1B0ciA9IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy4kbk9yZGVyQnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwdHIgPVxuICAgICAgICAgICAgdGhpcy4kYU9yZGVyQnkgKyBzaWkuc3FsaXRlM19pbmRleF9vcmRlcmJ5LnN0cnVjdEluZm8uc2l6ZW9mICogbjtcbiAgICAgICAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfb3JkZXJieShwdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgICAgICAgdGd0LFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZnVuYyxcbiAgICAgICAgICBhcHBseUFyZ2NDaGVjayA9IGNhbGxlZS5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoISh0Z3QgaW5zdGFuY2VvZiBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZSkpIHtcbiAgICAgICAgICAgIHRvc3MoJ1VzYWdlIGVycm9yOiB0YXJnZXQgb2JqZWN0IGlzLW5vdC1hIFN0cnVjdFR5cGUuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIXdhc20uaXNQdHIoZnVuYykpIHtcbiAgICAgICAgICAgIHRvc3MoJ1VzYWdlIGVycnJvcjogZXhwZWN0aW5nIGEgRnVuY3Rpb24gb3IgV0FTTSBwb2ludGVyIHRvIG9uZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAobiwgZikgPT4gY2FsbGVlKHRndCwgbiwgZiwgYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbGxlZS5hcmdjUHJveHkpIHtcbiAgICAgICAgICAgIGNhbGxlZS5hcmdjUHJveHkgPSBmdW5jdGlvbiAodGd0LCBmdW5jTmFtZSwgZnVuYywgc2lnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jLmxlbmd0aCAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0FyZ3VtZW50IG1pc21hdGNoIGZvcicsXG4gICAgICAgICAgICAgICAgICAgIHRndC5zdHJ1Y3RJbmZvLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICc6OicgK1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAnOiBOYXRpdmUgc2lnbmF0dXJlIGlzOicsXG4gICAgICAgICAgICAgICAgICAgIHNpZyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QuZm9yRWFjaCgodiwgbmR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2FzbS51bmluc3RhbGxGdW5jdGlvbih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2lnTiA9IHRndC5tZW1iZXJTaWduYXR1cmUobmFtZSk7XG4gICAgICAgICAgaWYgKHNpZ04ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ01lbWJlcicsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICdkb2VzIG5vdCBoYXZlIGEgZnVuY3Rpb24gcG9pbnRlciBzaWduYXR1cmU6JyxcbiAgICAgICAgICAgICAgc2lnTixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbUtleSA9IHRndC5tZW1iZXJLZXkobmFtZSk7XG4gICAgICAgICAgY29uc3QgZlByb3h5ID1cbiAgICAgICAgICAgIGFwcGx5QXJnY0NoZWNrICYmICF3YXNtLmlzUHRyKGZ1bmMpXG4gICAgICAgICAgICAgID8gY2FsbGVlLmFyZ2NQcm94eSh0Z3QsIG1lbUtleSwgZnVuYywgc2lnTilcbiAgICAgICAgICAgICAgOiBmdW5jO1xuICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGZQcm94eSkpIHtcbiAgICAgICAgICAgIGlmIChmUHJveHkgJiYgIXdhc20uZnVuY3Rpb25FbnRyeShmUHJveHkpKSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1BvaW50ZXInLCBmUHJveHksICdpcyBub3QgYSBXQVNNIGZ1bmN0aW9uIHRhYmxlIGVudHJ5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGd0W21lbUtleV0gPSBmUHJveHk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBGdW5jID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgICAgIGZQcm94eSxcbiAgICAgICAgICAgICAgdGd0Lm1lbWJlclNpZ25hdHVyZShuYW1lLCB0cnVlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0Z3RbbWVtS2V5XSA9IHBGdW5jO1xuICAgICAgICAgICAgaWYgKCF0Z3Qub25kaXNwb3NlIHx8ICF0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QpIHtcbiAgICAgICAgICAgICAgdGd0LmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgICAgICAnb25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgaGFuZGxlcicsXG4gICAgICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRndC5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdC5wdXNoKG1lbUtleSwgcEZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKG4sIGYpID0+IGNhbGxlZSh0Z3QsIG4sIGYsIGFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgaW5zdGFsbE1ldGhvZHMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgc3RydWN0SW5zdGFuY2UsXG4gICAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgICBhcHBseUFyZ2NDaGVjayA9IGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVjayxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobWV0aG9kcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXRob2RzW2tdO1xuICAgICAgICAgICAgY29uc3QgcHJpb3IgPSBzZWVuLmdldChtKTtcbiAgICAgICAgICAgIGlmIChwcmlvcikge1xuICAgICAgICAgICAgICBjb25zdCBta2V5ID0gc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KGspO1xuICAgICAgICAgICAgICBzdHJ1Y3RJbnN0YW5jZVtta2V5XSA9XG4gICAgICAgICAgICAgICAgc3RydWN0SW5zdGFuY2Vbc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KHByaW9yKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kKHN0cnVjdEluc3RhbmNlLCBrLCBtLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgICAgICAgIHNlZW4uc2V0KG0sIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RydWN0SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBmdW5jLFxuICAgICAgICAgIGFwcGx5QXJnY0NoZWNrID0gaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrLFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgbmFtZSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG5hbWVcbiAgICAgICAgICAgID8gaW5zdGFsbE1ldGhvZHModGhpcywgLi4uYXJndW1lbnRzKVxuICAgICAgICAgICAgOiBpbnN0YWxsTWV0aG9kKHRoaXMsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2RzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIG1ldGhvZHMsXG4gICAgICAgICAgYXBwbHlBcmdjQ2hlY2sgPSBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2ssXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBpbnN0YWxsTWV0aG9kcyh0aGlzLCBtZXRob2RzLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Zmcy5wcm90b3R5cGUucmVnaXN0ZXJWZnMgPSBmdW5jdGlvbiAoYXNEZWZhdWx0ID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2Ygc3FsaXRlMy5jYXBpLnNxbGl0ZTNfdmZzKSkge1xuICAgICAgICAgICAgdG9zcygnRXhwZWN0aW5nIGEgc3FsaXRlM192ZnMtdHlwZSBhcmd1bWVudC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfdmZzX3JlZ2lzdGVyKHRoaXMsIGFzRGVmYXVsdCA/IDEgOiAwKTtcbiAgICAgICAgICBpZiAocmMpIHtcbiAgICAgICAgICAgIHRvc3MoJ3NxbGl0ZTNfdmZzX3JlZ2lzdGVyKCcsIHRoaXMsICcpIGZhaWxlZCB3aXRoIHJjJywgcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5wb2ludGVyICE9PSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodGhpcy4kek5hbWUpKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnQlVHOiBzcWxpdGUzX3Zmc19maW5kKHZmcy4kek5hbWUpIGZhaWxlZCBmb3IganVzdC1pbnN0YWxsZWQgVkZTJyxcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZmcy5pbnN0YWxsVmZzID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgY29uc3QgcHJvcExpc3QgPSBbJ2lvJywgJ3ZmcyddO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHByb3BMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBvID0gb3B0W2tleV07XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kcyhvLnN0cnVjdCwgby5tZXRob2RzLCAhIW8uYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICAgICAgICBpZiAoJ3ZmcycgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghby5zdHJ1Y3QuJHpOYW1lICYmICdzdHJpbmcnID09PSB0eXBlb2Ygby5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBvLnN0cnVjdC5hZGRPbkRpc3Bvc2UoXG4gICAgICAgICAgICAgICAgICAgIChvLnN0cnVjdC4kek5hbWUgPSB3YXNtLmFsbG9jQ1N0cmluZyhvLm5hbWUpKSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG8uc3RydWN0LnJlZ2lzdGVyVmZzKCEhby5hc0RlZmF1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY291bnQpXG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnTWlzdXNlOiBpbnN0YWxsVmZzKCkgb3B0aW9ucyBvYmplY3QgcmVxdWlyZXMgYXQgbGVhc3QnLFxuICAgICAgICAgICAgICAnb25lIG9mOicsXG4gICAgICAgICAgICAgIHByb3BMaXN0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3hXcmFwRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBTdHJ1Y3RUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdHIsIHJlbW92ZU1hcHBpbmcgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHB0ciA9IG5ldyBTdHJ1Y3RUeXBlKCk7XG4gICAgICAgICAgICBpZiAocHRyIGluc3RhbmNlb2YgU3RydWN0VHlwZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldChwdHIucG9pbnRlciwgcHRyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXdhc20uaXNQdHIocHRyKSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHRvJyxcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lICsgJygpJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYyA9IHRoaXMuZ2V0KHB0cik7XG4gICAgICAgICAgICBpZiAocmVtb3ZlTWFwcGluZykgdGhpcy5kZWxldGUocHRyKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9LmJpbmQobmV3IE1hcCgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBTdHJ1Y3RQdHJNYXBwZXIgPSBmdW5jdGlvbiAobmFtZSwgU3RydWN0VHlwZSkge1xuICAgICAgICAgIGNvbnN0IF9feFdyYXAgPSBfX3hXcmFwRmFjdG9yeShuYW1lLCBTdHJ1Y3RUeXBlKTtcblxuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgIFN0cnVjdFR5cGUsXG5cbiAgICAgICAgICAgIGNyZWF0ZTogKHBwT3V0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gX194V3JhcCgpO1xuICAgICAgICAgICAgICB3YXNtLnBva2VQdHIocHBPdXQsIHJjLnBvaW50ZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQ6IChwQ09iaikgPT4gX194V3JhcChwQ09iaiksXG5cbiAgICAgICAgICAgIHVuZ2V0OiAocENPYmopID0+IF9feFdyYXAocENPYmosIHRydWUpLFxuXG4gICAgICAgICAgICBkaXNwb3NlOiAocENPYmopID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IF9feFdyYXAocENPYmosIHRydWUpO1xuICAgICAgICAgICAgICBpZiAobykgby5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZ0YWIueFZ0YWIgPSBTdHJ1Y3RQdHJNYXBwZXIoJ3hWdGFiJywgY2FwaS5zcWxpdGUzX3Z0YWIpO1xuXG4gICAgICAgIHZ0YWIueEN1cnNvciA9IFN0cnVjdFB0ck1hcHBlcigneEN1cnNvcicsIGNhcGkuc3FsaXRlM192dGFiX2N1cnNvcik7XG5cbiAgICAgICAgdnRhYi54SW5kZXhJbmZvID0gKHBJZHhJbmZvKSA9PiBuZXcgY2FwaS5zcWxpdGUzX2luZGV4X2luZm8ocElkeEluZm8pO1xuXG4gICAgICAgIHZ0YWIueEVycm9yID0gZnVuY3Rpb24gZihtZXRob2ROYW1lLCBlcnIsIGRlZmF1bHRSYykge1xuICAgICAgICAgIGlmIChmLmVycm9yUmVwb3J0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZi5lcnJvclJlcG9ydGVyKFxuICAgICAgICAgICAgICAgICdzcWxpdGUzX21vZHVsZTo6JyArIG1ldGhvZE5hbWUgKyAnKCk6ICcgKyBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByYztcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikgcmMgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgcmMgPSBkZWZhdWx0UmM7XG4gICAgICAgICAgZWxzZSBpZiAoZXJyIGluc3RhbmNlb2Ygc3FsaXRlMy5TUUxpdGUzRXJyb3IpIHJjID0gZXJyLnJlc3VsdENvZGU7XG4gICAgICAgICAgcmV0dXJuIHJjIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICB9O1xuICAgICAgICB2dGFiLnhFcnJvci5lcnJvclJlcG9ydGVyID0gMSA/IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSA6IGZhbHNlO1xuXG4gICAgICAgIHZ0YWIueFJvd2lkID0gKHBwUm93aWQ2NCwgdmFsdWUpID0+IHdhc20ucG9rZShwcFJvd2lkNjQsIHZhbHVlLCAnaTY0Jyk7XG5cbiAgICAgICAgdnRhYi5zZXR1cE1vZHVsZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICBsZXQgY3JlYXRlZE1vZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IG1vZCA9XG4gICAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgY2FwaS5zcWxpdGUzX21vZHVsZVxuICAgICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgICAgOiBvcHQuc3RydWN0IHx8IChjcmVhdGVkTW9kID0gbmV3IGNhcGkuc3FsaXRlM19tb2R1bGUoKSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHMgPSBvcHQubWV0aG9kcyB8fCB0b3NzKFwiTWlzc2luZyAnbWV0aG9kcycgb2JqZWN0LlwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh7XG4gICAgICAgICAgICAgIHhDb25uZWN0OiAneENyZWF0ZScsXG4gICAgICAgICAgICAgIHhEaXNjb25uZWN0OiAneERlc3Ryb3knLFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgayA9IGVbMF0sXG4gICAgICAgICAgICAgICAgdiA9IGVbMV07XG4gICAgICAgICAgICAgIGlmICh0cnVlID09PSBtZXRob2RzW2tdKSBtZXRob2RzW2tdID0gbWV0aG9kc1t2XTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAodHJ1ZSA9PT0gbWV0aG9kc1t2XSkgbWV0aG9kc1t2XSA9IG1ldGhvZHNba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmNhdGNoRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICBjb25zdCBmd3JhcCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBmdW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKFsneENvbm5lY3QnLCAneENyZWF0ZSddLmluZGV4T2YobWV0aG9kTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwRGIsIHBBdXgsIGFyZ2MsIGFyZ3YsIHBwVnRhYiwgcHpFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYyguLi5hcmd1bWVudHMpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc20uZGVhbGxvYyh3YXNtLnBlZWtQdHIocHpFcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc20ucG9rZVB0cihwekVyciwgd2FzbS5hbGxvY0NTdHJpbmcoZS5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2dGFiLnhFcnJvcihtZXRob2ROYW1lLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoLi4uYXJncykgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2dGFiLnhFcnJvcihtZXRob2ROYW1lLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNvbnN0IG1uYW1lcyA9IFtcbiAgICAgICAgICAgICAgICAneENyZWF0ZScsXG4gICAgICAgICAgICAgICAgJ3hDb25uZWN0JyxcbiAgICAgICAgICAgICAgICAneEJlc3RJbmRleCcsXG4gICAgICAgICAgICAgICAgJ3hEaXNjb25uZWN0JyxcbiAgICAgICAgICAgICAgICAneERlc3Ryb3knLFxuICAgICAgICAgICAgICAgICd4T3BlbicsXG4gICAgICAgICAgICAgICAgJ3hDbG9zZScsXG4gICAgICAgICAgICAgICAgJ3hGaWx0ZXInLFxuICAgICAgICAgICAgICAgICd4TmV4dCcsXG4gICAgICAgICAgICAgICAgJ3hFb2YnLFxuICAgICAgICAgICAgICAgICd4Q29sdW1uJyxcbiAgICAgICAgICAgICAgICAneFJvd2lkJyxcbiAgICAgICAgICAgICAgICAneFVwZGF0ZScsXG4gICAgICAgICAgICAgICAgJ3hCZWdpbicsXG4gICAgICAgICAgICAgICAgJ3hTeW5jJyxcbiAgICAgICAgICAgICAgICAneENvbW1pdCcsXG4gICAgICAgICAgICAgICAgJ3hSb2xsYmFjaycsXG4gICAgICAgICAgICAgICAgJ3hGaW5kRnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICd4UmVuYW1lJyxcbiAgICAgICAgICAgICAgICAneFNhdmVwb2ludCcsXG4gICAgICAgICAgICAgICAgJ3hSZWxlYXNlJyxcbiAgICAgICAgICAgICAgICAneFJvbGxiYWNrVG8nLFxuICAgICAgICAgICAgICAgICd4U2hhZG93TmFtZScsXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIGNvbnN0IHJlbWV0aG9kcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBtbmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gbWV0aG9kc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoIShtIGluc3RhbmNlb2YgRnVuY3Rpb24pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgneENvbm5lY3QnID09PSBrICYmIG1ldGhvZHMueENyZWF0ZSA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgcmVtZXRob2RzW2tdID0gbWV0aG9kcy54Q3JlYXRlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ3hDcmVhdGUnID09PSBrICYmIG1ldGhvZHMueENvbm5lY3QgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IG1ldGhvZHMueENvbm5lY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IGZ3cmFwKGssIG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kcyhtb2QsIHJlbWV0aG9kcywgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zdGFsbE1ldGhvZHMobW9kLCBtZXRob2RzLCAhIW9wdC5hcHBseUFyZ2NDaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA9PT0gbW9kLiRpVmVyc2lvbikge1xuICAgICAgICAgICAgICBsZXQgdjtcbiAgICAgICAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2Ygb3B0LmlWZXJzaW9uKSB2ID0gb3B0LmlWZXJzaW9uO1xuICAgICAgICAgICAgICBlbHNlIGlmIChtb2QuJHhTaGFkb3dOYW1lKSB2ID0gMztcbiAgICAgICAgICAgICAgZWxzZSBpZiAobW9kLiR4U2F2ZVBvaW50IHx8IG1vZC4keFJlbGVhc2UgfHwgbW9kLiR4Um9sbGJhY2tUbylcbiAgICAgICAgICAgICAgICB2ID0gMjtcbiAgICAgICAgICAgICAgZWxzZSB2ID0gMTtcbiAgICAgICAgICAgICAgbW9kLiRpVmVyc2lvbiA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZWRNb2QpIGNyZWF0ZWRNb2QuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfbW9kdWxlLnByb3RvdHlwZS5zZXR1cE1vZHVsZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICByZXR1cm4gdnRhYi5zZXR1cE1vZHVsZS5jYWxsKHRoaXMsIG9wdCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFsbE9wZnNWZnMgPSBmdW5jdGlvbiBjYWxsZWUob3B0aW9ucykge1xuICAgICAgICAgIGlmICghZ2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlciB8fCAhZ2xvYmFsVGhpcy5BdG9taWNzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGluc3RhbGwgT1BGUzogTWlzc2luZyBTaGFyZWRBcnJheUJ1ZmZlciBhbmQvb3IgQXRvbWljcy4gJyArXG4gICAgICAgICAgICAgICAgICAnVGhlIHNlcnZlciBtdXN0IGVtaXQgdGhlIENPT1AvQ09FUCByZXNwb25zZSBoZWFkZXJzIHRvIGVuYWJsZSB0aG9zZS4gJyArXG4gICAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vc3FsaXRlLm9yZy93YXNtL2RvYy90cnVuay9wZXJzaXN0ZW5jZS5tZCNjb29wLWNvZXAnLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdUaGUgT1BGUyBzcWxpdGUzX3ZmcyBjYW5ub3QgcnVuIGluIHRoZSBtYWluIHRocmVhZCAnICtcbiAgICAgICAgICAgICAgICAgICdiZWNhdXNlIGl0IHJlcXVpcmVzIEF0b21pY3Mud2FpdCgpLicsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUucHJvdG90eXBlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgfHxcbiAgICAgICAgICAgICFuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBPUEZTIEFQSXMuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTChnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYpLnNlYXJjaFBhcmFtcztcbiAgICAgICAgICBpZiAodXJsUGFyYW1zLmhhcygnb3Bmcy1kaXNhYmxlJykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3FsaXRlMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3B0aW9ucy52ZXJib3NlID0gdXJsUGFyYW1zLmhhcygnb3Bmcy12ZXJib3NlJylcbiAgICAgICAgICAgICAgPyArdXJsUGFyYW1zLmdldCgnb3Bmcy12ZXJib3NlJykgfHwgMlxuICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG9wdGlvbnMuc2FuaXR5Q2hlY2tzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNhbml0eUNoZWNrcyA9IHVybFBhcmFtcy5oYXMoJ29wZnMtc2FuaXR5LWNoZWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG9wdGlvbnMucHJveHlVcmkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHJveHlVcmkgPSBjYWxsZWUuZGVmYXVsdFByb3h5VXJpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucy5wcm94eVVyaSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wcm94eVVyaSA9IG9wdGlvbnMucHJveHlVcmkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGhlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHByb21pc2VSZXNvbHZlXyxcbiAgICAgICAgICAgIHByb21pc2VSZWplY3RfLFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgbG9nZ2VycyA9IFtcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IsXG4gICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4sXG4gICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBsb2dJbXBsID0gKGxldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcmJvc2UgPiBsZXZlbClcbiAgICAgICAgICAgICAgICBsb2dnZXJzW2xldmVsXSgnT1BGUyBzeW5jZXI6JywgLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbG9nID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMiwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCB3YXJuID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMSwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9ICguLi5hcmdzKSA9PiBsb2dJbXBsKDAsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgdG9zcyA9IHNxbGl0ZTMudXRpbC50b3NzO1xuICAgICAgICAgICAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaTtcbiAgICAgICAgICAgIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgICAgICBjb25zdCB3YXNtID0gc3FsaXRlMy53YXNtO1xuICAgICAgICAgICAgY29uc3Qgc3FsaXRlM192ZnMgPSBjYXBpLnNxbGl0ZTNfdmZzO1xuICAgICAgICAgICAgY29uc3Qgc3FsaXRlM19maWxlID0gY2FwaS5zcWxpdGUzX2ZpbGU7XG4gICAgICAgICAgICBjb25zdCBzcWxpdGUzX2lvX21ldGhvZHMgPSBjYXBpLnNxbGl0ZTNfaW9fbWV0aG9kcztcblxuICAgICAgICAgICAgY29uc3Qgb3Bmc1V0aWwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICBjb25zdCB0aGlzVGhyZWFkSGFzT1BGUyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlICYmXG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgIC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlICYmXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3RvcnlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLm1ldHJpY3MgPSB7XG4gICAgICAgICAgICAgIGR1bXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgayxcbiAgICAgICAgICAgICAgICAgIG4gPSAwLFxuICAgICAgICAgICAgICAgICAgdCA9IDAsXG4gICAgICAgICAgICAgICAgICB3ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gc3RhdGUub3BJZHMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBtZXRyaWNzW2tdO1xuICAgICAgICAgICAgICAgICAgbiArPSBtLmNvdW50O1xuICAgICAgICAgICAgICAgICAgdCArPSBtLnRpbWU7XG4gICAgICAgICAgICAgICAgICB3ICs9IG0ud2FpdDtcbiAgICAgICAgICAgICAgICAgIG0uYXZnVGltZSA9IG0uY291bnQgJiYgbS50aW1lID8gbS50aW1lIC8gbS5jb3VudCA6IDA7XG4gICAgICAgICAgICAgICAgICBtLmF2Z1dhaXQgPSBtLmNvdW50ICYmIG0ud2FpdCA/IG0ud2FpdCAvIG0uY291bnQgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2coXG4gICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgICAgICAnbWV0cmljcyBmb3InLFxuICAgICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgJzonLFxuICAgICAgICAgICAgICAgICAgbWV0cmljcyxcbiAgICAgICAgICAgICAgICAgICdcXG5Ub3RhbCBvZicsXG4gICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgJ29wKHMpIGZvcicsXG4gICAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgICAgJ21zIChpbmNsLiAnICsgdyArICcgbXMgb2Ygd2FpdGluZyBvbiB0aGUgYXN5bmMgc2lkZSknLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcubG9nKCdTZXJpYWxpemF0aW9uIG1ldHJpY3M6JywgbWV0cmljcy5zMTFuKTtcbiAgICAgICAgICAgICAgICBXLnBvc3RNZXNzYWdlKHsgdHlwZTogJ29wZnMtYXN5bmMtbWV0cmljcycgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGs7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IChtKSA9PiAobS5jb3VudCA9IG0udGltZSA9IG0ud2FpdCA9IDApO1xuICAgICAgICAgICAgICAgIGZvciAoayBpbiBzdGF0ZS5vcElkcykge1xuICAgICAgICAgICAgICAgICAgcigobWV0cmljc1trXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHMgPSAobWV0cmljcy5zMTFuID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICAgICAgcyA9IHMuc2VyaWFsaXplID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBzLmNvdW50ID0gcy50aW1lID0gMDtcbiAgICAgICAgICAgICAgICBzID0gbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBzLmNvdW50ID0gcy50aW1lID0gMDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvcGZzSW9NZXRob2RzID0gbmV3IHNxbGl0ZTNfaW9fbWV0aG9kcygpO1xuICAgICAgICAgICAgY29uc3Qgb3Bmc1ZmcyA9IG5ldyBzcWxpdGUzX3ZmcygpLmFkZE9uRGlzcG9zZSgoKSA9PlxuICAgICAgICAgICAgICBvcGZzSW9NZXRob2RzLmRpc3Bvc2UoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZVdhc1JlamVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVJlamVjdCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcHJvbWlzZVdhc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgb3Bmc1Zmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0XyhlcnIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VSZXNvbHZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICBwcm9taXNlV2FzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlXyhzcWxpdGUzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBXID0gbmV3IFdvcmtlcihcbiAgICAgICAgICAgICAgbmV3IFVSTCgnc3FsaXRlMy1vcGZzLWFzeW5jLXByb3h5LmpzJywgaW1wb3J0Lm1ldGEudXJsKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcHJvbWlzZVdhc1JlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVJlamVjdChcbiAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1RpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgT1BGUyBhc3luYyBwcm94eSB3b3JrZXIuJyxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNDAwMCk7XG4gICAgICAgICAgICBXLl9vcmlnaW5hbE9uRXJyb3IgPSBXLm9uZXJyb3I7XG4gICAgICAgICAgICBXLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgT1BGUyBhc3luY2VyOicsIGVycik7XG4gICAgICAgICAgICAgIHByb21pc2VSZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0xvYWRpbmcgT1BGUyBhc3luYyBXb3JrZXIgZmFpbGVkIGZvciB1bmtub3duIHJlYXNvbnMuJyxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBEVmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZFZmcyA9IHBEVmZzID8gbmV3IHNxbGl0ZTNfdmZzKHBEVmZzKSA6IG51bGw7XG4gICAgICAgICAgICBvcGZzSW9NZXRob2RzLiRpVmVyc2lvbiA9IDE7XG4gICAgICAgICAgICBvcGZzVmZzLiRpVmVyc2lvbiA9IDI7XG4gICAgICAgICAgICBvcGZzVmZzLiRzek9zRmlsZSA9IGNhcGkuc3FsaXRlM19maWxlLnN0cnVjdEluZm8uc2l6ZW9mO1xuICAgICAgICAgICAgb3Bmc1Zmcy4kbXhQYXRobmFtZSA9IDEwMjQ7XG4gICAgICAgICAgICBvcGZzVmZzLiR6TmFtZSA9IHdhc20uYWxsb2NDU3RyaW5nKCdvcGZzJyk7XG5cbiAgICAgICAgICAgIG9wZnNWZnMuJHhEbE9wZW4gPVxuICAgICAgICAgICAgICBvcGZzVmZzLiR4RGxFcnJvciA9XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhEbFN5bSA9XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhEbENsb3NlID1cbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgb3Bmc1Zmcy5hZGRPbkRpc3Bvc2UoXG4gICAgICAgICAgICAgICckek5hbWUnLFxuICAgICAgICAgICAgICBvcGZzVmZzLiR6TmFtZSxcbiAgICAgICAgICAgICAgJ2NsZWFudXAgZGVmYXVsdCBWRlMgd3JhcHBlcicsXG4gICAgICAgICAgICAgICgpID0+IChkVmZzID8gZFZmcy5kaXNwb3NlKCkgOiBudWxsKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHN0YXRlLnZlcmJvc2UgPSBvcHRpb25zLnZlcmJvc2U7XG4gICAgICAgICAgICBzdGF0ZS5saXR0bGVFbmRpYW4gPSAoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICAgICAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlcilbMF0gPT09IDI1NjtcbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgIHN0YXRlLmFzeW5jSWRsZVdhaXRUaW1lID0gMTUwO1xuXG4gICAgICAgICAgICBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zID0gMTtcblxuICAgICAgICAgICAgc3RhdGUuZmlsZUJ1ZmZlclNpemUgPSAxMDI0ICogNjQ7XG4gICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0ID0gc3RhdGUuZmlsZUJ1ZmZlclNpemU7XG5cbiAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplID0gb3Bmc1Zmcy4kbXhQYXRobmFtZSAqIDI7XG5cbiAgICAgICAgICAgIHN0YXRlLnNhYklPID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKFxuICAgICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSArIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0YXRlLm9wSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG5cbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMud2hpY2hPcCA9IGkrKztcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy5yYyA9IGkrKztcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54QWNjZXNzID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54Q2xvc2UgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhEZWxldGUgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhEZWxldGVOb1dhaXQgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhGaWxlU2l6ZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueExvY2sgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhPcGVuID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54UmVhZCA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueFNsZWVwID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54U3luYyA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueFRydW5jYXRlID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54VW5sb2NrID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54V3JpdGUgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLm1rZGlyID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkc1snb3Bmcy1hc3luYy1tZXRyaWNzJ10gPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzWydvcGZzLWFzeW5jLXNodXRkb3duJ10gPSBpKys7XG5cbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMucmV0cnkgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLnNhYk9QID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKGkgKiA0KTtcbiAgICAgICAgICAgICAgb3Bmc1V0aWwubWV0cmljcy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5zcTNDb2RlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdTUUxJVEVfQUNDRVNTX0VYSVNUUycsXG4gICAgICAgICAgICAgICdTUUxJVEVfQUNDRVNTX1JFQURXUklURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfQlVTWScsXG4gICAgICAgICAgICAgICdTUUxJVEVfRVJST1InLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9BQ0NFU1MnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0NMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9ERUxFVEUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0ZTWU5DJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9TSE9SVF9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9UUlVOQ0FURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfSU9FUlJfVU5MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9XUklURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19FWENMVVNJVkUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0xPQ0tfTk9ORScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19QRU5ESU5HJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1JFU0VSVkVEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1NIQVJFRCcsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS0VEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9NSVNVU0UnLFxuICAgICAgICAgICAgICAnU1FMSVRFX05PVEZPVU5EJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX0NSRUFURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX01BSU5fREInLFxuICAgICAgICAgICAgICAnU1FMSVRFX09QRU5fUkVBRE9OTFknLFxuICAgICAgICAgICAgXS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IChzdGF0ZS5zcTNDb2Rlc1trXSA9IGNhcGlba10pKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IG5vdCBmb3VuZDonLCBrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5vcGZzRmxhZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgT1BGU19VTkxPQ0tfQVNBUDogMHgwMSxcblxuICAgICAgICAgICAgICBkZWZhdWx0VW5sb2NrQXNhcDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgb3BSdW4gPSAob3AsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3BOZHggPSBzdGF0ZS5vcElkc1tvcF0gfHwgdG9zcygnSW52YWxpZCBvcCBJRDonLCBvcCk7XG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKTtcbiAgICAgICAgICAgICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3AsIG9wTmR4KTtcbiAgICAgICAgICAgICAgQXRvbWljcy5ub3RpZnkoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy53aGljaE9wKTtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICBBdG9taWNzLndhaXQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYywgLTEpO1xuICAgICAgICAgICAgICBjb25zdCByYyA9IEF0b21pY3MubG9hZChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJjKTtcbiAgICAgICAgICAgICAgbWV0cmljc1tvcF0ud2FpdCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgICAgICAgICAgIGlmIChyYyAmJiBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGVycm9yKG9wICsgJygpIGFzeW5jIGVycm9yOicsIC4uLmVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwuZGVidWcgPSB7XG4gICAgICAgICAgICAgIGFzeW5jU2h1dGRvd246ICgpID0+IHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ1NodXR0aW5nIGRvd24gT1BGUyBhc3luYyBsaXN0ZW5lci4gVGhlIE9QRlMgVkZTIHdpbGwgbm8gbG9uZ2VyIHdvcmsuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG9wUnVuKCdvcGZzLWFzeW5jLXNodXRkb3duJyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFzeW5jUmVzdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAnQXR0ZW1wdGluZyB0byByZXN0YXJ0IE9QRlMgVkZTIGFzeW5jIGxpc3RlbmVyLiBNaWdodCB3b3JrLCBtaWdodCBub3QuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1yZXN0YXJ0JyB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGluaXRTMTFuID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuczExbikgcmV0dXJuIHN0YXRlLnMxMW47XG4gICAgICAgICAgICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCksXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JyksXG4gICAgICAgICAgICAgICAgdmlld1U4ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuU2l6ZSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHZpZXdEViA9IG5ldyBEYXRhVmlldyhcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYklPLFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExbk9mZnNldCxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IFR5cGVJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBUeXBlSWRzLm51bWJlciA9IHtcbiAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICBzaXplOiA4LFxuICAgICAgICAgICAgICAgIGdldHRlcjogJ2dldEZsb2F0NjQnLFxuICAgICAgICAgICAgICAgIHNldHRlcjogJ3NldEZsb2F0NjQnLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUeXBlSWRzLmJpZ2ludCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMixcbiAgICAgICAgICAgICAgICBzaXplOiA4LFxuICAgICAgICAgICAgICAgIGdldHRlcjogJ2dldEJpZ0ludDY0JyxcbiAgICAgICAgICAgICAgICBzZXR0ZXI6ICdzZXRCaWdJbnQ2NCcsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFR5cGVJZHMuYm9vbGVhbiA9IHtcbiAgICAgICAgICAgICAgICBpZDogMyxcbiAgICAgICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgICAgIGdldHRlcjogJ2dldEludDMyJyxcbiAgICAgICAgICAgICAgICBzZXR0ZXI6ICdzZXRJbnQzMicsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFR5cGVJZHMuc3RyaW5nID0geyBpZDogNCB9O1xuXG4gICAgICAgICAgICAgIGNvbnN0IGdldFR5cGVJZCA9ICh2KSA9PlxuICAgICAgICAgICAgICAgIFR5cGVJZHNbdHlwZW9mIHZdIHx8XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICdNYWludGVuYW5jZSByZXF1aXJlZDogdGhpcyB2YWx1ZSB0eXBlIGNhbm5vdCBiZSBzZXJpYWxpemVkLicsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IGdldFR5cGVJZEJ5SWQgPSAodGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aWQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5udW1iZXIuaWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlSWRzLm51bWJlcjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5iaWdpbnQuaWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlSWRzLmJpZ2ludDtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5ib29sZWFuLmlkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUlkcy5ib29sZWFuO1xuICAgICAgICAgICAgICAgICAgY2FzZSBUeXBlSWRzLnN0cmluZy5pZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVJZHMuc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIElEOicsIHRpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4uZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoY2xlYXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICsrbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplLmNvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdjID0gdmlld1U4WzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gYXJnYyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoYXJnYykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZUlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDEsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAgIHY7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgKytpLCArK29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlSWRzLnB1c2goZ2V0VHlwZUlkQnlJZCh2aWV3VThbb2Zmc2V0XSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gdHlwZUlkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdiA9IHZpZXdEVlt0LmdldHRlcl0ob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSB0LnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbiA9IHZpZXdEVi5nZXRJbnQzMihvZmZzZXQsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgdiA9IHRleHREZWNvZGVyLmRlY29kZSh2aWV3VTguc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyKSB2aWV3VThbMF0gPSAwO1xuXG4gICAgICAgICAgICAgICAgbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICsrbWV0cmljcy5zMTFuLnNlcmlhbGl6ZS5jb3VudDtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGxldCBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgIHZpZXdVOFswXSA9IGFyZ3MubGVuZ3RoICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7ICsraSwgKytvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkcy5wdXNoKGdldFR5cGVJZChhcmdzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdVOFtvZmZzZXRdID0gdHlwZUlkc1tpXS5pZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0eXBlSWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5zZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3RFZbdC5zZXR0ZXJdKG9mZnNldCwgYXJnc1tpXSwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdC5zaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmlld0RWLnNldEludDMyKG9mZnNldCwgcy5ieXRlTGVuZ3RoLCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIHZpZXdVOC5zZXQocywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZpZXdVOFswXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldHJpY3MuczExbi5zZXJpYWxpemUudGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zMTFuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmFuZG9tRmlsZW5hbWUgPSBmdW5jdGlvbiBmKGxlbiA9IDE2KSB7XG4gICAgICAgICAgICAgIGlmICghZi5fY2hhcnMpIHtcbiAgICAgICAgICAgICAgICBmLl9jaGFycyA9XG4gICAgICAgICAgICAgICAgICAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICtcbiAgICAgICAgICAgICAgICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgK1xuICAgICAgICAgICAgICAgICAgJzAxMjM0Njc4OSc7XG4gICAgICAgICAgICAgICAgZi5fbiA9IGYuX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5keCA9IChNYXRoLnJhbmRvbSgpICogKGYuX24gKiA2NCkpICUgZi5fbiB8IDA7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGYuX2NoYXJzW25keF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGEuam9pbignJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBfX29wZW5GaWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9wVGltZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgb3BUaW1lci5vcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wVGltZXIuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBtVGltZVN0YXJ0ID0gKG9wKSA9PiB7XG4gICAgICAgICAgICAgIG9wVGltZXIuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgb3BUaW1lci5vcCA9IG9wO1xuICAgICAgICAgICAgICArK21ldHJpY3Nbb3BdLmNvdW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG1UaW1lRW5kID0gKCkgPT5cbiAgICAgICAgICAgICAgKG1ldHJpY3Nbb3BUaW1lci5vcF0udGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIG9wVGltZXIuc3RhcnQpO1xuXG4gICAgICAgICAgICBjb25zdCBpb1N5bmNXcmFwcGVycyA9IHtcbiAgICAgICAgICAgICAgeENoZWNrUmVzZXJ2ZWRMb2NrOiBmdW5jdGlvbiAocEZpbGUsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCBmLmxvY2tUeXBlID8gMSA6IDAsICdpMzInKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeENsb3NlOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4Q2xvc2UnKTtcbiAgICAgICAgICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4Q2xvc2UnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZi5zcTNGaWxlKSBmLnNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeERldmljZUNoYXJhY3RlcmlzdGljczogZnVuY3Rpb24gKHBGaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeEZpbGVDb250cm9sOiBmdW5jdGlvbiAocEZpbGUsIG9wSWQsIHBBcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGaWxlU2l6ZTogZnVuY3Rpb24gKHBGaWxlLCBwU3o2NCkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hGaWxlU2l6ZScpO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IG9wUnVuKCd4RmlsZVNpemUnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT0gcmMpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN6ID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpWzBdO1xuICAgICAgICAgICAgICAgICAgICB3YXNtLnBva2UocFN6NjQsIHN6LCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHJlYWRpbmcgeEZpbGVTaXplKCkgcmVzdWx0OicsIGUpO1xuICAgICAgICAgICAgICAgICAgICByYyA9IHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhMb2NrOiBmdW5jdGlvbiAocEZpbGUsIGxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneExvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWYubG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHJjID0gb3BSdW4oJ3hMb2NrJywgcEZpbGUsIGxvY2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4UmVhZDogZnVuY3Rpb24gKHBGaWxlLCBwRGVzdCwgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4UmVhZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4UmVhZCcsIHBGaWxlLCBuLCBOdW1iZXIob2Zmc2V0NjQpKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYyB8fCBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEID09PSByYykge1xuICAgICAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLnNldChmLnNhYlZpZXcuc3ViYXJyYXkoMCwgbiksIHBEZXN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcigneFJlYWQoJywgYXJndW1lbnRzLCAnKSBmYWlsZWQ6JywgZSwgZik7XG4gICAgICAgICAgICAgICAgICByYyA9IGNhcGkuU1FMSVRFX0lPRVJSX1JFQUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4U3luYzogZnVuY3Rpb24gKHBGaWxlLCBmbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hTeW5jJyk7XG4gICAgICAgICAgICAgICAgKyttZXRyaWNzLnhTeW5jLmNvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hTeW5jJywgcEZpbGUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFRydW5jYXRlOiBmdW5jdGlvbiAocEZpbGUsIHN6NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4VHJ1bmNhdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4VHJ1bmNhdGUnLCBwRmlsZSwgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFVubG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hVbmxvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGNhcGkuU1FMSVRFX0xPQ0tfTk9ORSA9PT0gbG9ja1R5cGUgJiYgZi5sb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgICAgcmMgPSBvcFJ1bigneFVubG9jaycsIHBGaWxlLCBsb2NrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4V3JpdGU6IGZ1bmN0aW9uIChwRmlsZSwgcFNyYywgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4V3JpdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZi5zYWJWaWV3LnNldCh3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBTcmMsIHBTcmMgKyBuKSk7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4V3JpdGUnLCBwRmlsZSwgbiwgTnVtYmVyKG9mZnNldDY0KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ3hXcml0ZSgnLCBhcmd1bWVudHMsICcpIGZhaWxlZDonLCBlLCBmKTtcbiAgICAgICAgICAgICAgICAgIHJjID0gY2FwaS5TUUxJVEVfSU9FUlJfV1JJVEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdmZzU3luY1dyYXBwZXJzID0ge1xuICAgICAgICAgICAgICB4QWNjZXNzOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIGZsYWdzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneEFjY2VzcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hBY2Nlc3MnLCB3YXNtLmNzdHJUb0pzKHpOYW1lKSk7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIHJjID8gMCA6IDEsICdpMzInKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWU6IGZ1bmN0aW9uIChwVmZzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKFxuICAgICAgICAgICAgICAgICAgcE91dCxcbiAgICAgICAgICAgICAgICAgIDI0NDA1ODcuNSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gODY0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAnZG91YmxlJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2UoXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICAgMjQ0MDU4Ny41ICogODY0MDAwMDAgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICdpNjQnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhEZWxldGU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneERlbGV0ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oXG4gICAgICAgICAgICAgICAgICAneERlbGV0ZScsXG4gICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHpOYW1lKSxcbiAgICAgICAgICAgICAgICAgIGRvU3luY0RpcixcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGdWxsUGF0aG5hbWU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FybignT1BGUyB4R2V0TGFzdEVycm9yKCkgaGFzIG5vdGhpbmcgc2Vuc2libGUgdG8gcmV0dXJuLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIHhPcGVuOiBmdW5jdGlvbiBmKHBWZnMsIHpOYW1lLCBwRmlsZSwgZmxhZ3MsIHBPdXRGbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hPcGVuJyk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZnNGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHpOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB6TmFtZSA9IHJhbmRvbUZpbGVuYW1lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHpOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FwaS5zcWxpdGUzX3VyaV9ib29sZWFuKHpOYW1lLCAnb3Bmcy11bmxvY2stYXNhcCcsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZnNGbGFncyB8PSBzdGF0ZS5vcGZzRmxhZ3MuT1BGU19VTkxPQ0tfQVNBUDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHpOYW1lID0gd2FzbS5jc3RyVG9Kcyh6TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBmaC5maWQgPSBwRmlsZTtcbiAgICAgICAgICAgICAgICBmaC5maWxlbmFtZSA9IHpOYW1lO1xuICAgICAgICAgICAgICAgIGZoLnNhYiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihzdGF0ZS5maWxlQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgZmguZmxhZ3MgPSBmbGFncztcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4T3BlbicsIHBGaWxlLCB6TmFtZSwgZmxhZ3MsIG9wZnNGbGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYykge1xuICAgICAgICAgICAgICAgICAgaWYgKGZoLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0RmxhZ3MsIGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFksICdpMzInKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9fb3BlbkZpbGVzW3BGaWxlXSA9IGZoO1xuICAgICAgICAgICAgICAgICAgZmguc2FiVmlldyA9IHN0YXRlLnNhYkZpbGVCdWZWaWV3O1xuICAgICAgICAgICAgICAgICAgZmguc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgICAgICAgZmguc3EzRmlsZS4kcE1ldGhvZHMgPSBvcGZzSW9NZXRob2RzLnBvaW50ZXI7XG4gICAgICAgICAgICAgICAgICBmaC5sb2NrVHlwZSA9IGNhcGkuU1FMSVRFX0xPQ0tfTk9ORTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZFZmcykge1xuICAgICAgICAgICAgICBvcGZzVmZzLiR4UmFuZG9tbmVzcyA9IGRWZnMuJHhSYW5kb21uZXNzO1xuICAgICAgICAgICAgICBvcGZzVmZzLiR4U2xlZXAgPSBkVmZzLiR4U2xlZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wZnNWZnMuJHhSYW5kb21uZXNzKSB7XG4gICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54UmFuZG9tbmVzcyA9IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhcCA9IHdhc20uaGVhcDh1KCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbk91dDsgKytpKVxuICAgICAgICAgICAgICAgICAgaGVhcFtwT3V0ICsgaV0gPSAoTWF0aC5yYW5kb20oKSAqIDI1NTAwMCkgJiAweGZmO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcGZzVmZzLiR4U2xlZXApIHtcbiAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhTbGVlcCA9IGZ1bmN0aW9uIChwVmZzLCBtcykge1xuICAgICAgICAgICAgICAgIEF0b21pY3Mud2FpdChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnhTbGVlcCwgMCwgbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGZzVXRpbC5nZXRSZXNvbHZlZFBhdGggPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHNwbGl0SXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBVUkwoZmlsZW5hbWUsICdmaWxlOi8vaXJyZWxldmFudCcpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gc3BsaXRJdCA/IHAuc3BsaXQoJy8nKS5maWx0ZXIoKHYpID0+ICEhdikgOiBwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUgPSBhc3luYyBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgICBhYnNGaWxlbmFtZSxcbiAgICAgICAgICAgICAgY3JlYXRlRGlycyA9IGZhbHNlLFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBvcGZzVXRpbC5nZXRSZXNvbHZlZFBhdGgoYWJzRmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgIGxldCBkaCA9IG9wZnNVdGlsLnJvb3REaXJlY3Rvcnk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgZGlyTmFtZSBvZiBwYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGRoID0gYXdhaXQgZGguZ2V0RGlyZWN0b3J5SGFuZGxlKGRpck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiAhIWNyZWF0ZURpcnMsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFtkaCwgZmlsZW5hbWVdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwubWtkaXIgPSBhc3luYyBmdW5jdGlvbiAoYWJzRGlyTmFtZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKFxuICAgICAgICAgICAgICAgICAgYWJzRGlyTmFtZSArICcvZmlsZXBhcnQnLFxuICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5lbnRyeUV4aXN0cyA9IGFzeW5jIGZ1bmN0aW9uIChmc0VudHJ5TmFtZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtkaCwgZm5dID0gYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoZnNFbnRyeU5hbWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRoLmdldEZpbGVIYW5kbGUoZm4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5yYW5kb21GaWxlbmFtZSA9IHJhbmRvbUZpbGVuYW1lO1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5yZWdpc3RlclZmcyA9IChhc0RlZmF1bHQgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfdmZzX3JlZ2lzdGVyKFxuICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICBhc0RlZmF1bHQgPyAxIDogMCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnRyZWVMaXN0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCBkb0RpciA9IGFzeW5jIGZ1bmN0aW9uIGNhbGxlZShkaXJIYW5kbGUsIHRndCkge1xuICAgICAgICAgICAgICAgIHRndC5uYW1lID0gZGlySGFuZGxlLm5hbWU7XG4gICAgICAgICAgICAgICAgdGd0LmRpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0Z3QuZmlsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgnZGlyZWN0b3J5JyA9PT0gaGFuZGxlLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViRGlyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmRpcnMucHVzaChzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsZWUoaGFuZGxlLCBzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmZpbGVzLnB1c2goaGFuZGxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3Qgcm9vdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGF3YWl0IGRvRGlyKG9wZnNVdGlsLnJvb3REaXJlY3RvcnksIHJvb3QpO1xuICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnJtZnIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpciA9IG9wZnNVdGlsLnJvb3REaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgb3B0ID0geyByZWN1cnNlOiB0cnVlIH07XG4gICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaGFuZGxlIG9mIGRpci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGRpci5yZW1vdmVFbnRyeShoYW5kbGUubmFtZSwgb3B0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudW5saW5rID0gYXN5bmMgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICBmc0VudHJ5TmFtZSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlID0gZmFsc2UsXG4gICAgICAgICAgICAgIHRocm93T25FcnJvciA9IGZhbHNlLFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZpbGVuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICAgIGZzRW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KGZpbGVuYW1lUGFydCwgeyByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICd1bmxpbmsoJyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAnKSBmYWlsZWQ6ICcgKyBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudHJhdmVyc2UgPSBhc3luYyBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRPcHQgPSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogb3Bmc1V0aWwucm9vdERpcmVjdG9yeSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHQpIHtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IGNhbGxiYWNrOiBvcHQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHQsIG9wdCB8fCB7fSk7XG4gICAgICAgICAgICAgIGNvbnN0IGRvRGlyID0gYXN5bmMgZnVuY3Rpb24gY2FsbGVlKGRpckhhbmRsZSwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gb3B0LmNhbGxiYWNrKGhhbmRsZSwgZGlySGFuZGxlLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdC5yZWN1cnNpdmUgJiYgJ2RpcmVjdG9yeScgPT09IGhhbmRsZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gKGF3YWl0IGNhbGxlZShoYW5kbGUsIGRlcHRoICsgMSkpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGRvRGlyKG9wdC5kaXJlY3RvcnksIDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgaW1wb3J0RGJDaHVua2VkID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjb25zdCBbaERpciwgZm5hbWVQYXJ0XSA9IGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxldCBzYWggPSBhd2FpdCBoRmlsZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgICAgIGxldCBuV3JvdGUgPSAwLFxuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBuV3JvdGUgJiYgY2h1bmsuYnl0ZUxlbmd0aCA+PSAxNSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHsgYXQ6IG5Xcm90ZSB9KTtcbiAgICAgICAgICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobldyb3RlIDwgNTEyIHx8IDAgIT09IG5Xcm90ZSAlIDUxMikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0lucHV0IHNpemUnLFxuICAgICAgICAgICAgICAgICAgICBuV3JvdGUsXG4gICAgICAgICAgICAgICAgICAgICdpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLicsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KDIwKTtcbiAgICAgICAgICAgICAgICAgIHNhaC5yZWFkKGhlYWRlciwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBzYWggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5pbXBvcnREYiA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlbmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RGJDaHVua2VkKGZpbGVuYW1lLCBieXRlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICAgICAgICB1dGlsLmFmZmlybUlzRGIoYnl0ZXMpO1xuICAgICAgICAgICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsZXQgc2FoLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBuV3JvdGUgPSAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNhaCA9IGF3YWl0IGhGaWxlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7IGF0OiAwIH0pO1xuICAgICAgICAgICAgICAgIGlmIChuV3JvdGUgIT0gbikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIHRvIHdyaXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG4gK1xuICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMgYnV0IHdyb3RlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG5Xcm90ZSArXG4gICAgICAgICAgICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FoKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHNhaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc3FsaXRlMy5vbzEpIHtcbiAgICAgICAgICAgICAgY29uc3QgT3Bmc0RiID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBzcWxpdGUzLm9vMS5EQi5kYkN0b3JIZWxwZXIubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBvcHQudmZzID0gb3Bmc1Zmcy4kek5hbWU7XG4gICAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgT3Bmc0RiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3FsaXRlMy5vbzEuREIucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuT3Bmc0RiID0gT3Bmc0RiO1xuICAgICAgICAgICAgICBPcGZzRGIuaW1wb3J0RGIgPSBvcGZzVXRpbC5pbXBvcnREYjtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLnNldFZmc1Bvc3RPcGVuU3FsKFxuICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAob28xRGIsIHNxbGl0ZTMpIHtcbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2J1c3lfdGltZW91dChvbzFEYiwgMTAwMDApO1xuICAgICAgICAgICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfZXhlYyhcbiAgICAgICAgICAgICAgICAgICAgb28xRGIsXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAncHJhZ21hIGpvdXJuYWxfbW9kZT1ERUxFVEU7JyxcblxuICAgICAgICAgICAgICAgICAgICAgICdwcmFnbWEgY2FjaGVfc2l6ZT0tMTYzODQ7JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUoKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWQgPSBzcTNGaWxlLnBvaW50ZXI7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlbkZsYWdzID1cbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQjtcbiAgICAgICAgICAgICAgICBjb25zdCBwT3V0ID0gd2FzbS5zY29wZWRBbGxvYyg4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYkZpbGUgPSAnL3Nhbml0eS9jaGVjay9maWxlJyArIHJhbmRvbUZpbGVuYW1lKDgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpEYkZpbGUgPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhkYkZpbGUpO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSgnVGhpcyBpcyDDpCBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgcmMgPSBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgbG9nKCdkZXNlcmlhbGl6ZSgpIHNheXM6JywgcmMpO1xuICAgICAgICAgICAgICAgIGlmICgnVGhpcyBpcyDDpCBzdHJpbmcuJyAhPT0gcmNbMF0pIHRvc3MoJ1N0cmluZyBkMTNuIGVycm9yLicpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGxvZygneEFjY2VzcygnLCBkYkZpbGUsICcpIGV4aXN0cyA/PScsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IHZmc1N5bmNXcmFwcGVycy54T3BlbihcbiAgICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIHpEYkZpbGUsXG4gICAgICAgICAgICAgICAgICBmaWQsXG4gICAgICAgICAgICAgICAgICBvcGVuRmxhZ3MsXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgJ29wZW4gcmMgPScsXG4gICAgICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgICAgICdzdGF0ZS5zYWJPUFZpZXdbeE9wZW5dID0nLFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiT1BWaWV3W3N0YXRlLm9wSWRzLnhPcGVuXSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSByYykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ29wZW4gZmFpbGVkIHdpdGggY29kZScsIHJjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhBY2Nlc3Mob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAwLCBwT3V0KTtcbiAgICAgICAgICAgICAgICByYyA9IHdhc20ucGVlayhwT3V0LCAnaTMyJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYykgdG9zcygneEFjY2VzcygpIGZhaWxlZCB0byBkZXRlY3QgZmlsZS4nKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhTeW5jKHNxM0ZpbGUucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJjKSB0b3NzKCdzeW5jIGZhaWxlZCB3LyByYycsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhUcnVuY2F0ZShzcTNGaWxlLnBvaW50ZXIsIDEwMjQpO1xuICAgICAgICAgICAgICAgIGlmIChyYykgdG9zcygndHJ1bmNhdGUgZmFpbGVkIHcvIHJjJywgcmMpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCAwLCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54RmlsZVNpemUoc3EzRmlsZS5wb2ludGVyLCBwT3V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hGaWxlU2l6ZSBmYWlsZWQgdy8gcmMnLCByYyk7XG4gICAgICAgICAgICAgICAgbG9nKCd4RmlsZVNpemUgc2F5czonLCB3YXNtLnBlZWsocE91dCwgJ2k2NCcpKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhXcml0ZShzcTNGaWxlLnBvaW50ZXIsIHpEYkZpbGUsIDEwLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hXcml0ZSgpIGZhaWxlZCEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkQnVmID0gd2FzbS5zY29wZWRBbGxvYygxNik7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54UmVhZChzcTNGaWxlLnBvaW50ZXIsIHJlYWRCdWYsIDYsIDIpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShyZWFkQnVmICsgNiwgMCk7XG4gICAgICAgICAgICAgICAgbGV0IGpSZWFkID0gd2FzbS5jc3RyVG9KcyhyZWFkQnVmKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hSZWFkKCkgZ290OicsIGpSZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3Nhbml0eScgIT09IGpSZWFkKSB0b3NzKCdVbmV4cGVjdGVkIHhSZWFkKCkgdmFsdWUuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZmc1N5bmNXcmFwcGVycy54U2xlZXApIHtcbiAgICAgICAgICAgICAgICAgIGxvZygneFNsZWVwKClpbmcgYmVmb3JlIGNsb3NlKClpbmcuLi4nKTtcbiAgICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54U2xlZXAob3Bmc1Zmcy5wb2ludGVyLCAyMDAwKTtcbiAgICAgICAgICAgICAgICAgIGxvZygnd2FraW5nIHVwIGZyb20geFNsZWVwKCknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54Q2xvc2UoZmlkKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hDbG9zZSByYyA9JywgcmMsICdzYWJPUFZpZXcgPScsIHN0YXRlLnNhYk9QVmlldyk7XG4gICAgICAgICAgICAgICAgbG9nKCdEZWxldGluZyBmaWxlOicsIGRiRmlsZSk7XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhEZWxldGUob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAweDEyMzQpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAgICdFeHBlY3RpbmcgMCBmcm9tIHhBY2Nlc3MoJyxcbiAgICAgICAgICAgICAgICAgICAgZGJGaWxlLFxuICAgICAgICAgICAgICAgICAgICAnKSBhZnRlciB4RGVsZXRlKCkuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgd2FybignRW5kIG9mIE9QRlMgc2FuaXR5IGNoZWNrcy4nKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgVy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoeyBkYXRhIH0pIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLXVuYXZhaWxhYmxlJzpcbiAgICAgICAgICAgICAgICAgIHByb21pc2VSZWplY3QobmV3IEVycm9yKGRhdGEucGF5bG9hZC5qb2luKCcgJykpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtbG9hZGVkJzpcbiAgICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1pbml0JywgYXJnczogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLWFzeW5jLWluaXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0cnVlID09PSBwcm9taXNlV2FzUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICAgICAgICAgICAgICAgICAgICBpbzogeyBzdHJ1Y3Q6IG9wZnNJb01ldGhvZHMsIG1ldGhvZHM6IGlvU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgdmZzOiB7IHN0cnVjdDogb3Bmc1ZmcywgbWV0aG9kczogdmZzU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJPUFZpZXcgPSBuZXcgSW50MzJBcnJheShzdGF0ZS5zYWJPUCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYkZpbGVCdWZWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpbml0UzExbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zYW5pdHlDaGVja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1J1bm5pbmcgc2FuaXR5IGNoZWNrcyBiZWNhdXNlIG9mIG9wZnMtc2FuaXR5LWNoZWNrIFVSTCBhcmcuLi4nLFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgc2FuaXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1RocmVhZEhhc09QRlMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RGlyZWN0b3J5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFcub25lcnJvciA9IFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3FsaXRlMy5vcGZzID0gb3Bmc1V0aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wZnNVdGlsLnJvb3REaXJlY3RvcnkgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0VuZCBvZiBPUEZTIHNxbGl0ZTNfdmZzIHNldHVwLicsIG9wZnNWZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChwcm9taXNlUmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9XG4gICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIG1lc3NhZ2UgZnJvbSB0aGUgT1BGUyBhc3luYyB3b3JrZXI6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KG5ldyBFcnJvcihlcnJNc2cpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhlUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID0gJ3NxbGl0ZTMtb3Bmcy1hc3luYy1wcm94eS5qcyc7XG4gICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYy5wdXNoKFxuICAgICAgICAgIGFzeW5jIChzcWxpdGUzKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgcHJveHlKcyA9IGluc3RhbGxPcGZzVmZzLmRlZmF1bHRQcm94eVVyaTtcbiAgICAgICAgICAgICAgaWYgKHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID1cbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyICsgcHJveHlKcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFsbE9wZnNWZnMoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICAgICAnSWdub3JpbmcgaW5hYmlsaXR5IHRvIGluc3RhbGwgT1BGUyBzcWxpdGUzX3ZmczonLFxuICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcignaW5zdGFsbE9wZnNWZnMoKSBleGNlcHRpb246JywgZSk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGNvbnN0IHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zcztcbiAgICAgICAgY29uc3QgdG9zczMgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gICAgICAgIGNvbnN0IGluaXRQcm9taXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGk7XG4gICAgICAgIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG5cbiAgICAgICAgY29uc3QgU0VDVE9SX1NJWkUgPSA0MDk2O1xuICAgICAgICBjb25zdCBIRUFERVJfTUFYX1BBVEhfU0laRSA9IDUxMjtcbiAgICAgICAgY29uc3QgSEVBREVSX0ZMQUdTX1NJWkUgPSA0O1xuICAgICAgICBjb25zdCBIRUFERVJfRElHRVNUX1NJWkUgPSA4O1xuICAgICAgICBjb25zdCBIRUFERVJfQ09SUFVTX1NJWkUgPSBIRUFERVJfTUFYX1BBVEhfU0laRSArIEhFQURFUl9GTEFHU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0ZMQUdTID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gICAgICAgIGNvbnN0IEhFQURFUl9PRkZTRVRfRElHRVNUID0gSEVBREVSX0NPUlBVU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0RBVEEgPSBTRUNUT1JfU0laRTtcblxuICAgICAgICBjb25zdCBQRVJTSVNURU5UX0ZJTEVfVFlQRVMgPVxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQiB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0pPVVJOQUwgfFxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fU1VQRVJfSk9VUk5BTCB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9XQUw7XG5cbiAgICAgICAgY29uc3QgT1BBUVVFX0RJUl9OQU1FID0gJy5vcGFxdWUnO1xuXG4gICAgICAgIGNvbnN0IGdldFJhbmRvbU5hbWUgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbkRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgbmFtZTogJ29wZnMtc2FocG9vbCcsXG4gICAgICAgICAgZGlyZWN0b3J5OiB1bmRlZmluZWQsXG4gICAgICAgICAgaW5pdGlhbENhcGFjaXR5OiA2LFxuICAgICAgICAgIGNsZWFyT25Jbml0OiBmYWxzZSxcblxuICAgICAgICAgIHZlcmJvc2l0eTogMixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbG9nZ2VycyA9IFtcbiAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcixcbiAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuLFxuICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbG9nID0gc3FsaXRlMy5jb25maWcubG9nO1xuICAgICAgICBjb25zdCB3YXJuID0gc3FsaXRlMy5jb25maWcud2FybjtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBzcWxpdGUzLmNvbmZpZy5lcnJvcjtcblxuICAgICAgICBjb25zdCBfX21hcFZmc1RvUG9vbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZ2V0UG9vbEZvclZmcyA9IChwVmZzKSA9PiBfX21hcFZmc1RvUG9vbC5nZXQocFZmcyk7XG4gICAgICAgIGNvbnN0IHNldFBvb2xGb3JWZnMgPSAocFZmcywgcG9vbCkgPT4ge1xuICAgICAgICAgIGlmIChwb29sKSBfX21hcFZmc1RvUG9vbC5zZXQocFZmcywgcG9vbCk7XG4gICAgICAgICAgZWxzZSBfX21hcFZmc1RvUG9vbC5kZWxldGUocFZmcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tYXBTcWxpdGUzRmlsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZ2V0UG9vbEZvclBGaWxlID0gKHBGaWxlKSA9PiBfX21hcFNxbGl0ZTNGaWxlLmdldChwRmlsZSk7XG4gICAgICAgIGNvbnN0IHNldFBvb2xGb3JQRmlsZSA9IChwRmlsZSwgcG9vbCkgPT4ge1xuICAgICAgICAgIGlmIChwb29sKSBfX21hcFNxbGl0ZTNGaWxlLnNldChwRmlsZSwgcG9vbCk7XG4gICAgICAgICAgZWxzZSBfX21hcFNxbGl0ZTNGaWxlLmRlbGV0ZShwRmlsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaW9NZXRob2RzID0ge1xuICAgICAgICAgIHhDaGVja1Jlc2VydmVkTG9jazogZnVuY3Rpb24gKHBGaWxlLCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKCd4Q2hlY2tSZXNlcnZlZExvY2snKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIHdhc20ucG9rZTMyKHBPdXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Q2xvc2U6IGZ1bmN0aW9uIChwRmlsZSkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBvb2wubG9nKGB4Q2xvc2UgJHtmaWxlLnBhdGh9YCk7XG4gICAgICAgICAgICAgICAgcG9vbC5tYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZmlsZS5zYWguZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5mbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fREVMRVRFT05DTE9TRSkge1xuICAgICAgICAgICAgICAgICAgcG9vbC5kZWxldGVQYXRoKGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhEZXZpY2VDaGFyYWN0ZXJpc3RpY3M6IGZ1bmN0aW9uIChwRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhGaWxlQ29udHJvbDogZnVuY3Rpb24gKHBGaWxlLCBvcElkLCBwQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RmlsZVNpemU6IGZ1bmN0aW9uIChwRmlsZSwgcFN6NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhGaWxlU2l6ZWApO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGZpbGUuc2FoLmdldFNpemUoKSAtIEhFQURFUl9PRkZTRVRfREFUQTtcblxuICAgICAgICAgICAgd2FzbS5wb2tlNjQocFN6NjQsIEJpZ0ludChzaXplKSk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhMb2NrOiBmdW5jdGlvbiAocEZpbGUsIGxvY2tUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4TG9jayAke2xvY2tUeXBlfWApO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgZmlsZS5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4UmVhZDogZnVuY3Rpb24gKHBGaWxlLCBwRGVzdCwgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhSZWFkICR7ZmlsZS5wYXRofSAke259IEAgJHtvZmZzZXQ2NH1gKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5SZWFkID0gZmlsZS5zYWgucmVhZChcbiAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBEZXN0LCBwRGVzdCArIG4pLFxuICAgICAgICAgICAgICAgIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIE51bWJlcihvZmZzZXQ2NCkgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKG5SZWFkIDwgbikge1xuICAgICAgICAgICAgICAgIHdhc20uaGVhcDh1KCkuZmlsbCgwLCBwRGVzdCArIG5SZWFkLCBwRGVzdCArIG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4U2VjdG9yU2l6ZTogZnVuY3Rpb24gKHBGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gU0VDVE9SX1NJWkU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4U3luYzogZnVuY3Rpb24gKHBGaWxlLCBmbGFncykge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZyhgeFN5bmMgJHtmbGFnc31gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmlsZS5zYWguZmx1c2goKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHhUcnVuY2F0ZTogZnVuY3Rpb24gKHBGaWxlLCBzejY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4VHJ1bmNhdGUgJHtzejY0fWApO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmaWxlLnNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEgKyBOdW1iZXIoc3o2NCkpO1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeFVubG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZygneFVubG9jaycpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgZmlsZS5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4V3JpdGU6IGZ1bmN0aW9uIChwRmlsZSwgcFNyYywgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhXcml0ZSAke2ZpbGUucGF0aH0gJHtufSAke29mZnNldDY0fWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgbkJ5dGVzID0gZmlsZS5zYWgud3JpdGUoXG4gICAgICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5zdWJhcnJheShwU3JjLCBwU3JjICsgbiksXG4gICAgICAgICAgICAgICAgeyBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgTnVtYmVyKG9mZnNldDY0KSB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gbiA9PT0gbkJ5dGVzID8gMCA6IHRvc3MoJ1Vua25vd24gd3JpdGUoKSBmYWlsdXJlLicpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvcGZzSW9NZXRob2RzID0gbmV3IGNhcGkuc3FsaXRlM19pb19tZXRob2RzKCk7XG4gICAgICAgIG9wZnNJb01ldGhvZHMuJGlWZXJzaW9uID0gMTtcbiAgICAgICAgc3FsaXRlMy52ZnMuaW5zdGFsbFZmcyh7XG4gICAgICAgICAgaW86IHsgc3RydWN0OiBvcGZzSW9NZXRob2RzLCBtZXRob2RzOiBpb01ldGhvZHMgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdmZzTWV0aG9kcyA9IHtcbiAgICAgICAgICB4QWNjZXNzOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIGZsYWdzLCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwb29sLmdldFBhdGgoek5hbWUpO1xuICAgICAgICAgICAgICB3YXNtLnBva2UzMihwT3V0LCBwb29sLmhhc0ZpbGVuYW1lKG5hbWUpID8gMSA6IDApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB3YXNtLnBva2UzMihwT3V0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeEN1cnJlbnRUaW1lOiBmdW5jdGlvbiAocFZmcywgcE91dCkge1xuICAgICAgICAgICAgd2FzbS5wb2tlKFxuICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAyNDQwNTg3LjUgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDg2NDAwMDAwLFxuICAgICAgICAgICAgICAnZG91YmxlJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhDdXJyZW50VGltZUludDY0OiBmdW5jdGlvbiAocFZmcywgcE91dCkge1xuICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIDI0NDA1ODcuNSAqIDg2NDAwMDAwICsgbmV3IERhdGUoKS5nZXRUaW1lKCksICdpNjQnKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeERlbGV0ZTogZnVuY3Rpb24gKHBWZnMsIHpOYW1lLCBkb1N5bmNEaXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhEZWxldGUgJHt3YXNtLmNzdHJUb0pzKHpOYW1lKX1gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBvb2wuZGVsZXRlUGF0aChwb29sLmdldFBhdGgoek5hbWUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoZSk7XG4gICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUl9ERUxFVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RnVsbFBhdGhuYW1lOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIG5PdXQsIHBPdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgICAgICAgIHJldHVybiBpIDwgbk91dCA/IDAgOiBjYXBpLlNRTElURV9DQU5UT1BFTjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBwb29sLnBvcEVycigpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhHZXRMYXN0RXJyb3IgJHtuT3V0fSBlID1gLCBlKTtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY01zZywgbl0gPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhlLm1lc3NhZ2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIHdhc20uY3N0cm5jcHkocE91dCwgY01zZywgbk91dCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gPiBuT3V0KSB3YXNtLnBva2U4KHBPdXQgKyBuT3V0IC0gMSwgMCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlID8gZS5zcWxpdGUzUmMgfHwgY2FwaS5TUUxJVEVfSU9FUlIgOiAwO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB4T3BlbjogZnVuY3Rpb24gZihwVmZzLCB6TmFtZSwgcEZpbGUsIGZsYWdzLCBwT3V0RmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcG9vbC5sb2coYHhPcGVuICR7d2FzbS5jc3RyVG9Kcyh6TmFtZSl9ICR7ZmxhZ3N9YCk7XG5cbiAgICAgICAgICAgICAgY29uc3QgcGF0aCA9XG4gICAgICAgICAgICAgICAgek5hbWUgJiYgd2FzbS5wZWVrOCh6TmFtZSlcbiAgICAgICAgICAgICAgICAgID8gcG9vbC5nZXRQYXRoKHpOYW1lKVxuICAgICAgICAgICAgICAgICAgOiBnZXRSYW5kb21OYW1lKCk7XG4gICAgICAgICAgICAgIGxldCBzYWggPSBwb29sLmdldFNBSEZvclBhdGgocGF0aCk7XG4gICAgICAgICAgICAgIGlmICghc2FoICYmIGZsYWdzICYgY2FwaS5TUUxJVEVfT1BFTl9DUkVBVEUpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9vbC5nZXRGaWxlQ291bnQoKSA8IHBvb2wuZ2V0Q2FwYWNpdHkoKSkge1xuICAgICAgICAgICAgICAgICAgc2FoID0gcG9vbC5uZXh0QXZhaWxhYmxlU0FIKCk7XG4gICAgICAgICAgICAgICAgICBwb29sLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgcGF0aCwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b3NzKCdTQUggcG9vbCBpcyBmdWxsLiBDYW5ub3QgY3JlYXRlIGZpbGUnLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzYWgpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdmaWxlIG5vdCBmb3VuZDonLCBwYXRoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB7IHBhdGgsIGZsYWdzLCBzYWggfTtcbiAgICAgICAgICAgICAgcG9vbC5tYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmaWxlKTtcbiAgICAgICAgICAgICAgZmlsZS5sb2NrVHlwZSA9IGNhcGkuU1FMSVRFX0xPQ0tfTk9ORTtcbiAgICAgICAgICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBjYXBpLnNxbGl0ZTNfZmlsZShwRmlsZSk7XG4gICAgICAgICAgICAgIHNxM0ZpbGUuJHBNZXRob2RzID0gb3Bmc0lvTWV0aG9kcy5wb2ludGVyO1xuICAgICAgICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlMzIocE91dEZsYWdzLCBmbGFncyk7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBwb29sLnN0b3JlRXJyKGUpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjcmVhdGVPcGZzVmZzID0gZnVuY3Rpb24gKHZmc05hbWUpIHtcbiAgICAgICAgICBpZiAoc3FsaXRlMy5jYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodmZzTmFtZSkpIHtcbiAgICAgICAgICAgIHRvc3MzKCdWRlMgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQ6JywgdmZzTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9wZnNWZnMgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcygpO1xuXG4gICAgICAgICAgY29uc3QgcERWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQobnVsbCk7XG4gICAgICAgICAgY29uc3QgZFZmcyA9IHBEVmZzID8gbmV3IGNhcGkuc3FsaXRlM192ZnMocERWZnMpIDogbnVsbDtcbiAgICAgICAgICBvcGZzVmZzLiRpVmVyc2lvbiA9IDI7XG4gICAgICAgICAgb3Bmc1Zmcy4kc3pPc0ZpbGUgPSBjYXBpLnNxbGl0ZTNfZmlsZS5zdHJ1Y3RJbmZvLnNpemVvZjtcbiAgICAgICAgICBvcGZzVmZzLiRteFBhdGhuYW1lID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gICAgICAgICAgb3Bmc1Zmcy5hZGRPbkRpc3Bvc2UoXG4gICAgICAgICAgICAob3Bmc1Zmcy4kek5hbWUgPSB3YXNtLmFsbG9jQ1N0cmluZyh2ZnNOYW1lKSksXG4gICAgICAgICAgICAoKSA9PiBzZXRQb29sRm9yVmZzKG9wZnNWZnMucG9pbnRlciwgMCksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChkVmZzKSB7XG4gICAgICAgICAgICBvcGZzVmZzLiR4UmFuZG9tbmVzcyA9IGRWZnMuJHhSYW5kb21uZXNzO1xuICAgICAgICAgICAgb3Bmc1Zmcy4keFNsZWVwID0gZFZmcy4keFNsZWVwO1xuICAgICAgICAgICAgZFZmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3Bmc1Zmcy4keFJhbmRvbW5lc3MgJiYgIXZmc01ldGhvZHMueFJhbmRvbW5lc3MpIHtcbiAgICAgICAgICAgIHZmc01ldGhvZHMueFJhbmRvbW5lc3MgPSBmdW5jdGlvbiAocFZmcywgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICBmb3IgKDsgaSA8IG5PdXQ7ICsraSlcbiAgICAgICAgICAgICAgICBoZWFwW3BPdXQgKyBpXSA9IChNYXRoLnJhbmRvbSgpICogMjU1MDAwKSAmIDB4ZmY7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFvcGZzVmZzLiR4U2xlZXAgJiYgIXZmc01ldGhvZHMueFNsZWVwKSB7XG4gICAgICAgICAgICB2ZnNNZXRob2RzLnhTbGVlcCA9IChwVmZzLCBtcykgPT4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3FsaXRlMy52ZnMuaW5zdGFsbFZmcyh7XG4gICAgICAgICAgICB2ZnM6IHsgc3RydWN0OiBvcGZzVmZzLCBtZXRob2RzOiB2ZnNNZXRob2RzIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG9wZnNWZnM7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xhc3MgT3Bmc1NBSFBvb2wge1xuICAgICAgICAgIHZmc0RpcjtcblxuICAgICAgICAgICNkaFZmc1Jvb3Q7XG5cbiAgICAgICAgICAjZGhPcGFxdWU7XG5cbiAgICAgICAgICAjZGhWZnNQYXJlbnQ7XG5cbiAgICAgICAgICAjbWFwU0FIVG9OYW1lID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgI21hcEZpbGVuYW1lVG9TQUggPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAjYXZhaWxhYmxlU0FIID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgI21hcFMzRmlsZVRvT0ZpbGVfID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgI2FwQm9keSA9IG5ldyBVaW50OEFycmF5KEhFQURFUl9DT1JQVVNfU0laRSk7XG5cbiAgICAgICAgICAjZHZCb2R5O1xuXG4gICAgICAgICAgI2NWZnM7XG5cbiAgICAgICAgICAjdmVyYm9zaXR5O1xuXG4gICAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuI3ZlcmJvc2l0eSA9IG9wdGlvbnMudmVyYm9zaXR5ID8/IG9wdGlvbkRlZmF1bHRzLnZlcmJvc2l0eTtcbiAgICAgICAgICAgIHRoaXMudmZzTmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25EZWZhdWx0cy5uYW1lO1xuICAgICAgICAgICAgdGhpcy4jY1ZmcyA9IGNyZWF0ZU9wZnNWZnModGhpcy52ZnNOYW1lKTtcbiAgICAgICAgICAgIHNldFBvb2xGb3JWZnModGhpcy4jY1Zmcy5wb2ludGVyLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmZzRGlyID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgJy4nICsgdGhpcy52ZnNOYW1lO1xuICAgICAgICAgICAgdGhpcy4jZHZCb2R5ID0gbmV3IERhdGFWaWV3KFxuICAgICAgICAgICAgICB0aGlzLiNhcEJvZHkuYnVmZmVyLFxuICAgICAgICAgICAgICB0aGlzLiNhcEJvZHkuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0aGlzLnJlc2V0KFxuICAgICAgICAgICAgICAhIShvcHRpb25zLmNsZWFyT25Jbml0ID8/IG9wdGlvbkRlZmF1bHRzLmNsZWFyT25Jbml0KSxcbiAgICAgICAgICAgICkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLiRlcnJvcikgdGhyb3cgdGhpcy4kZXJyb3I7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhcGFjaXR5KClcbiAgICAgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmFkZENhcGFjaXR5KFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmluaXRpYWxDYXBhY2l0eSB8fCBvcHRpb25EZWZhdWx0cy5pbml0aWFsQ2FwYWNpdHksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgI2xvZ0ltcGwobGV2ZWwsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2ZXJib3NpdHkgPiBsZXZlbClcbiAgICAgICAgICAgICAgbG9nZ2Vyc1tsZXZlbF0odGhpcy52ZnNOYW1lICsgJzonLCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ0ltcGwoMiwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICAgICAgdGhpcy4jbG9nSW1wbCgxLCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICAgICAgdGhpcy4jbG9nSW1wbCgwLCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRWZnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jY1ZmcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRDYXBhY2l0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXBTQUhUb05hbWUuc2l6ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRGaWxlQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5zaXplO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldEZpbGVOYW1lcygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICAgICAgICBjb25zdCBpdGVyID0gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5rZXlzKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgaXRlcikgcmMucHVzaChuKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyBhZGRDYXBhY2l0eShuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICAgICAgICBjb25zdCBoID0gYXdhaXQgdGhpcy4jZGhPcGFxdWUuZ2V0RmlsZUhhbmRsZShuYW1lLCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLnNldChhaCwgbmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoYWgsICcnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhcGFjaXR5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVkdWNlQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgbGV0IG5SbSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFoIG9mIEFycmF5LmZyb20odGhpcy4jYXZhaWxhYmxlU0FIKSkge1xuICAgICAgICAgICAgICBpZiAoblJtID09PSBuIHx8IHRoaXMuZ2V0RmlsZUNvdW50KCkgPT09IHRoaXMuZ2V0Q2FwYWNpdHkoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLiNtYXBTQUhUb05hbWUuZ2V0KGFoKTtcblxuICAgICAgICAgICAgICBhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaE9wYXF1ZS5yZW1vdmVFbnRyeShuYW1lKTtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLmRlbGV0ZShhaCk7XG4gICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoYWgpO1xuICAgICAgICAgICAgICArK25SbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuUm07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVsZWFzZUFjY2Vzc0hhbmRsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFoIG9mIHRoaXMuI21hcFNBSFRvTmFtZS5rZXlzKCkpIGFoLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLiNtYXBTQUhUb05hbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5jbGVhcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIGFjcXVpcmVBY2Nlc3NIYW5kbGVzKGNsZWFyRmlsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gW107XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IFtuYW1lLCBoXSBvZiB0aGlzLiNkaE9wYXF1ZSkge1xuICAgICAgICAgICAgICBpZiAoJ2ZpbGUnID09PSBoLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKFtuYW1lLCBoXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgZmlsZXMubWFwKGFzeW5jIChbbmFtZSwgaF0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5zZXQoYWgsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNsZWFyRmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChhaCwgJycsIDApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZ2V0QXNzb2NpYXRlZFBhdGgoYWgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2V0KHBhdGgsIGFoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguYWRkKGFoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVFcnIoZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VBY2Nlc3NIYW5kbGVzKCk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldEFzc29jaWF0ZWRQYXRoKHNhaCkge1xuICAgICAgICAgICAgc2FoLnJlYWQodGhpcy4jYXBCb2R5LCB7IGF0OiAwIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHRoaXMuI2R2Qm9keS5nZXRVaW50MzIoSEVBREVSX09GRlNFVF9GTEFHUyk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMuI2FwQm9keVswXSAmJlxuICAgICAgICAgICAgICAoZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UgfHxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQRVJTSVNURU5UX0ZJTEVfVFlQRVMpID09PSAwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgYFJlbW92aW5nIGZpbGUgd2l0aCB1bmV4cGVjdGVkIGZsYWdzICR7ZmxhZ3MudG9TdHJpbmcoMTYpfWAsXG4gICAgICAgICAgICAgICAgdGhpcy4jYXBCb2R5LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVEaWdlc3QgPSBuZXcgVWludDMyQXJyYXkoSEVBREVSX0RJR0VTVF9TSVpFIC8gNCk7XG4gICAgICAgICAgICBzYWgucmVhZChmaWxlRGlnZXN0LCB7IGF0OiBIRUFERVJfT0ZGU0VUX0RJR0VTVCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBEaWdlc3QgPSB0aGlzLmNvbXB1dGVEaWdlc3QodGhpcy4jYXBCb2R5KTtcbiAgICAgICAgICAgIGlmIChmaWxlRGlnZXN0LmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBjb21wRGlnZXN0W2ldKSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoQnl0ZXMgPSB0aGlzLiNhcEJvZHkuZmluZEluZGV4KCh2KSA9PiAwID09PSB2KTtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHBhdGhCeXRlcykge1xuICAgICAgICAgICAgICAgIHNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwYXRoQnl0ZXNcbiAgICAgICAgICAgICAgICA/IHRleHREZWNvZGVyLmRlY29kZSh0aGlzLiNhcEJvZHkuc3ViYXJyYXkoMCwgcGF0aEJ5dGVzKSlcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybignRGlzYXNzb2NpYXRpbmcgZmlsZSB3aXRoIGJhZCBkaWdlc3QuJyk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRBc3NvY2lhdGVkUGF0aChzYWgsIHBhdGgsIGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmMgPSB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHBhdGgsIHRoaXMuI2FwQm9keSk7XG4gICAgICAgICAgICBpZiAoSEVBREVSX01BWF9QQVRIX1NJWkUgPD0gZW5jLndyaXR0ZW4gKyAxKSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1BhdGggdG9vIGxvbmc6JywgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNhcEJvZHkuZmlsbCgwLCBlbmMud3JpdHRlbiwgSEVBREVSX01BWF9QQVRIX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy4jZHZCb2R5LnNldFVpbnQzMihIRUFERVJfT0ZGU0VUX0ZMQUdTLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IHRoaXMuY29tcHV0ZURpZ2VzdCh0aGlzLiNhcEJvZHkpO1xuICAgICAgICAgICAgc2FoLndyaXRlKHRoaXMuI2FwQm9keSwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgIHNhaC53cml0ZShkaWdlc3QsIHsgYXQ6IEhFQURFUl9PRkZTRVRfRElHRVNUIH0pO1xuICAgICAgICAgICAgc2FoLmZsdXNoKCk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2V0KHBhdGgsIHNhaCk7XG4gICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoc2FoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguYWRkKHNhaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tcHV0ZURpZ2VzdChieXRlQXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBoMSA9IDB4ZGVhZGJlZWY7XG4gICAgICAgICAgICBsZXQgaDIgPSAweDQxYzZjZTU3O1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJ5dGVBcnJheSkge1xuICAgICAgICAgICAgICBoMSA9IDMxICogaDEgKyB2ICogMzA3O1xuICAgICAgICAgICAgICBoMiA9IDMxICogaDIgKyB2ICogMzA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShbaDEgPj4+IDAsIGgyID4+PiAwXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVzZXQoY2xlYXJGaWxlcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pc1JlYWR5O1xuICAgICAgICAgICAgbGV0IGggPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICAgICAgICAgIGxldCBwcmV2LCBwcmV2TmFtZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZCBvZiB0aGlzLnZmc0Rpci5zcGxpdCgnLycpKSB7XG4gICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGg7XG4gICAgICAgICAgICAgICAgaCA9IGF3YWl0IGguZ2V0RGlyZWN0b3J5SGFuZGxlKGQsIHsgY3JlYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNkaFZmc1Jvb3QgPSBoO1xuICAgICAgICAgICAgdGhpcy4jZGhWZnNQYXJlbnQgPSBwcmV2O1xuICAgICAgICAgICAgdGhpcy4jZGhPcGFxdWUgPSBhd2FpdCB0aGlzLiNkaFZmc1Jvb3QuZ2V0RGlyZWN0b3J5SGFuZGxlKFxuICAgICAgICAgICAgICBPUEFRVUVfRElSX05BTUUsXG4gICAgICAgICAgICAgIHsgY3JlYXRlOiB0cnVlIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlQWNjZXNzSGFuZGxlcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNxdWlyZUFjY2Vzc0hhbmRsZXMoY2xlYXJGaWxlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0UGF0aChhcmcpIHtcbiAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGFyZykpIGFyZyA9IHdhc20uY3N0clRvSnMoYXJnKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGFyZyBpbnN0YW5jZW9mIFVSTCA/IGFyZyA6IG5ldyBVUkwoYXJnLCAnZmlsZTovL2xvY2FsaG9zdC8nKVxuICAgICAgICAgICAgKS5wYXRobmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGVQYXRoKHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhaCA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KHBhdGgpO1xuICAgICAgICAgICAgaWYgKHNhaCkge1xuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIXNhaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdG9yZUVycihlLCBjb2RlKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICBlLnNxbGl0ZTNSYyA9IGNvZGUgfHwgY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRlcnJvciA9IGU7XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3BFcnIoKSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHRoaXMuJGVycm9yO1xuICAgICAgICAgICAgdGhpcy4kZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dEF2YWlsYWJsZVNBSCgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtyY10gPSB0aGlzLiNhdmFpbGFibGVTQUgua2V5cygpO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uZ2V0KHBGaWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmaWxlKSB7XG4gICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICB0aGlzLiNtYXBTM0ZpbGVUb09GaWxlXy5zZXQocEZpbGUsIGZpbGUpO1xuICAgICAgICAgICAgICBzZXRQb29sRm9yUEZpbGUocEZpbGUsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uZGVsZXRlKHBGaWxlKTtcbiAgICAgICAgICAgICAgc2V0UG9vbEZvclBGaWxlKHBGaWxlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzRmlsZW5hbWUobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguaGFzKG5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFNBSEZvclBhdGgocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlbW92ZVZmcygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jY1Zmcy5wb2ludGVyIHx8ICF0aGlzLiNkaE9wYXF1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHRoaXMuI2NWZnMucG9pbnRlcik7XG4gICAgICAgICAgICB0aGlzLiNjVmZzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGhWZnNSb290LnJlbW92ZUVudHJ5KE9QQVFVRV9ESVJfTkFNRSwge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuI2RoT3BhcXVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaFZmc1BhcmVudC5yZW1vdmVFbnRyeSh0aGlzLiNkaFZmc1Jvb3QubmFtZSwge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuI2RoVmZzUm9vdCA9IHRoaXMuI2RoVmZzUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcih0aGlzLnZmc05hbWUsICdyZW1vdmVWZnMoKSBmYWlsZWQ6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRGaWxlKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhaCA9XG4gICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KG5hbWUpIHx8IHRvc3MoJ0ZpbGUgbm90IGZvdW5kOicsIG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbiA9IHNhaC5nZXRTaXplKCkgLSBIRUFERVJfT0ZGU0VUX0RBVEE7XG4gICAgICAgICAgICBjb25zdCBiID0gbmV3IFVpbnQ4QXJyYXkobiA+IDAgPyBuIDogMCk7XG4gICAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgblJlYWQgPSBzYWgucmVhZChiLCB7IGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgfSk7XG4gICAgICAgICAgICAgIGlmIChuUmVhZCAhPSBuKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCB0byByZWFkICcgKyBuICsgJyBieXRlcyBidXQgcmVhZCAnICsgblJlYWQgKyAnLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgaW1wb3J0RGJDaHVua2VkKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBzYWggPVxuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKSB8fFxuICAgICAgICAgICAgICB0aGlzLm5leHRBdmFpbGFibGVTQUgoKSB8fFxuICAgICAgICAgICAgICB0b3NzKCdObyBhdmFpbGFibGUgaGFuZGxlcyB0byBpbXBvcnQgdG8uJyk7XG4gICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICBsZXQgbldyb3RlID0gMCxcbiAgICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aGlsZSAodW5kZWZpbmVkICE9PSAoY2h1bmsgPSBhd2FpdCBjYWxsYmFjaygpKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbldyb3RlICYmIGNodW5rLmJ5dGVMZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhaC53cml0ZShjaHVuaywgeyBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgbldyb3RlIH0pO1xuICAgICAgICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuV3JvdGUgPCA1MTIgfHwgMCAhPT0gbldyb3RlICUgNTEyKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICdJbnB1dCBzaXplJyxcbiAgICAgICAgICAgICAgICAgIG5Xcm90ZSxcbiAgICAgICAgICAgICAgICAgICdpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgyMCk7XG4gICAgICAgICAgICAgICAgc2FoLnJlYWQoaGVhZGVyLCB7IGF0OiAwIH0pO1xuICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsIDFdKSwge1xuICAgICAgICAgICAgICAgIGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyAxOCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgbmFtZSwgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCKTtcbiAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW1wb3J0RGIobmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydERiQ2h1bmtlZChuYW1lLCBieXRlcyk7XG4gICAgICAgICAgICBjb25zdCBzYWggPVxuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKSB8fFxuICAgICAgICAgICAgICB0aGlzLm5leHRBdmFpbGFibGVTQUgoKSB8fFxuICAgICAgICAgICAgICB0b3NzKCdObyBhdmFpbGFibGUgaGFuZGxlcyB0byBpbXBvcnQgdG8uJyk7XG4gICAgICAgICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuIDwgNTEyIHx8IG4gJSA1MTIgIT0gMCkge1xuICAgICAgICAgICAgICB0b3NzKCdCeXRlIGFycmF5IHNpemUgaXMgaW52YWxpZCBmb3IgYW4gU1FMaXRlIGRiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gJ1NRTGl0ZSBmb3JtYXQgMyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoaGVhZGVyLmNoYXJDb2RlQXQoaSkgIT09IGJ5dGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUgZGF0YWJhc2UgaGVhZGVyLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuV3JvdGUgPSBzYWgud3JpdGUoYnl0ZXMsIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSB9KTtcbiAgICAgICAgICAgIGlmIChuV3JvdGUgIT0gbikge1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCB0byB3cml0ZSAnICsgbiArICcgYnl0ZXMgYnV0IHdyb3RlICcgKyBuV3JvdGUgKyAnLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsIDFdKSwge1xuICAgICAgICAgICAgICAgIGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyAxOCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBuYW1lLCBjYXBpLlNRTElURV9PUEVOX01BSU5fREIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5Xcm90ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzcyBPcGZzU0FIUG9vbFV0aWwge1xuICAgICAgICAgICNwO1xuXG4gICAgICAgICAgY29uc3RydWN0b3Ioc2FoUG9vbCkge1xuICAgICAgICAgICAgdGhpcy4jcCA9IHNhaFBvb2w7XG4gICAgICAgICAgICB0aGlzLnZmc05hbWUgPSBzYWhQb29sLnZmc05hbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgYWRkQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuYWRkQ2FwYWNpdHkobik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVkdWNlQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AucmVkdWNlQ2FwYWNpdHkobik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0Q2FwYWNpdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC5nZXRDYXBhY2l0eSh0aGlzLiNwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRGaWxlQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC5nZXRGaWxlQ291bnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0RmlsZU5hbWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZ2V0RmlsZU5hbWVzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVzZXJ2ZU1pbmltdW1DYXBhY2l0eShtaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLiNwLmdldENhcGFjaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gYyA8IG1pbiA/IHRoaXMuI3AuYWRkQ2FwYWNpdHkobWluIC0gYykgOiBjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydEZpbGUobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZXhwb3J0RmlsZShuYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbXBvcnREYihuYW1lLCBieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuaW1wb3J0RGIobmFtZSwgYnl0ZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHdpcGVGaWxlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLnJlc2V0KHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVubGluayhmaWxlbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZGVsZXRlUGF0aChmaWxlbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVtb3ZlVmZzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AucmVtb3ZlVmZzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbkNoZWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRoID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgICAgICAgY29uc3QgZm4gPSAnLm9wZnMtc2FocG9vbC1zeW5jLWNoZWNrLScgKyBnZXRSYW5kb21OYW1lKCk7XG4gICAgICAgICAgY29uc3QgZmggPSBhd2FpdCBkaC5nZXRGaWxlSGFuZGxlKGZuLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCBhaCA9IGF3YWl0IGZoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICBjb25zdCBjbG9zZSA9IGFoLmNsb3NlKCk7XG4gICAgICAgICAgYXdhaXQgY2xvc2U7XG4gICAgICAgICAgYXdhaXQgZGgucmVtb3ZlRW50cnkoZm4pO1xuICAgICAgICAgIGlmIChjbG9zZT8udGhlbikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ1RoZSBsb2NhbCBPUEZTIEFQSSBpcyB0b28gb2xkIGZvciBvcGZzLXNhaHBvb2w6JyxcbiAgICAgICAgICAgICAgJ2l0IGhhcyBhbiBhc3luYyBGaWxlU3lzdGVtU3luY0FjY2Vzc0hhbmRsZS5jbG9zZSgpIG1ldGhvZC4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGluc3RhbmNlQ291bnRlciA9IDA7XG5cbiAgICAgICAgc3FsaXRlMy5pbnN0YWxsT3Bmc1NBSFBvb2xWZnMgPSBhc3luYyBmdW5jdGlvbiAoXG4gICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHZmc05hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9uRGVmYXVsdHMubmFtZTtcbiAgICAgICAgICBpZiAoMCAmJiAyID09PSArK2luc3RhbmNlQ291bnRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKdXN0IHRlc3RpbmcgcmVqZWN0aW9uLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5pdFByb21pc2VzW3Zmc05hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdFByb21pc2VzW3Zmc05hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUucHJvdG90eXBlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgfHxcbiAgICAgICAgICAgICFuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChpbml0UHJvbWlzZXNbdmZzTmFtZV0gPSBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIE9QRlMgQVBJcy4nKSxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gYXBpVmVyc2lvbkNoZWNrKClcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuJHRlc3RUaHJvd0luSW5pdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG9wdGlvbnMuJHRlc3RUaHJvd0luSW5pdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB0aGVQb29sID0gbmV3IE9wZnNTQUhQb29sKG9wdGlvbnMpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhlUG9vbC5pc1JlYWR5XG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcG9vbFV0aWwgPSBuZXcgT3Bmc1NBSFBvb2xVdGlsKHRoZVBvb2wpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNxbGl0ZTMub28xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9vMSA9IHNxbGl0ZTMub28xO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGVWZnMgPSB0aGVQb29sLmdldFZmcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBPcGZzU0FIUG9vbERiID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBvbzEuREIuZGJDdG9ySGVscGVyLm5vcm1hbGl6ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0LnZmcyA9IHRoZVZmcy4kek5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgb28xLkRCLmRiQ3RvckhlbHBlci5jYWxsKHRoaXMsIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIE9wZnNTQUhQb29sRGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvbzEuREIucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICBwb29sVXRpbC5PcGZzU0FIUG9vbERiID0gT3Bmc1NBSFBvb2xEYjtcbiAgICAgICAgICAgICAgICAgICAgb28xLkRCLmRiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlblNxbChcbiAgICAgICAgICAgICAgICAgICAgICB0aGVWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob28xRGIsIHNxbGl0ZTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2V4ZWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9vMURiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByYWdtYSBqb3VybmFsX21vZGU9REVMRVRFOycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByYWdtYSBjYWNoZV9zaXplPS0xNjM4NDsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhlUG9vbC5sb2coJ1ZGUyBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwb29sVXRpbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhlUG9vbC5yZW1vdmVWZnMoKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgU0FCQyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHBvcnRzOlxuICAgICAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdhc21FeHBvcnRzID8gTW9kdWxlWydhc20nXSA6IHdhc21FeHBvcnRzLFxuICAgICAgICAgICAgbWVtb3J5OiBNb2R1bGUud2FzbU1lbW9yeSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fCB7fSxcbiAgICAgICAgKTtcblxuICAgICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgPSBTQUJDO1xuICAgICAgICBsZXQgc3FsaXRlMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzcWxpdGUzID0gZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzQXBpQm9vdHN0cmFwKCkgZXJyb3I6JywgZSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwO1xuICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWc7XG4gICAgICAgIH1cblxuICAgICAgICBNb2R1bGUuc3FsaXRlMyA9IHNxbGl0ZTM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoaXMgaXMgbm90IHJ1bm5pbmcgaW4gYW4gRW1zY3JpcHRlbiBtb2R1bGUgY29udGV4dCwgc28nLFxuICAgICAgICAgICdnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAoKSBpcyBfbm90XyBiZWluZyBjYWxsZWQgZHVlIHRvIGxhY2snLFxuICAgICAgICAgICdvZiBjb25maWcgaW5mbyBmb3IgdGhlIFdBU00gZW52aXJvbm1lbnQuJyxcbiAgICAgICAgICAnSXQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkuJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzcWxpdGUzSW5pdE1vZHVsZS5yZWFkeTtcbiAgfTtcbn0pKCk7XG5cbmNvbnN0IHRvRXhwb3J0Rm9yRVNNID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgb3JpZ2luYWxJbml0ID0gc3FsaXRlM0luaXRNb2R1bGU7XG4gIGlmICghb3JpZ2luYWxJbml0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0V4cGVjdGluZyBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlIHRvIGJlIGRlZmluZWQgYnkgdGhlIEVtc2NyaXB0ZW4gYnVpbGQuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW5pdE1vZHVsZVN0YXRlID0gKGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICB7XG4gICAgICBtb2R1bGVTY3JpcHQ6IGdsb2JhbFRoaXM/LmRvY3VtZW50Py5jdXJyZW50U2NyaXB0LFxuICAgICAgaXNXb3JrZXI6ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUsXG4gICAgICBsb2NhdGlvbjogZ2xvYmFsVGhpcy5sb2NhdGlvbixcbiAgICAgIHVybFBhcmFtczogZ2xvYmFsVGhpcz8ubG9jYXRpb24/LmhyZWZcbiAgICAgICAgPyBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zXG4gICAgICAgIDogbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxuICAgIH0sXG4gICkpO1xuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUgPSBpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcyhcbiAgICAnc3FsaXRlMy5kZWJ1Z01vZHVsZScsXG4gIClcbiAgICA/ICguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4oJ3NxbGl0ZTMuZGVidWdNb2R1bGU6JywgLi4uYXJncylcbiAgICA6ICgpID0+IHt9O1xuXG4gIGlmIChpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcygnc3FsaXRlMy5kaXInKSkge1xuICAgIGluaXRNb2R1bGVTdGF0ZS5zcWxpdGUzRGlyID1cbiAgICAgIGluaXRNb2R1bGVTdGF0ZS51cmxQYXJhbXMuZ2V0KCdzcWxpdGUzLmRpcicpICsgJy8nO1xuICB9IGVsc2UgaWYgKGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQpIHtcbiAgICBjb25zdCBsaSA9IGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQuc3JjLnNwbGl0KCcvJyk7XG4gICAgbGkucG9wKCk7XG4gICAgaW5pdE1vZHVsZVN0YXRlLnNxbGl0ZTNEaXIgPSBsaS5qb2luKCcvJykgKyAnLyc7XG4gIH1cblxuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlID0gZnVuY3Rpb24gZmYoLi4uYXJncykge1xuICAgIHJldHVybiBvcmlnaW5hbEluaXQoLi4uYXJncylcbiAgICAgIC50aGVuKChFbXNjcmlwdGVuTW9kdWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBFbXNjcmlwdGVuTW9kdWxlLnNxbGl0ZTM7XG4gICAgICAgIHMuc2NyaXB0SW5mbyA9IGluaXRNb2R1bGVTdGF0ZTtcblxuICAgICAgICBpZiAoZmYuX19pc1VuZGVyVGVzdCkgcy5fX2lzVW5kZXJUZXN0ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZiA9IHMuYXN5bmNQb3N0SW5pdDtcbiAgICAgICAgZGVsZXRlIHMuYXN5bmNQb3N0SW5pdDtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIGxvYWRpbmcgc3FsaXRlMyBtb2R1bGU6JywgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgfTtcbiAgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZS5yZWFkeSA9IG9yaWdpbmFsSW5pdC5yZWFkeTtcblxuICBpZiAoZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlLm1vZHVsZVNjcmlwdCkge1xuICAgIGNvbnN0IHNpbSA9IGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZTtcbiAgICBsZXQgc3JjID0gc2ltLm1vZHVsZVNjcmlwdC5zcmMuc3BsaXQoJy8nKTtcbiAgICBzcmMucG9wKCk7XG4gICAgc2ltLnNjcmlwdERpciA9IHNyYy5qb2luKCcvJykgKyAnLyc7XG4gIH1cbiAgaW5pdE1vZHVsZVN0YXRlLmRlYnVnTW9kdWxlKCdzcWxpdGUzSW5pdE1vZHVsZVN0YXRlID0nLCBpbml0TW9kdWxlU3RhdGUpO1xuICBpZiAoMCkge1xuICAgIGNvbnNvbGUud2FybignUmVwbGFjZWQgc3FsaXRlM0luaXRNb2R1bGUoKScpO1xuICAgIGNvbnNvbGUud2FybignZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmID0nLCBnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYpO1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGRvY3VtZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA9JyxcbiAgICAgICAgZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQ/LnNyYyxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlO1xufSkoKTtcbnNxbGl0ZTNJbml0TW9kdWxlID0gdG9FeHBvcnRGb3JFU007XG5leHBvcnQgZGVmYXVsdCBzcWxpdGUzSW5pdE1vZHVsZTtcbiIsIi8qXG4gIDIwMjItMDgtMjRcblxuICBUaGUgYXV0aG9yIGRpc2NsYWltcyBjb3B5cmlnaHQgdG8gdGhpcyBzb3VyY2UgY29kZS4gIEluIHBsYWNlIG9mIGFcbiAgbGVnYWwgbm90aWNlLCBoZXJlIGlzIGEgYmxlc3Npbmc6XG5cbiAgKiAgIE1heSB5b3UgZG8gZ29vZCBhbmQgbm90IGV2aWwuXG4gICogICBNYXkgeW91IGZpbmQgZm9yZ2l2ZW5lc3MgZm9yIHlvdXJzZWxmIGFuZCBmb3JnaXZlIG90aGVycy5cbiAgKiAgIE1heSB5b3Ugc2hhcmUgZnJlZWx5LCBuZXZlciB0YWtpbmcgbW9yZSB0aGFuIHlvdSBnaXZlLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgVGhpcyBmaWxlIGltcGxlbWVudHMgYSBQcm9taXNlLWJhc2VkIHByb3h5IGZvciB0aGUgc3FsaXRlMyBXb3JrZXJcbiAgQVBJICMxLiBJdCBpcyBpbnRlbmRlZCB0byBiZSBpbmNsdWRlZCBlaXRoZXIgZnJvbSB0aGUgbWFpbiB0aHJlYWQgb3JcbiAgYSBXb3JrZXIsIGJ1dCBvbmx5IGlmIChBKSB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgbmVzdGVkIFdvcmtlcnNcbiAgYW5kIChCKSBpdCdzIF9ub3RfIGEgV29ya2VyIHdoaWNoIGxvYWRzIHRoZSBzcWxpdGUzIFdBU00vSlNcbiAgbW9kdWxlLiBUaGlzIGZpbGUncyBmZWF0dXJlcyB3aWxsIGxvYWQgdGhhdCBtb2R1bGUgYW5kIHByb3ZpZGUgYVxuICBzbGlnaHRseSBzaW1wbGVyIGNsaWVudC1zaWRlIGludGVyZmFjZSB0aGFuIHRoZSBzbGlnaHRseS1sb3dlci1sZXZlbFxuICBXb3JrZXIgQVBJIGRvZXMuXG5cbiAgVGhpcyBzY3JpcHQgbmVjZXNzYXJpbHkgZXhwb3NlcyBvbmUgZ2xvYmFsIHN5bWJvbCwgYnV0IGNsaWVudHMgbWF5XG4gIGZyZWVseSBgZGVsZXRlYCB0aGF0IHN5bWJvbCBhZnRlciBjYWxsaW5nIGl0LlxuKi9cbid1c2Ugc3RyaWN0JztcblxuZ2xvYmFsVGhpcy5zcWxpdGUzV29ya2VyMVByb21pc2VyID0gZnVuY3Rpb24gY2FsbGVlKFxuICBjb25maWcgPSBjYWxsZWUuZGVmYXVsdENvbmZpZyxcbikge1xuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgY29uc3QgZiA9IGNvbmZpZztcbiAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGNhbGxlZS5kZWZhdWx0Q29uZmlnKTtcbiAgICBjb25maWcub25yZWFkeSA9IGY7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBjYWxsZWUuZGVmYXVsdENvbmZpZywgY29uZmlnKTtcbiAgfVxuICBjb25zdCBoYW5kbGVyTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICBjb25zdCBlcnIgPSBjb25maWcub25lcnJvciB8fCBub29wO1xuICBjb25zdCBkZWJ1ZyA9IGNvbmZpZy5kZWJ1ZyB8fCBub29wO1xuICBjb25zdCBpZFR5cGVNYXAgPSBjb25maWcuZ2VuZXJhdGVNZXNzYWdlSWQgPyB1bmRlZmluZWQgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBnZW5Nc2dJZCA9XG4gICAgY29uZmlnLmdlbmVyYXRlTWVzc2FnZUlkIHx8XG4gICAgZnVuY3Rpb24gKG1zZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbXNnLnR5cGUgKyAnIycgKyAoaWRUeXBlTWFwW21zZy50eXBlXSA9IChpZFR5cGVNYXBbbXNnLnR5cGVdIHx8IDApICsgMSlcbiAgICAgICk7XG4gICAgfTtcbiAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgfTtcbiAgaWYgKCFjb25maWcud29ya2VyKSBjb25maWcud29ya2VyID0gY2FsbGVlLmRlZmF1bHRDb25maWcud29ya2VyO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbmZpZy53b3JrZXIpIGNvbmZpZy53b3JrZXIgPSBjb25maWcud29ya2VyKCk7XG4gIGxldCBkYklkO1xuICBjb25maWcud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIGV2ID0gZXYuZGF0YTtcbiAgICBkZWJ1Zygnd29ya2VyMS5vbm1lc3NhZ2UnLCBldik7XG4gICAgbGV0IG1zZ0hhbmRsZXIgPSBoYW5kbGVyTWFwW2V2Lm1lc3NhZ2VJZF07XG4gICAgaWYgKCFtc2dIYW5kbGVyKSB7XG4gICAgICBpZiAoZXYgJiYgJ3NxbGl0ZTMtYXBpJyA9PT0gZXYudHlwZSAmJiAnd29ya2VyMS1yZWFkeScgPT09IGV2LnJlc3VsdCkge1xuICAgICAgICBpZiAoY29uZmlnLm9ucmVhZHkpIGNvbmZpZy5vbnJlYWR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1zZ0hhbmRsZXIgPSBoYW5kbGVyTWFwW2V2LnR5cGVdO1xuICAgICAgaWYgKG1zZ0hhbmRsZXIgJiYgbXNnSGFuZGxlci5vbnJvdykge1xuICAgICAgICBtc2dIYW5kbGVyLm9ucm93KGV2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5vbnVuaGFuZGxlZCkgY29uZmlnLm9udW5oYW5kbGVkKGFyZ3VtZW50c1swXSk7XG4gICAgICBlbHNlIGVycignc3FsaXRlM1dvcmtlcjFQcm9taXNlcigpIHVuaGFuZGxlZCB3b3JrZXIgbWVzc2FnZTonLCBldik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBoYW5kbGVyTWFwW2V2Lm1lc3NhZ2VJZF07XG4gICAgc3dpdGNoIChldi50eXBlKSB7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIG1zZ0hhbmRsZXIucmVqZWN0KGV2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIGlmICghZGJJZCkgZGJJZCA9IGV2LmRiSWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICBpZiAoZXYuZGJJZCA9PT0gZGJJZCkgZGJJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG1zZ0hhbmRsZXIucmVzb2x2ZShldik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXNnSGFuZGxlci5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtc2c7XG4gICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIG1zZyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIG1zZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtc2cudHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG1zZy5hcmdzID0gYXJndW1lbnRzWzFdO1xuICAgICAgbXNnLmRiSWQgPSBtc2cuYXJncy5kYklkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3NzKCdJbnZhbGlkIGFydWdtZW50cyBmb3Igc3FsaXRlM1dvcmtlcjFQcm9taXNlcigpLWNyZWF0ZWQgZmFjdG9yeS4nKTtcbiAgICB9XG4gICAgaWYgKCFtc2cuZGJJZCAmJiBtc2cudHlwZSAhPT0gJ29wZW4nKSBtc2cuZGJJZCA9IGRiSWQ7XG4gICAgbXNnLm1lc3NhZ2VJZCA9IGdlbk1zZ0lkKG1zZyk7XG4gICAgbXNnLmRlcGFydHVyZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBwcm94eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcHJveHkubWVzc2FnZSA9IG1zZztcbiAgICBsZXQgcm93Q2FsbGJhY2tJZDtcbiAgICBpZiAoJ2V4ZWMnID09PSBtc2cudHlwZSAmJiBtc2cuYXJncykge1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBtc2cuYXJncy5jYWxsYmFjaykge1xuICAgICAgICByb3dDYWxsYmFja0lkID0gbXNnLm1lc3NhZ2VJZCArICc6cm93JztcbiAgICAgICAgcHJveHkub25yb3cgPSBtc2cuYXJncy5jYWxsYmFjaztcbiAgICAgICAgbXNnLmFyZ3MuY2FsbGJhY2sgPSByb3dDYWxsYmFja0lkO1xuICAgICAgICBoYW5kbGVyTWFwW3Jvd0NhbGxiYWNrSWRdID0gcHJveHk7XG4gICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgbXNnLmFyZ3MuY2FsbGJhY2spIHtcbiAgICAgICAgdG9zcyhcbiAgICAgICAgICAnZXhlYyBjYWxsYmFjayBtYXkgbm90IGJlIGEgc3RyaW5nIHdoZW4gdXNpbmcgdGhlIFByb21pc2UgaW50ZXJmYWNlLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm94eS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb3h5LnJlamVjdCA9IHJlamVjdDtcbiAgICAgIGhhbmRsZXJNYXBbbXNnLm1lc3NhZ2VJZF0gPSBwcm94eTtcbiAgICAgIGRlYnVnKFxuICAgICAgICAnUG9zdGluZycsXG4gICAgICAgIG1zZy50eXBlLFxuICAgICAgICAnbWVzc2FnZSB0byBXb3JrZXIgZGJJZD0nICsgKGRiSWQgfHwgJ2RlZmF1bHQnKSArICc6JyxcbiAgICAgICAgbXNnLFxuICAgICAgKTtcbiAgICAgIGNvbmZpZy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICB9KTtcbiAgICBpZiAocm93Q2FsbGJhY2tJZCkgcCA9IHAuZmluYWxseSgoKSA9PiBkZWxldGUgaGFuZGxlck1hcFtyb3dDYWxsYmFja0lkXSk7XG4gICAgcmV0dXJuIHA7XG4gIH07XG59O1xuZ2xvYmFsVGhpcy5zcWxpdGUzV29ya2VyMVByb21pc2VyLmRlZmF1bHRDb25maWcgPSB7XG4gIHdvcmtlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgV29ya2VyKFxuICAgICAgbmV3IFVSTCgnc3FsaXRlMy13b3JrZXIxLWJ1bmRsZXItZnJpZW5kbHkubWpzJywgaW1wb3J0Lm1ldGEudXJsKSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgICB9LFxuICAgICk7XG4gIH0sXG4gIG9uZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCd3b3JrZXIxIHByb21pc2VyIGVycm9yJywgLi4uYXJncyksXG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbnZhciBpc01vZGVybiA9IChcbiAgdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuKVxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChpbnB1dCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpbnB1dCkuc2xpY2UoOCwgLTEpID09PSAnQXJyYXlCdWZmZXInXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYnl0ZU9mZnNldCA+Pj49IDBcblxuICB2YXIgbWF4TGVuZ3RoID0gb2JqLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0XG5cbiAgaWYgKG1heExlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidvZmZzZXQnIGlzIG91dCBvZiBib3VuZHNcIilcbiAgfVxuXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IG1heExlbmd0aFxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA+Pj49IDBcblxuICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2xlbmd0aCcgaXMgb3V0IG9mIGJvdW5kc1wiKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20ob2JqLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpKVxuICAgIDogbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShvYmouc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCkpKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZylcbiAgICA6IG5ldyBCdWZmZXIoc3RyaW5nLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYnVmZmVyRnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICA6IG5ldyBCdWZmZXIodmFsdWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyRnJvbVxuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGA6cm9vdHstLWR0LXJvdy1zZWxlY3RlZDogMTMsIDExMCwgMjUzOy0tZHQtcm93LXNlbGVjdGVkLXRleHQ6IDI1NSwgMjU1LCAyNTU7LS1kdC1yb3ctc2VsZWN0ZWQtbGluazogOSwgMTAsIDExOy0tZHQtcm93LXN0cmlwZTogMCwgMCwgMDstLWR0LXJvdy1ob3ZlcjogMCwgMCwgMDstLWR0LWNvbHVtbi1vcmRlcmluZzogMCwgMCwgMDstLWR0LWh0bWwtYmFja2dyb3VuZDogd2hpdGV9OnJvb3QuZGFya3stLWR0LWh0bWwtYmFja2dyb3VuZDogcmdiKDMzLCAzNywgNDEpfXRhYmxlLmRhdGFUYWJsZSB0ZC5kdC1jb250cm9se3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjpwb2ludGVyfXRhYmxlLmRhdGFUYWJsZSB0ZC5kdC1jb250cm9sOmJlZm9yZXtkaXNwbGF5OmlubGluZS1ibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29udGVudDpcIlwiO2JvcmRlci10b3A6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjEwcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjUpO2JvcmRlci1ib3R0b206NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDowcHggc29saWQgdHJhbnNwYXJlbnR9dGFibGUuZGF0YVRhYmxlIHRyLmR0LWhhc0NoaWxkIHRkLmR0LWNvbnRyb2w6YmVmb3Jle2JvcmRlci10b3A6MTBweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNSk7Ym9yZGVyLWxlZnQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206MHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo1cHggc29saWQgdHJhbnNwYXJlbnR9dGFibGUuZGF0YVRhYmxlIHRmb290OmVtcHR5e2Rpc3BsYXk6bm9uZX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlIHRkLmR0LWNvbnRyb2w6YmVmb3JlLDpyb290W2RhdGEtYnMtdGhlbWU9ZGFya10gdGFibGUuZGF0YVRhYmxlIHRkLmR0LWNvbnRyb2w6YmVmb3JlLDpyb290W2RhdGEtdGhlbWU9ZGFya10gdGFibGUuZGF0YVRhYmxlIHRkLmR0LWNvbnRyb2w6YmVmb3Jle2JvcmRlci1sZWZ0LWNvbG9yOnJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlIHRyLmR0LWhhc0NoaWxkIHRkLmR0LWNvbnRyb2w6YmVmb3JlLDpyb290W2RhdGEtYnMtdGhlbWU9ZGFya10gdGFibGUuZGF0YVRhYmxlIHRyLmR0LWhhc0NoaWxkIHRkLmR0LWNvbnRyb2w6YmVmb3JlLDpyb290W2RhdGEtdGhlbWU9ZGFya10gdGFibGUuZGF0YVRhYmxlIHRyLmR0LWhhc0NoaWxkIHRkLmR0LWNvbnRyb2w6YmVmb3Jle2JvcmRlci10b3AtY29sb3I6cmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50fWRpdi5kdC1zY3JvbGx7d2lkdGg6MTAwJX1kaXYuZHQtc2Nyb2xsLWJvZHkgdGhlYWQgdHIsZGl2LmR0LXNjcm9sbC1ib2R5IHRmb290IHRye2hlaWdodDowfWRpdi5kdC1zY3JvbGwtYm9keSB0aGVhZCB0ciB0aCxkaXYuZHQtc2Nyb2xsLWJvZHkgdGhlYWQgdHIgdGQsZGl2LmR0LXNjcm9sbC1ib2R5IHRmb290IHRyIHRoLGRpdi5kdC1zY3JvbGwtYm9keSB0Zm9vdCB0ciB0ZHtoZWlnaHQ6MCAhaW1wb3J0YW50O3BhZGRpbmctdG9wOjBweCAhaW1wb3J0YW50O3BhZGRpbmctYm90dG9tOjBweCAhaW1wb3J0YW50O2JvcmRlci10b3Atd2lkdGg6MHB4ICFpbXBvcnRhbnQ7Ym9yZGVyLWJvdHRvbS13aWR0aDowcHggIWltcG9ydGFudH1kaXYuZHQtc2Nyb2xsLWJvZHkgdGhlYWQgdHIgdGggZGl2LmR0LXNjcm9sbC1zaXppbmcsZGl2LmR0LXNjcm9sbC1ib2R5IHRoZWFkIHRyIHRkIGRpdi5kdC1zY3JvbGwtc2l6aW5nLGRpdi5kdC1zY3JvbGwtYm9keSB0Zm9vdCB0ciB0aCBkaXYuZHQtc2Nyb2xsLXNpemluZyxkaXYuZHQtc2Nyb2xsLWJvZHkgdGZvb3QgdHIgdGQgZGl2LmR0LXNjcm9sbC1zaXppbmd7aGVpZ2h0OjAgIWltcG9ydGFudDtvdmVyZmxvdzpoaWRkZW4gIWltcG9ydGFudH10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGg6YWN0aXZlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZDphY3RpdmV7b3V0bGluZTpub25lfXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztib3R0b206NTAlO2NvbnRlbnQ6XCLilrJcIjtjb250ZW50Olwi4payXCIvXCJcIn10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmluZy1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7dG9wOjUwJTtjb250ZW50Olwi4pa8XCI7Y29udGVudDpcIuKWvFwiL1wiXCJ9dGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1hc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1kZXNjLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmluZy1hc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWRlc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1hc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmluZy1hc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWRlc2N7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZy1yaWdodDozMHB4fXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmluZy1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmluZy1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVye3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjEycHg7dG9wOjA7Ym90dG9tOjA7d2lkdGg6MTJweH10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YmVmb3JlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmluZy1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YmVmb3JlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmluZy1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YmVmb3JlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmluZy1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVye2xlZnQ6MDtvcGFjaXR5Oi4xMjU7bGluZS1oZWlnaHQ6OXB4O2ZvbnQtc2l6ZTouOGVtfXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtYXNjLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtZGVzYyx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWFzYyx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWRlc2N7Y3Vyc29yOnBvaW50ZXJ9dGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1hc2M6aG92ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1kZXNjOmhvdmVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtYXNjOmhvdmVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtZGVzYzpob3ZlcntvdXRsaW5lOjJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMDUpO291dGxpbmUtb2Zmc2V0Oi0ycHh9dGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXJ7b3BhY2l0eTouNn10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguc29ydGluZ19kZXNjX2Rpc2FibGVkIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5zb3J0aW5nX2FzY19kaXNhYmxlZCBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLnNvcnRpbmdfZGVzY19kaXNhYmxlZCBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuc29ydGluZ19hc2NfZGlzYWJsZWQgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YmVmb3Jle2Rpc3BsYXk6bm9uZX10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGg6YWN0aXZlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZDphY3RpdmV7b3V0bGluZTpub25lfWRpdi5kdC1zY3JvbGwtYm9keT50YWJsZS5kYXRhVGFibGU+dGhlYWQ+dHI+dGgsZGl2LmR0LXNjcm9sbC1ib2R5PnRhYmxlLmRhdGFUYWJsZT50aGVhZD50cj50ZHtvdmVyZmxvdzpoaWRkZW59OnJvb3QuZGFyayB0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWFzYzpob3Zlciw6cm9vdC5kYXJrIHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtZGVzYzpob3Zlciw6cm9vdC5kYXJrIHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtYXNjOmhvdmVyLDpyb290LmRhcmsgdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjOmhvdmVyLDpyb290W2RhdGEtYnMtdGhlbWU9ZGFya10gdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1hc2M6aG92ZXIsOnJvb3RbZGF0YS1icy10aGVtZT1kYXJrXSB0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWRlc2M6aG92ZXIsOnJvb3RbZGF0YS1icy10aGVtZT1kYXJrXSB0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWFzYzpob3Zlciw6cm9vdFtkYXRhLWJzLXRoZW1lPWRhcmtdIHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtZGVzYzpob3ZlcntvdXRsaW5lOjJweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDUpfWRpdi5kdC1wcm9jZXNzaW5ne3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7d2lkdGg6MjAwcHg7bWFyZ2luLWxlZnQ6LTEwMHB4O21hcmdpbi10b3A6LTIycHg7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzoycHg7ei1pbmRleDoxMH1kaXYuZHQtcHJvY2Vzc2luZz5kaXY6bGFzdC1jaGlsZHtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDo4MHB4O2hlaWdodDoxNXB4O21hcmdpbjoxZW0gYXV0b31kaXYuZHQtcHJvY2Vzc2luZz5kaXY6bGFzdC1jaGlsZD5kaXZ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6MTNweDtoZWlnaHQ6MTNweDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOnJnYigxMywgMTEwLCAyNTMpO2JhY2tncm91bmQ6cmdiKHZhcigtLWR0LXJvdy1zZWxlY3RlZCkpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAsIDEsIDEsIDApfWRpdi5kdC1wcm9jZXNzaW5nPmRpdjpsYXN0LWNoaWxkPmRpdjpudGgtY2hpbGQoMSl7bGVmdDo4cHg7YW5pbWF0aW9uOmRhdGF0YWJsZXMtbG9hZGVyLTEgLjZzIGluZmluaXRlfWRpdi5kdC1wcm9jZXNzaW5nPmRpdjpsYXN0LWNoaWxkPmRpdjpudGgtY2hpbGQoMil7bGVmdDo4cHg7YW5pbWF0aW9uOmRhdGF0YWJsZXMtbG9hZGVyLTIgLjZzIGluZmluaXRlfWRpdi5kdC1wcm9jZXNzaW5nPmRpdjpsYXN0LWNoaWxkPmRpdjpudGgtY2hpbGQoMyl7bGVmdDozMnB4O2FuaW1hdGlvbjpkYXRhdGFibGVzLWxvYWRlci0yIC42cyBpbmZpbml0ZX1kaXYuZHQtcHJvY2Vzc2luZz5kaXY6bGFzdC1jaGlsZD5kaXY6bnRoLWNoaWxkKDQpe2xlZnQ6NTZweDthbmltYXRpb246ZGF0YXRhYmxlcy1sb2FkZXItMyAuNnMgaW5maW5pdGV9QGtleWZyYW1lcyBkYXRhdGFibGVzLWxvYWRlci0xezAle3RyYW5zZm9ybTpzY2FsZSgwKX0xMDAle3RyYW5zZm9ybTpzY2FsZSgxKX19QGtleWZyYW1lcyBkYXRhdGFibGVzLWxvYWRlci0zezAle3RyYW5zZm9ybTpzY2FsZSgxKX0xMDAle3RyYW5zZm9ybTpzY2FsZSgwKX19QGtleWZyYW1lcyBkYXRhdGFibGVzLWxvYWRlci0yezAle3RyYW5zZm9ybTp0cmFuc2xhdGUoMCwgMCl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlKDI0cHgsIDApfX10YWJsZS5kYXRhVGFibGUubm93cmFwIHRoLHRhYmxlLmRhdGFUYWJsZS5ub3dyYXAgdGR7d2hpdGUtc3BhY2U6bm93cmFwfXRhYmxlLmRhdGFUYWJsZSB0aCx0YWJsZS5kYXRhVGFibGUgdGR7Ym94LXNpemluZzpib3JkZXItYm94fXRhYmxlLmRhdGFUYWJsZSB0aC5kdC10eXBlLW51bWVyaWMsdGFibGUuZGF0YVRhYmxlIHRoLmR0LXR5cGUtZGF0ZSx0YWJsZS5kYXRhVGFibGUgdGQuZHQtdHlwZS1udW1lcmljLHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC10eXBlLWRhdGV7dGV4dC1hbGlnbjpyaWdodH10YWJsZS5kYXRhVGFibGUgdGguZHQtbGVmdCx0YWJsZS5kYXRhVGFibGUgdGQuZHQtbGVmdHt0ZXh0LWFsaWduOmxlZnR9dGFibGUuZGF0YVRhYmxlIHRoLmR0LWNlbnRlcix0YWJsZS5kYXRhVGFibGUgdGQuZHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyfXRhYmxlLmRhdGFUYWJsZSB0aC5kdC1yaWdodCx0YWJsZS5kYXRhVGFibGUgdGQuZHQtcmlnaHR7dGV4dC1hbGlnbjpyaWdodH10YWJsZS5kYXRhVGFibGUgdGguZHQtanVzdGlmeSx0YWJsZS5kYXRhVGFibGUgdGQuZHQtanVzdGlmeXt0ZXh0LWFsaWduOmp1c3RpZnl9dGFibGUuZGF0YVRhYmxlIHRoLmR0LW5vd3JhcCx0YWJsZS5kYXRhVGFibGUgdGQuZHQtbm93cmFwe3doaXRlLXNwYWNlOm5vd3JhcH10YWJsZS5kYXRhVGFibGUgdGguZHQtZW1wdHksdGFibGUuZGF0YVRhYmxlIHRkLmR0LWVtcHR5e3RleHQtYWxpZ246Y2VudGVyO3ZlcnRpY2FsLWFsaWduOnRvcH10YWJsZS5kYXRhVGFibGUgdGhlYWQgdGgsdGFibGUuZGF0YVRhYmxlIHRoZWFkIHRkLHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0aCx0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGR7dGV4dC1hbGlnbjpsZWZ0fXRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aC5kdC1oZWFkLWxlZnQsdGFibGUuZGF0YVRhYmxlIHRoZWFkIHRkLmR0LWhlYWQtbGVmdCx0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGguZHQtaGVhZC1sZWZ0LHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0ZC5kdC1oZWFkLWxlZnR7dGV4dC1hbGlnbjpsZWZ0fXRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aC5kdC1oZWFkLWNlbnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQgdGQuZHQtaGVhZC1jZW50ZXIsdGFibGUuZGF0YVRhYmxlIHRmb290IHRoLmR0LWhlYWQtY2VudGVyLHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0ZC5kdC1oZWFkLWNlbnRlcnt0ZXh0LWFsaWduOmNlbnRlcn10YWJsZS5kYXRhVGFibGUgdGhlYWQgdGguZHQtaGVhZC1yaWdodCx0YWJsZS5kYXRhVGFibGUgdGhlYWQgdGQuZHQtaGVhZC1yaWdodCx0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGguZHQtaGVhZC1yaWdodCx0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGQuZHQtaGVhZC1yaWdodHt0ZXh0LWFsaWduOnJpZ2h0fXRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aC5kdC1oZWFkLWp1c3RpZnksdGFibGUuZGF0YVRhYmxlIHRoZWFkIHRkLmR0LWhlYWQtanVzdGlmeSx0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGguZHQtaGVhZC1qdXN0aWZ5LHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0ZC5kdC1oZWFkLWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fXRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aC5kdC1oZWFkLW5vd3JhcCx0YWJsZS5kYXRhVGFibGUgdGhlYWQgdGQuZHQtaGVhZC1ub3dyYXAsdGFibGUuZGF0YVRhYmxlIHRmb290IHRoLmR0LWhlYWQtbm93cmFwLHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0ZC5kdC1oZWFkLW5vd3JhcHt3aGl0ZS1zcGFjZTpub3dyYXB9dGFibGUuZGF0YVRhYmxlIHRib2R5IHRoLmR0LWJvZHktbGVmdCx0YWJsZS5kYXRhVGFibGUgdGJvZHkgdGQuZHQtYm9keS1sZWZ0e3RleHQtYWxpZ246bGVmdH10YWJsZS5kYXRhVGFibGUgdGJvZHkgdGguZHQtYm9keS1jZW50ZXIsdGFibGUuZGF0YVRhYmxlIHRib2R5IHRkLmR0LWJvZHktY2VudGVye3RleHQtYWxpZ246Y2VudGVyfXRhYmxlLmRhdGFUYWJsZSB0Ym9keSB0aC5kdC1ib2R5LXJpZ2h0LHRhYmxlLmRhdGFUYWJsZSB0Ym9keSB0ZC5kdC1ib2R5LXJpZ2h0e3RleHQtYWxpZ246cmlnaHR9dGFibGUuZGF0YVRhYmxlIHRib2R5IHRoLmR0LWJvZHktanVzdGlmeSx0YWJsZS5kYXRhVGFibGUgdGJvZHkgdGQuZHQtYm9keS1qdXN0aWZ5e3RleHQtYWxpZ246anVzdGlmeX10YWJsZS5kYXRhVGFibGUgdGJvZHkgdGguZHQtYm9keS1ub3dyYXAsdGFibGUuZGF0YVRhYmxlIHRib2R5IHRkLmR0LWJvZHktbm93cmFwe3doaXRlLXNwYWNlOm5vd3JhcH06cm9vdHstLWR0LXJvdy1ob3Zlci1hbHBoYTogMC4wMzU7LS1kdC1yb3ctc3RyaXBlLWFscGhhOiAwLjAyMzstLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYTogMC4wMTk7LS1kdC1yb3ctc2VsZWN0ZWQtc3RyaXBlLWFscGhhOiAwLjkyMzstLWR0LXJvdy1zZWxlY3RlZC1jb2x1bW4tb3JkZXJpbmctYWxwaGE6IDAuOTE5fXRhYmxlLmRhdGFUYWJsZXt3aWR0aDoxMDAlO21hcmdpbjowIGF1dG87Ym9yZGVyLXNwYWNpbmc6MH10YWJsZS5kYXRhVGFibGUgdGhlYWQgdGgsdGFibGUuZGF0YVRhYmxlIHRmb290IHRoe2ZvbnQtd2VpZ2h0OmJvbGR9dGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRoLHRhYmxlLmRhdGFUYWJsZT50aGVhZD50cj50ZHtwYWRkaW5nOjEwcHg7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjMpfXRhYmxlLmRhdGFUYWJsZT50aGVhZD50cj50aDphY3RpdmUsdGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRkOmFjdGl2ZXtvdXRsaW5lOm5vbmV9dGFibGUuZGF0YVRhYmxlPnRmb290PnRyPnRoLHRhYmxlLmRhdGFUYWJsZT50Zm9vdD50cj50ZHtib3JkZXItdG9wOjFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMyk7cGFkZGluZzoxMHB4IDEwcHggNnB4IDEwcHh9dGFibGUuZGF0YVRhYmxlPnRib2R5PnRye2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9dGFibGUuZGF0YVRhYmxlPnRib2R5PnRyOmZpcnN0LWNoaWxkPip7Ym9yZGVyLXRvcDpub25lfXRhYmxlLmRhdGFUYWJsZT50Ym9keT50cjpsYXN0LWNoaWxkPip7Ym9yZGVyLWJvdHRvbTpub25lfXRhYmxlLmRhdGFUYWJsZT50Ym9keT50ci5zZWxlY3RlZD4qe2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMTMsIDExMCwgMjUzLCAwLjkpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgMC45KTtjb2xvcjpyZ2IoMjU1LCAyNTUsIDI1NSk7Y29sb3I6cmdiKHZhcigtLWR0LXJvdy1zZWxlY3RlZC10ZXh0KSl9dGFibGUuZGF0YVRhYmxlPnRib2R5PnRyLnNlbGVjdGVkIGF7Y29sb3I6cmdiKDksIDEwLCAxMSk7Y29sb3I6cmdiKHZhcigtLWR0LXJvdy1zZWxlY3RlZC1saW5rKSl9dGFibGUuZGF0YVRhYmxlPnRib2R5PnRyPnRoLHRhYmxlLmRhdGFUYWJsZT50Ym9keT50cj50ZHtwYWRkaW5nOjhweCAxMHB4fXRhYmxlLmRhdGFUYWJsZS5yb3ctYm9yZGVyPnRib2R5PnRyPiosdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI+Kntib3JkZXItdG9wOjFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMTUpfXRhYmxlLmRhdGFUYWJsZS5yb3ctYm9yZGVyPnRib2R5PnRyOmZpcnN0LWNoaWxkPiosdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6Zmlyc3QtY2hpbGQ+Kntib3JkZXItdG9wOm5vbmV9dGFibGUuZGF0YVRhYmxlLnJvdy1ib3JkZXI+dGJvZHk+dHIuc2VsZWN0ZWQrdHIuc2VsZWN0ZWQ+dGQsdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHIuc2VsZWN0ZWQrdHIuc2VsZWN0ZWQ+dGR7Ym9yZGVyLXRvcC1jb2xvcjpyZ2JhKDEzLCAxMTAsIDI1MywgMC42NSk7Ym9yZGVyLXRvcC1jb2xvcjpyZ2JhKHZhcigtLWR0LXJvdy1zZWxlY3RlZCksIDAuNjUpfXRhYmxlLmRhdGFUYWJsZS5jZWxsLWJvcmRlcj50Ym9keT50cj4qe2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xNSk7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMTUpfXRhYmxlLmRhdGFUYWJsZS5jZWxsLWJvcmRlcj50Ym9keT50cj4qOmZpcnN0LWNoaWxke2JvcmRlci1sZWZ0OjFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMTUpfXRhYmxlLmRhdGFUYWJsZS5jZWxsLWJvcmRlcj50Ym9keT50cjpmaXJzdC1jaGlsZD4qe2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKX10YWJsZS5kYXRhVGFibGUuc3RyaXBlPnRib2R5PnRyOm50aC1jaGlsZChvZGQpPiosdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCk+Kntib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDAsIDAsIDAsIDAuMDIzKTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LXJvdy1zdHJpcGUpLCB2YXIoLS1kdC1yb3ctc3RyaXBlLWFscGhhKSl9dGFibGUuZGF0YVRhYmxlLnN0cmlwZT50Ym9keT50cjpudGgtY2hpbGQob2RkKS5zZWxlY3RlZD4qLHRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOm50aC1jaGlsZChvZGQpLnNlbGVjdGVkPip7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgxMywgMTEwLCAyNTMsIDAuOTIzKTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LXJvdy1zZWxlY3RlZCksIHZhcigtLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGEpKX10YWJsZS5kYXRhVGFibGUuaG92ZXI+dGJvZHk+dHI6aG92ZXI+Kix0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cjpob3Zlcj4qe2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMCwgMCwgMCwgMC4wMzUpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LWhvdmVyKSwgdmFyKC0tZHQtcm93LWhvdmVyLWFscGhhKSl9dGFibGUuZGF0YVRhYmxlLmhvdmVyPnRib2R5PnRyLnNlbGVjdGVkOmhvdmVyPiosdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHIuc2VsZWN0ZWQ6aG92ZXI+Kntib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCAjMGQ2ZWZkICFpbXBvcnRhbnQ7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCAxKSAhaW1wb3J0YW50fXRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4+dGJvZHkgdHI+LnNvcnRpbmdfMSx0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uPnRib2R5IHRyPi5zb3J0aW5nXzIsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbj50Ym9keSB0cj4uc29ydGluZ18zLHRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5IHRyPi5zb3J0aW5nXzEsdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHkgdHI+LnNvcnRpbmdfMix0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keSB0cj4uc29ydGluZ18ze2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMCwgMCwgMCwgMC4wMTkpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nKSwgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSl9dGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbj50Ym9keSB0ci5zZWxlY3RlZD4uc29ydGluZ18xLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4+dGJvZHkgdHIuc2VsZWN0ZWQ+LnNvcnRpbmdfMix0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uPnRib2R5IHRyLnNlbGVjdGVkPi5zb3J0aW5nXzMsdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHkgdHIuc2VsZWN0ZWQ+LnNvcnRpbmdfMSx0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keSB0ci5zZWxlY3RlZD4uc29ydGluZ18yLHRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5IHRyLnNlbGVjdGVkPi5zb3J0aW5nXzN7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgxMywgMTEwLCAyNTMsIDAuOTE5KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LXJvdy1zZWxlY3RlZCksIHZhcigtLWR0LXJvdy1zZWxlY3RlZC1jb2x1bW4tb3JkZXJpbmctYWxwaGEpKX10YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cjpudGgtY2hpbGQob2RkKT4uc29ydGluZ18xLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4uc3RyaXBlPnRib2R5PnRyOm50aC1jaGlsZChvZGQpPi5zb3J0aW5nXzF7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgwLCAwLCAwLCAwLjA1NCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmcpLCBjYWxjKHZhcigtLWR0LXJvdy1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSkpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOm50aC1jaGlsZChvZGQpPi5zb3J0aW5nXzIsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5zdHJpcGU+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCk+LnNvcnRpbmdfMntib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDAsIDAsIDAsIDAuMDQ3KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZyksIGNhbGModmFyKC0tZHQtcm93LXN0cmlwZS1hbHBoYSkgKyB2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmctYWxwaGEpIC0gMC4wMDcpKX10YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cjpudGgtY2hpbGQob2RkKT4uc29ydGluZ18zLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4uc3RyaXBlPnRib2R5PnRyOm50aC1jaGlsZChvZGQpPi5zb3J0aW5nXzN7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgwLCAwLCAwLCAwLjAzOSk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmcpLCBjYWxjKHZhcigtLWR0LXJvdy1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSAtIDAuMDE1KSl9dGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCkuc2VsZWN0ZWQ+LnNvcnRpbmdfMSx0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uLnN0cmlwZT50Ym9keT50cjpudGgtY2hpbGQob2RkKS5zZWxlY3RlZD4uc29ydGluZ18xe2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMTMsIDExMCwgMjUzLCAwLjk1NCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCBjYWxjKHZhcigtLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSkpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOm50aC1jaGlsZChvZGQpLnNlbGVjdGVkPi5zb3J0aW5nXzIsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5zdHJpcGU+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCkuc2VsZWN0ZWQ+LnNvcnRpbmdfMntib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDEzLCAxMTAsIDI1MywgMC45NDcpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgY2FsYyh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQtc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkgLSAwLjAwNykpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOm50aC1jaGlsZChvZGQpLnNlbGVjdGVkPi5zb3J0aW5nXzMsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5zdHJpcGU+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCkuc2VsZWN0ZWQ+LnNvcnRpbmdfM3tib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDEzLCAxMTAsIDI1MywgMC45MzkpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgY2FsYyh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQtc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkgLSAwLjAxNSkpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5IHRib2R5IHRyOmhvdmVyPi5zb3J0aW5nXzEsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5ob3ZlciB0Ym9keSB0cjpob3Zlcj4uc29ydGluZ18xe2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMCwgMCwgMCwgMC4wODIpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LWhvdmVyKSwgY2FsYyh2YXIoLS1kdC1yb3ctc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkgKyB2YXIoLS1kdC1yb3ctaG92ZXItYWxwaGEpKSl9dGFibGUuZGF0YVRhYmxlLmRpc3BsYXkgdGJvZHkgdHI6aG92ZXI+LnNvcnRpbmdfMix0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uLmhvdmVyIHRib2R5IHRyOmhvdmVyPi5zb3J0aW5nXzJ7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgwLCAwLCAwLCAwLjA3NCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctaG92ZXIpLCBjYWxjKHZhcigtLWR0LXJvdy1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSArIHZhcigtLWR0LXJvdy1ob3Zlci1hbHBoYSkgLSAwLjAwNykpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5IHRib2R5IHRyOmhvdmVyPi5zb3J0aW5nXzMsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5ob3ZlciB0Ym9keSB0cjpob3Zlcj4uc29ydGluZ18ze2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMCwgMCwgMCwgMC4wNjIpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LWhvdmVyKSwgY2FsYyh2YXIoLS1kdC1yb3ctc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkgKyB2YXIoLS1kdC1yb3ctaG92ZXItYWxwaGEpIC0gMC4wMTUpKX10YWJsZS5kYXRhVGFibGUuZGlzcGxheSB0Ym9keSB0cjpob3Zlci5zZWxlY3RlZD4uc29ydGluZ18xLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4uaG92ZXIgdGJvZHkgdHI6aG92ZXIuc2VsZWN0ZWQ+LnNvcnRpbmdfMXtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDEzLCAxMTAsIDI1MywgMC45ODIpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgY2FsYyh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQtc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkpKX10YWJsZS5kYXRhVGFibGUuZGlzcGxheSB0Ym9keSB0cjpob3Zlci5zZWxlY3RlZD4uc29ydGluZ18yLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4uaG92ZXIgdGJvZHkgdHI6aG92ZXIuc2VsZWN0ZWQ+LnNvcnRpbmdfMntib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDEzLCAxMTAsIDI1MywgMC45NzQpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgY2FsYyh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQtc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkgKyB2YXIoLS1kdC1yb3ctaG92ZXItYWxwaGEpIC0gMC4wMDcpKX10YWJsZS5kYXRhVGFibGUuZGlzcGxheSB0Ym9keSB0cjpob3Zlci5zZWxlY3RlZD4uc29ydGluZ18zLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4uaG92ZXIgdGJvZHkgdHI6aG92ZXIuc2VsZWN0ZWQ+LnNvcnRpbmdfM3tib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDEzLCAxMTAsIDI1MywgMC45NjIpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgY2FsYyh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQtc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkgKyB2YXIoLS1kdC1yb3ctaG92ZXItYWxwaGEpIC0gMC4wMTUpKX10YWJsZS5kYXRhVGFibGUuY29tcGFjdCB0aGVhZCB0aCx0YWJsZS5kYXRhVGFibGUuY29tcGFjdCB0aGVhZCB0ZCx0YWJsZS5kYXRhVGFibGUuY29tcGFjdCB0Zm9vdCB0aCx0YWJsZS5kYXRhVGFibGUuY29tcGFjdCB0Zm9vdCB0ZCx0YWJsZS5kYXRhVGFibGUuY29tcGFjdCB0Ym9keSB0aCx0YWJsZS5kYXRhVGFibGUuY29tcGFjdCB0Ym9keSB0ZHtwYWRkaW5nOjRweH1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtcm93e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXI7d2lkdGg6MTAwJTttYXJnaW46Ljc1ZW0gMH1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtcm93IGRpdi5kdC1sYXlvdXQtY2VsbHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47YWxpZ24taXRlbXM6Y2VudGVyfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3cgZGl2LmR0LWxheW91dC1jZWxsLmR0LWxheW91dC1zdGFydHtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDttYXJnaW4tcmlnaHQ6YXV0b31kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtcm93IGRpdi5kdC1sYXlvdXQtY2VsbC5kdC1sYXlvdXQtZW5ke2p1c3RpZnktY29udGVudDpmbGV4LWVuZDttYXJnaW4tbGVmdDphdXRvfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3cgZGl2LmR0LWxheW91dC1jZWxsOmVtcHR5e2Rpc3BsYXk6bm9uZX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCl7ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LXJvdzpub3QoLmR0LWxheW91dC10YWJsZSl7ZGlzcGxheTpibG9ja31kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtcm93Om5vdCguZHQtbGF5b3V0LXRhYmxlKSBkaXYuZHQtbGF5b3V0LWNlbGx7ZGlzcGxheTpibG9jazt0ZXh0LWFsaWduOmNlbnRlcn1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtcm93Om5vdCguZHQtbGF5b3V0LXRhYmxlKSBkaXYuZHQtbGF5b3V0LWNlbGw+KnttYXJnaW46LjVlbSAwfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3c6bm90KC5kdC1sYXlvdXQtdGFibGUpIGRpdi5kdC1sYXlvdXQtY2VsbC5kdC1sYXlvdXQtc3RhcnR7bWFyZ2luLXJpZ2h0OjB9ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LXJvdzpub3QoLmR0LWxheW91dC10YWJsZSkgZGl2LmR0LWxheW91dC1jZWxsLmR0LWxheW91dC1lbmR7bWFyZ2luLWxlZnQ6MH19ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LXN0YXJ0Pio6bm90KDpsYXN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6MWVtfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1lbmQ+Kjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDoxZW19ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LWZ1bGx7d2lkdGg6MTAwJX1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtZnVsbD4qOm9ubHktY2hpbGR7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b31kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtdGFibGU+ZGl2e2Rpc3BsYXk6YmxvY2sgIWltcG9ydGFudH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCl7ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LXN0YXJ0Pio6bm90KDpsYXN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6MH1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtZW5kPio6bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLWxlZnQ6MH19ZGl2LmR0LWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTtjbGVhcjpib3RofWRpdi5kdC1jb250YWluZXIgLmR0LXNlYXJjaCBpbnB1dHtib3JkZXI6MXB4IHNvbGlkICNhYWE7Ym9yZGVyLXJhZGl1czozcHg7cGFkZGluZzo1cHg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtjb2xvcjppbmhlcml0O21hcmdpbi1sZWZ0OjNweH1kaXYuZHQtY29udGFpbmVyIC5kdC1pbnB1dHtib3JkZXI6MXB4IHNvbGlkICNhYWE7Ym9yZGVyLXJhZGl1czozcHg7cGFkZGluZzo1cHg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtjb2xvcjppbmhlcml0fWRpdi5kdC1jb250YWluZXIgc2VsZWN0LmR0LWlucHV0e3BhZGRpbmc6NHB4fWRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbntib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWluLXdpZHRoOjEuNWVtO3BhZGRpbmc6LjVlbSAxZW07bWFyZ2luLWxlZnQ6MnB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lICFpbXBvcnRhbnQ7Y3Vyc29yOnBvaW50ZXI7Y29sb3I6aW5oZXJpdCAhaW1wb3J0YW50O2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czoycHg7YmFja2dyb3VuZDp0cmFuc3BhcmVudH1kaXYuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b24uY3VycmVudCxkaXYuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b24uY3VycmVudDpob3Zlcntjb2xvcjppbmhlcml0ICFpbXBvcnRhbnQ7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMyk7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsIDAsIDAsIDAuMDUpO2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgdG9wLCBsZWZ0IGJvdHRvbSwgY29sb3Itc3RvcCgwJSwgcmdiYSgyMzAsIDIzMCwgMjMwLCAwLjA1KSksIGNvbG9yLXN0b3AoMTAwJSwgcmdiYSgwLCAwLCAwLCAwLjA1KSkpO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCByZ2JhKDIzMCwgMjMwLCAyMzAsIDAuMDUpIDAlLCByZ2JhKDAsIDAsIDAsIDAuMDUpIDEwMCUpO2JhY2tncm91bmQ6LW1vei1saW5lYXItZ3JhZGllbnQodG9wLCByZ2JhKDIzMCwgMjMwLCAyMzAsIDAuMDUpIDAlLCByZ2JhKDAsIDAsIDAsIDAuMDUpIDEwMCUpO2JhY2tncm91bmQ6LW1zLWxpbmVhci1ncmFkaWVudCh0b3AsIHJnYmEoMjMwLCAyMzAsIDIzMCwgMC4wNSkgMCUsIHJnYmEoMCwgMCwgMCwgMC4wNSkgMTAwJSk7YmFja2dyb3VuZDotby1saW5lYXItZ3JhZGllbnQodG9wLCByZ2JhKDIzMCwgMjMwLCAyMzAsIDAuMDUpIDAlLCByZ2JhKDAsIDAsIDAsIDAuMDUpIDEwMCUpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgcmdiYSgyMzAsIDIzMCwgMjMwLCAwLjA1KSAwJSwgcmdiYSgwLCAwLCAwLCAwLjA1KSAxMDAlKX1kaXYuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b24uZGlzYWJsZWQsZGl2LmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5kdC1wYWdpbmctYnV0dG9uLmRpc2FibGVkOmhvdmVyLGRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5kaXNhYmxlZDphY3RpdmV7Y3Vyc29yOmRlZmF1bHQ7Y29sb3I6cmdiYSgwLCAwLCAwLCAwLjUpICFpbXBvcnRhbnQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2JveC1zaGFkb3c6bm9uZX1kaXYuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b246aG92ZXJ7Y29sb3I6d2hpdGUgIWltcG9ydGFudDtib3JkZXI6MXB4IHNvbGlkICMxMTE7YmFja2dyb3VuZC1jb2xvcjojMTExO2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgdG9wLCBsZWZ0IGJvdHRvbSwgY29sb3Itc3RvcCgwJSwgIzU4NTg1OCksIGNvbG9yLXN0b3AoMTAwJSwgIzExMSkpO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAjNTg1ODU4IDAlLCAjMTExIDEwMCUpO2JhY2tncm91bmQ6LW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAjNTg1ODU4IDAlLCAjMTExIDEwMCUpO2JhY2tncm91bmQ6LW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICM1ODU4NTggMCUsICMxMTEgMTAwJSk7YmFja2dyb3VuZDotby1saW5lYXItZ3JhZGllbnQodG9wLCAjNTg1ODU4IDAlLCAjMTExIDEwMCUpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgIzU4NTg1OCAwJSwgIzExMSAxMDAlKX1kaXYuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b246YWN0aXZle291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiMwYzBjMGM7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIGxlZnQgYm90dG9tLCBjb2xvci1zdG9wKDAlLCAjMmIyYjJiKSwgY29sb3Itc3RvcCgxMDAlLCAjMGMwYzBjKSk7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICMyYjJiMmIgMCUsICMwYzBjMGMgMTAwJSk7YmFja2dyb3VuZDotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICMyYjJiMmIgMCUsICMwYzBjMGMgMTAwJSk7YmFja2dyb3VuZDotbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgIzJiMmIyYiAwJSwgIzBjMGMwYyAxMDAlKTtiYWNrZ3JvdW5kOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsICMyYjJiMmIgMCUsICMwYzBjMGMgMTAwJSk7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjMmIyYjJiIDAlLCAjMGMwYzBjIDEwMCUpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDNweCAjMTExfWRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZWxsaXBzaXN7cGFkZGluZzowIDFlbX1kaXYuZHQtY29udGFpbmVyIC5kdC1sZW5ndGgsZGl2LmR0LWNvbnRhaW5lciAuZHQtc2VhcmNoLGRpdi5kdC1jb250YWluZXIgLmR0LWluZm8sZGl2LmR0LWNvbnRhaW5lciAuZHQtcHJvY2Vzc2luZyxkaXYuZHQtY29udGFpbmVyIC5kdC1wYWdpbmd7Y29sb3I6aW5oZXJpdH1kaXYuZHQtY29udGFpbmVyIC5kYXRhVGFibGVzX3Njcm9sbHtjbGVhcjpib3RofWRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xsIGRpdi5kdC1zY3JvbGwtYm9keXstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaH1kaXYuZHQtY29udGFpbmVyIC5kYXRhVGFibGVzX3Njcm9sbCBkaXYuZHQtc2Nyb2xsLWJvZHk+dGFibGU+dGhlYWQ+dHI+dGgsZGl2LmR0LWNvbnRhaW5lciAuZGF0YVRhYmxlc19zY3JvbGwgZGl2LmR0LXNjcm9sbC1ib2R5PnRhYmxlPnRoZWFkPnRyPnRkLGRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xsIGRpdi5kdC1zY3JvbGwtYm9keT50YWJsZT50Ym9keT50cj50aCxkaXYuZHQtY29udGFpbmVyIC5kYXRhVGFibGVzX3Njcm9sbCBkaXYuZHQtc2Nyb2xsLWJvZHk+dGFibGU+dGJvZHk+dHI+dGR7dmVydGljYWwtYWxpZ246bWlkZGxlfWRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xsIGRpdi5kdC1zY3JvbGwtYm9keT50YWJsZT50aGVhZD50cj50aD5kaXYuZGF0YVRhYmxlc19zaXppbmcsZGl2LmR0LWNvbnRhaW5lciAuZGF0YVRhYmxlc19zY3JvbGwgZGl2LmR0LXNjcm9sbC1ib2R5PnRhYmxlPnRoZWFkPnRyPnRkPmRpdi5kYXRhVGFibGVzX3NpemluZyxkaXYuZHQtY29udGFpbmVyIC5kYXRhVGFibGVzX3Njcm9sbCBkaXYuZHQtc2Nyb2xsLWJvZHk+dGFibGU+dGJvZHk+dHI+dGg+ZGl2LmRhdGFUYWJsZXNfc2l6aW5nLGRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xsIGRpdi5kdC1zY3JvbGwtYm9keT50YWJsZT50Ym9keT50cj50ZD5kaXYuZGF0YVRhYmxlc19zaXppbmd7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbjowICFpbXBvcnRhbnQ7cGFkZGluZzowICFpbXBvcnRhbnR9ZGl2LmR0LWNvbnRhaW5lci5kdC1lbXB0eS1mb290ZXIgdGJvZHk+dHI6bGFzdC1jaGlsZD4qe2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKX1kaXYuZHQtY29udGFpbmVyLmR0LWVtcHR5LWZvb3RlciAuZHQtc2Nyb2xsLWJvZHl7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjMpfWRpdi5kdC1jb250YWluZXIuZHQtZW1wdHktZm9vdGVyIC5kdC1zY3JvbGwtYm9keSB0Ym9keT50cjpsYXN0LWNoaWxkPip7Ym9yZGVyLWJvdHRvbTpub25lfWh0bWwuZGFya3stLWR0LXJvdy1ob3ZlcjogMjU1LCAyNTUsIDI1NTstLWR0LXJvdy1zdHJpcGU6IDI1NSwgMjU1LCAyNTU7LS1kdC1jb2x1bW4tb3JkZXJpbmc6IDI1NSwgMjU1LCAyNTV9aHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZT50aGVhZD50cj50aCxodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRke2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYig4OSwgOTEsIDk0KX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRoOmFjdGl2ZSxodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRkOmFjdGl2ZXtvdXRsaW5lOm5vbmV9aHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZT50Zm9vdD50cj50aCxodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlPnRmb290PnRyPnRke2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYig4OSwgOTEsIDk0KX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLnJvdy1ib3JkZXI+dGJvZHk+dHI+KixodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI+Kntib3JkZXItdG9wOjFweCBzb2xpZCByZ2IoNjQsIDY3LCA3MCl9aHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZS5yb3ctYm9yZGVyPnRib2R5PnRyOmZpcnN0LWNoaWxkPiosaHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOmZpcnN0LWNoaWxkPip7Ym9yZGVyLXRvcDpub25lfWh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUucm93LWJvcmRlcj50Ym9keT50ci5zZWxlY3RlZCt0ci5zZWxlY3RlZD50ZCxodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHIuc2VsZWN0ZWQrdHIuc2VsZWN0ZWQ+dGR7Ym9yZGVyLXRvcC1jb2xvcjpyZ2JhKDEzLCAxMTAsIDI1MywgMC42NSk7Ym9yZGVyLXRvcC1jb2xvcjpyZ2JhKHZhcigtLWR0LXJvdy1zZWxlY3RlZCksIDAuNjUpfWh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUuY2VsbC1ib3JkZXI+dGJvZHk+dHI+dGgsaHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZS5jZWxsLWJvcmRlcj50Ym9keT50cj50ZHtib3JkZXItdG9wOjFweCBzb2xpZCByZ2IoNjQsIDY3LCA3MCk7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2IoNjQsIDY3LCA3MCl9aHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZS5jZWxsLWJvcmRlcj50Ym9keT50cj50aDpmaXJzdC1jaGlsZCxodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLmNlbGwtYm9yZGVyPnRib2R5PnRyPnRkOmZpcnN0LWNoaWxke2JvcmRlci1sZWZ0OjFweCBzb2xpZCByZ2IoNjQsIDY3LCA3MCl9aHRtbC5kYXJrIC5kdC1jb250YWluZXIuZHQtZW1wdHktZm9vdGVyIHRhYmxlLmRhdGFUYWJsZXtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2IoODksIDkxLCA5NCl9aHRtbC5kYXJrIC5kdC1jb250YWluZXIgLmR0LXNlYXJjaCBpbnB1dCxodG1sLmRhcmsgLmR0LWNvbnRhaW5lciAuZHQtbGVuZ3RoIHNlbGVjdHtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWR0LWh0bWwtYmFja2dyb3VuZCl9aHRtbC5kYXJrIC5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5jdXJyZW50LGh0bWwuZGFyayAuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b24uY3VycmVudDpob3Zlcntib3JkZXI6MXB4IHNvbGlkIHJnYig4OSwgOTEsIDk0KTtiYWNrZ3JvdW5kOnJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNSl9aHRtbC5kYXJrIC5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5kaXNhYmxlZCxodG1sLmRhcmsgLmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5kdC1wYWdpbmctYnV0dG9uLmRpc2FibGVkOmhvdmVyLGh0bWwuZGFyayAuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b24uZGlzYWJsZWQ6YWN0aXZle2NvbG9yOiM2NjYgIWltcG9ydGFudH1odG1sLmRhcmsgLmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5kdC1wYWdpbmctYnV0dG9uOmhvdmVye2JvcmRlcjoxcHggc29saWQgcmdiKDUzLCA1MywgNTMpO2JhY2tncm91bmQ6cmdiKDUzLCA1MywgNTMpfWh0bWwuZGFyayAuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b246YWN0aXZle2JhY2tncm91bmQ6IzNhM2EzYX0qW2Rpcj1ydGxdIHRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aCwqW2Rpcj1ydGxdIHRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0ZCwqW2Rpcj1ydGxdIHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0aCwqW2Rpcj1ydGxdIHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0ZHt0ZXh0LWFsaWduOnJpZ2h0fSpbZGlyPXJ0bF0gdGFibGUuZGF0YVRhYmxlIHRoLmR0LXR5cGUtbnVtZXJpYywqW2Rpcj1ydGxdIHRhYmxlLmRhdGFUYWJsZSB0aC5kdC10eXBlLWRhdGUsKltkaXI9cnRsXSB0YWJsZS5kYXRhVGFibGUgdGQuZHQtdHlwZS1udW1lcmljLCpbZGlyPXJ0bF0gdGFibGUuZGF0YVRhYmxlIHRkLmR0LXR5cGUtZGF0ZXt0ZXh0LWFsaWduOmxlZnR9KltkaXI9cnRsXSBkaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtY2VsbC5kdC1zdGFydHt0ZXh0LWFsaWduOnJpZ2h0fSpbZGlyPXJ0bF0gZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LWNlbGwuZHQtZW5ke3RleHQtYWxpZ246bGVmdH0qW2Rpcj1ydGxdIGRpdi5kdC1jb250YWluZXIgZGl2LmR0LXNlYXJjaCBpbnB1dHttYXJnaW46MCAzcHggMCAwfVxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtZHQvY3NzL2RhdGFUYWJsZXMuZGF0YVRhYmxlcy5taW4uY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLE1BQU0sK0JBQStCLENBQUMscUNBQXFDLENBQUMsaUNBQWlDLENBQUMsd0JBQXdCLENBQUMsdUJBQXVCLENBQUMsNkJBQTZCLENBQUMsMkJBQTJCLENBQUMsV0FBVyxxQ0FBcUMsQ0FBQyw4QkFBOEIsaUJBQWlCLENBQUMsY0FBYyxDQUFDLHFDQUFxQyxvQkFBb0IsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsZ0NBQWdDLENBQUMseUNBQXlDLENBQUMsbUNBQW1DLENBQUMsa0NBQWtDLENBQUMsb0RBQW9ELHdDQUF3QyxDQUFDLGlDQUFpQyxDQUFDLG1DQUFtQyxDQUFDLGtDQUFrQyxDQUFDLDRCQUE0QixZQUFZLENBQUMsMEtBQTBLLDBDQUEwQyxDQUFDLHVOQUF1Tix5Q0FBeUMsQ0FBQyw2QkFBNkIsQ0FBQyxjQUFjLFVBQVUsQ0FBQyx3REFBd0QsUUFBUSxDQUFDLDRIQUE0SCxtQkFBbUIsQ0FBQywwQkFBMEIsQ0FBQyw2QkFBNkIsQ0FBQywrQkFBK0IsQ0FBQyxrQ0FBa0MsQ0FBQyxnTkFBZ04sbUJBQW1CLENBQUMsMEJBQTBCLENBQUMsc0VBQXNFLFlBQVksQ0FBQyxrU0FBa1MsaUJBQWlCLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLGtTQUFrUyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsd1dBQXdXLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLGdoQkFBZ2hCLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyx3b0NBQXdvQyxNQUFNLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUMsc0xBQXNMLGNBQWMsQ0FBQyw4TUFBOE0scUNBQXFDLENBQUMsbUJBQW1CLENBQUMsZ1NBQWdTLFVBQVUsQ0FBQyxvVEFBb1QsWUFBWSxDQUFDLHNFQUFzRSxZQUFZLENBQUMsOEZBQThGLGVBQWUsQ0FBQyxnakJBQWdqQiwyQ0FBMkMsQ0FBQyxrQkFBa0IsaUJBQWlCLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxpQ0FBaUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUMscUNBQXFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLGlCQUFpQixDQUFDLDRCQUE0QixDQUFDLHNDQUFzQyxDQUFDLGtEQUFrRCxDQUFDLGtEQUFrRCxRQUFRLENBQUMsMENBQTBDLENBQUMsa0RBQWtELFFBQVEsQ0FBQywwQ0FBMEMsQ0FBQyxrREFBa0QsU0FBUyxDQUFDLDBDQUEwQyxDQUFDLGtEQUFrRCxTQUFTLENBQUMsMENBQTBDLENBQUMsK0JBQStCLEdBQUcsa0JBQWtCLENBQUMsS0FBSyxrQkFBa0IsQ0FBQyxDQUFDLCtCQUErQixHQUFHLGtCQUFrQixDQUFDLEtBQUssa0JBQWtCLENBQUMsQ0FBQywrQkFBK0IsR0FBRyx5QkFBeUIsQ0FBQyxLQUFLLDRCQUE0QixDQUFDLENBQUMsb0RBQW9ELGtCQUFrQixDQUFDLHNDQUFzQyxxQkFBcUIsQ0FBQyxzSUFBc0ksZ0JBQWdCLENBQUMsc0RBQXNELGVBQWUsQ0FBQywwREFBMEQsaUJBQWlCLENBQUMsd0RBQXdELGdCQUFnQixDQUFDLDREQUE0RCxrQkFBa0IsQ0FBQywwREFBMEQsa0JBQWtCLENBQUMsd0RBQXdELGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLG9HQUFvRyxlQUFlLENBQUMsd0pBQXdKLGVBQWUsQ0FBQyxnS0FBZ0ssaUJBQWlCLENBQUMsNEpBQTRKLGdCQUFnQixDQUFDLG9LQUFvSyxrQkFBa0IsQ0FBQyxnS0FBZ0ssa0JBQWtCLENBQUMsNEVBQTRFLGVBQWUsQ0FBQyxnRkFBZ0YsaUJBQWlCLENBQUMsOEVBQThFLGdCQUFnQixDQUFDLGtGQUFrRixrQkFBa0IsQ0FBQyxnRkFBZ0Ysa0JBQWtCLENBQUMsTUFBTSwyQkFBMkIsQ0FBQyw0QkFBNEIsQ0FBQyxpQ0FBaUMsQ0FBQyxxQ0FBcUMsQ0FBQyw4Q0FBOEMsQ0FBQyxnQkFBZ0IsVUFBVSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxrREFBa0QsZ0JBQWdCLENBQUMsd0RBQXdELFlBQVksQ0FBQywwQ0FBMEMsQ0FBQyxzRUFBc0UsWUFBWSxDQUFDLHdEQUF3RCx1Q0FBdUMsQ0FBQywwQkFBMEIsQ0FBQyx5QkFBeUIsNEJBQTRCLENBQUMsdUNBQXVDLGVBQWUsQ0FBQyxzQ0FBc0Msa0JBQWtCLENBQUMsb0NBQW9DLHFEQUFxRCxDQUFDLCtEQUErRCxDQUFDLHdCQUF3QixDQUFDLHNDQUFzQyxDQUFDLG9DQUFvQyxvQkFBb0IsQ0FBQyxzQ0FBc0MsQ0FBQyx3REFBd0QsZ0JBQWdCLENBQUMseUVBQXlFLHdDQUF3QyxDQUFDLGlHQUFpRyxlQUFlLENBQUMscUhBQXFILHlDQUF5QyxDQUFDLG1EQUFtRCxDQUFDLHVDQUF1Qyx3Q0FBd0MsQ0FBQywwQ0FBMEMsQ0FBQyxtREFBbUQseUNBQXlDLENBQUMsbURBQW1ELHVDQUF1QyxDQUFDLG1HQUFtRyxrREFBa0QsQ0FBQyxvRkFBb0YsQ0FBQyxxSEFBcUgsdURBQXVELENBQUMsK0ZBQStGLENBQUMsZ0ZBQWdGLGtEQUFrRCxDQUFDLGtGQUFrRixDQUFDLGtHQUFrRyxnREFBZ0QsQ0FBQyx3RUFBd0UsQ0FBQyx1UkFBdVIsa0RBQWtELENBQUMsOEZBQThGLENBQUMsNlVBQTZVLHVEQUF1RCxDQUFDLHdHQUF3RyxDQUFDLGtJQUFrSSxrREFBa0QsQ0FBQyxpSUFBaUksQ0FBQyxrSUFBa0ksa0RBQWtELENBQUMseUlBQXlJLENBQUMsa0lBQWtJLGtEQUFrRCxDQUFDLHlJQUF5SSxDQUFDLG9KQUFvSix1REFBdUQsQ0FBQyx1SUFBdUksQ0FBQyxvSkFBb0osdURBQXVELENBQUMsK0lBQStJLENBQUMsb0pBQW9KLHVEQUF1RCxDQUFDLCtJQUErSSxDQUFDLCtHQUErRyxrREFBa0QsQ0FBQyx1SkFBdUosQ0FBQywrR0FBK0csa0RBQWtELENBQUMsK0pBQStKLENBQUMsK0dBQStHLGtEQUFrRCxDQUFDLCtKQUErSixDQUFDLGlJQUFpSSx1REFBdUQsQ0FBQyx1SUFBdUksQ0FBQyxpSUFBaUksdURBQXVELENBQUMsMktBQTJLLENBQUMsaUlBQWlJLHVEQUF1RCxDQUFDLDJLQUEySyxDQUFDLHNNQUFzTSxXQUFXLENBQUMsbUNBQW1DLFlBQVksQ0FBQyw2QkFBNkIsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLHNEQUFzRCxZQUFZLENBQUMsNkJBQTZCLENBQUMsa0JBQWtCLENBQUMsc0VBQXNFLDBCQUEwQixDQUFDLGlCQUFpQixDQUFDLG9FQUFvRSx3QkFBd0IsQ0FBQyxnQkFBZ0IsQ0FBQyw0REFBNEQsWUFBWSxDQUFDLHFDQUFxQyx5REFBeUQsYUFBYSxDQUFDLDRFQUE0RSxhQUFhLENBQUMsaUJBQWlCLENBQUMsOEVBQThFLGFBQWEsQ0FBQyw0RkFBNEYsY0FBYyxDQUFDLDBGQUEwRixhQUFhLENBQUMsQ0FBQyx3REFBd0QsZ0JBQWdCLENBQUMsdURBQXVELGVBQWUsQ0FBQyxvQ0FBb0MsVUFBVSxDQUFDLGlEQUFpRCxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyx5Q0FBeUMsd0JBQXdCLENBQUMscUNBQXFDLHdEQUF3RCxjQUFjLENBQUMsdURBQXVELGFBQWEsQ0FBQyxDQUFDLGlCQUFpQixpQkFBaUIsQ0FBQyxVQUFVLENBQUMsa0NBQWtDLHFCQUFxQixDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyw0QkFBNEIsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLDJCQUEyQixxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsNEJBQTRCLENBQUMsYUFBYSxDQUFDLGlDQUFpQyxXQUFXLENBQUMsOENBQThDLHFCQUFxQixDQUFDLG9CQUFvQixDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsK0JBQStCLENBQUMsY0FBYyxDQUFDLHdCQUF3QixDQUFDLDRCQUE0QixDQUFDLGlCQUFpQixDQUFDLHNCQUFzQixDQUFDLGtIQUFrSCx3QkFBd0IsQ0FBQyxtQ0FBbUMsQ0FBQyxvQ0FBb0MsQ0FBQyw0SUFBNEksQ0FBQywrRkFBK0YsQ0FBQyw0RkFBNEYsQ0FBQywyRkFBMkYsQ0FBQywwRkFBMEYsQ0FBQyw2RkFBNkYsQ0FBQyxrTEFBa0wsY0FBYyxDQUFDLG1DQUFtQyxDQUFDLDRCQUE0QixDQUFDLHNCQUFzQixDQUFDLGVBQWUsQ0FBQyxvREFBb0Qsc0JBQXNCLENBQUMscUJBQXFCLENBQUMscUJBQXFCLENBQUMsMkdBQTJHLENBQUMsOERBQThELENBQUMsMkRBQTJELENBQUMsMERBQTBELENBQUMseURBQXlELENBQUMsNERBQTRELENBQUMscURBQXFELFlBQVksQ0FBQyx3QkFBd0IsQ0FBQyw4R0FBOEcsQ0FBQyxpRUFBaUUsQ0FBQyw4REFBOEQsQ0FBQyw2REFBNkQsQ0FBQyw0REFBNEQsQ0FBQywrREFBK0QsQ0FBQyw2QkFBNkIsQ0FBQyxzQ0FBc0MsYUFBYSxDQUFDLDhJQUE4SSxhQUFhLENBQUMsb0NBQW9DLFVBQVUsQ0FBQyx1REFBdUQsZ0NBQWdDLENBQUMsb1NBQW9TLHFCQUFxQixDQUFDLDRYQUE0WCxRQUFRLENBQUMsZUFBZSxDQUFDLG1CQUFtQixDQUFDLG9CQUFvQixDQUFDLHVEQUF1RCwwQ0FBMEMsQ0FBQyxpREFBaUQsMENBQTBDLENBQUMsdUVBQXVFLGtCQUFrQixDQUFDLFVBQVUsNkJBQTZCLENBQUMsOEJBQThCLENBQUMsbUNBQW1DLENBQUMsNEVBQTRFLHVDQUF1QyxDQUFDLDBGQUEwRixZQUFZLENBQUMsNEVBQTRFLG9DQUFvQyxDQUFDLDZGQUE2RixvQ0FBb0MsQ0FBQyxxSEFBcUgsZUFBZSxDQUFDLHlJQUF5SSx5Q0FBeUMsQ0FBQyxtREFBbUQsQ0FBQyxvR0FBb0csb0NBQW9DLENBQUMsc0NBQXNDLENBQUMsNEhBQTRILHFDQUFxQyxDQUFDLHdEQUF3RCx1Q0FBdUMsQ0FBQyxtRkFBbUYseUNBQXlDLENBQUMsMENBQTBDLENBQUMsZ0lBQWdJLGdDQUFnQyxDQUFDLG9DQUFvQyxDQUFDLHVNQUF1TSxxQkFBcUIsQ0FBQywyREFBMkQsZ0NBQWdDLENBQUMsMEJBQTBCLENBQUMsNERBQTRELGtCQUFrQixDQUFDLGdKQUFnSixnQkFBZ0IsQ0FBQyxrTEFBa0wsZUFBZSxDQUFDLHdEQUF3RCxnQkFBZ0IsQ0FBQyxzREFBc0QsZUFBZSxDQUFDLGdEQUFnRCxnQkFBZ0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiOnJvb3R7LS1kdC1yb3ctc2VsZWN0ZWQ6IDEzLCAxMTAsIDI1MzstLWR0LXJvdy1zZWxlY3RlZC10ZXh0OiAyNTUsIDI1NSwgMjU1Oy0tZHQtcm93LXNlbGVjdGVkLWxpbms6IDksIDEwLCAxMTstLWR0LXJvdy1zdHJpcGU6IDAsIDAsIDA7LS1kdC1yb3ctaG92ZXI6IDAsIDAsIDA7LS1kdC1jb2x1bW4tb3JkZXJpbmc6IDAsIDAsIDA7LS1kdC1odG1sLWJhY2tncm91bmQ6IHdoaXRlfTpyb290LmRhcmt7LS1kdC1odG1sLWJhY2tncm91bmQ6IHJnYigzMywgMzcsIDQxKX10YWJsZS5kYXRhVGFibGUgdGQuZHQtY29udHJvbHt0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcn10YWJsZS5kYXRhVGFibGUgdGQuZHQtY29udHJvbDpiZWZvcmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O2NvbnRlbnQ6XFxcIlxcXCI7Ym9yZGVyLXRvcDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6MTBweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNSk7Ym9yZGVyLWJvdHRvbTo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjBweCBzb2xpZCB0cmFuc3BhcmVudH10YWJsZS5kYXRhVGFibGUgdHIuZHQtaGFzQ2hpbGQgdGQuZHQtY29udHJvbDpiZWZvcmV7Ym9yZGVyLXRvcDoxMHB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC41KTtib3JkZXItbGVmdDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTowcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjVweCBzb2xpZCB0cmFuc3BhcmVudH10YWJsZS5kYXRhVGFibGUgdGZvb3Q6ZW1wdHl7ZGlzcGxheTpub25lfWh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUgdGQuZHQtY29udHJvbDpiZWZvcmUsOnJvb3RbZGF0YS1icy10aGVtZT1kYXJrXSB0YWJsZS5kYXRhVGFibGUgdGQuZHQtY29udHJvbDpiZWZvcmUsOnJvb3RbZGF0YS10aGVtZT1kYXJrXSB0YWJsZS5kYXRhVGFibGUgdGQuZHQtY29udHJvbDpiZWZvcmV7Ym9yZGVyLWxlZnQtY29sb3I6cmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpfWh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUgdHIuZHQtaGFzQ2hpbGQgdGQuZHQtY29udHJvbDpiZWZvcmUsOnJvb3RbZGF0YS1icy10aGVtZT1kYXJrXSB0YWJsZS5kYXRhVGFibGUgdHIuZHQtaGFzQ2hpbGQgdGQuZHQtY29udHJvbDpiZWZvcmUsOnJvb3RbZGF0YS10aGVtZT1kYXJrXSB0YWJsZS5kYXRhVGFibGUgdHIuZHQtaGFzQ2hpbGQgdGQuZHQtY29udHJvbDpiZWZvcmV7Ym9yZGVyLXRvcC1jb2xvcjpyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnR9ZGl2LmR0LXNjcm9sbHt3aWR0aDoxMDAlfWRpdi5kdC1zY3JvbGwtYm9keSB0aGVhZCB0cixkaXYuZHQtc2Nyb2xsLWJvZHkgdGZvb3QgdHJ7aGVpZ2h0OjB9ZGl2LmR0LXNjcm9sbC1ib2R5IHRoZWFkIHRyIHRoLGRpdi5kdC1zY3JvbGwtYm9keSB0aGVhZCB0ciB0ZCxkaXYuZHQtc2Nyb2xsLWJvZHkgdGZvb3QgdHIgdGgsZGl2LmR0LXNjcm9sbC1ib2R5IHRmb290IHRyIHRke2hlaWdodDowICFpbXBvcnRhbnQ7cGFkZGluZy10b3A6MHB4ICFpbXBvcnRhbnQ7cGFkZGluZy1ib3R0b206MHB4ICFpbXBvcnRhbnQ7Ym9yZGVyLXRvcC13aWR0aDowcHggIWltcG9ydGFudDtib3JkZXItYm90dG9tLXdpZHRoOjBweCAhaW1wb3J0YW50fWRpdi5kdC1zY3JvbGwtYm9keSB0aGVhZCB0ciB0aCBkaXYuZHQtc2Nyb2xsLXNpemluZyxkaXYuZHQtc2Nyb2xsLWJvZHkgdGhlYWQgdHIgdGQgZGl2LmR0LXNjcm9sbC1zaXppbmcsZGl2LmR0LXNjcm9sbC1ib2R5IHRmb290IHRyIHRoIGRpdi5kdC1zY3JvbGwtc2l6aW5nLGRpdi5kdC1zY3JvbGwtYm9keSB0Zm9vdCB0ciB0ZCBkaXYuZHQtc2Nyb2xsLXNpemluZ3toZWlnaHQ6MCAhaW1wb3J0YW50O292ZXJmbG93OmhpZGRlbiAhaW1wb3J0YW50fXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aDphY3RpdmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkOmFjdGl2ZXtvdXRsaW5lOm5vbmV9dGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YmVmb3JlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmluZy1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YmVmb3JlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO2JvdHRvbTo1MCU7Y29udGVudDpcXFwi4payXFxcIjtjb250ZW50OlxcXCLilrJcXFwiL1xcXCJcXFwifXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt0b3A6NTAlO2NvbnRlbnQ6XFxcIuKWvFxcXCI7Y29udGVudDpcXFwi4pa8XFxcIi9cXFwiXFxcIn10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWFzYyx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWRlc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWFzYyx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctZGVzYyx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWFzYyx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWRlc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWFzYyx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJpbmctZGVzY3twb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nLXJpZ2h0OjMwcHh9dGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmluZy1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmluZy1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTJweDt0b3A6MDtib3R0b206MDt3aWR0aDoxMnB4fXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YmVmb3JlLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmluZy1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1hc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWFzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJpbmctZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyaW5nLWRlc2Mgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXJ7bGVmdDowO29wYWNpdHk6LjEyNTtsaW5lLWhlaWdodDo5cHg7Zm9udC1zaXplOi44ZW19dGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1hc2MsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1kZXNjLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtYXNjLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtZGVzY3tjdXJzb3I6cG9pbnRlcn10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWFzYzpob3Zlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWRlc2M6aG92ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1hc2M6aG92ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjOmhvdmVye291dGxpbmU6MnB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4wNSk7b3V0bGluZS1vZmZzZXQ6LTJweH10YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJpbmctZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcix0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJpbmctYXNjIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJpbmctZGVzYyBzcGFuLmR0LWNvbHVtbi1vcmRlcjphZnRlcntvcGFjaXR5Oi42fXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5zb3J0aW5nX2Rlc2NfZGlzYWJsZWQgc3Bhbi5kdC1jb2x1bW4tb3JkZXI6YWZ0ZXIsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLnNvcnRpbmdfYXNjX2Rpc2FibGVkIHNwYW4uZHQtY29sdW1uLW9yZGVyOmJlZm9yZSx0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuc29ydGluZ19kZXNjX2Rpc2FibGVkIHNwYW4uZHQtY29sdW1uLW9yZGVyOmFmdGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5zb3J0aW5nX2FzY19kaXNhYmxlZCBzcGFuLmR0LWNvbHVtbi1vcmRlcjpiZWZvcmV7ZGlzcGxheTpub25lfXRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aDphY3RpdmUsdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkOmFjdGl2ZXtvdXRsaW5lOm5vbmV9ZGl2LmR0LXNjcm9sbC1ib2R5PnRhYmxlLmRhdGFUYWJsZT50aGVhZD50cj50aCxkaXYuZHQtc2Nyb2xsLWJvZHk+dGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRke292ZXJmbG93OmhpZGRlbn06cm9vdC5kYXJrIHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtYXNjOmhvdmVyLDpyb290LmRhcmsgdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRoLmR0LW9yZGVyYWJsZS1kZXNjOmhvdmVyLDpyb290LmRhcmsgdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1hc2M6aG92ZXIsOnJvb3QuZGFyayB0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGQuZHQtb3JkZXJhYmxlLWRlc2M6aG92ZXIsOnJvb3RbZGF0YS1icy10aGVtZT1kYXJrXSB0YWJsZS5kYXRhVGFibGUgdGhlYWQ+dHI+dGguZHQtb3JkZXJhYmxlLWFzYzpob3Zlciw6cm9vdFtkYXRhLWJzLXRoZW1lPWRhcmtdIHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50aC5kdC1vcmRlcmFibGUtZGVzYzpob3Zlciw6cm9vdFtkYXRhLWJzLXRoZW1lPWRhcmtdIHRhYmxlLmRhdGFUYWJsZSB0aGVhZD50cj50ZC5kdC1vcmRlcmFibGUtYXNjOmhvdmVyLDpyb290W2RhdGEtYnMtdGhlbWU9ZGFya10gdGFibGUuZGF0YVRhYmxlIHRoZWFkPnRyPnRkLmR0LW9yZGVyYWJsZS1kZXNjOmhvdmVye291dGxpbmU6MnB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSl9ZGl2LmR0LXByb2Nlc3Npbmd7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTt3aWR0aDoyMDBweDttYXJnaW4tbGVmdDotMTAwcHg7bWFyZ2luLXRvcDotMjJweDt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjJweDt6LWluZGV4OjEwfWRpdi5kdC1wcm9jZXNzaW5nPmRpdjpsYXN0LWNoaWxke3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjgwcHg7aGVpZ2h0OjE1cHg7bWFyZ2luOjFlbSBhdXRvfWRpdi5kdC1wcm9jZXNzaW5nPmRpdjpsYXN0LWNoaWxkPmRpdntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt3aWR0aDoxM3B4O2hlaWdodDoxM3B4O2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQ6cmdiKDEzLCAxMTAsIDI1Myk7YmFja2dyb3VuZDpyZ2IodmFyKC0tZHQtcm93LXNlbGVjdGVkKSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMCwgMSwgMSwgMCl9ZGl2LmR0LXByb2Nlc3Npbmc+ZGl2Omxhc3QtY2hpbGQ+ZGl2Om50aC1jaGlsZCgxKXtsZWZ0OjhweDthbmltYXRpb246ZGF0YXRhYmxlcy1sb2FkZXItMSAuNnMgaW5maW5pdGV9ZGl2LmR0LXByb2Nlc3Npbmc+ZGl2Omxhc3QtY2hpbGQ+ZGl2Om50aC1jaGlsZCgyKXtsZWZ0OjhweDthbmltYXRpb246ZGF0YXRhYmxlcy1sb2FkZXItMiAuNnMgaW5maW5pdGV9ZGl2LmR0LXByb2Nlc3Npbmc+ZGl2Omxhc3QtY2hpbGQ+ZGl2Om50aC1jaGlsZCgzKXtsZWZ0OjMycHg7YW5pbWF0aW9uOmRhdGF0YWJsZXMtbG9hZGVyLTIgLjZzIGluZmluaXRlfWRpdi5kdC1wcm9jZXNzaW5nPmRpdjpsYXN0LWNoaWxkPmRpdjpudGgtY2hpbGQoNCl7bGVmdDo1NnB4O2FuaW1hdGlvbjpkYXRhdGFibGVzLWxvYWRlci0zIC42cyBpbmZpbml0ZX1Aa2V5ZnJhbWVzIGRhdGF0YWJsZXMtbG9hZGVyLTF7MCV7dHJhbnNmb3JtOnNjYWxlKDApfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDEpfX1Aa2V5ZnJhbWVzIGRhdGF0YWJsZXMtbG9hZGVyLTN7MCV7dHJhbnNmb3JtOnNjYWxlKDEpfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDApfX1Aa2V5ZnJhbWVzIGRhdGF0YWJsZXMtbG9hZGVyLTJ7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZSgwLCAwKX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGUoMjRweCwgMCl9fXRhYmxlLmRhdGFUYWJsZS5ub3dyYXAgdGgsdGFibGUuZGF0YVRhYmxlLm5vd3JhcCB0ZHt3aGl0ZS1zcGFjZTpub3dyYXB9dGFibGUuZGF0YVRhYmxlIHRoLHRhYmxlLmRhdGFUYWJsZSB0ZHtib3gtc2l6aW5nOmJvcmRlci1ib3h9dGFibGUuZGF0YVRhYmxlIHRoLmR0LXR5cGUtbnVtZXJpYyx0YWJsZS5kYXRhVGFibGUgdGguZHQtdHlwZS1kYXRlLHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC10eXBlLW51bWVyaWMsdGFibGUuZGF0YVRhYmxlIHRkLmR0LXR5cGUtZGF0ZXt0ZXh0LWFsaWduOnJpZ2h0fXRhYmxlLmRhdGFUYWJsZSB0aC5kdC1sZWZ0LHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC1sZWZ0e3RleHQtYWxpZ246bGVmdH10YWJsZS5kYXRhVGFibGUgdGguZHQtY2VudGVyLHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9dGFibGUuZGF0YVRhYmxlIHRoLmR0LXJpZ2h0LHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC1yaWdodHt0ZXh0LWFsaWduOnJpZ2h0fXRhYmxlLmRhdGFUYWJsZSB0aC5kdC1qdXN0aWZ5LHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC1qdXN0aWZ5e3RleHQtYWxpZ246anVzdGlmeX10YWJsZS5kYXRhVGFibGUgdGguZHQtbm93cmFwLHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC1ub3dyYXB7d2hpdGUtc3BhY2U6bm93cmFwfXRhYmxlLmRhdGFUYWJsZSB0aC5kdC1lbXB0eSx0YWJsZS5kYXRhVGFibGUgdGQuZHQtZW1wdHl7dGV4dC1hbGlnbjpjZW50ZXI7dmVydGljYWwtYWxpZ246dG9wfXRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aCx0YWJsZS5kYXRhVGFibGUgdGhlYWQgdGQsdGFibGUuZGF0YVRhYmxlIHRmb290IHRoLHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0ZHt0ZXh0LWFsaWduOmxlZnR9dGFibGUuZGF0YVRhYmxlIHRoZWFkIHRoLmR0LWhlYWQtbGVmdCx0YWJsZS5kYXRhVGFibGUgdGhlYWQgdGQuZHQtaGVhZC1sZWZ0LHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0aC5kdC1oZWFkLWxlZnQsdGFibGUuZGF0YVRhYmxlIHRmb290IHRkLmR0LWhlYWQtbGVmdHt0ZXh0LWFsaWduOmxlZnR9dGFibGUuZGF0YVRhYmxlIHRoZWFkIHRoLmR0LWhlYWQtY2VudGVyLHRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0ZC5kdC1oZWFkLWNlbnRlcix0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGguZHQtaGVhZC1jZW50ZXIsdGFibGUuZGF0YVRhYmxlIHRmb290IHRkLmR0LWhlYWQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyfXRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aC5kdC1oZWFkLXJpZ2h0LHRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0ZC5kdC1oZWFkLXJpZ2h0LHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0aC5kdC1oZWFkLXJpZ2h0LHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0ZC5kdC1oZWFkLXJpZ2h0e3RleHQtYWxpZ246cmlnaHR9dGFibGUuZGF0YVRhYmxlIHRoZWFkIHRoLmR0LWhlYWQtanVzdGlmeSx0YWJsZS5kYXRhVGFibGUgdGhlYWQgdGQuZHQtaGVhZC1qdXN0aWZ5LHRhYmxlLmRhdGFUYWJsZSB0Zm9vdCB0aC5kdC1oZWFkLWp1c3RpZnksdGFibGUuZGF0YVRhYmxlIHRmb290IHRkLmR0LWhlYWQtanVzdGlmeXt0ZXh0LWFsaWduOmp1c3RpZnl9dGFibGUuZGF0YVRhYmxlIHRoZWFkIHRoLmR0LWhlYWQtbm93cmFwLHRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0ZC5kdC1oZWFkLW5vd3JhcCx0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGguZHQtaGVhZC1ub3dyYXAsdGFibGUuZGF0YVRhYmxlIHRmb290IHRkLmR0LWhlYWQtbm93cmFwe3doaXRlLXNwYWNlOm5vd3JhcH10YWJsZS5kYXRhVGFibGUgdGJvZHkgdGguZHQtYm9keS1sZWZ0LHRhYmxlLmRhdGFUYWJsZSB0Ym9keSB0ZC5kdC1ib2R5LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fXRhYmxlLmRhdGFUYWJsZSB0Ym9keSB0aC5kdC1ib2R5LWNlbnRlcix0YWJsZS5kYXRhVGFibGUgdGJvZHkgdGQuZHQtYm9keS1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9dGFibGUuZGF0YVRhYmxlIHRib2R5IHRoLmR0LWJvZHktcmlnaHQsdGFibGUuZGF0YVRhYmxlIHRib2R5IHRkLmR0LWJvZHktcmlnaHR7dGV4dC1hbGlnbjpyaWdodH10YWJsZS5kYXRhVGFibGUgdGJvZHkgdGguZHQtYm9keS1qdXN0aWZ5LHRhYmxlLmRhdGFUYWJsZSB0Ym9keSB0ZC5kdC1ib2R5LWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fXRhYmxlLmRhdGFUYWJsZSB0Ym9keSB0aC5kdC1ib2R5LW5vd3JhcCx0YWJsZS5kYXRhVGFibGUgdGJvZHkgdGQuZHQtYm9keS1ub3dyYXB7d2hpdGUtc3BhY2U6bm93cmFwfTpyb290ey0tZHQtcm93LWhvdmVyLWFscGhhOiAwLjAzNTstLWR0LXJvdy1zdHJpcGUtYWxwaGE6IDAuMDIzOy0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhOiAwLjAxOTstLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGE6IDAuOTIzOy0tZHQtcm93LXNlbGVjdGVkLWNvbHVtbi1vcmRlcmluZy1hbHBoYTogMC45MTl9dGFibGUuZGF0YVRhYmxle3dpZHRoOjEwMCU7bWFyZ2luOjAgYXV0bztib3JkZXItc3BhY2luZzowfXRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aCx0YWJsZS5kYXRhVGFibGUgdGZvb3QgdGh7Zm9udC13ZWlnaHQ6Ym9sZH10YWJsZS5kYXRhVGFibGU+dGhlYWQ+dHI+dGgsdGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRke3BhZGRpbmc6MTBweDtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMyl9dGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRoOmFjdGl2ZSx0YWJsZS5kYXRhVGFibGU+dGhlYWQ+dHI+dGQ6YWN0aXZle291dGxpbmU6bm9uZX10YWJsZS5kYXRhVGFibGU+dGZvb3Q+dHI+dGgsdGFibGUuZGF0YVRhYmxlPnRmb290PnRyPnRke2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtwYWRkaW5nOjEwcHggMTBweCA2cHggMTBweH10YWJsZS5kYXRhVGFibGU+dGJvZHk+dHJ7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH10YWJsZS5kYXRhVGFibGU+dGJvZHk+dHI6Zmlyc3QtY2hpbGQ+Kntib3JkZXItdG9wOm5vbmV9dGFibGUuZGF0YVRhYmxlPnRib2R5PnRyOmxhc3QtY2hpbGQ+Kntib3JkZXItYm90dG9tOm5vbmV9dGFibGUuZGF0YVRhYmxlPnRib2R5PnRyLnNlbGVjdGVkPip7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgxMywgMTEwLCAyNTMsIDAuOSk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCAwLjkpO2NvbG9yOnJnYigyNTUsIDI1NSwgMjU1KTtjb2xvcjpyZ2IodmFyKC0tZHQtcm93LXNlbGVjdGVkLXRleHQpKX10YWJsZS5kYXRhVGFibGU+dGJvZHk+dHIuc2VsZWN0ZWQgYXtjb2xvcjpyZ2IoOSwgMTAsIDExKTtjb2xvcjpyZ2IodmFyKC0tZHQtcm93LXNlbGVjdGVkLWxpbmspKX10YWJsZS5kYXRhVGFibGU+dGJvZHk+dHI+dGgsdGFibGUuZGF0YVRhYmxlPnRib2R5PnRyPnRke3BhZGRpbmc6OHB4IDEwcHh9dGFibGUuZGF0YVRhYmxlLnJvdy1ib3JkZXI+dGJvZHk+dHI+Kix0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cj4qe2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xNSl9dGFibGUuZGF0YVRhYmxlLnJvdy1ib3JkZXI+dGJvZHk+dHI6Zmlyc3QtY2hpbGQ+Kix0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cjpmaXJzdC1jaGlsZD4qe2JvcmRlci10b3A6bm9uZX10YWJsZS5kYXRhVGFibGUucm93LWJvcmRlcj50Ym9keT50ci5zZWxlY3RlZCt0ci5zZWxlY3RlZD50ZCx0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50ci5zZWxlY3RlZCt0ci5zZWxlY3RlZD50ZHtib3JkZXItdG9wLWNvbG9yOnJnYmEoMTMsIDExMCwgMjUzLCAwLjY1KTtib3JkZXItdG9wLWNvbG9yOnJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgMC42NSl9dGFibGUuZGF0YVRhYmxlLmNlbGwtYm9yZGVyPnRib2R5PnRyPip7Ym9yZGVyLXRvcDoxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjE1KTtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xNSl9dGFibGUuZGF0YVRhYmxlLmNlbGwtYm9yZGVyPnRib2R5PnRyPio6Zmlyc3QtY2hpbGR7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xNSl9dGFibGUuZGF0YVRhYmxlLmNlbGwtYm9yZGVyPnRib2R5PnRyOmZpcnN0LWNoaWxkPip7Ym9yZGVyLXRvcDoxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjMpfXRhYmxlLmRhdGFUYWJsZS5zdHJpcGU+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCk+Kix0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cjpudGgtY2hpbGQob2RkKT4qe2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMCwgMCwgMCwgMC4wMjMpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXN0cmlwZSksIHZhcigtLWR0LXJvdy1zdHJpcGUtYWxwaGEpKX10YWJsZS5kYXRhVGFibGUuc3RyaXBlPnRib2R5PnRyOm50aC1jaGlsZChvZGQpLnNlbGVjdGVkPiosdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCkuc2VsZWN0ZWQ+Kntib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDEzLCAxMTAsIDI1MywgMC45MjMpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgdmFyKC0tZHQtcm93LXNlbGVjdGVkLXN0cmlwZS1hbHBoYSkpfXRhYmxlLmRhdGFUYWJsZS5ob3Zlcj50Ym9keT50cjpob3Zlcj4qLHRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOmhvdmVyPip7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgwLCAwLCAwLCAwLjAzNSk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctaG92ZXIpLCB2YXIoLS1kdC1yb3ctaG92ZXItYWxwaGEpKX10YWJsZS5kYXRhVGFibGUuaG92ZXI+dGJvZHk+dHIuc2VsZWN0ZWQ6aG92ZXI+Kix0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50ci5zZWxlY3RlZDpob3Zlcj4qe2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4ICMwZDZlZmQgIWltcG9ydGFudDtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LXJvdy1zZWxlY3RlZCksIDEpICFpbXBvcnRhbnR9dGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbj50Ym9keSB0cj4uc29ydGluZ18xLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4+dGJvZHkgdHI+LnNvcnRpbmdfMix0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uPnRib2R5IHRyPi5zb3J0aW5nXzMsdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHkgdHI+LnNvcnRpbmdfMSx0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keSB0cj4uc29ydGluZ18yLHRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5IHRyPi5zb3J0aW5nXzN7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgwLCAwLCAwLCAwLjAxOSk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmcpLCB2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmctYWxwaGEpKX10YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uPnRib2R5IHRyLnNlbGVjdGVkPi5zb3J0aW5nXzEsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbj50Ym9keSB0ci5zZWxlY3RlZD4uc29ydGluZ18yLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4+dGJvZHkgdHIuc2VsZWN0ZWQ+LnNvcnRpbmdfMyx0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keSB0ci5zZWxlY3RlZD4uc29ydGluZ18xLHRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5IHRyLnNlbGVjdGVkPi5zb3J0aW5nXzIsdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHkgdHIuc2VsZWN0ZWQ+LnNvcnRpbmdfM3tib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDEzLCAxMTAsIDI1MywgMC45MTkpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgdmFyKC0tZHQtcm93LXNlbGVjdGVkLWNvbHVtbi1vcmRlcmluZy1hbHBoYSkpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOm50aC1jaGlsZChvZGQpPi5zb3J0aW5nXzEsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5zdHJpcGU+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCk+LnNvcnRpbmdfMXtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDAsIDAsIDAsIDAuMDU0KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZyksIGNhbGModmFyKC0tZHQtcm93LXN0cmlwZS1hbHBoYSkgKyB2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmctYWxwaGEpKSl9dGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCk+LnNvcnRpbmdfMix0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uLnN0cmlwZT50Ym9keT50cjpudGgtY2hpbGQob2RkKT4uc29ydGluZ18ye2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMCwgMCwgMCwgMC4wNDcpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEodmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nKSwgY2FsYyh2YXIoLS1kdC1yb3ctc3RyaXBlLWFscGhhKSArIHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZy1hbHBoYSkgLSAwLjAwNykpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5PnRib2R5PnRyOm50aC1jaGlsZChvZGQpPi5zb3J0aW5nXzMsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5zdHJpcGU+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCk+LnNvcnRpbmdfM3tib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDAsIDAsIDAsIDAuMDM5KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LWNvbHVtbi1vcmRlcmluZyksIGNhbGModmFyKC0tZHQtcm93LXN0cmlwZS1hbHBoYSkgKyB2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmctYWxwaGEpIC0gMC4wMTUpKX10YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cjpudGgtY2hpbGQob2RkKS5zZWxlY3RlZD4uc29ydGluZ18xLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4uc3RyaXBlPnRib2R5PnRyOm50aC1jaGlsZChvZGQpLnNlbGVjdGVkPi5zb3J0aW5nXzF7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgxMywgMTEwLCAyNTMsIDAuOTU0KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LXJvdy1zZWxlY3RlZCksIGNhbGModmFyKC0tZHQtcm93LXNlbGVjdGVkLXN0cmlwZS1hbHBoYSkgKyB2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmctYWxwaGEpKSl9dGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCkuc2VsZWN0ZWQ+LnNvcnRpbmdfMix0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uLnN0cmlwZT50Ym9keT50cjpudGgtY2hpbGQob2RkKS5zZWxlY3RlZD4uc29ydGluZ18ye2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMTMsIDExMCwgMjUzLCAwLjk0Nyk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCBjYWxjKHZhcigtLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSAtIDAuMDA3KSl9dGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6bnRoLWNoaWxkKG9kZCkuc2VsZWN0ZWQ+LnNvcnRpbmdfMyx0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uLnN0cmlwZT50Ym9keT50cjpudGgtY2hpbGQob2RkKS5zZWxlY3RlZD4uc29ydGluZ18ze2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMTMsIDExMCwgMjUzLCAwLjkzOSk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCBjYWxjKHZhcigtLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSAtIDAuMDE1KSl9dGFibGUuZGF0YVRhYmxlLmRpc3BsYXkgdGJvZHkgdHI6aG92ZXI+LnNvcnRpbmdfMSx0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uLmhvdmVyIHRib2R5IHRyOmhvdmVyPi5zb3J0aW5nXzF7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgwLCAwLCAwLCAwLjA4Mik7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctaG92ZXIpLCBjYWxjKHZhcigtLWR0LXJvdy1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSArIHZhcigtLWR0LXJvdy1ob3Zlci1hbHBoYSkpKX10YWJsZS5kYXRhVGFibGUuZGlzcGxheSB0Ym9keSB0cjpob3Zlcj4uc29ydGluZ18yLHRhYmxlLmRhdGFUYWJsZS5vcmRlci1jb2x1bW4uaG92ZXIgdGJvZHkgdHI6aG92ZXI+LnNvcnRpbmdfMntib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKDAsIDAsIDAsIDAuMDc0KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDk5OTlweCByZ2JhKHZhcigtLWR0LXJvdy1ob3ZlciksIGNhbGModmFyKC0tZHQtcm93LXN0cmlwZS1hbHBoYSkgKyB2YXIoLS1kdC1jb2x1bW4tb3JkZXJpbmctYWxwaGEpICsgdmFyKC0tZHQtcm93LWhvdmVyLWFscGhhKSAtIDAuMDA3KSl9dGFibGUuZGF0YVRhYmxlLmRpc3BsYXkgdGJvZHkgdHI6aG92ZXI+LnNvcnRpbmdfMyx0YWJsZS5kYXRhVGFibGUub3JkZXItY29sdW1uLmhvdmVyIHRib2R5IHRyOmhvdmVyPi5zb3J0aW5nXzN7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSgwLCAwLCAwLCAwLjA2Mik7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctaG92ZXIpLCBjYWxjKHZhcigtLWR0LXJvdy1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSArIHZhcigtLWR0LXJvdy1ob3Zlci1hbHBoYSkgLSAwLjAxNSkpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5IHRib2R5IHRyOmhvdmVyLnNlbGVjdGVkPi5zb3J0aW5nXzEsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5ob3ZlciB0Ym9keSB0cjpob3Zlci5zZWxlY3RlZD4uc29ydGluZ18xe2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMTMsIDExMCwgMjUzLCAwLjk4Mik7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCBjYWxjKHZhcigtLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSkpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5IHRib2R5IHRyOmhvdmVyLnNlbGVjdGVkPi5zb3J0aW5nXzIsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5ob3ZlciB0Ym9keSB0cjpob3Zlci5zZWxlY3RlZD4uc29ydGluZ18ye2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMTMsIDExMCwgMjUzLCAwLjk3NCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCBjYWxjKHZhcigtLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSArIHZhcigtLWR0LXJvdy1ob3Zlci1hbHBoYSkgLSAwLjAwNykpfXRhYmxlLmRhdGFUYWJsZS5kaXNwbGF5IHRib2R5IHRyOmhvdmVyLnNlbGVjdGVkPi5zb3J0aW5nXzMsdGFibGUuZGF0YVRhYmxlLm9yZGVyLWNvbHVtbi5ob3ZlciB0Ym9keSB0cjpob3Zlci5zZWxlY3RlZD4uc29ydGluZ18ze2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgOTk5OXB4IHJnYmEoMTMsIDExMCwgMjUzLCAwLjk2Mik7Ym94LXNoYWRvdzppbnNldCAwIDAgMCA5OTk5cHggcmdiYSh2YXIoLS1kdC1yb3ctc2VsZWN0ZWQpLCBjYWxjKHZhcigtLWR0LXJvdy1zZWxlY3RlZC1zdHJpcGUtYWxwaGEpICsgdmFyKC0tZHQtY29sdW1uLW9yZGVyaW5nLWFscGhhKSArIHZhcigtLWR0LXJvdy1ob3Zlci1hbHBoYSkgLSAwLjAxNSkpfXRhYmxlLmRhdGFUYWJsZS5jb21wYWN0IHRoZWFkIHRoLHRhYmxlLmRhdGFUYWJsZS5jb21wYWN0IHRoZWFkIHRkLHRhYmxlLmRhdGFUYWJsZS5jb21wYWN0IHRmb290IHRoLHRhYmxlLmRhdGFUYWJsZS5jb21wYWN0IHRmb290IHRkLHRhYmxlLmRhdGFUYWJsZS5jb21wYWN0IHRib2R5IHRoLHRhYmxlLmRhdGFUYWJsZS5jb21wYWN0IHRib2R5IHRke3BhZGRpbmc6NHB4fWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3d7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcjt3aWR0aDoxMDAlO21hcmdpbjouNzVlbSAwfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3cgZGl2LmR0LWxheW91dC1jZWxse2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXJ9ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LXJvdyBkaXYuZHQtbGF5b3V0LWNlbGwuZHQtbGF5b3V0LXN0YXJ0e2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O21hcmdpbi1yaWdodDphdXRvfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3cgZGl2LmR0LWxheW91dC1jZWxsLmR0LWxheW91dC1lbmR7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO21hcmdpbi1sZWZ0OmF1dG99ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LXJvdyBkaXYuZHQtbGF5b3V0LWNlbGw6ZW1wdHl7ZGlzcGxheTpub25lfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2N3B4KXtkaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtcm93Om5vdCguZHQtbGF5b3V0LXRhYmxlKXtkaXNwbGF5OmJsb2NrfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3c6bm90KC5kdC1sYXlvdXQtdGFibGUpIGRpdi5kdC1sYXlvdXQtY2VsbHtkaXNwbGF5OmJsb2NrO3RleHQtYWxpZ246Y2VudGVyfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1yb3c6bm90KC5kdC1sYXlvdXQtdGFibGUpIGRpdi5kdC1sYXlvdXQtY2VsbD4qe21hcmdpbjouNWVtIDB9ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LXJvdzpub3QoLmR0LWxheW91dC10YWJsZSkgZGl2LmR0LWxheW91dC1jZWxsLmR0LWxheW91dC1zdGFydHttYXJnaW4tcmlnaHQ6MH1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtcm93Om5vdCguZHQtbGF5b3V0LXRhYmxlKSBkaXYuZHQtbGF5b3V0LWNlbGwuZHQtbGF5b3V0LWVuZHttYXJnaW4tbGVmdDowfX1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtc3RhcnQ+Kjpub3QoOmxhc3QtY2hpbGQpe21hcmdpbi1yaWdodDoxZW19ZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtbGF5b3V0LWVuZD4qOm5vdCg6Zmlyc3QtY2hpbGQpe21hcmdpbi1sZWZ0OjFlbX1kaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtZnVsbHt3aWR0aDoxMDAlfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1mdWxsPio6b25seS1jaGlsZHttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC10YWJsZT5kaXZ7ZGlzcGxheTpibG9jayAhaW1wb3J0YW50fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2N3B4KXtkaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtc3RhcnQ+Kjpub3QoOmxhc3QtY2hpbGQpe21hcmdpbi1yaWdodDowfWRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1lbmQ+Kjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDowfX1kaXYuZHQtY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO2NsZWFyOmJvdGh9ZGl2LmR0LWNvbnRhaW5lciAuZHQtc2VhcmNoIGlucHV0e2JvcmRlcjoxcHggc29saWQgI2FhYTtib3JkZXItcmFkaXVzOjNweDtwYWRkaW5nOjVweDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2NvbG9yOmluaGVyaXQ7bWFyZ2luLWxlZnQ6M3B4fWRpdi5kdC1jb250YWluZXIgLmR0LWlucHV0e2JvcmRlcjoxcHggc29saWQgI2FhYTtib3JkZXItcmFkaXVzOjNweDtwYWRkaW5nOjVweDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2NvbG9yOmluaGVyaXR9ZGl2LmR0LWNvbnRhaW5lciBzZWxlY3QuZHQtaW5wdXR7cGFkZGluZzo0cHh9ZGl2LmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5kdC1wYWdpbmctYnV0dG9ue2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmlubGluZS1ibG9jazttaW4td2lkdGg6MS41ZW07cGFkZGluZzouNWVtIDFlbTttYXJnaW4tbGVmdDoycHg7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC1kZWNvcmF0aW9uOm5vbmUgIWltcG9ydGFudDtjdXJzb3I6cG9pbnRlcjtjb2xvcjppbmhlcml0ICFpbXBvcnRhbnQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjJweDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fWRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5jdXJyZW50LGRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5jdXJyZW50OmhvdmVye2NvbG9yOmluaGVyaXQgIWltcG9ydGFudDtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwgMCwgMCwgMC4wNSk7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIGxlZnQgYm90dG9tLCBjb2xvci1zdG9wKDAlLCByZ2JhKDIzMCwgMjMwLCAyMzAsIDAuMDUpKSwgY29sb3Itc3RvcCgxMDAlLCByZ2JhKDAsIDAsIDAsIDAuMDUpKSk7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsIHJnYmEoMjMwLCAyMzAsIDIzMCwgMC4wNSkgMCUsIHJnYmEoMCwgMCwgMCwgMC4wNSkgMTAwJSk7YmFja2dyb3VuZDotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsIHJnYmEoMjMwLCAyMzAsIDIzMCwgMC4wNSkgMCUsIHJnYmEoMCwgMCwgMCwgMC4wNSkgMTAwJSk7YmFja2dyb3VuZDotbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgcmdiYSgyMzAsIDIzMCwgMjMwLCAwLjA1KSAwJSwgcmdiYSgwLCAwLCAwLCAwLjA1KSAxMDAlKTtiYWNrZ3JvdW5kOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsIHJnYmEoMjMwLCAyMzAsIDIzMCwgMC4wNSkgMCUsIHJnYmEoMCwgMCwgMCwgMC4wNSkgMTAwJSk7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKDIzMCwgMjMwLCAyMzAsIDAuMDUpIDAlLCByZ2JhKDAsIDAsIDAsIDAuMDUpIDEwMCUpfWRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5kaXNhYmxlZCxkaXYuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b24uZGlzYWJsZWQ6aG92ZXIsZGl2LmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5kdC1wYWdpbmctYnV0dG9uLmRpc2FibGVkOmFjdGl2ZXtjdXJzb3I6ZGVmYXVsdDtjb2xvcjpyZ2JhKDAsIDAsIDAsIDAuNSkgIWltcG9ydGFudDtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ym94LXNoYWRvdzpub25lfWRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbjpob3Zlcntjb2xvcjp3aGl0ZSAhaW1wb3J0YW50O2JvcmRlcjoxcHggc29saWQgIzExMTtiYWNrZ3JvdW5kLWNvbG9yOiMxMTE7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIGxlZnQgYm90dG9tLCBjb2xvci1zdG9wKDAlLCAjNTg1ODU4KSwgY29sb3Itc3RvcCgxMDAlLCAjMTExKSk7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICM1ODU4NTggMCUsICMxMTEgMTAwJSk7YmFja2dyb3VuZDotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICM1ODU4NTggMCUsICMxMTEgMTAwJSk7YmFja2dyb3VuZDotbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgIzU4NTg1OCAwJSwgIzExMSAxMDAlKTtiYWNrZ3JvdW5kOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsICM1ODU4NTggMCUsICMxMTEgMTAwJSk7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjNTg1ODU4IDAlLCAjMTExIDEwMCUpfWRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbjphY3RpdmV7b3V0bGluZTpub25lO2JhY2tncm91bmQtY29sb3I6IzBjMGMwYztiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgbGVmdCBib3R0b20sIGNvbG9yLXN0b3AoMCUsICMyYjJiMmIpLCBjb2xvci1zdG9wKDEwMCUsICMwYzBjMGMpKTtiYWNrZ3JvdW5kOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgIzJiMmIyYiAwJSwgIzBjMGMwYyAxMDAlKTtiYWNrZ3JvdW5kOi1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgIzJiMmIyYiAwJSwgIzBjMGMwYyAxMDAlKTtiYWNrZ3JvdW5kOi1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAjMmIyYjJiIDAlLCAjMGMwYzBjIDEwMCUpO2JhY2tncm91bmQ6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwgIzJiMmIyYiAwJSwgIzBjMGMwYyAxMDAlKTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICMyYjJiMmIgMCUsICMwYzBjMGMgMTAwJSk7Ym94LXNoYWRvdzppbnNldCAwIDAgM3B4ICMxMTF9ZGl2LmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5lbGxpcHNpc3twYWRkaW5nOjAgMWVtfWRpdi5kdC1jb250YWluZXIgLmR0LWxlbmd0aCxkaXYuZHQtY29udGFpbmVyIC5kdC1zZWFyY2gsZGl2LmR0LWNvbnRhaW5lciAuZHQtaW5mbyxkaXYuZHQtY29udGFpbmVyIC5kdC1wcm9jZXNzaW5nLGRpdi5kdC1jb250YWluZXIgLmR0LXBhZ2luZ3tjb2xvcjppbmhlcml0fWRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xse2NsZWFyOmJvdGh9ZGl2LmR0LWNvbnRhaW5lciAuZGF0YVRhYmxlc19zY3JvbGwgZGl2LmR0LXNjcm9sbC1ib2R5ey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNofWRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xsIGRpdi5kdC1zY3JvbGwtYm9keT50YWJsZT50aGVhZD50cj50aCxkaXYuZHQtY29udGFpbmVyIC5kYXRhVGFibGVzX3Njcm9sbCBkaXYuZHQtc2Nyb2xsLWJvZHk+dGFibGU+dGhlYWQ+dHI+dGQsZGl2LmR0LWNvbnRhaW5lciAuZGF0YVRhYmxlc19zY3JvbGwgZGl2LmR0LXNjcm9sbC1ib2R5PnRhYmxlPnRib2R5PnRyPnRoLGRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xsIGRpdi5kdC1zY3JvbGwtYm9keT50YWJsZT50Ym9keT50cj50ZHt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9ZGl2LmR0LWNvbnRhaW5lciAuZGF0YVRhYmxlc19zY3JvbGwgZGl2LmR0LXNjcm9sbC1ib2R5PnRhYmxlPnRoZWFkPnRyPnRoPmRpdi5kYXRhVGFibGVzX3NpemluZyxkaXYuZHQtY29udGFpbmVyIC5kYXRhVGFibGVzX3Njcm9sbCBkaXYuZHQtc2Nyb2xsLWJvZHk+dGFibGU+dGhlYWQ+dHI+dGQ+ZGl2LmRhdGFUYWJsZXNfc2l6aW5nLGRpdi5kdC1jb250YWluZXIgLmRhdGFUYWJsZXNfc2Nyb2xsIGRpdi5kdC1zY3JvbGwtYm9keT50YWJsZT50Ym9keT50cj50aD5kaXYuZGF0YVRhYmxlc19zaXppbmcsZGl2LmR0LWNvbnRhaW5lciAuZGF0YVRhYmxlc19zY3JvbGwgZGl2LmR0LXNjcm9sbC1ib2R5PnRhYmxlPnRib2R5PnRyPnRkPmRpdi5kYXRhVGFibGVzX3NpemluZ3toZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47bWFyZ2luOjAgIWltcG9ydGFudDtwYWRkaW5nOjAgIWltcG9ydGFudH1kaXYuZHQtY29udGFpbmVyLmR0LWVtcHR5LWZvb3RlciB0Ym9keT50cjpsYXN0LWNoaWxkPip7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjMpfWRpdi5kdC1jb250YWluZXIuZHQtZW1wdHktZm9vdGVyIC5kdC1zY3JvbGwtYm9keXtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMyl9ZGl2LmR0LWNvbnRhaW5lci5kdC1lbXB0eS1mb290ZXIgLmR0LXNjcm9sbC1ib2R5IHRib2R5PnRyOmxhc3QtY2hpbGQ+Kntib3JkZXItYm90dG9tOm5vbmV9aHRtbC5kYXJrey0tZHQtcm93LWhvdmVyOiAyNTUsIDI1NSwgMjU1Oy0tZHQtcm93LXN0cmlwZTogMjU1LCAyNTUsIDI1NTstLWR0LWNvbHVtbi1vcmRlcmluZzogMjU1LCAyNTUsIDI1NX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlPnRoZWFkPnRyPnRoLGh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGU+dGhlYWQ+dHI+dGR7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiKDg5LCA5MSwgOTQpfWh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGU+dGhlYWQ+dHI+dGg6YWN0aXZlLGh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGU+dGhlYWQ+dHI+dGQ6YWN0aXZle291dGxpbmU6bm9uZX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlPnRmb290PnRyPnRoLGh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGU+dGZvb3Q+dHI+dGR7Ym9yZGVyLXRvcDoxcHggc29saWQgcmdiKDg5LCA5MSwgOTQpfWh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUucm93LWJvcmRlcj50Ym9keT50cj4qLGh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50cj4qe2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYig2NCwgNjcsIDcwKX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLnJvdy1ib3JkZXI+dGJvZHk+dHI6Zmlyc3QtY2hpbGQ+KixodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLmRpc3BsYXk+dGJvZHk+dHI6Zmlyc3QtY2hpbGQ+Kntib3JkZXItdG9wOm5vbmV9aHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZS5yb3ctYm9yZGVyPnRib2R5PnRyLnNlbGVjdGVkK3RyLnNlbGVjdGVkPnRkLGh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUuZGlzcGxheT50Ym9keT50ci5zZWxlY3RlZCt0ci5zZWxlY3RlZD50ZHtib3JkZXItdG9wLWNvbG9yOnJnYmEoMTMsIDExMCwgMjUzLCAwLjY1KTtib3JkZXItdG9wLWNvbG9yOnJnYmEodmFyKC0tZHQtcm93LXNlbGVjdGVkKSwgMC42NSl9aHRtbC5kYXJrIHRhYmxlLmRhdGFUYWJsZS5jZWxsLWJvcmRlcj50Ym9keT50cj50aCxodG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLmNlbGwtYm9yZGVyPnRib2R5PnRyPnRke2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYig2NCwgNjcsIDcwKTtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYig2NCwgNjcsIDcwKX1odG1sLmRhcmsgdGFibGUuZGF0YVRhYmxlLmNlbGwtYm9yZGVyPnRib2R5PnRyPnRoOmZpcnN0LWNoaWxkLGh0bWwuZGFyayB0YWJsZS5kYXRhVGFibGUuY2VsbC1ib3JkZXI+dGJvZHk+dHI+dGQ6Zmlyc3QtY2hpbGR7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkIHJnYig2NCwgNjcsIDcwKX1odG1sLmRhcmsgLmR0LWNvbnRhaW5lci5kdC1lbXB0eS1mb290ZXIgdGFibGUuZGF0YVRhYmxle2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYig4OSwgOTEsIDk0KX1odG1sLmRhcmsgLmR0LWNvbnRhaW5lciAuZHQtc2VhcmNoIGlucHV0LGh0bWwuZGFyayAuZHQtY29udGFpbmVyIC5kdC1sZW5ndGggc2VsZWN0e2JvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO2JhY2tncm91bmQtY29sb3I6dmFyKC0tZHQtaHRtbC1iYWNrZ3JvdW5kKX1odG1sLmRhcmsgLmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5kdC1wYWdpbmctYnV0dG9uLmN1cnJlbnQsaHRtbC5kYXJrIC5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5jdXJyZW50OmhvdmVye2JvcmRlcjoxcHggc29saWQgcmdiKDg5LCA5MSwgOTQpO2JhY2tncm91bmQ6cmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE1KX1odG1sLmRhcmsgLmR0LWNvbnRhaW5lciAuZHQtcGFnaW5nIC5kdC1wYWdpbmctYnV0dG9uLmRpc2FibGVkLGh0bWwuZGFyayAuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b24uZGlzYWJsZWQ6aG92ZXIsaHRtbC5kYXJrIC5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbi5kaXNhYmxlZDphY3RpdmV7Y29sb3I6IzY2NiAhaW1wb3J0YW50fWh0bWwuZGFyayAuZHQtY29udGFpbmVyIC5kdC1wYWdpbmcgLmR0LXBhZ2luZy1idXR0b246aG92ZXJ7Ym9yZGVyOjFweCBzb2xpZCByZ2IoNTMsIDUzLCA1Myk7YmFja2dyb3VuZDpyZ2IoNTMsIDUzLCA1Myl9aHRtbC5kYXJrIC5kdC1jb250YWluZXIgLmR0LXBhZ2luZyAuZHQtcGFnaW5nLWJ1dHRvbjphY3RpdmV7YmFja2dyb3VuZDojM2EzYTNhfSpbZGlyPXJ0bF0gdGFibGUuZGF0YVRhYmxlIHRoZWFkIHRoLCpbZGlyPXJ0bF0gdGFibGUuZGF0YVRhYmxlIHRoZWFkIHRkLCpbZGlyPXJ0bF0gdGFibGUuZGF0YVRhYmxlIHRmb290IHRoLCpbZGlyPXJ0bF0gdGFibGUuZGF0YVRhYmxlIHRmb290IHRke3RleHQtYWxpZ246cmlnaHR9KltkaXI9cnRsXSB0YWJsZS5kYXRhVGFibGUgdGguZHQtdHlwZS1udW1lcmljLCpbZGlyPXJ0bF0gdGFibGUuZGF0YVRhYmxlIHRoLmR0LXR5cGUtZGF0ZSwqW2Rpcj1ydGxdIHRhYmxlLmRhdGFUYWJsZSB0ZC5kdC10eXBlLW51bWVyaWMsKltkaXI9cnRsXSB0YWJsZS5kYXRhVGFibGUgdGQuZHQtdHlwZS1kYXRle3RleHQtYWxpZ246bGVmdH0qW2Rpcj1ydGxdIGRpdi5kdC1jb250YWluZXIgZGl2LmR0LWxheW91dC1jZWxsLmR0LXN0YXJ0e3RleHQtYWxpZ246cmlnaHR9KltkaXI9cnRsXSBkaXYuZHQtY29udGFpbmVyIGRpdi5kdC1sYXlvdXQtY2VsbC5kdC1lbmR7dGV4dC1hbGlnbjpsZWZ0fSpbZGlyPXJ0bF0gZGl2LmR0LWNvbnRhaW5lciBkaXYuZHQtc2VhcmNoIGlucHV0e21hcmdpbjowIDNweCAwIDB9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgdGFibGUuZml4ZWRIZWFkZXItZmxvYXRpbmcsdGFibGUuZml4ZWRIZWFkZXItbG9ja2Vke3Bvc2l0aW9uOnJlbGF0aXZlICFpbXBvcnRhbnQ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1kdC1odG1sLWJhY2tncm91bmQpO2JhY2tncm91bmQtY29sb3I6dmFyKC0tZHQtaHRtbC1iYWNrZ3JvdW5kKX1AbWVkaWEgcHJpbnR7dGFibGUuZml4ZWRIZWFkZXItZmxvYXRpbmd7ZGlzcGxheTpub25lfX1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LWZpeGVkaGVhZGVyLWR0L2Nzcy9maXhlZEhlYWRlci5kYXRhVGFibGVzLm1pbi5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsb0RBQW9ELDRCQUE0QixDQUFDLDBDQUEwQyxDQUFDLDBDQUEwQyxDQUFDLGFBQWEsMkJBQTJCLFlBQVksQ0FBQ1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCJ0YWJsZS5maXhlZEhlYWRlci1mbG9hdGluZyx0YWJsZS5maXhlZEhlYWRlci1sb2NrZWR7cG9zaXRpb246cmVsYXRpdmUgIWltcG9ydGFudDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWR0LWh0bWwtYmFja2dyb3VuZCk7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1kdC1odG1sLWJhY2tncm91bmQpfUBtZWRpYSBwcmludHt0YWJsZS5maXhlZEhlYWRlci1mbG9hdGluZ3tkaXNwbGF5Om5vbmV9fVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgYm9keSB7XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMDtcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBoZWlnaHQ6IDEwMHZoO1xufVxuXG4uYXBwLWNvbnRhaW5lciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGhlaWdodDogMTAwdmg7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XG59XG5cbi5tZW51LWJhciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigzMCwgMzAsIDMwKTtcbiAgcGFkZGluZzogNHB4O1xuICBjb2xvcjogd2hpdGU7XG59XG5cbi5tZW51LWdyb3VwIHtcbiAgZGlzcGxheTogZmxleDtcbiAgbWFyZ2luLXJpZ2h0OiAxNXB4O1xuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gIHBhZGRpbmctcmlnaHQ6IDE1cHg7XG59XG5cbi5tZW51LWJ1dHRvbiB7XG4gIGJhY2tncm91bmQ6IG5vbmU7XG4gIGJvcmRlcjogbm9uZTtcbiAgY29sb3I6IHdoaXRlO1xuICBwYWRkaW5nOiA1cHggMTBweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBmb250LXNpemU6IDEycHg7XG59XG5cbi5tZW51LWJ1dHRvbjpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbn1cblxuLmljb24ge1xuICBtYXJnaW4tcmlnaHQ6IDVweDtcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xufVxuXG4ubWFpbi1sYXlvdXQge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4OiAxO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4uc2lkZWJhciB7XG4gIHdpZHRoOiAyNTBweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2RkZDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cblxuLnRyZWUtdGl0bGUge1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xuICBwYWRkaW5nOiA4cHg7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlOGU4ZTg7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xufVxuXG4udHJlZS12aWV3IHtcbiAgZmxleDogMTtcbiAgb3ZlcmZsb3c6IGF1dG87XG4gIHBhZGRpbmc6IDVweDtcbn1cblxuLnRyZWUtaXRlbSB7XG4gIG1hcmdpbjogMnB4IDA7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLnRyZWUtbGFiZWwge1xuICBwYWRkaW5nOiAzcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGZvbnQtc2l6ZTogMTZweDsgLyog5paH5a2X44K144Kk44K6ICovXG59XG5cbi8qIOODhOODquODvOODqeODmeODq+WGheOBruOCouOCpOOCs+ODs+OCteOCpOOCuuiqv+aVtCAqL1xuLnRyZWUtbGFiZWwgLm1hdGVyaWFsLXN5bWJvbHMtb3V0bGluZWQge1xuICBmb250LXNpemU6IDE4cHg7IC8qIOOCouOCpOOCs+ODs+OCteOCpOOCuiAqL1xuICBtYXJnaW4tcmlnaHQ6IDRweDsgLyog44Ki44Kk44Kz44Oz44Go44OG44Kt44K544OI44Gu6ZaT6ZqU6Kq/5pW0ICovXG59XG5cbi8qIOODiOOCsOODq+OCouOCpOOCs+ODs+OBruiqv+aVtCAo5b+F6KaB44Gr5b+c44GY44GmKSAqL1xuLnRyZWUtbGFiZWwgLnRvZ2dsZS1pY29uIHtcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XG59XG5cbi50cmVlLWxhYmVsOmhvdmVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2UwZTBlMDtcbn1cblxuLnRyZWUtaXRlbXMge1xuICBtYXJnaW4tbGVmdDogMzBweDsgLyog44Kk44Oz44OH44Oz44OI44KSIDIwcHgg44GL44KJIDMwcHgg44Gr5aSJ5pu0ICovXG59XG5cbi5tYWluLWFyZWEge1xuICBmbGV4OiAxO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4ucXVlcnktdGFicyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlOGU4ZTg7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xufVxuXG4ucXVlcnktdGFiIHtcbiAgcGFkZGluZzogOHB4IDE1cHg7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBmb250LXNpemU6IDEzcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbi5xdWVyeS10YWIuYWN0aXZlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG59XG5cbi5jbG9zZS10YWIge1xuICBtYXJnaW4tbGVmdDogOHB4O1xuICBmb250LXNpemU6IDE0cHg7XG4gIG9wYWNpdHk6IDAuNjtcbn1cblxuLmNsb3NlLXRhYjpob3ZlciB7XG4gIG9wYWNpdHk6IDE7XG59XG5cbi8qIOOCv+ODluOBruiDjOaZr+iJsjog44Ki44Kv44OG44Kj44OW44Go6Z2e44Ki44Kv44OG44Kj44OWICovXG4ucXVlcnktdGFiIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcbn1cbi5xdWVyeS10YWIuYWN0aXZlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG59XG5cbi5xdWVyeS1lZGl0b3Ige1xuICBoZWlnaHQ6IDIwMHB4O1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcbn1cblxuLnF1ZXJ5LWVkaXRvciB0ZXh0YXJlYSB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHJlc2l6ZTogbm9uZTtcbiAgYm9yZGVyOiBub25lO1xuICBwYWRkaW5nOiAxMHB4O1xuICBmb250LWZhbWlseTogJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlO1xuICBmb250LXNpemU6IDE0cHg7XG59XG5cbi5yZXN1bHRzLWNvbnRhaW5lciB7XG4gIGZsZXg6IDE7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5yZXN1bHRzLXRhYnMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcbn1cblxuLnJlc3VsdC10YWIge1xuICBwYWRkaW5nOiA1cHggMTVweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ucmVzdWx0LXRhYi5hY3RpdmUge1xuICBib3JkZXItYm90dG9tOiAycHggc29saWQgIzAwNzhkNztcbn1cblxuLnJlc3VsdHMtZ3JpZCB7XG4gIGZsZXg6IDE7XG4gIHBhZGRpbmc6IDA7IC8qIOODkeODh+OCo+ODs+OCsOOCkiAwIOOBq+WkieabtCAqL1xuICBvdmVyZmxvdy15OiBhdXRvOyAvKiDnuKbjgrnjgq/jg63jg7zjg6vjgpLjgrPjg7Pjg4bjg4rjgafnrqHnkIYgKi9cbiAgb3ZlcmZsb3cteDogYXV0bzsgLyog5qiq44K544Kv44Ot44O844OrICovXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICBkaXNwbGF5OiBmbGV4OyAvKiBEYXRhVGFibGVz44Kz44Oz44OG44OK44GMZmxleOOCouOCpOODhuODoOOBqOOBl+OBpumrmOOBleOCkuWNoOOCgeOCi+OCiOOBhuOBqyAqL1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyAvKiBEYXRhVGFibGVz44Kz44Oz44OG44OK44KS57im44Gr6YWN572uICovXG59XG5cbi8qIERhdGFUYWJsZXPjga7jgrPjg7Pjg4bjg4rjga7pq5jjgZXjgpIxMDAl44Gr44GZ44KLICovXG4uZGF0YVRhYmxlc193cmFwcGVyIHtcbiAgcGFkZGluZy10b3A6IDA7IC8qIOS4iuOBruS9meeZveOCkuWJiumZpCAqL1xuICBmbGV4OiAxOyAvKiDopqropoHntKAoLnJlc3VsdHMtZ3JpZCnjga7mrovjgorjga7pq5jjgZXjgpLljaDjgoHjgosgKi9cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cblxuLyogRGF0YVRhYmxlc+OBruOCueOCr+ODreODvOODq+WPr+iDveOBquacrOS9kyAqL1xuLmRhdGFUYWJsZXNfc2Nyb2xsQm9keSB7XG4gIGZsZXg6IDE7IC8qIOWIqeeUqOWPr+iDveOBqumrmOOBleOCkuWNoOOCgeOCiyAqL1xufVxuXG4uc3RhdHVzLWJhciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xuICBwYWRkaW5nOiAzcHggMTBweDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBjb2xvcjogIzU1NTtcbiAgaGVpZ2h0OiAyMHB4O1xufVxuXG4uc3RhdHVzLWVycm9yIHtcbiAgY29sb3I6ICNkODNiMDE7XG59XG5cbi5zdGF0dXMtc3VjY2VzcyB7XG4gIGNvbG9yOiAjMTA3YzEwO1xufVxuXG4vKiBEYXRhVGFibGVzIOOCueOCv+OCpOODq+S4iuabuOOBjSAqL1xuLmRhdGFUYWJsZXNfd3JhcHBlciB7XG4gIHBhZGRpbmctdG9wOiAwOyAvKiDkuIrjga7kvZnnmb3jgpLliYrpmaQgKOmHjeikh+OBmeOCi+OBjOW/teOBruOBn+OCgSkgKi9cbn1cblxudGFibGUuZGF0YVRhYmxlIHtcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbiAgd2lkdGg6IDEwMCU7XG59XG5cbnRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlOGU4ZTg7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XG4gIHBhZGRpbmc6IDhweDtcbiAgdGV4dC1hbGlnbjogbGVmdDtcbiAgZm9udC1zaXplOiAxM3B4OyAvKiDjg5Xjgqnjg7Pjg4jjgrXjgqTjgrrlpInmm7QgKi9cbn1cblxudGFibGUuZGF0YVRhYmxlIHRib2R5IHRkIHtcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcbiAgcGFkZGluZzogNnB4O1xuICBmb250LXNpemU6IDEzcHg7IC8qIOODleOCqeODs+ODiOOCteOCpOOCuuWkieabtCAqL1xufVxuXG4uZGF0YVRhYmxlc19pbmZvLCAuZGF0YVRhYmxlc19wYWdpbmF0ZSB7XG4gIGZvbnQtc2l6ZTogMTZweDsgLyog44OV44Kp44Oz44OI44K144Kk44K65aSJ5pu0ICovXG4gIHBhZGRpbmc6IDEwcHggMDtcbn1cblxuLnNwbGl0dGVyIHtcbiAgZmxleDogbm9uZTtcbiAgd2lkdGg6IDVweDtcbiAgY3Vyc29yOiBjb2wtcmVzaXplO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbi5zcGxpdHRlcjpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKTtcbn1cblxuLyog5rC05bmz44K544OX44Oq44OD44K/ICovXG4ucm93LXNwbGl0dGVyIHtcbiAgaGVpZ2h0OiA1cHg7XG4gIGN1cnNvcjogcm93LXJlc2l6ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG4ucm93LXNwbGl0dGVyOmhvdmVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpO1xufVxuXG4vKiDmm7TmlrDjg5zjgr/jg7Pjga7jgqLjgqTjgrPjg7PoibIgKi9cbiNyZWZyZXNoLWRiLWJ1dHRvbiAubWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZCB7XG4gIGNvbG9yOiBibGFjaztcbn1gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvYXBwLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLFNBQVM7RUFDVCxVQUFVO0VBQ1YsOEJBQThCO0VBQzlCLGdCQUFnQjtFQUNoQixhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLGFBQWE7RUFDYix5QkFBeUI7QUFDM0I7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsaUNBQWlDO0VBQ2pDLFlBQVk7RUFDWixZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxhQUFhO0VBQ2Isa0JBQWtCO0VBQ2xCLGdEQUFnRDtFQUNoRCxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxnQkFBZ0I7RUFDaEIsWUFBWTtFQUNaLFlBQVk7RUFDWixpQkFBaUI7RUFDakIsZUFBZTtFQUNmLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLDBDQUEwQztBQUM1Qzs7QUFFQTtFQUNFLGlCQUFpQjtFQUNqQixrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsT0FBTztFQUNQLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLFlBQVk7RUFDWix5QkFBeUI7RUFDekIsNEJBQTRCO0VBQzVCLGFBQWE7RUFDYixzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsOEJBQThCO0VBQzlCLG1CQUFtQjtFQUNuQixpQkFBaUI7RUFDakIsWUFBWTtFQUNaLHlCQUF5QjtFQUN6Qiw2QkFBNkI7QUFDL0I7O0FBRUE7RUFDRSxPQUFPO0VBQ1AsY0FBYztFQUNkLFlBQVk7QUFDZDs7QUFFQTtFQUNFLGFBQWE7RUFDYixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsWUFBWTtFQUNaLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsZUFBZSxFQUFFLFVBQVU7QUFDN0I7O0FBRUEsc0JBQXNCO0FBQ3RCO0VBQ0UsZUFBZSxFQUFFLFlBQVk7RUFDN0IsaUJBQWlCLEVBQUUsbUJBQW1CO0FBQ3hDOztBQUVBLHdCQUF3QjtBQUN4QjtFQUNFLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLHlCQUF5QjtBQUMzQjs7QUFFQTtFQUNFLGlCQUFpQixFQUFFLDRCQUE0QjtBQUNqRDs7QUFFQTtFQUNFLE9BQU87RUFDUCxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLGFBQWE7RUFDYix5QkFBeUI7RUFDekIsNkJBQTZCO0FBQy9COztBQUVBO0VBQ0UsaUJBQWlCO0VBQ2pCLHlCQUF5QjtFQUN6Qiw0QkFBNEI7RUFDNUIsZUFBZTtFQUNmLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2YsYUFBYTtFQUNiLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLHVCQUF1QjtBQUN6Qjs7QUFFQTtFQUNFLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsWUFBWTtBQUNkOztBQUVBO0VBQ0UsVUFBVTtBQUNaOztBQUVBLHlCQUF5QjtBQUN6QjtFQUNFLHlCQUF5QjtBQUMzQjtBQUNBO0VBQ0UsdUJBQXVCO0FBQ3pCOztBQUVBO0VBQ0UsYUFBYTtFQUNiLDZCQUE2QjtBQUMvQjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxZQUFZO0VBQ1osWUFBWTtFQUNaLFlBQVk7RUFDWixhQUFhO0VBQ2IscUNBQXFDO0VBQ3JDLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxPQUFPO0VBQ1AsYUFBYTtFQUNiLHNCQUFzQjtFQUN0QixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsNkJBQTZCO0VBQzdCLHlCQUF5QjtBQUMzQjs7QUFFQTtFQUNFLGlCQUFpQjtFQUNqQixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsZ0NBQWdDO0FBQ2xDOztBQUVBO0VBQ0UsT0FBTztFQUNQLFVBQVUsRUFBRSxpQkFBaUI7RUFDN0IsZ0JBQWdCLEVBQUUsbUJBQW1CO0VBQ3JDLGdCQUFnQixFQUFFLFdBQVc7RUFDN0IsdUJBQXVCO0VBQ3ZCLGFBQWEsRUFBRSx3Q0FBd0M7RUFDdkQsc0JBQXNCLEVBQUUsd0JBQXdCO0FBQ2xEOztBQUVBLCtCQUErQjtBQUMvQjtFQUNFLGNBQWMsRUFBRSxZQUFZO0VBQzVCLE9BQU8sRUFBRSxpQ0FBaUM7RUFDMUMsYUFBYTtFQUNiLHNCQUFzQjtBQUN4Qjs7QUFFQSwwQkFBMEI7QUFDMUI7RUFDRSxPQUFPLEVBQUUsZ0JBQWdCO0FBQzNCOztBQUVBO0VBQ0UseUJBQXlCO0VBQ3pCLDBCQUEwQjtFQUMxQixpQkFBaUI7RUFDakIsZUFBZTtFQUNmLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQSx1QkFBdUI7QUFDdkI7RUFDRSxjQUFjLEVBQUUsd0JBQXdCO0FBQzFDOztBQUVBO0VBQ0UseUJBQXlCO0VBQ3pCLFdBQVc7QUFDYjs7QUFFQTtFQUNFLHlCQUF5QjtFQUN6QixzQkFBc0I7RUFDdEIsWUFBWTtFQUNaLGdCQUFnQjtFQUNoQixlQUFlLEVBQUUsY0FBYztBQUNqQzs7QUFFQTtFQUNFLHNCQUFzQjtFQUN0QixZQUFZO0VBQ1osZUFBZSxFQUFFLGNBQWM7QUFDakM7O0FBRUE7RUFDRSxlQUFlLEVBQUUsY0FBYztFQUMvQixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsVUFBVTtFQUNWLFVBQVU7RUFDVixrQkFBa0I7RUFDbEIsNkJBQTZCO0FBQy9CO0FBQ0E7RUFDRSxvQ0FBb0M7QUFDdEM7O0FBRUEsWUFBWTtBQUNaO0VBQ0UsV0FBVztFQUNYLGtCQUFrQjtFQUNsQiw2QkFBNkI7QUFDL0I7QUFDQTtFQUNFLG9DQUFvQztBQUN0Qzs7QUFFQSxnQkFBZ0I7QUFDaEI7RUFDRSxZQUFZO0FBQ2RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiYm9keSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGhlaWdodDogMTAwdmg7XFxufVxcblxcbi5hcHAtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XFxufVxcblxcbi5tZW51LWJhciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDMwLCAzMCwgMzApO1xcbiAgcGFkZGluZzogNHB4O1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4ubWVudS1ncm91cCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgbWFyZ2luLXJpZ2h0OiAxNXB4O1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgcGFkZGluZy1yaWdodDogMTVweDtcXG59XFxuXFxuLm1lbnUtYnV0dG9uIHtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjb2xvcjogd2hpdGU7XFxuICBwYWRkaW5nOiA1cHggMTBweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbn1cXG5cXG4ubWVudS1idXR0b246aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xcbn1cXG5cXG4uaWNvbiB7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG59XFxuXFxuLm1haW4tbGF5b3V0IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4OiAxO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnNpZGViYXIge1xcbiAgd2lkdGg6IDI1MHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLnRyZWUtdGl0bGUge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHBhZGRpbmc6IDhweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlOGU4ZTg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXG59XFxuXFxuLnRyZWUtdmlldyB7XFxuICBmbGV4OiAxO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBwYWRkaW5nOiA1cHg7XFxufVxcblxcbi50cmVlLWl0ZW0ge1xcbiAgbWFyZ2luOiAycHggMDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnRyZWUtbGFiZWwge1xcbiAgcGFkZGluZzogM3B4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmb250LXNpemU6IDE2cHg7IC8qIOaWh+Wtl+OCteOCpOOCuiAqL1xcbn1cXG5cXG4vKiDjg4Tjg6rjg7zjg6njg5njg6vlhoXjga7jgqLjgqTjgrPjg7PjgrXjgqTjgrroqr/mlbQgKi9cXG4udHJlZS1sYWJlbCAubWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZCB7XFxuICBmb250LXNpemU6IDE4cHg7IC8qIOOCouOCpOOCs+ODs+OCteOCpOOCuiAqL1xcbiAgbWFyZ2luLXJpZ2h0OiA0cHg7IC8qIOOCouOCpOOCs+ODs+OBqOODhuOCreOCueODiOOBrumWk+malOiqv+aVtCAqL1xcbn1cXG5cXG4vKiDjg4jjgrDjg6vjgqLjgqTjgrPjg7Pjga7oqr/mlbQgKOW/heimgeOBq+W/nOOBmOOBpikgKi9cXG4udHJlZS1sYWJlbCAudG9nZ2xlLWljb24ge1xcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XFxufVxcblxcbi50cmVlLWxhYmVsOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlMGUwZTA7XFxufVxcblxcbi50cmVlLWl0ZW1zIHtcXG4gIG1hcmdpbi1sZWZ0OiAzMHB4OyAvKiDjgqTjg7Pjg4fjg7Pjg4jjgpIgMjBweCDjgYvjgokgMzBweCDjgavlpInmm7QgKi9cXG59XFxuXFxuLm1haW4tYXJlYSB7XFxuICBmbGV4OiAxO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4ucXVlcnktdGFicyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U4ZThlODtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcbn1cXG5cXG4ucXVlcnktdGFiIHtcXG4gIHBhZGRpbmc6IDhweCAxNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLnF1ZXJ5LXRhYi5hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcblxcbi5jbG9zZS10YWIge1xcbiAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIG9wYWNpdHk6IDAuNjtcXG59XFxuXFxuLmNsb3NlLXRhYjpob3ZlciB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4vKiDjgr/jg5bjga7og4zmma/oibI6IOOCouOCr+ODhuOCo+ODluOBqOmdnuOCouOCr+ODhuOCo+ODliAqL1xcbi5xdWVyeS10YWIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcXG59XFxuLnF1ZXJ5LXRhYi5hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcblxcbi5xdWVyeS1lZGl0b3Ige1xcbiAgaGVpZ2h0OiAyMDBweDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcbn1cXG5cXG4ucXVlcnktZWRpdG9yIHRleHRhcmVhIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcmVzaXplOiBub25lO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGZvbnQtZmFtaWx5OiAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbi5yZXN1bHRzLWNvbnRhaW5lciB7XFxuICBmbGV4OiAxO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4ucmVzdWx0cy10YWJzIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XFxufVxcblxcbi5yZXN1bHQtdGFiIHtcXG4gIHBhZGRpbmc6IDVweCAxNXB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4ucmVzdWx0LXRhYi5hY3RpdmUge1xcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICMwMDc4ZDc7XFxufVxcblxcbi5yZXN1bHRzLWdyaWQge1xcbiAgZmxleDogMTtcXG4gIHBhZGRpbmc6IDA7IC8qIOODkeODh+OCo+ODs+OCsOOCkiAwIOOBq+WkieabtCAqL1xcbiAgb3ZlcmZsb3cteTogYXV0bzsgLyog57im44K544Kv44Ot44O844Or44KS44Kz44Oz44OG44OK44Gn566h55CGICovXFxuICBvdmVyZmxvdy14OiBhdXRvOyAvKiDmqKrjgrnjgq/jg63jg7zjg6sgKi9cXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgZGlzcGxheTogZmxleDsgLyogRGF0YVRhYmxlc+OCs+ODs+ODhuODiuOBjGZsZXjjgqLjgqTjg4bjg6DjgajjgZfjgabpq5jjgZXjgpLljaDjgoHjgovjgojjgYbjgasgKi9cXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IC8qIERhdGFUYWJsZXPjgrPjg7Pjg4bjg4rjgpLnuKbjgavphY3nva4gKi9cXG59XFxuXFxuLyogRGF0YVRhYmxlc+OBruOCs+ODs+ODhuODiuOBrumrmOOBleOCkjEwMCXjgavjgZnjgosgKi9cXG4uZGF0YVRhYmxlc193cmFwcGVyIHtcXG4gIHBhZGRpbmctdG9wOiAwOyAvKiDkuIrjga7kvZnnmb3jgpLliYrpmaQgKi9cXG4gIGZsZXg6IDE7IC8qIOimquimgee0oCgucmVzdWx0cy1ncmlkKeOBruaui+OCiuOBrumrmOOBleOCkuWNoOOCgeOCiyAqL1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbi8qIERhdGFUYWJsZXPjga7jgrnjgq/jg63jg7zjg6vlj6/og73jgarmnKzkvZMgKi9cXG4uZGF0YVRhYmxlc19zY3JvbGxCb2R5IHtcXG4gIGZsZXg6IDE7IC8qIOWIqeeUqOWPr+iDveOBqumrmOOBleOCkuWNoOOCgeOCiyAqL1xcbn1cXG5cXG4uc3RhdHVzLWJhciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmMGYwO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxuICBwYWRkaW5nOiAzcHggMTBweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiAjNTU1O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbn1cXG5cXG4uc3RhdHVzLWVycm9yIHtcXG4gIGNvbG9yOiAjZDgzYjAxO1xcbn1cXG5cXG4uc3RhdHVzLXN1Y2Nlc3Mge1xcbiAgY29sb3I6ICMxMDdjMTA7XFxufVxcblxcbi8qIERhdGFUYWJsZXMg44K544K/44Kk44Or5LiK5pu444GNICovXFxuLmRhdGFUYWJsZXNfd3JhcHBlciB7XFxuICBwYWRkaW5nLXRvcDogMDsgLyog5LiK44Gu5L2Z55m944KS5YmK6ZmkICjph43opIfjgZnjgovjgYzlv7Xjga7jgZ/jgoEpICovXFxufVxcblxcbnRhYmxlLmRhdGFUYWJsZSB7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbnRhYmxlLmRhdGFUYWJsZSB0aGVhZCB0aCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZThlOGU4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG4gIHBhZGRpbmc6IDhweDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBmb250LXNpemU6IDEzcHg7IC8qIOODleOCqeODs+ODiOOCteOCpOOCuuWkieabtCAqL1xcbn1cXG5cXG50YWJsZS5kYXRhVGFibGUgdGJvZHkgdGQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG4gIHBhZGRpbmc6IDZweDtcXG4gIGZvbnQtc2l6ZTogMTNweDsgLyog44OV44Kp44Oz44OI44K144Kk44K65aSJ5pu0ICovXFxufVxcblxcbi5kYXRhVGFibGVzX2luZm8sIC5kYXRhVGFibGVzX3BhZ2luYXRlIHtcXG4gIGZvbnQtc2l6ZTogMTZweDsgLyog44OV44Kp44Oz44OI44K144Kk44K65aSJ5pu0ICovXFxuICBwYWRkaW5nOiAxMHB4IDA7XFxufVxcblxcbi5zcGxpdHRlciB7XFxuICBmbGV4OiBub25lO1xcbiAgd2lkdGg6IDVweDtcXG4gIGN1cnNvcjogY29sLXJlc2l6ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG4uc3BsaXR0ZXI6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbn1cXG5cXG4vKiDmsLTlubPjgrnjg5fjg6rjg4Pjgr8gKi9cXG4ucm93LXNwbGl0dGVyIHtcXG4gIGhlaWdodDogNXB4O1xcbiAgY3Vyc29yOiByb3ctcmVzaXplO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcbi5yb3ctc3BsaXR0ZXI6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbn1cXG5cXG4vKiDmm7TmlrDjg5zjgr/jg7Pjga7jgqLjgqTjgrPjg7PoibIgKi9cXG4jcmVmcmVzaC1kYi1idXR0b24gLm1hdGVyaWFsLXN5bWJvbHMtb3V0bGluZWQge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2RhdGFUYWJsZXMuZGF0YVRhYmxlcy5taW4uY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5vcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9kYXRhVGFibGVzLmRhdGFUYWJsZXMubWluLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIi8qISBEYXRhVGFibGVzIHN0eWxpbmcgaW50ZWdyYXRpb25cbiAqIMKpIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuaW1wb3J0IGpRdWVyeSBmcm9tICdqcXVlcnknO1xuaW1wb3J0IERhdGFUYWJsZSBmcm9tICdkYXRhdGFibGVzLm5ldCc7XG5cbi8vIEFsbG93IHJlYXNzaWdubWVudCBvZiB0aGUgJCB2YXJpYWJsZVxubGV0ICQgPSBqUXVlcnk7XG5cblxuXG5cbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZTtcbiIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2ZpeGVkSGVhZGVyLmRhdGFUYWJsZXMubWluLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xub3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZml4ZWRIZWFkZXIuZGF0YVRhYmxlcy5taW4uY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiLyohIERhdGFUYWJsZXMgc3R5bGluZyB3cmFwcGVyIGZvciBGaXhlZEhlYWRlclxuICogwqkgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgalF1ZXJ5IGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgRGF0YVRhYmxlIGZyb20gJ2RhdGF0YWJsZXMubmV0LWR0JztcbmltcG9ydCBGaXhlZEhlYWRlciBmcm9tICdkYXRhdGFibGVzLm5ldC1maXhlZGhlYWRlcic7XG5cbi8vIEFsbG93IHJlYXNzaWdubWVudCBvZiB0aGUgJCB2YXJpYWJsZVxubGV0ICQgPSBqUXVlcnk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGU7XG4iLCIvKiEgRml4ZWRIZWFkZXIgNC4wLjFcbiAqIMKpIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuaW1wb3J0IGpRdWVyeSBmcm9tICdqcXVlcnknO1xuaW1wb3J0IERhdGFUYWJsZSBmcm9tICdkYXRhdGFibGVzLm5ldCc7XG5cbi8vIEFsbG93IHJlYXNzaWdubWVudCBvZiB0aGUgJCB2YXJpYWJsZVxubGV0ICQgPSBqUXVlcnk7XG5cblxuLyoqXG4gKiBAc3VtbWFyeSAgICAgRml4ZWRIZWFkZXJcbiAqIEBkZXNjcmlwdGlvbiBGaXggYSB0YWJsZSdzIGhlYWRlciBvciBmb290ZXIsIHNvIGl0IGlzIGFsd2F5cyB2aXNpYmxlIHdoaWxlXG4gKiAgICAgICAgICAgICAgc2Nyb2xsaW5nXG4gKiBAdmVyc2lvbiAgICAgNC4wLjFcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkXG4gKiBAY29udGFjdCAgICAgZGF0YXRhYmxlcy5uZXRcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIGF2YWlsYWJsZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKiAgIE1JVCBsaWNlbnNlIC0gaHR0cDovL2RhdGF0YWJsZXMubmV0L2xpY2Vuc2UvbWl0XG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldFxuICovXG5cbnZhciBfaW5zdENvdW50ZXIgPSAwO1xuXG52YXIgRml4ZWRIZWFkZXIgPSBmdW5jdGlvbiAoZHQsIGNvbmZpZykge1xuXHRpZiAoIURhdGFUYWJsZS52ZXJzaW9uQ2hlY2soJzInKSkge1xuXHRcdHRocm93ICdXYXJuaW5nOiBGaXhlZEhlYWRlciByZXF1aXJlcyBEYXRhVGFibGVzIDIgb3IgbmV3ZXInO1xuXHR9XG5cblx0Ly8gU2FuaXR5IGNoZWNrIC0geW91IGp1c3Qga25vdyBpdCB3aWxsIGhhcHBlblxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRml4ZWRIZWFkZXIpKSB7XG5cdFx0dGhyb3cgXCJGaXhlZEhlYWRlciBtdXN0IGJlIGluaXRpYWxpc2VkIHdpdGggdGhlICduZXcnIGtleXdvcmQuXCI7XG5cdH1cblxuXHQvLyBBbGxvdyBhIGJvb2xlYW4gdHJ1ZSBmb3IgZGVmYXVsdHNcblx0aWYgKGNvbmZpZyA9PT0gdHJ1ZSkge1xuXHRcdGNvbmZpZyA9IHt9O1xuXHR9XG5cblx0ZHQgPSBuZXcgRGF0YVRhYmxlLkFwaShkdCk7XG5cblx0dGhpcy5jID0gJC5leHRlbmQodHJ1ZSwge30sIEZpeGVkSGVhZGVyLmRlZmF1bHRzLCBjb25maWcpO1xuXG5cdHRoaXMucyA9IHtcblx0XHRkdDogZHQsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdHRoZWFkVG9wOiAwLFxuXHRcdFx0dGJvZHlUb3A6IDAsXG5cdFx0XHR0Zm9vdFRvcDogMCxcblx0XHRcdHRmb290Qm90dG9tOiAwLFxuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0dGZvb3RIZWlnaHQ6IDAsXG5cdFx0XHR0aGVhZEhlaWdodDogMCxcblx0XHRcdHdpbmRvd0hlaWdodDogJCh3aW5kb3cpLmhlaWdodCgpLFxuXHRcdFx0dmlzaWJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0aGVhZGVyTW9kZTogbnVsbCxcblx0XHRmb290ZXJNb2RlOiBudWxsLFxuXHRcdGF1dG9XaWR0aDogZHQuc2V0dGluZ3MoKVswXS5vRmVhdHVyZXMuYkF1dG9XaWR0aCxcblx0XHRuYW1lc3BhY2U6ICcuZHRmYycgKyBfaW5zdENvdW50ZXIrKyxcblx0XHRzY3JvbGxMZWZ0OiB7XG5cdFx0XHRoZWFkZXI6IC0xLFxuXHRcdFx0Zm9vdGVyOiAtMVxuXHRcdH0sXG5cdFx0ZW5hYmxlOiB0cnVlLFxuXHRcdGF1dG9EaXNhYmxlOiBmYWxzZVxuXHR9O1xuXG5cdHRoaXMuZG9tID0ge1xuXHRcdGZsb2F0aW5nSGVhZGVyOiBudWxsLFxuXHRcdHRoZWFkOiAkKGR0LnRhYmxlKCkuaGVhZGVyKCkpLFxuXHRcdHRib2R5OiAkKGR0LnRhYmxlKCkuYm9keSgpKSxcblx0XHR0Zm9vdDogJChkdC50YWJsZSgpLmZvb3RlcigpKSxcblx0XHRoZWFkZXI6IHtcblx0XHRcdGhvc3Q6IG51bGwsXG5cdFx0XHRmbG9hdGluZzogbnVsbCxcblx0XHRcdGZsb2F0aW5nUGFyZW50OiAkKCc8ZGl2IGNsYXNzPVwiZHRmaC1mbG9hdGluZ3BhcmVudFwiPjxkaXY+PC9kaXY+PC9kaXY+JyksXG5cdFx0XHRwbGFjZWhvbGRlcjogbnVsbFxuXHRcdH0sXG5cdFx0Zm9vdGVyOiB7XG5cdFx0XHRob3N0OiBudWxsLFxuXHRcdFx0ZmxvYXRpbmc6IG51bGwsXG5cdFx0XHRmbG9hdGluZ1BhcmVudDogJCgnPGRpdiBjbGFzcz1cImR0ZmgtZmxvYXRpbmdwYXJlbnRcIj48ZGl2PjwvZGl2PjwvZGl2PicpLFxuXHRcdFx0cGxhY2Vob2xkZXI6IG51bGxcblx0XHR9XG5cdH07XG5cblx0dGhpcy5kb20uaGVhZGVyLmhvc3QgPSB0aGlzLmRvbS50aGVhZC5wYXJlbnQoKTtcblx0dGhpcy5kb20uZm9vdGVyLmhvc3QgPSB0aGlzLmRvbS50Zm9vdC5wYXJlbnQoKTtcblxuXHR2YXIgZHRTZXR0aW5ncyA9IGR0LnNldHRpbmdzKClbMF07XG5cdGlmIChkdFNldHRpbmdzLl9maXhlZEhlYWRlcikge1xuXHRcdHRocm93IChcblx0XHRcdCdGaXhlZEhlYWRlciBhbHJlYWR5IGluaXRpYWxpc2VkIG9uIHRhYmxlICcgKyBkdFNldHRpbmdzLm5UYWJsZS5pZFxuXHRcdCk7XG5cdH1cblxuXHRkdFNldHRpbmdzLl9maXhlZEhlYWRlciA9IHRoaXM7XG5cblx0dGhpcy5fY29uc3RydWN0b3IoKTtcbn07XG5cbi8qXG4gKiBWYXJpYWJsZTogRml4ZWRIZWFkZXJcbiAqIFB1cnBvc2U6ICBQcm90b3R5cGUgZm9yIEZpeGVkSGVhZGVyXG4gKiBTY29wZTogICAgZ2xvYmFsXG4gKi9cbiQuZXh0ZW5kKEZpeGVkSGVhZGVyLnByb3RvdHlwZSwge1xuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBBUEkgbWV0aG9kc1xuXHQgKi9cblxuXHQvKipcblx0ICogS2lsbCBvZmYgRkggYW5kIGFueSBldmVudHNcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZG9tID0gdGhpcy5kb207XG5cblx0XHR0aGlzLnMuZHQub2ZmKCcuZHRmYycpO1xuXHRcdCQod2luZG93KS5vZmYodGhpcy5zLm5hbWVzcGFjZSk7XG5cblx0XHQvLyBSZW1vdmUgY2xvbmVzIG9mIEZDIGJsb2NrZXJzXG5cdFx0aWYgKGRvbS5oZWFkZXIucmlnaHRCbG9ja2VyKSB7XG5cdFx0XHRkb20uaGVhZGVyLnJpZ2h0QmxvY2tlci5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKGRvbS5oZWFkZXIubGVmdEJsb2NrZXIpIHtcblx0XHRcdGRvbS5oZWFkZXIubGVmdEJsb2NrZXIucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmIChkb20uZm9vdGVyLnJpZ2h0QmxvY2tlcikge1xuXHRcdFx0ZG9tLmZvb3Rlci5yaWdodEJsb2NrZXIucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmIChkb20uZm9vdGVyLmxlZnRCbG9ja2VyKSB7XG5cdFx0XHRkb20uZm9vdGVyLmxlZnRCbG9ja2VyLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmMuaGVhZGVyKSB7XG5cdFx0XHR0aGlzLl9tb2RlQ2hhbmdlKCdpbi1wbGFjZScsICdoZWFkZXInLCB0cnVlKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5jLmZvb3RlciAmJiBkb20udGZvb3QubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLl9tb2RlQ2hhbmdlKCdpbi1wbGFjZScsICdmb290ZXInLCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEVuYWJsZSAvIGRpc2FibGUgdGhlIGZpeGVkIGVsZW1lbnRzXG5cdCAqXG5cdCAqIEBwYXJhbSAge2Jvb2xlYW59IGVuYWJsZSBgdHJ1ZWAgdG8gZW5hYmxlLCBgZmFsc2VgIHRvIGRpc2FibGVcblx0ICovXG5cdGVuYWJsZTogZnVuY3Rpb24gKGVuYWJsZSwgdXBkYXRlLCB0eXBlKSB7XG5cdFx0dGhpcy5zLmVuYWJsZSA9IGVuYWJsZTtcblxuXHRcdHRoaXMucy5lbmFibGVUeXBlID0gdHlwZTtcblxuXHRcdGlmICh1cGRhdGUgfHwgdXBkYXRlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucygpO1xuXHRcdFx0dGhpcy5fc2Nyb2xsKHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IGVuYWJsZWQgc3RhdHVzXG5cdCAqL1xuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucy5lbmFibGU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBoZWFkZXIgb2Zmc2V0XG5cdCAqXG5cdCAqIEBwYXJhbSAge2ludH0gbmV3IHZhbHVlIGZvciBoZWFkZXJPZmZzZXRcblx0ICovXG5cdGhlYWRlck9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHRcdGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5jLmhlYWRlck9mZnNldCA9IG9mZnNldDtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYy5oZWFkZXJPZmZzZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBmb290ZXIgb2Zmc2V0XG5cdCAqXG5cdCAqIEBwYXJhbSAge2ludH0gbmV3IHZhbHVlIGZvciBmb290ZXJPZmZzZXRcblx0ICovXG5cdGZvb3Rlck9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHRcdGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5jLmZvb3Rlck9mZnNldCA9IG9mZnNldDtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYy5mb290ZXJPZmZzZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZml4ZWQgZWxlbWVudHMgYW5kIGZvcmNlIHRoZW0gaW50byBwbGFjZVxuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbiAoZm9yY2UpIHtcblx0XHR2YXIgdGFibGUgPSB0aGlzLnMuZHQudGFibGUoKS5ub2RlKCk7XG5cblx0XHQvLyBVcGRhdGUgc2hvdWxkIG9ubHkgZG8gc29tZXRoaW5nIGlmIGVuYWJsZWQgYnkgdGhlIGRldi5cblx0XHRpZiAoIXRoaXMucy5lbmFibGUgJiYgIXRoaXMucy5hdXRvRGlzYWJsZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgkKHRhYmxlKS5pcygnOnZpc2libGUnKSkge1xuXHRcdFx0dGhpcy5zLmF1dG9EaXNhYmxlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmVuYWJsZSh0cnVlLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5zLmF1dG9EaXNhYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMuZW5hYmxlKGZhbHNlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGlmIGhlYWRlciBpcyBub3QgaW4gdGhlIGRvY3VtZW50IGF0bSAoZHVlIHRvXG5cdFx0Ly8gYXN5bmMgZXZlbnRzKVxuXHRcdGlmICgkKHRhYmxlKS5jaGlsZHJlbigndGhlYWQnKS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9wb3NpdGlvbnMoKTtcblx0XHR0aGlzLl9zY3JvbGwoZm9yY2UgIT09IHVuZGVmaW5lZCA/IGZvcmNlIDogdHJ1ZSk7XG5cdFx0dGhpcy5fd2lkdGhzKHRoaXMuZG9tLmhlYWRlcik7XG5cdFx0dGhpcy5fd2lkdGhzKHRoaXMuZG9tLmZvb3Rlcik7XG5cdH0sXG5cblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogQ29uc3RydWN0b3Jcblx0ICovXG5cblx0LyoqXG5cdCAqIEZpeGVkSGVhZGVyIGNvbnN0cnVjdG9yIC0gYWRkaW5nIHRoZSByZXF1aXJlZCBldmVudCBsaXN0ZW5lcnMgYW5kXG5cdCAqIHNpbXBsZSBpbml0aWFsaXNhdGlvblxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblxuXHRcdCQod2luZG93KVxuXHRcdFx0Lm9uKCdzY3JvbGwnICsgdGhpcy5zLm5hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9zY3JvbGwoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXG5cdFx0XHRcdCdyZXNpemUnICsgdGhpcy5zLm5hbWVzcGFjZSxcblx0XHRcdFx0RGF0YVRhYmxlLnV0aWwudGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoYXQucy5wb3NpdGlvbi53aW5kb3dIZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XG5cdFx0XHRcdFx0dGhhdC51cGRhdGUoKTtcblx0XHRcdFx0fSwgNTApXG5cdFx0XHQpO1xuXG5cdFx0dmFyIGF1dG9IZWFkZXIgPSAkKCcuZmgtZml4ZWRIZWFkZXInKTtcblx0XHRpZiAoIXRoaXMuYy5oZWFkZXJPZmZzZXQgJiYgYXV0b0hlYWRlci5sZW5ndGgpIHtcblx0XHRcdHRoaXMuYy5oZWFkZXJPZmZzZXQgPSBhdXRvSGVhZGVyLm91dGVySGVpZ2h0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIGF1dG9Gb290ZXIgPSAkKCcuZmgtZml4ZWRGb290ZXInKTtcblx0XHRpZiAoIXRoaXMuYy5mb290ZXJPZmZzZXQgJiYgYXV0b0Zvb3Rlci5sZW5ndGgpIHtcblx0XHRcdHRoaXMuYy5mb290ZXJPZmZzZXQgPSBhdXRvRm9vdGVyLm91dGVySGVpZ2h0KCk7XG5cdFx0fVxuXG5cdFx0ZHQub24oXG5cdFx0XHQnY29sdW1uLXJlb3JkZXIuZHQuZHRmYyBjb2x1bW4tdmlzaWJpbGl0eS5kdC5kdGZjIGNvbHVtbi1zaXppbmcuZHQuZHRmYyByZXNwb25zaXZlLWRpc3BsYXkuZHQuZHRmYycsXG5cdFx0XHRmdW5jdGlvbiAoZSwgY3R4KSB7XG5cdFx0XHRcdHRoYXQudXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0KS5vbignZHJhdy5kdC5kdGZjJywgZnVuY3Rpb24gKGUsIGN0eCkge1xuXHRcdFx0Ly8gRm9yIHVwZGF0ZXMgZnJvbSBvdXIgb3duIHRhYmxlLCBkb24ndCByZWNsb25lLCBidXQgZm9yIGFsbCBvdGhlcnMsIGRvXG5cdFx0XHR0aGF0LnVwZGF0ZShjdHggPT09IGR0LnNldHRpbmdzKClbMF0gPyBmYWxzZSA6IHRydWUpO1xuXHRcdH0pO1xuXG5cdFx0ZHQub24oJ2Rlc3Ryb3kuZHRmYycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuZGVzdHJveSgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcG9zaXRpb25zKCk7XG5cdFx0dGhpcy5fc2Nyb2xsKCk7XG5cdH0sXG5cblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogUHJpdmF0ZSBtZXRob2RzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDbG9uZSBhIGZpeGVkIGl0ZW0gdG8gYWN0IGFzIGEgcGxhY2UgaG9sZGVyIGZvciB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHQgKiB3aGljaCBpcyBtb3ZlZCBpbnRvIGEgY2xvbmUgb2YgdGhlIHRhYmxlIGVsZW1lbnQsIGFuZCBtb3ZlZCBhcm91bmQgdGhlXG5cdCAqIGRvY3VtZW50IHRvIGdpdmUgdGhlIGZpeGVkIGVmZmVjdC5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgaXRlbSAgJ2hlYWRlcicgb3IgJ2Zvb3Rlcidcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2UgRm9yY2UgdGhlIGNsb25lIHRvIGhhcHBlbiwgb3IgYWxsb3cgYXV0b21hdGljXG5cdCAqICAgZGVjaXNpb24gKHJldXNlIGV4aXN0aW5nIGlmIGF2YWlsYWJsZSlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jbG9uZTogZnVuY3Rpb24gKGl0ZW0sIGZvcmNlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgaXRlbURvbSA9IHRoaXMuZG9tW2l0ZW1dO1xuXHRcdHZhciBpdGVtRWxlbWVudCA9IGl0ZW0gPT09ICdoZWFkZXInID8gdGhpcy5kb20udGhlYWQgOiB0aGlzLmRvbS50Zm9vdDtcblxuXHRcdC8vIElmIGZvb3RlciBhbmQgc2Nyb2xsaW5nIGlzIGVuYWJsZWQgdGhlbiB3ZSBkb24ndCBjbG9uZVxuXHRcdC8vIEluc3RlYWQgdGhlIHRhYmxlJ3MgaGVpZ2h0IGlzIGRlY3JlYXNlZCBhY2NvcmRpbmdseSAtIHNlZSBgX3Njcm9sbCgpYFxuXHRcdGlmIChpdGVtID09PSAnZm9vdGVyJyAmJiB0aGlzLl9zY3JvbGxFbmFibGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIWZvcmNlICYmIGl0ZW1Eb20uZmxvYXRpbmcpIHtcblx0XHRcdC8vIGV4aXN0aW5nIGZsb2F0aW5nIGVsZW1lbnQgLSByZXVzZSBpdFxuXHRcdFx0aXRlbURvbS5mbG9hdGluZy5yZW1vdmVDbGFzcyhcblx0XHRcdFx0J2ZpeGVkSGVhZGVyLWZsb2F0aW5nIGZpeGVkSGVhZGVyLWxvY2tlZCdcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKGl0ZW1Eb20uZmxvYXRpbmcpIHtcblx0XHRcdFx0aWYgKGl0ZW1Eb20ucGxhY2Vob2xkZXIgIT09IG51bGwpIHtcblx0XHRcdFx0XHRpdGVtRG9tLnBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aXRlbURvbS5mbG9hdGluZy5jaGlsZHJlbigpLmRldGFjaCgpO1xuXHRcdFx0XHRpdGVtRG9tLmZsb2F0aW5nLnJlbW92ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGFibGVOb2RlID0gJChkdC50YWJsZSgpLm5vZGUoKSk7XG5cdFx0XHR2YXIgc2Nyb2xsQm9keSA9ICQodGFibGVOb2RlLnBhcmVudCgpKTtcblx0XHRcdHZhciBzY3JvbGxFbmFibGVkID0gdGhpcy5fc2Nyb2xsRW5hYmxlZCgpO1xuXG5cdFx0XHRpdGVtRG9tLmZsb2F0aW5nID0gJChkdC50YWJsZSgpLm5vZGUoKS5jbG9uZU5vZGUoZmFsc2UpKVxuXHRcdFx0XHQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRsZWZ0OiAwXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpO1xuXG5cdFx0XHRpdGVtRG9tLmZsb2F0aW5nUGFyZW50XG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxCb2R5WzBdLm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRoZWlnaHQ6ICdmaXQtY29udGVudCcsXG5cdFx0XHRcdFx0cG9zaXRpb246ICdmaXhlZCcsXG5cdFx0XHRcdFx0bGVmdDogc2Nyb2xsRW5hYmxlZFxuXHRcdFx0XHRcdFx0PyB0YWJsZU5vZGUub2Zmc2V0KCkubGVmdCArIHNjcm9sbEJvZHkuc2Nyb2xsTGVmdCgpXG5cdFx0XHRcdFx0XHQ6IDBcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyhcblx0XHRcdFx0XHRpdGVtID09PSAnaGVhZGVyJ1xuXHRcdFx0XHRcdFx0PyB7XG5cdFx0XHRcdFx0XHRcdFx0dG9wOiB0aGlzLmMuaGVhZGVyT2Zmc2V0LFxuXHRcdFx0XHRcdFx0XHRcdGJvdHRvbTogJydcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdDoge1xuXHRcdFx0XHRcdFx0XHRcdHRvcDogJycsXG5cdFx0XHRcdFx0XHRcdFx0Ym90dG9tOiB0aGlzLmMuZm9vdGVyT2Zmc2V0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdFx0LmFkZENsYXNzKFxuXHRcdFx0XHRcdGl0ZW0gPT09ICdmb290ZXInXG5cdFx0XHRcdFx0XHQ/ICdkdGZoLWZsb2F0aW5ncGFyZW50LWZvb3QnXG5cdFx0XHRcdFx0XHQ6ICdkdGZoLWZsb2F0aW5ncGFyZW50LWhlYWQnXG5cdFx0XHRcdClcblx0XHRcdFx0LmFwcGVuZFRvKCdib2R5Jylcblx0XHRcdFx0LmNoaWxkcmVuKClcblx0XHRcdFx0LmVxKDApXG5cdFx0XHRcdC5hcHBlbmQoaXRlbURvbS5mbG9hdGluZyk7XG5cblx0XHRcdHRoaXMuX3N0aWNreVBvc2l0aW9uKGl0ZW1Eb20uZmxvYXRpbmcsICctJyk7XG5cblx0XHRcdHZhciBzY3JvbGxMZWZ0VXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgc2Nyb2xsTGVmdCA9IHNjcm9sbEJvZHkuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0XHR0aGF0LnMuc2Nyb2xsTGVmdCA9IHsgZm9vdGVyOiBzY3JvbGxMZWZ0LCBoZWFkZXI6IHNjcm9sbExlZnQgfTtcblx0XHRcdFx0aXRlbURvbS5mbG9hdGluZ1BhcmVudC5zY3JvbGxMZWZ0KHRoYXQucy5zY3JvbGxMZWZ0LmhlYWRlcik7XG5cdFx0XHR9O1xuXG5cdFx0XHRzY3JvbGxMZWZ0VXBkYXRlKCk7XG5cdFx0XHRzY3JvbGxCb2R5Lm9mZignc2Nyb2xsLmR0ZmgnKS5vbignc2Nyb2xsLmR0ZmgnLCBzY3JvbGxMZWZ0VXBkYXRlKTtcblxuXHRcdFx0Ly8gTmVlZCBwYWRkaW5nIG9uIHRoZSBoZWFkZXIncyBjb250YWluZXIgdG8gYWxsb3cgZm9yIGEgc2Nyb2xsYmFyLFxuXHRcdFx0Ly8ganVzdCBsaWtlIGhvdyBEYXRhVGFibGVzIGhhbmRsZXMgaXRcblx0XHRcdGl0ZW1Eb20uZmxvYXRpbmdQYXJlbnQuY2hpbGRyZW4oKS5jc3Moe1xuXHRcdFx0XHR3aWR0aDogJ2ZpdC1jb250ZW50Jyxcblx0XHRcdFx0cGFkZGluZ1JpZ2h0OiB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vQnJvd3Nlci5iYXJXaWR0aFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEJsb2NrZXIgdG8gaGlkZSB0aGUgdGFibGUgYmVoaW5kIHRoZSBzY3JvbGxiYXIgLSB0aGlzIG5lZWRzIHRvIHVzZVxuXHRcdFx0Ly8gZml4ZWQgcG9zaXRpb25pbmcgaW4gdGhlIGNvbnRhaW5lciBzaW5jZSB3ZSBkb24ndCBoYXZlIGFuIG91dGVyIHdyYXBwZXJcblx0XHRcdGxldCBibG9ja2VyID0gJChcblx0XHRcdFx0aXRlbSA9PT0gJ2Zvb3Rlcidcblx0XHRcdFx0XHQ/ICdkaXYuZHRmYy1ib3R0b20tYmxvY2tlcidcblx0XHRcdFx0XHQ6ICdkaXYuZHRmYy10b3AtYmxvY2tlcicsXG5cdFx0XHRcdGR0LnRhYmxlKCkuY29udGFpbmVyKClcblx0XHRcdCk7XG5cblx0XHRcdGlmIChibG9ja2VyLmxlbmd0aCkge1xuXHRcdFx0XHRibG9ja2VyXG5cdFx0XHRcdFx0LmNsb25lKClcblx0XHRcdFx0XHQuYXBwZW5kVG8oaXRlbURvbS5mbG9hdGluZ1BhcmVudClcblx0XHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnZml4ZWQnLFxuXHRcdFx0XHRcdFx0cmlnaHQ6IGJsb2NrZXIud2lkdGgoKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnNlcnQgYSBmYWtlIHRoZWFkL3Rmb290IGludG8gdGhlIERhdGFUYWJsZSB0byBzdG9wIGl0IGp1bXBpbmcgYXJvdW5kXG5cdFx0XHRpdGVtRG9tLnBsYWNlaG9sZGVyID0gaXRlbUVsZW1lbnQuY2xvbmUoZmFsc2UpO1xuXHRcdFx0aXRlbURvbS5wbGFjZWhvbGRlci5maW5kKCcqW2lkXScpLnJlbW92ZUF0dHIoJ2lkJyk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIHRoZWFkIC8gdGZvb3QgZWxlbWVudHMgYXJvdW5kIC0gb3JpZ2luYWwgaW50byB0aGUgZmxvYXRpbmdcblx0XHRcdC8vIGVsZW1lbnQgYW5kIGNsb25lIGludG8gdGhlIG9yaWdpbmFsIHRhYmxlXG5cdFx0XHRpdGVtRG9tLmhvc3QucHJlcGVuZChpdGVtRG9tLnBsYWNlaG9sZGVyKTtcblx0XHRcdGl0ZW1Eb20uZmxvYXRpbmcuYXBwZW5kKGl0ZW1FbGVtZW50KTtcblxuXHRcdFx0dGhpcy5fd2lkdGhzKGl0ZW1Eb20pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgc3RpY2t5IHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIgZWxlbWVudHMgdG8gbWF0Y2ggZml4ZWQgY29sdW1uc1xuXHQgKiBAcGFyYW0ge0pRdWVyeTxIVE1MRWxlbWVudD59IGVsXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzaWduXG5cdCAqL1xuXHRfc3RpY2t5UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgc2lnbikge1xuXHRcdGlmICh0aGlzLl9zY3JvbGxFbmFibGVkKCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHZhciBydGwgPSAkKHRoYXQucy5kdC50YWJsZSgpLm5vZGUoKSkuY3NzKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCc7XG5cblx0XHRcdGVsLmZpbmQoJ3RoJykuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIEZpbmQgb3V0IGlmIGZpeGVkIGhlYWRlciBoYXMgcHJldmlvdXNseSBzZXQgdGhpcyBjb2x1bW5cblx0XHRcdFx0aWYgKCQodGhpcykuY3NzKCdwb3NpdGlvbicpID09PSAnc3RpY2t5Jykge1xuXHRcdFx0XHRcdHZhciByaWdodCA9ICQodGhpcykuY3NzKCdyaWdodCcpO1xuXHRcdFx0XHRcdHZhciBsZWZ0ID0gJCh0aGlzKS5jc3MoJ2xlZnQnKTtcblx0XHRcdFx0XHR2YXIgcG90ZW50aWFsO1xuXG5cdFx0XHRcdFx0aWYgKHJpZ2h0ICE9PSAnYXV0bycgJiYgIXJ0bCkge1xuXHRcdFx0XHRcdFx0cG90ZW50aWFsID0gK3JpZ2h0LnJlcGxhY2UoL3B4L2csICcnKVxuXG5cdFx0XHRcdFx0XHQkKHRoaXMpLmNzcygncmlnaHQnLCBwb3RlbnRpYWwgPiAwID8gcG90ZW50aWFsIDogMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKGxlZnQgIT09ICdhdXRvJyAmJiBydGwpIHtcblx0XHRcdFx0XHRcdHBvdGVudGlhbCA9ICtsZWZ0LnJlcGxhY2UoL3B4L2csICcnKTtcblxuXHRcdFx0XHRcdFx0JCh0aGlzKS5jc3MoJ2xlZnQnLCBwb3RlbnRpYWwgPiAwID8gcG90ZW50aWFsIDogMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlcG9zaXRpb24gdGhlIGZsb2F0aW5nIGVsZW1lbnRzIHRvIHRha2UgYWNjb3VudCBvZiBob3Jpem9udGFsIHBhZ2Vcblx0ICogc2Nyb2xsXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gaXRlbSAgICAgICBUaGUgYGhlYWRlcmAgb3IgYGZvb3RlcmBcblx0ICogQHBhcmFtICB7aW50fSAgICBzY3JvbGxMZWZ0IERvY3VtZW50IHNjcm9sbExlZnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9ob3Jpem9udGFsOiBmdW5jdGlvbiAoaXRlbSwgc2Nyb2xsTGVmdCkge1xuXHRcdHZhciBpdGVtRG9tID0gdGhpcy5kb21baXRlbV07XG5cdFx0dmFyIGxhc3RTY3JvbGxMZWZ0ID0gdGhpcy5zLnNjcm9sbExlZnQ7XG5cblx0XHRpZiAoaXRlbURvbS5mbG9hdGluZyAmJiBsYXN0U2Nyb2xsTGVmdFtpdGVtXSAhPT0gc2Nyb2xsTGVmdCkge1xuXHRcdFx0Ly8gSWYgc2Nyb2xsaW5nIGlzIGVuYWJsZWQgd2UgbmVlZCB0byBtYXRjaCB0aGUgZmxvYXRpbmcgaGVhZGVyIHRvIHRoZSBib2R5XG5cdFx0XHRpZiAodGhpcy5fc2Nyb2xsRW5hYmxlZCgpKSB7XG5cdFx0XHRcdHZhciBuZXdTY3JvbGxMZWZ0ID0gJChcblx0XHRcdFx0XHQkKHRoaXMucy5kdC50YWJsZSgpLm5vZGUoKSkucGFyZW50KClcblx0XHRcdFx0KS5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRcdGl0ZW1Eb20uZmxvYXRpbmcuc2Nyb2xsTGVmdChuZXdTY3JvbGxMZWZ0KTtcblx0XHRcdFx0aXRlbURvbS5mbG9hdGluZ1BhcmVudC5zY3JvbGxMZWZ0KG5ld1Njcm9sbExlZnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXN0U2Nyb2xsTGVmdFtpdGVtXSA9IHNjcm9sbExlZnQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgZnJvbSBvbmUgZGlzcGxheSBtb2RlIHRvIGFub3RoZXIuIEVhY2ggZml4ZWQgaXRlbSBjYW4gYmUgaW4gb25lXG5cdCAqIG9mOlxuXHQgKlxuXHQgKiAqIGBpbi1wbGFjZWAgLSBJbiB0aGUgbWFpbiBEYXRhVGFibGVcblx0ICogKiBgaW5gIC0gRmxvYXRpbmcgb3ZlciB0aGUgRGF0YVRhYmxlXG5cdCAqICogYGJlbG93YCAtIChIZWFkZXIgb25seSkgRml4ZWQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFibGUgYm9keVxuXHQgKiAqIGBhYm92ZWAgLSAoRm9vdGVyIG9ubHkpIEZpeGVkIHRvIHRoZSB0b3Agb2YgdGhlIHRhYmxlIGJvZHlcblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgbW9kZSAgICAgICAgTW9kZSB0aGF0IHRoZSBpdGVtIHNob3VsZCBiZSBzaG93biBpblxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICBpdGVtICAgICAgICAnaGVhZGVyJyBvciAnZm9vdGVyJ1xuXHQgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZUNoYW5nZSBGb3JjZSBhIHJlZHJhdyBvZiB0aGUgbW9kZSwgZXZlbiBpZiBhbHJlYWR5XG5cdCAqICAgICBpbiB0aGF0IG1vZGUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbW9kZUNoYW5nZTogZnVuY3Rpb24gKG1vZGUsIGl0ZW0sIGZvcmNlQ2hhbmdlKSB7XG5cdFx0dmFyIGl0ZW1Eb20gPSB0aGlzLmRvbVtpdGVtXTtcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLnMucG9zaXRpb247XG5cblx0XHQvLyBKdXN0IGRldGVybWluZSBpZiBzY3JvbGwgaXMgZW5hYmxlZCBvbmNlXG5cdFx0dmFyIHNjcm9sbEVuYWJsZWQgPSB0aGlzLl9zY3JvbGxFbmFibGVkKCk7XG5cblx0XHQvLyBJZiBmb290ZXIgYW5kIHNjcm9sbGluZyBpcyBlbmFibGVkIHRoZW4gd2UgZG9uJ3QgY2xvbmVcblx0XHQvLyBJbnN0ZWFkIHRoZSB0YWJsZSdzIGhlaWdodCBpcyBkZWNyZWFzZWQgYWNjb3JkaW5nbHkgLSBzZWUgYF9zY3JvbGwoKWBcblx0XHRpZiAoaXRlbSA9PT0gJ2Zvb3RlcicgJiYgc2Nyb2xsRW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEl0IGlzbid0IHRyaXZpYWwgdG8gYWRkIGEgIWltcG9ydGFudCBjc3MgYXR0cmlidXRlLi4uXG5cdFx0dmFyIGltcG9ydGFudFdpZHRoID0gZnVuY3Rpb24gKHcpIHtcblx0XHRcdGl0ZW1Eb20uZmxvYXRpbmdbMF0uc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgdyArICdweCcsICdpbXBvcnRhbnQnKTtcblxuXHRcdFx0Ly8gSWYgbm90IHNjcm9sbGluZyBhbHNvIGhhdmUgdG8gdXBkYXRlIHRoZSBmbG9hdGluZ1BhcmVudFxuXHRcdFx0aWYgKCFzY3JvbGxFbmFibGVkKSB7XG5cdFx0XHRcdGl0ZW1Eb20uZmxvYXRpbmdQYXJlbnRbMF0uc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgdyArICdweCcsICdpbXBvcnRhbnQnKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gUmVjb3JkIGZvY3VzLiBCcm93c2VyJ3Mgd2lsbCBjYXVzZSBpbnB1dCBlbGVtZW50cyB0byBsb29zZSBmb2N1cyBpZlxuXHRcdC8vIHRoZXkgYXJlIGluc2VydGVkIGVsc2Ugd2hlcmUgaW4gdGhlIGRvY1xuXHRcdHZhciB0YWJsZVBhcnQgPSB0aGlzLmRvbVtpdGVtID09PSAnZm9vdGVyJyA/ICd0Zm9vdCcgOiAndGhlYWQnXTtcblx0XHR2YXIgZm9jdXMgPSAkLmNvbnRhaW5zKHRhYmxlUGFydFswXSwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcblx0XHRcdD8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuXHRcdFx0OiBudWxsO1xuXHRcdHZhciBzY3JvbGxCb2R5ID0gJCgkKHRoaXMucy5kdC50YWJsZSgpLm5vZGUoKSkucGFyZW50KCkpO1xuXG5cdFx0aWYgKG1vZGUgPT09ICdpbi1wbGFjZScpIHtcblx0XHRcdC8vIEluc2VydCB0aGUgaGVhZGVyIGJhY2sgaW50byB0aGUgdGFibGUncyByZWFsIGhlYWRlclxuXHRcdFx0aWYgKGl0ZW1Eb20ucGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0aXRlbURvbS5wbGFjZWhvbGRlci5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbURvbS5wbGFjZWhvbGRlciA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpdGVtID09PSAnaGVhZGVyJykge1xuXHRcdFx0XHRpdGVtRG9tLmhvc3QucHJlcGVuZCh0YWJsZVBhcnQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGl0ZW1Eb20uaG9zdC5hcHBlbmQodGFibGVQYXJ0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGl0ZW1Eb20uZmxvYXRpbmcpIHtcblx0XHRcdFx0aXRlbURvbS5mbG9hdGluZy5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbURvbS5mbG9hdGluZyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuX3N0aWNreVBvc2l0aW9uKGl0ZW1Eb20uaG9zdCwgJysnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGl0ZW1Eb20uZmxvYXRpbmdQYXJlbnQpIHtcblx0XHRcdFx0aXRlbURvbS5mbG9hdGluZ1BhcmVudC5maW5kKCdkaXYuZHRmYy10b3AtYmxvY2tlcicpLnJlbW92ZSgpO1xuXHRcdFx0XHRpdGVtRG9tLmZsb2F0aW5nUGFyZW50LnJlbW92ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQkKCQoaXRlbURvbS5ob3N0LnBhcmVudCgpKS5wYXJlbnQoKSkuc2Nyb2xsTGVmdChcblx0XHRcdFx0c2Nyb2xsQm9keS5zY3JvbGxMZWZ0KClcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG1vZGUgPT09ICdpbicpIHtcblx0XHRcdC8vIFJlbW92ZSB0aGUgaGVhZGVyIGZyb20gdGhlIHJlYWwgdGFibGUgYW5kIGluc2VydCBpbnRvIGEgZml4ZWRcblx0XHRcdC8vIHBvc2l0aW9uZWQgZmxvYXRpbmcgdGFibGUgY2xvbmVcblx0XHRcdHRoaXMuX2Nsb25lKGl0ZW0sIGZvcmNlQ2hhbmdlKTtcblxuXHRcdFx0Ly8gR2V0IHVzZWZ1bCBwb3NpdGlvbiB2YWx1ZXNcblx0XHRcdHZhciBzY3JvbGxPZmZzZXQgPSBzY3JvbGxCb2R5Lm9mZnNldCgpO1xuXHRcdFx0dmFyIHdpbmRvd1RvcCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpO1xuXHRcdFx0dmFyIHdpbmRvd0hlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKTtcblx0XHRcdHZhciB3aW5kb3dCb3R0b20gPSB3aW5kb3dUb3AgKyB3aW5kb3dIZWlnaHQ7XG5cdFx0XHR2YXIgYm9keVRvcCA9IHNjcm9sbEVuYWJsZWQgPyBzY3JvbGxPZmZzZXQudG9wIDogcG9zaXRpb24udGJvZHlUb3A7XG5cdFx0XHR2YXIgYm9keUJvdHRvbSA9IHNjcm9sbEVuYWJsZWRcblx0XHRcdFx0PyBzY3JvbGxPZmZzZXQudG9wICsgc2Nyb2xsQm9keS5vdXRlckhlaWdodCgpXG5cdFx0XHRcdDogcG9zaXRpb24udGZvb3RUb3A7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgYW1vdW50IHRoYXQgdGhlIGZvb3RlciBvciBoZWFkZXIgbmVlZHMgdG8gYmUgc2h1ZmZsZWRcblx0XHRcdHZhciBzaHVmZmxlO1xuXG5cdFx0XHRpZiAoaXRlbSA9PT0gJ2Zvb3RlcicpIHtcblx0XHRcdFx0c2h1ZmZsZSA9XG5cdFx0XHRcdFx0Ym9keVRvcCA+IHdpbmRvd0JvdHRvbVxuXHRcdFx0XHRcdFx0PyBwb3NpdGlvbi50Zm9vdEhlaWdodCAvLyBZZXMgLSBwdXNoIHRoZSBmb290ZXIgYmVsb3dcblx0XHRcdFx0XHRcdDogYm9keVRvcCArIHBvc2l0aW9uLnRmb290SGVpZ2h0IC0gd2luZG93Qm90dG9tOyAvLyBOb1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBtdXN0IGJlIGEgaGVhZGVyIHNvIGdldCB0aGUgZGlmZmVyZW5jZSBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG5cdFx0XHRcdC8vICBkZXNpcmVkIGZsb2F0aW5nIGhlYWRlciBhbmQgdGhlIGJvdHRvbSBvZiB0aGUgdGFibGUgYm9keVxuXHRcdFx0XHRzaHVmZmxlID1cblx0XHRcdFx0XHR3aW5kb3dUb3AgK1xuXHRcdFx0XHRcdHRoaXMuYy5oZWFkZXJPZmZzZXQgK1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRoZWFkSGVpZ2h0IC1cblx0XHRcdFx0XHRib2R5Qm90dG9tO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIHRvcCBvciBib3R0b20gYmFzZWQgb2ZmIG9mIHRoZSBvZmZzZXQgYW5kIHRoZSBzaHVmZmxlIHZhbHVlXG5cdFx0XHR2YXIgcHJvcCA9IGl0ZW0gPT09ICdoZWFkZXInID8gJ3RvcCcgOiAnYm90dG9tJztcblx0XHRcdHZhciB2YWwgPSB0aGlzLmNbaXRlbSArICdPZmZzZXQnXSAtIChzaHVmZmxlID4gMCA/IHNodWZmbGUgOiAwKTtcblxuXHRcdFx0aXRlbURvbS5mbG9hdGluZy5hZGRDbGFzcygnZml4ZWRIZWFkZXItZmxvYXRpbmcnKTtcblx0XHRcdGl0ZW1Eb20uZmxvYXRpbmdQYXJlbnRcblx0XHRcdFx0LmNzcyhwcm9wLCB2YWwpXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdGxlZnQ6IHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0J3otaW5kZXgnOiAzXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRpbXBvcnRhbnRXaWR0aChwb3NpdGlvbi53aWR0aCk7XG5cblx0XHRcdGlmIChpdGVtID09PSAnZm9vdGVyJykge1xuXHRcdFx0XHRpdGVtRG9tLmZsb2F0aW5nLmNzcygndG9wJywgJycpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChtb2RlID09PSAnYmVsb3cnKSB7XG5cdFx0XHQvLyBvbmx5IHVzZWQgZm9yIHRoZSBoZWFkZXJcblx0XHRcdC8vIEZpeCB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGhlYWRlciBhdCBiYXNlIG9mIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0aGlzLl9jbG9uZShpdGVtLCBmb3JjZUNoYW5nZSk7XG5cblx0XHRcdGl0ZW1Eb20uZmxvYXRpbmcuYWRkQ2xhc3MoJ2ZpeGVkSGVhZGVyLWxvY2tlZCcpO1xuXHRcdFx0aXRlbURvbS5mbG9hdGluZ1BhcmVudC5jc3Moe1xuXHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0dG9wOiBwb3NpdGlvbi50Zm9vdFRvcCAtIHBvc2l0aW9uLnRoZWFkSGVpZ2h0LFxuXHRcdFx0XHRsZWZ0OiBwb3NpdGlvbi5sZWZ0ICsgJ3B4J1xuXHRcdFx0fSk7XG5cblx0XHRcdGltcG9ydGFudFdpZHRoKHBvc2l0aW9uLndpZHRoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAobW9kZSA9PT0gJ2Fib3ZlJykge1xuXHRcdFx0Ly8gb25seSB1c2VkIGZvciB0aGUgZm9vdGVyXG5cdFx0XHQvLyBGaXggdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBmb290ZXIgYXQgdG9wIG9mIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0aGlzLl9jbG9uZShpdGVtLCBmb3JjZUNoYW5nZSk7XG5cblx0XHRcdGl0ZW1Eb20uZmxvYXRpbmcuYWRkQ2xhc3MoJ2ZpeGVkSGVhZGVyLWxvY2tlZCcpO1xuXHRcdFx0aXRlbURvbS5mbG9hdGluZ1BhcmVudC5jc3Moe1xuXHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0dG9wOiBwb3NpdGlvbi50Ym9keVRvcCxcblx0XHRcdFx0bGVmdDogcG9zaXRpb24ubGVmdCArICdweCdcblx0XHRcdH0pO1xuXG5cdFx0XHRpbXBvcnRhbnRXaWR0aChwb3NpdGlvbi53aWR0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzdG9yZSBmb2N1cyBpZiBpdCB3YXMgbG9zdFxuXHRcdGlmIChmb2N1cyAmJiBmb2N1cyAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZvY3VzLmZvY3VzKCk7XG5cdFx0XHR9LCAxMCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zLnNjcm9sbExlZnQuaGVhZGVyID0gLTE7XG5cdFx0dGhpcy5zLnNjcm9sbExlZnQuZm9vdGVyID0gLTE7XG5cdFx0dGhpcy5zW2l0ZW0gKyAnTW9kZSddID0gbW9kZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FjaGUgdGhlIHBvc2l0aW9uYWwgaW5mb3JtYXRpb24gdGhhdCBpcyByZXF1aXJlZCBmb3IgdGhlIG1vZGVcblx0ICogY2FsY3VsYXRpb25zIHRoYXQgRml4ZWRIZWFkZXIgcGVyZm9ybXMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcG9zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciB0YWJsZSA9IGR0LnRhYmxlKCk7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5zLnBvc2l0aW9uO1xuXHRcdHZhciBkb20gPSB0aGlzLmRvbTtcblx0XHR2YXIgdGFibGVOb2RlID0gJCh0YWJsZS5ub2RlKCkpO1xuXHRcdHZhciBzY3JvbGxFbmFibGVkID0gdGhpcy5fc2Nyb2xsRW5hYmxlZCgpO1xuXG5cdFx0Ly8gTmVlZCB0byB1c2UgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRoYXQgYXJlIGluIHRoZSBtYWluIHRhYmxlLFxuXHRcdC8vIHJlZ2FyZGxlc3Mgb2YgaWYgdGhleSBhcmUgY2xvbmVzLCBzaW5jZSB0aGV5IGhvbGQgdGhlIHBvc2l0aW9ucyB3ZVxuXHRcdC8vIHdhbnQgdG8gbWVhc3VyZSBmcm9tXG5cdFx0dmFyIHRoZWFkID0gJChkdC50YWJsZSgpLmhlYWRlcigpKTtcblx0XHR2YXIgdGZvb3QgPSAkKGR0LnRhYmxlKCkuZm9vdGVyKCkpO1xuXHRcdHZhciB0Ym9keSA9IGRvbS50Ym9keTtcblx0XHR2YXIgc2Nyb2xsQm9keSA9IHRhYmxlTm9kZS5wYXJlbnQoKTtcblxuXHRcdHBvc2l0aW9uLnZpc2libGUgPSB0YWJsZU5vZGUuaXMoJzp2aXNpYmxlJyk7XG5cdFx0cG9zaXRpb24ud2lkdGggPSB0YWJsZU5vZGUub3V0ZXJXaWR0aCgpO1xuXHRcdHBvc2l0aW9uLmxlZnQgPSB0YWJsZU5vZGUub2Zmc2V0KCkubGVmdDtcblx0XHRwb3NpdGlvbi50aGVhZFRvcCA9IHRoZWFkLm9mZnNldCgpLnRvcDtcblx0XHRwb3NpdGlvbi50Ym9keVRvcCA9IHNjcm9sbEVuYWJsZWRcblx0XHRcdD8gc2Nyb2xsQm9keS5vZmZzZXQoKS50b3Bcblx0XHRcdDogdGJvZHkub2Zmc2V0KCkudG9wO1xuXHRcdHBvc2l0aW9uLnRib2R5SGVpZ2h0ID0gc2Nyb2xsRW5hYmxlZFxuXHRcdFx0PyBzY3JvbGxCb2R5Lm91dGVySGVpZ2h0KClcblx0XHRcdDogdGJvZHkub3V0ZXJIZWlnaHQoKTtcblx0XHRwb3NpdGlvbi50aGVhZEhlaWdodCA9IHRoZWFkLm91dGVySGVpZ2h0KCk7XG5cdFx0cG9zaXRpb24udGhlYWRCb3R0b20gPSBwb3NpdGlvbi50aGVhZFRvcCArIHBvc2l0aW9uLnRoZWFkSGVpZ2h0O1xuXHRcdHBvc2l0aW9uLnRmb290VG9wID0gcG9zaXRpb24udGJvZHlUb3AgKyBwb3NpdGlvbi50Ym9keUhlaWdodDsgLy90Zm9vdC5vZmZzZXQoKS50b3A7XG5cblx0XHRpZiAodGZvb3QubGVuZ3RoKSB7XG5cdFx0XHRwb3NpdGlvbi50Zm9vdEJvdHRvbSA9IHBvc2l0aW9uLnRmb290VG9wICsgdGZvb3Qub3V0ZXJIZWlnaHQoKTtcblx0XHRcdHBvc2l0aW9uLnRmb290SGVpZ2h0ID0gdGZvb3Qub3V0ZXJIZWlnaHQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRwb3NpdGlvbi50Zm9vdEJvdHRvbSA9IHBvc2l0aW9uLnRmb290VG9wO1xuXHRcdFx0cG9zaXRpb24udGZvb3RIZWlnaHQgPSAwO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTW9kZSBjYWxjdWxhdGlvbiAtIGRldGVybWluZSB3aGF0IG1vZGUgdGhlIGZpeGVkIGl0ZW1zIHNob3VsZCBiZSBwbGFjZWRcblx0ICogaW50by5cblx0ICpcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2VDaGFuZ2UgRm9yY2UgYSByZWRyYXcgb2YgdGhlIG1vZGUsIGV2ZW4gaWYgYWxyZWFkeVxuXHQgKiAgICAgaW4gdGhhdCBtb2RlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Njcm9sbDogZnVuY3Rpb24gKGZvcmNlQ2hhbmdlKSB7XG5cdFx0aWYgKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLmJEZXN0cm95aW5nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU2Nyb2xsQm9keSBkZXRhaWxzXG5cdFx0dmFyIHNjcm9sbEVuYWJsZWQgPSB0aGlzLl9zY3JvbGxFbmFibGVkKCk7XG5cdFx0dmFyIHNjcm9sbEJvZHkgPSAkKHRoaXMucy5kdC50YWJsZSgpLm5vZGUoKSkucGFyZW50KCk7XG5cdFx0dmFyIHNjcm9sbE9mZnNldCA9IHNjcm9sbEJvZHkub2Zmc2V0KCk7XG5cdFx0dmFyIHNjcm9sbEhlaWdodCA9IHNjcm9sbEJvZHkub3V0ZXJIZWlnaHQoKTtcblxuXHRcdC8vIFdpbmRvdyBkZXRhaWxzXG5cdFx0dmFyIHdpbmRvd0xlZnQgPSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCk7XG5cdFx0dmFyIHdpbmRvd1RvcCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpO1xuXHRcdHZhciB3aW5kb3dIZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XG5cdFx0dmFyIHdpbmRvd0JvdHRvbSA9IHdpbmRvd0hlaWdodCArIHdpbmRvd1RvcDtcblxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMucy5wb3NpdGlvbjtcblx0XHR2YXIgaGVhZGVyTW9kZSwgZm9vdGVyTW9kZTtcblxuXHRcdC8vIEJvZHkgRGV0YWlsc1xuXHRcdHZhciBib2R5VG9wID0gc2Nyb2xsRW5hYmxlZCA/IHNjcm9sbE9mZnNldC50b3AgOiBwb3NpdGlvbi50Ym9keVRvcDtcblx0XHR2YXIgYm9keUxlZnQgPSBzY3JvbGxFbmFibGVkID8gc2Nyb2xsT2Zmc2V0LmxlZnQgOiBwb3NpdGlvbi5sZWZ0O1xuXHRcdHZhciBib2R5Qm90dG9tID0gc2Nyb2xsRW5hYmxlZFxuXHRcdFx0PyBzY3JvbGxPZmZzZXQudG9wICsgc2Nyb2xsSGVpZ2h0XG5cdFx0XHQ6IHBvc2l0aW9uLnRmb290VG9wO1xuXHRcdHZhciBib2R5V2lkdGggPSBzY3JvbGxFbmFibGVkXG5cdFx0XHQ/IHNjcm9sbEJvZHkub3V0ZXJXaWR0aCgpXG5cdFx0XHQ6IHBvc2l0aW9uLnRib2R5V2lkdGg7XG5cblx0XHRpZiAodGhpcy5jLmhlYWRlcikge1xuXHRcdFx0aWYgKCF0aGlzLnMuZW5hYmxlKSB7XG5cdFx0XHRcdGhlYWRlck1vZGUgPSAnaW4tcGxhY2UnO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGhlIGhlYWRlciBpcyBpbiBpdCdzIG5vcm1hbCBwbGFjZSBpZiB0aGUgYm9keSB0b3AgaXMgbG93ZXIgdGhhblxuXHRcdFx0Ly8gIHRoZSBzY3JvbGwgb2YgdGhlIHdpbmRvdyBwbHVzIHRoZSBoZWFkZXJPZmZzZXQgYW5kIHRoZSBoZWlnaHQgb2YgdGhlIGhlYWRlclxuXHRcdFx0ZWxzZSBpZiAoXG5cdFx0XHRcdCFwb3NpdGlvbi52aXNpYmxlIHx8XG5cdFx0XHRcdHdpbmRvd1RvcCArIHRoaXMuYy5oZWFkZXJPZmZzZXQgKyBwb3NpdGlvbi50aGVhZEhlaWdodCA8PVxuXHRcdFx0XHRcdGJvZHlUb3Bcblx0XHRcdCkge1xuXHRcdFx0XHRoZWFkZXJNb2RlID0gJ2luLXBsYWNlJztcblx0XHRcdH1cblx0XHRcdC8vIFRoZSBoZWFkZXIgc2hvdWxkIGJlIGZsb2F0ZWQgaWZcblx0XHRcdGVsc2UgaWYgKFxuXHRcdFx0XHQvLyBUaGUgc2Nyb2xsaW5nIHBsdXMgdGhlIGhlYWRlciBvZmZzZXQgcGx1cyB0aGUgaGVpZ2h0IG9mIHRoZSBoZWFkZXIgaXMgbG93ZXIgdGhhbiB0aGUgdG9wIG9mIHRoZSBib2R5XG5cdFx0XHRcdHdpbmRvd1RvcCArIHRoaXMuYy5oZWFkZXJPZmZzZXQgKyBwb3NpdGlvbi50aGVhZEhlaWdodCA+XG5cdFx0XHRcdFx0Ym9keVRvcCAmJlxuXHRcdFx0XHQvLyBBbmQgdGhlIHNjcm9sbGluZyBhdCB0aGUgdG9wIHBsdXMgdGhlIGhlYWRlciBvZmZzZXQgaXMgYWJvdmUgdGhlIGJvdHRvbSBvZiB0aGUgYm9keVxuXHRcdFx0XHR3aW5kb3dUb3AgKyB0aGlzLmMuaGVhZGVyT2Zmc2V0ICsgcG9zaXRpb24udGhlYWRIZWlnaHQgPFxuXHRcdFx0XHRcdGJvZHlCb3R0b21cblx0XHRcdCkge1xuXHRcdFx0XHRoZWFkZXJNb2RlID0gJ2luJztcblxuXHRcdFx0XHQvLyBGdXJ0aGVyIHRvIHRoZSBhYm92ZSwgSWYgdGhlIHNjcm9sbGluZyBwbHVzIHRoZSBoZWFkZXIgb2Zmc2V0IHBsdXMgdGhlIGhlYWRlciBoZWlnaHQgaXMgbG93ZXJcblx0XHRcdFx0Ly8gdGhhbiB0aGUgYm90dG9tIG9mIHRoZSB0YWJsZSBhIHNodWZmbGUgaXMgcmVxdWlyZWQgc28gaGF2ZSB0byBmb3JjZSB0aGUgY2FsY3VsYXRpb25cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHdpbmRvd1RvcCArIHRoaXMuYy5oZWFkZXJPZmZzZXQgKyBwb3NpdGlvbi50aGVhZEhlaWdodCA+XG5cdFx0XHRcdFx0XHRib2R5Qm90dG9tIHx8XG5cdFx0XHRcdFx0dGhpcy5kb20uaGVhZGVyLmZsb2F0aW5nUGFyZW50ID09PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Zm9yY2VDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZG9tLmhlYWRlci5mbG9hdGluZ1BhcmVudFxuXHRcdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRcdHRvcDogdGhpcy5jLmhlYWRlck9mZnNldCxcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246ICdmaXhlZCdcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oKVxuXHRcdFx0XHRcdFx0LmVxKDApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKHRoaXMuZG9tLmhlYWRlci5mbG9hdGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEFueXRoaW5nIGVsc2UgYW5kIHRoZSB2aWV3IGlzIGJlbG93IHRoZSB0YWJsZVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGhlYWRlck1vZGUgPSAnYmVsb3cnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZm9yY2VDaGFuZ2UgfHwgaGVhZGVyTW9kZSAhPT0gdGhpcy5zLmhlYWRlck1vZGUpIHtcblx0XHRcdFx0dGhpcy5fbW9kZUNoYW5nZShoZWFkZXJNb2RlLCAnaGVhZGVyJywgZm9yY2VDaGFuZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9ob3Jpem9udGFsKCdoZWFkZXInLCB3aW5kb3dMZWZ0KTtcblx0XHR9XG5cblx0XHR2YXIgaGVhZGVyID0ge1xuXHRcdFx0b2Zmc2V0OiB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblx0XHR2YXIgZm9vdGVyID0ge1xuXHRcdFx0b2Zmc2V0OiB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblxuXHRcdGlmIChcblx0XHRcdHRoaXMuYy5mb290ZXIgJiZcblx0XHRcdHRoaXMuZG9tLnRmb290Lmxlbmd0aCAmJlxuXHRcdFx0dGhpcy5kb20udGZvb3QuZmluZCgndGgsIHRkJykubGVuZ3RoXG5cdFx0KSB7XG5cdFx0XHRpZiAoIXRoaXMucy5lbmFibGUpIHtcblx0XHRcdFx0Zm9vdGVyTW9kZSA9ICdpbi1wbGFjZSc7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChcblx0XHRcdFx0IXBvc2l0aW9uLnZpc2libGUgfHxcblx0XHRcdFx0cG9zaXRpb24udGZvb3RCb3R0b20gKyB0aGlzLmMuZm9vdGVyT2Zmc2V0IDw9IHdpbmRvd0JvdHRvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdGZvb3Rlck1vZGUgPSAnaW4tcGxhY2UnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoXG5cdFx0XHRcdGJvZHlCb3R0b20gKyBwb3NpdGlvbi50Zm9vdEhlaWdodCArIHRoaXMuYy5mb290ZXJPZmZzZXQgPlxuXHRcdFx0XHRcdHdpbmRvd0JvdHRvbSAmJlxuXHRcdFx0XHRib2R5VG9wICsgdGhpcy5jLmZvb3Rlck9mZnNldCA8IHdpbmRvd0JvdHRvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdGZvb3Rlck1vZGUgPSAnaW4nO1xuXHRcdFx0XHRmb3JjZUNoYW5nZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zm9vdGVyTW9kZSA9ICdhYm92ZSc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmb3JjZUNoYW5nZSB8fCBmb290ZXJNb2RlICE9PSB0aGlzLnMuZm9vdGVyTW9kZSkge1xuXHRcdFx0XHR0aGlzLl9tb2RlQ2hhbmdlKGZvb3Rlck1vZGUsICdmb290ZXInLCBmb3JjZUNoYW5nZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2hvcml6b250YWwoJ2Zvb3RlcicsIHdpbmRvd0xlZnQpO1xuXG5cdFx0XHR2YXIgZ2V0T2Zmc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBlbC5vZmZzZXQoKSxcblx0XHRcdFx0XHRoZWlnaHQ6IGVsLm91dGVySGVpZ2h0KClcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHRcdGhlYWRlciA9IHRoaXMuZG9tLmhlYWRlci5mbG9hdGluZ1xuXHRcdFx0XHQ/IGdldE9mZnNldEhlaWdodCh0aGlzLmRvbS5oZWFkZXIuZmxvYXRpbmcpXG5cdFx0XHRcdDogZ2V0T2Zmc2V0SGVpZ2h0KHRoaXMuZG9tLnRoZWFkKTtcblx0XHRcdGZvb3RlciA9IHRoaXMuZG9tLmZvb3Rlci5mbG9hdGluZ1xuXHRcdFx0XHQ/IGdldE9mZnNldEhlaWdodCh0aGlzLmRvbS5mb290ZXIuZmxvYXRpbmcpXG5cdFx0XHRcdDogZ2V0T2Zmc2V0SGVpZ2h0KHRoaXMuZG9tLnRmb290KTtcblxuXHRcdFx0Ly8gSWYgc2Nyb2xsaW5nIGlzIGVuYWJsZWQgYW5kIHRoZSBmb290ZXIgaXMgb2ZmIHRoZSBzY3JlZW5cblx0XHRcdGlmIChzY3JvbGxFbmFibGVkICYmIGZvb3Rlci5vZmZzZXQudG9wID4gd2luZG93VG9wKSB7XG5cdFx0XHRcdC8vICYmIGZvb3Rlci5vZmZzZXQudG9wID49IHdpbmRvd0JvdHRvbSkge1xuXHRcdFx0XHQvLyBDYWxjdWxhdGUgdGhlIGdhcCBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHNjcm9sbEJvZHkgYW5kIHRoZSB0b3Agb2YgdGhlIHdpbmRvd1xuXHRcdFx0XHR2YXIgb3ZlcmxhcCA9IHdpbmRvd1RvcCAtIHNjcm9sbE9mZnNldC50b3A7XG5cdFx0XHRcdC8vIFRoZSBuZXcgaGVpZ2h0IGlzIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvd1xuXHRcdFx0XHR2YXIgbmV3SGVpZ2h0ID1cblx0XHRcdFx0XHR3aW5kb3dCb3R0b20gK1xuXHRcdFx0XHRcdC8vIElmIHRoZSBnYXAgYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBzY3JvbGxib2R5IGFuZCB0aGUgd2luZG93IGlzIG1vcmUgdGhhblxuXHRcdFx0XHRcdC8vICB0aGUgaGVpZ2h0IG9mIHRoZSBoZWFkZXIgdGhlbiB0aGUgdG9wIG9mIHRoZSB0YWJsZSBpcyBzdGlsbCB2aXNpYmxlIHNvIGFkZCB0aGF0IGdhcFxuXHRcdFx0XHRcdC8vIERvaW5nIHRoaXMgaGFzIGVmZmVjdGl2ZWx5IGNhbGN1bGF0ZWQgdGhlIGhlaWdodCBmcm9tIHRoZSB0b3Agb2YgdGhlIHRhYmxlIHRvIHRoZSBib3R0b20gb2YgdGhlIGN1cnJlbnQgcGFnZVxuXHRcdFx0XHRcdChvdmVybGFwID4gLWhlYWRlci5oZWlnaHQgPyBvdmVybGFwIDogMCkgLVxuXHRcdFx0XHRcdC8vIFRha2UgZnJvbSB0aGF0XG5cdFx0XHRcdFx0Ly8gVGhlIHRvcCBvZiB0aGUgaGVhZGVyIHBsdXNcblx0XHRcdFx0XHQoaGVhZGVyLm9mZnNldC50b3AgK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGhlYWRlciBoZWlnaHQgaWYgdGhlIHN0YW5kYXJkIGhlYWRlciBpcyBwcmVzZW50XG5cdFx0XHRcdFx0XHQob3ZlcmxhcCA8IC1oZWFkZXIuaGVpZ2h0ID8gaGVhZGVyLmhlaWdodCA6IDApICtcblx0XHRcdFx0XHRcdC8vIEFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBmb290ZXJcblx0XHRcdFx0XHRcdGZvb3Rlci5oZWlnaHQpO1xuXG5cdFx0XHRcdC8vIERvbid0IHdhbnQgYSBuZWdhdGl2ZSBoZWlnaHRcblx0XHRcdFx0aWYgKG5ld0hlaWdodCA8IDApIHtcblx0XHRcdFx0XHRuZXdIZWlnaHQgPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXQgdGhlIGVuZCBvZiB0aGUgYWJvdmUgY2FsY3VsYXRpb24gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGhlYWRlciAodG9wIG9mIHRoZSBwYWdlIGlmIGZsb2F0aW5nKVxuXHRcdFx0XHQvLyBhbmQgdGhlIHBvaW50IGp1c3QgYWJvdmUgdGhlIGZvb3RlciBzaG91bGQgYmUgdGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGhlaWdodCBvZiB0aGUgdGFibGUuXG5cdFx0XHRcdHNjcm9sbEJvZHkub3V0ZXJIZWlnaHQobmV3SGVpZ2h0KTtcblxuXHRcdFx0XHQvLyBOZWVkIHNvbWUgcm91bmRpbmcgaGVyZSBhcyBzb21ldGltZXMgdmVyeSBzbWFsbCBkZWNpbWFsIHBsYWNlcyBhcmUgZW5jb3VudGVyZWRcblx0XHRcdFx0Ly8gSWYgdGhlIGFjdHVhbCBoZWlnaHQgaXMgYmlnZ2VyIG9yIGVxdWFsIHRvIHRoZSBoZWlnaHQgd2UganVzdCBhcHBsaWVkIHRoZW4gdGhlIGZvb3RlciBpcyBcIkZsb2F0aW5nXCJcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdE1hdGgucm91bmQoc2Nyb2xsQm9keS5vdXRlckhlaWdodCgpKSA+PVxuXHRcdFx0XHRcdE1hdGgucm91bmQobmV3SGVpZ2h0KVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQkKHRoaXMuZG9tLnRmb290LnBhcmVudCgpKS5hZGRDbGFzcygnZml4ZWRIZWFkZXItZmxvYXRpbmcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBPdGhlcndpc2UgbWF4LXdpZHRoIGhhcyBraWNrZWQgaW4gc28gaXQgaXMgbm90IGZsb2F0aW5nXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdCQodGhpcy5kb20udGZvb3QucGFyZW50KCkpLnJlbW92ZUNsYXNzKFxuXHRcdFx0XHRcdFx0J2ZpeGVkSGVhZGVyLWZsb2F0aW5nJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5kb20uaGVhZGVyLmZsb2F0aW5nKSB7XG5cdFx0XHR0aGlzLmRvbS5oZWFkZXIuZmxvYXRpbmdQYXJlbnQuY3NzKCdsZWZ0JywgYm9keUxlZnQgLSB3aW5kb3dMZWZ0KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuZG9tLmZvb3Rlci5mbG9hdGluZykge1xuXHRcdFx0dGhpcy5kb20uZm9vdGVyLmZsb2F0aW5nUGFyZW50LmNzcygnbGVmdCcsIGJvZHlMZWZ0IC0gd2luZG93TGVmdCk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgZml4ZWQgY29sdW1ucyBpcyBiZWluZyB1c2VkIG9uIHRoaXMgdGFibGUgdGhlbiB0aGUgYmxvY2tlcnMgbmVlZCB0byBiZSBjb3BpZWQgYWNyb3NzXG5cdFx0Ly8gQ2xvbmluZyB0aGVzZSBpcyBjbGVhbmVyIHRoYW4gY3JlYXRpbmcgYXMgb3VyIG93biBhcyBpdCB3aWxsIGtlZXAgY29uc2lzdGVuY3kgd2l0aCBmaXhlZENvbHVtbnMgYXV0b21hdGljYWxseVxuXHRcdC8vIEFTU1VNSU5HIHRoYXQgdGhlIGNsYXNzIHJlbWFpbnMgdGhlIHNhbWVcblx0XHRpZiAodGhpcy5zLmR0LnNldHRpbmdzKClbMF0uX2ZpeGVkQ29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgYWRqdXN0QmxvY2tlciA9IGZ1bmN0aW9uIChzaWRlLCBlbmQsIGVsKSB7XG5cdFx0XHRcdGlmIChlbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFyIGJsb2NrZXIgPSAkKFxuXHRcdFx0XHRcdFx0J2Rpdi5kdGZjLScgKyBzaWRlICsgJy0nICsgZW5kICsgJy1ibG9ja2VyJ1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRlbCA9XG5cdFx0XHRcdFx0XHRibG9ja2VyLmxlbmd0aCA9PT0gMFxuXHRcdFx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHRcdFx0OiBibG9ja2VyLmNsb25lKCkuY3NzKCd6LWluZGV4JywgMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWwgIT09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyTW9kZSA9PT0gJ2luJyB8fCBoZWFkZXJNb2RlID09PSAnYmVsb3cnKSB7XG5cdFx0XHRcdFx0XHRlbC5hcHBlbmRUbygnYm9keScpLmNzcyh7XG5cdFx0XHRcdFx0XHRcdHRvcDpcblx0XHRcdFx0XHRcdFx0XHRlbmQgPT09ICd0b3AnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGhlYWRlci5vZmZzZXQudG9wXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGZvb3Rlci5vZmZzZXQudG9wLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OlxuXHRcdFx0XHRcdFx0XHRcdHNpZGUgPT09ICdyaWdodCdcblx0XHRcdFx0XHRcdFx0XHRcdD8gYm9keUxlZnQgKyBib2R5V2lkdGggLSBlbC53aWR0aCgpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGJvZHlMZWZ0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRlbC5kZXRhY2goKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWw7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBBZGp1c3QgYWxsIGJsb2NrZXJzXG5cdFx0XHR0aGlzLmRvbS5oZWFkZXIucmlnaHRCbG9ja2VyID0gYWRqdXN0QmxvY2tlcihcblx0XHRcdFx0J3JpZ2h0Jyxcblx0XHRcdFx0J3RvcCcsXG5cdFx0XHRcdHRoaXMuZG9tLmhlYWRlci5yaWdodEJsb2NrZXJcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmRvbS5oZWFkZXIubGVmdEJsb2NrZXIgPSBhZGp1c3RCbG9ja2VyKFxuXHRcdFx0XHQnbGVmdCcsXG5cdFx0XHRcdCd0b3AnLFxuXHRcdFx0XHR0aGlzLmRvbS5oZWFkZXIubGVmdEJsb2NrZXJcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmRvbS5mb290ZXIucmlnaHRCbG9ja2VyID0gYWRqdXN0QmxvY2tlcihcblx0XHRcdFx0J3JpZ2h0Jyxcblx0XHRcdFx0J2JvdHRvbScsXG5cdFx0XHRcdHRoaXMuZG9tLmZvb3Rlci5yaWdodEJsb2NrZXJcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmRvbS5mb290ZXIubGVmdEJsb2NrZXIgPSBhZGp1c3RCbG9ja2VyKFxuXHRcdFx0XHQnbGVmdCcsXG5cdFx0XHRcdCdib3R0b20nLFxuXHRcdFx0XHR0aGlzLmRvbS5mb290ZXIubGVmdEJsb2NrZXJcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0byBjaGVjayBpZiBzY3JvbGxpbmcgaXMgZW5hYmxlZCBvbiB0aGUgdGFibGUgb3Igbm90XG5cdCAqIEByZXR1cm5zIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiBzY3JvbGxpbmcgb24gdGhlIHRhYmxlIGlzIGVuYWJsZWQgb3Igbm90XG5cdCAqL1xuXHRfc2Nyb2xsRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvU2Nyb2xsID0gdGhpcy5zLmR0LnNldHRpbmdzKClbMF0ub1Njcm9sbDtcblx0XHRpZiAob1Njcm9sbC5zWSAhPT0gJycgfHwgb1Njcm9sbC5zWCAhPT0gJycpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWxpZ24gY29sdW1ucyBieSB1c2luZyB0aGUgY29sZ3JvdXAgdGFnIGFuZFxuXHQgKiBjaGVja2luZyBjb2x1bW4gd2lkdGhzXG5cdCAqL1xuXHRfd2lkdGhzOiBmdW5jdGlvbiAoaXRlbURvbSkge1xuXHRcdGlmICghIGl0ZW1Eb20gfHwgISBpdGVtRG9tLnBsYWNlaG9sZGVyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWF0Y2ggdGhlIHRhYmxlIG92ZXJhbGwgd2lkdGhcblx0XHR2YXIgdGFibGVOb2RlID0gJCh0aGlzLnMuZHQudGFibGUoKS5ub2RlKCkpO1xuXHRcdHZhciBzY3JvbGxCb2R5ID0gJCh0YWJsZU5vZGUucGFyZW50KCkpO1xuXG5cdFx0aXRlbURvbS5mbG9hdGluZ1BhcmVudC5jc3MoJ3dpZHRoJywgc2Nyb2xsQm9keVswXS5vZmZzZXRXaWR0aCk7XG5cdFx0aXRlbURvbS5mbG9hdGluZy5jc3MoJ3dpZHRoJywgdGFibGVOb2RlWzBdLm9mZnNldFdpZHRoKTtcblxuXHRcdC8vIFN0cmlwIG91dCB0aGUgb2xkIGNvbGdyb3VwXG5cdFx0JCgnY29sZ3JvdXAnLCBpdGVtRG9tLmZsb2F0aW5nKS5yZW1vdmUoKTtcblxuXHRcdC8vIENvcHkgdGhlIGBjb2xncm91cGAgZWxlbWVudCB0byBkZWZpbmUgdGhlIG51bWJlciBvZiBjb2x1bW5zIC0gbmVlZGVkXG5cdFx0Ly8gZm9yIGNvbXBsZXggaGVhZGVyIGNhc2VzIHdoZXJlIGEgY29sdW1uIG1pZ2h0IG5vdCBoYXZlIGEgdW5pcXVlXG5cdFx0Ly8gaGVhZGVyXG5cdFx0dmFyIGNvbHMgPSBpdGVtRG9tLnBsYWNlaG9sZGVyXG5cdFx0XHQucGFyZW50KClcblx0XHRcdC5maW5kKCdjb2xncm91cCcpXG5cdFx0XHQuY2xvbmUoKVxuXHRcdFx0LmFwcGVuZFRvKGl0ZW1Eb20uZmxvYXRpbmcpXG5cdFx0XHQuZmluZCgnY29sJyk7XG5cblx0XHQvLyBIb3dldmVyLCB0aGUgd2lkdGhzIGRlZmluZWQgaW4gdGhlIGNvbGdyb3VwIGZyb20gdGhlIERhdGFUYWJsZSBtaWdodFxuXHRcdC8vIG5vdCBleGFjdGx5IHJlZmxlY3QgdGhlIGFjdHVhbCB3aWR0aHMgb2YgdGhlIGNvbHVtbnMgKGNvbnRlbnQgY2FuXG5cdFx0Ly8gZm9yY2UgaXQgdG8gc3RyZXRjaCkuIFNvIHdlIG5lZWQgdG8gY29weSB0aGUgYWN0dWFsIHdpZHRocyBpbnRvIHRoZVxuXHRcdC8vIGNvbGdyb3VwIC8gY29sJ3MgdXNlZCBmb3IgdGhlIGZsb2F0aW5nIGhlYWRlci5cblx0XHR2YXIgd2lkdGhzID0gdGhpcy5zLmR0LmNvbHVtbnMoJzp2aXNpYmxlJykud2lkdGhzKCk7XG5cblx0XHRmb3IgKHZhciBpPTAgOyBpPHdpZHRocy5sZW5ndGggOyBpKyspIHtcblx0XHRcdGNvbHMuZXEoaSkuY3NzKCd3aWR0aCcsIHdpZHRoc1tpXSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBWZXJzaW9uXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5GaXhlZEhlYWRlci52ZXJzaW9uID0gJzQuMC4xJztcblxuLyoqXG4gKiBEZWZhdWx0c1xuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqL1xuRml4ZWRIZWFkZXIuZGVmYXVsdHMgPSB7XG5cdGhlYWRlcjogdHJ1ZSxcblx0Zm9vdGVyOiBmYWxzZSxcblx0aGVhZGVyT2Zmc2V0OiAwLFxuXHRmb290ZXJPZmZzZXQ6IDBcbn07XG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBEYXRhVGFibGVzIGludGVyZmFjZXNcbiAqL1xuXG4vLyBBdHRhY2ggZm9yIGNvbnN0cnVjdG9yIGFjY2Vzc1xuJC5mbi5kYXRhVGFibGUuRml4ZWRIZWFkZXIgPSBGaXhlZEhlYWRlcjtcbiQuZm4uRGF0YVRhYmxlLkZpeGVkSGVhZGVyID0gRml4ZWRIZWFkZXI7XG5cbi8vIERhdGFUYWJsZXMgY3JlYXRpb24gLSBjaGVjayBpZiB0aGUgRml4ZWRIZWFkZXIgb3B0aW9uIGhhcyBiZWVuIGRlZmluZWQgb24gdGhlXG4vLyB0YWJsZSBhbmQgaWYgc28sIGluaXRpYWxpc2VcbiQoZG9jdW1lbnQpLm9uKCdpbml0LmR0LmR0ZmgnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcblx0aWYgKGUubmFtZXNwYWNlICE9PSAnZHQnKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGluaXQgPSBzZXR0aW5ncy5vSW5pdC5maXhlZEhlYWRlcjtcblx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmZpeGVkSGVhZGVyO1xuXG5cdGlmICgoaW5pdCB8fCBkZWZhdWx0cykgJiYgIXNldHRpbmdzLl9maXhlZEhlYWRlcikge1xuXHRcdHZhciBvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBpbml0KTtcblxuXHRcdGlmIChpbml0ICE9PSBmYWxzZSkge1xuXHRcdFx0bmV3IEZpeGVkSGVhZGVyKHNldHRpbmdzLCBvcHRzKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBEYXRhVGFibGVzIEFQSSBtZXRob2RzXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCdmaXhlZEhlYWRlcigpJywgZnVuY3Rpb24gKCkgeyB9KTtcblxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlcignZml4ZWRIZWFkZXIuYWRqdXN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcblx0XHR2YXIgZmggPSBjdHguX2ZpeGVkSGVhZGVyO1xuXG5cdFx0aWYgKGZoKSB7XG5cdFx0XHRmaC51cGRhdGUoKTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoJ2ZpeGVkSGVhZGVyLmVuYWJsZSgpJywgZnVuY3Rpb24gKGZsYWcpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xuXHRcdHZhciBmaCA9IGN0eC5fZml4ZWRIZWFkZXI7XG5cblx0XHRmbGFnID0gZmxhZyAhPT0gdW5kZWZpbmVkID8gZmxhZyA6IHRydWU7XG5cdFx0aWYgKGZoICYmIGZsYWcgIT09IGZoLmVuYWJsZWQoKSkge1xuXHRcdFx0ZmguZW5hYmxlKGZsYWcpO1xuXHRcdH1cblx0fSk7XG59KTtcblxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlcignZml4ZWRIZWFkZXIuZW5hYmxlZCgpJywgZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCkge1xuXHRcdHZhciBmaCA9IHRoaXMuY29udGV4dFswXS5fZml4ZWRIZWFkZXI7XG5cblx0XHRpZiAoZmgpIHtcblx0XHRcdHJldHVybiBmaC5lbmFibGVkKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufSk7XG5cbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoJ2ZpeGVkSGVhZGVyLmRpc2FibGUoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xuXHRcdHZhciBmaCA9IGN0eC5fZml4ZWRIZWFkZXI7XG5cblx0XHRpZiAoZmggJiYgZmguZW5hYmxlZCgpKSB7XG5cdFx0XHRmaC5lbmFibGUoZmFsc2UpO1xuXHRcdH1cblx0fSk7XG59KTtcblxuJC5lYWNoKFsnaGVhZGVyJywgJ2Zvb3RlciddLCBmdW5jdGlvbiAoaSwgZWwpIHtcblx0RGF0YVRhYmxlLkFwaS5yZWdpc3RlcignZml4ZWRIZWFkZXIuJyArIGVsICsgJ09mZnNldCgpJywgZnVuY3Rpb24gKG9mZnNldCkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIGN0eFswXS5fZml4ZWRIZWFkZXJcblx0XHRcdFx0PyBjdHhbMF0uX2ZpeGVkSGVhZGVyW2VsICsgJ09mZnNldCddKClcblx0XHRcdFx0OiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xuXHRcdFx0dmFyIGZoID0gY3R4Ll9maXhlZEhlYWRlcjtcblxuXHRcdFx0aWYgKGZoKSB7XG5cdFx0XHRcdGZoW2VsICsgJ09mZnNldCddKG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlO1xuIiwiLyohIERhdGFUYWJsZXMgMi4yLjJcbiAqIMKpIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuaW1wb3J0IGpRdWVyeSBmcm9tICdqcXVlcnknO1xuXG4vLyBEYXRhVGFibGVzIGNvZGUgdXNlcyAkIGludGVybmFsbHksIGJ1dCB3ZSB3YW50IHRvIGJlIGFibGUgdG9cbi8vIHJlYXNzaWduICQgd2l0aCB0aGUgYHVzZWAgbWV0aG9kLCBzbyBpdCBpcyBhIHJlZ3VsYXIgdmFyLlxudmFyICQgPSBqUXVlcnk7XG5cblxudmFyIERhdGFUYWJsZSA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdGlvbnMgKVxue1xuXHQvLyBDaGVjayBpZiBjYWxsZWQgd2l0aCBhIHdpbmRvdyBvciBqUXVlcnkgb2JqZWN0IGZvciBET00gbGVzcyBhcHBsaWNhdGlvbnNcblx0Ly8gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0aWYgKERhdGFUYWJsZS5mYWN0b3J5KHNlbGVjdG9yLCBvcHRpb25zKSkge1xuXHRcdHJldHVybiBEYXRhVGFibGU7XG5cdH1cblxuXHQvLyBXaGVuIGNyZWF0aW5nIHdpdGggYG5ld2AsIGNyZWF0ZSBhIG5ldyBEYXRhVGFibGUsIHJldHVybmluZyB0aGUgQVBJIGluc3RhbmNlXG5cdGlmICh0aGlzIGluc3RhbmNlb2YgRGF0YVRhYmxlKSB7XG5cdFx0cmV0dXJuICQoc2VsZWN0b3IpLkRhdGFUYWJsZShvcHRpb25zKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBBcmd1bWVudCBzd2l0Y2hpbmdcblx0XHRvcHRpb25zID0gc2VsZWN0b3I7XG5cdH1cblxuXHR2YXIgX3RoYXQgPSB0aGlzO1xuXHR2YXIgZW1wdHlJbml0ID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkO1xuXHR2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cblx0aWYgKCBlbXB0eUluaXQgKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0Ly8gTWV0aG9kIHRvIGdldCBEVCBBUEkgaW5zdGFuY2UgZnJvbSBqUXVlcnkgb2JqZWN0XG5cdHRoaXMuYXBpID0gZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcyApO1xuXHR9O1xuXG5cdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHQvLyBGb3IgZWFjaCBpbml0aWFsaXNhdGlvbiB3ZSB3YW50IHRvIGdpdmUgaXQgYSBjbGVhbiBpbml0aWFsaXNhdGlvblxuXHRcdC8vIG9iamVjdCB0aGF0IGNhbiBiZSBiYXNoZWQgYXJvdW5kXG5cdFx0dmFyIG8gPSB7fTtcblx0XHR2YXIgb0luaXQgPSBsZW4gPiAxID8gLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgdGFibGUgY2FzZVxuXHRcdFx0X2ZuRXh0ZW5kKCBvLCBvcHRpb25zLCB0cnVlICkgOlxuXHRcdFx0b3B0aW9ucztcblxuXHRcdFxuXHRcdHZhciBpPTAsIGlMZW47XG5cdFx0dmFyIHNJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzO1xuXHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XG5cdFx0XG5cdFx0LyogU2FuaXR5IGNoZWNrICovXG5cdFx0aWYgKCB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3RhYmxlJyApXG5cdFx0e1xuXHRcdFx0X2ZuTG9nKCBudWxsLCAwLCAnTm9uLXRhYmxlIG5vZGUgaW5pdGlhbGlzYXRpb24gKCcrdGhpcy5ub2RlTmFtZSsnKScsIDIgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0JCh0aGlzKS50cmlnZ2VyKCAnb3B0aW9ucy5kdCcsIG9Jbml0ICk7XG5cdFx0XG5cdFx0LyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBkZWZhdWx0cyAqL1xuXHRcdF9mbkNvbXBhdE9wdHMoIGRlZmF1bHRzICk7XG5cdFx0X2ZuQ29tcGF0Q29scyggZGVmYXVsdHMuY29sdW1uICk7XG5cdFx0XG5cdFx0LyogQ29udmVydCB0aGUgY2FtZWwtY2FzZSBkZWZhdWx0cyB0byBIdW5nYXJpYW4gKi9cblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cywgZGVmYXVsdHMsIHRydWUgKTtcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cy5jb2x1bW4sIGRlZmF1bHRzLmNvbHVtbiwgdHJ1ZSApO1xuXHRcdFxuXHRcdC8qIFNldHRpbmcgdXAgdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdCAqL1xuXHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCAkLmV4dGVuZCggb0luaXQsICR0aGlzLmRhdGEoKSApLCB0cnVlICk7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZS1pbml0aWFsaXNpbmcgYSB0YWJsZSAqL1xuXHRcdHZhciBhbGxTZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0XHRmb3IgKCBpPTAsIGlMZW49YWxsU2V0dGluZ3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHR2YXIgcyA9IGFsbFNldHRpbmdzW2ldO1xuXHRcdFxuXHRcdFx0LyogQmFzZSBjaGVjayBvbiB0YWJsZSBub2RlICovXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHMublRhYmxlID09IHRoaXMgfHxcblx0XHRcdFx0KHMublRIZWFkICYmIHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcykgfHxcblx0XHRcdFx0KHMublRGb290ICYmIHMublRGb290LnBhcmVudE5vZGUgPT0gdGhpcylcblx0XHRcdCkge1xuXHRcdFx0XHR2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG5cdFx0XHRcdHZhciBiRGVzdHJveSA9IG9Jbml0LmJEZXN0cm95ICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iRGVzdHJveSA6IGRlZmF1bHRzLmJEZXN0cm95O1xuXHRcdFxuXHRcdFx0XHRpZiAoIGVtcHR5SW5pdCB8fCBiUmV0cmlldmUgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHMub0luc3RhbmNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBiRGVzdHJveSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuZXcgRGF0YVRhYmxlLkFwaShzKS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2ZuTG9nKCBzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHQvKiBJZiB0aGUgZWxlbWVudCB3ZSBhcmUgaW5pdGlhbGlzaW5nIGhhcyB0aGUgc2FtZSBJRCBhcyBhIHRhYmxlIHdoaWNoIHdhcyBwcmV2aW91c2x5XG5cdFx0XHQgKiBpbml0aWFsaXNlZCwgYnV0IHRoZSB0YWJsZSBub2RlcyBkb24ndCBtYXRjaCAoZnJvbSBiZWZvcmUpIHRoZW4gd2UgZGVzdHJveSB0aGUgb2xkXG5cdFx0XHQgKiBpbnN0YW5jZSBieSBzaW1wbHkgZGVsZXRpbmcgaXQuIFRoaXMgaXMgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGUgdGFibGUgaGFzIGJlZW5cblx0XHRcdCAqIGRlc3Ryb3llZCBieSBvdGhlciBtZXRob2RzLiBBbnlvbmUgdXNpbmcgbm9uLWlkIHNlbGVjdG9ycyB3aWxsIG5lZWQgdG8gZG8gdGhpcyBtYW51YWxseVxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIHMuc1RhYmxlSWQgPT0gdGhpcy5pZCApXG5cdFx0XHR7XG5cdFx0XHRcdGFsbFNldHRpbmdzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyogRW5zdXJlIHRoZSB0YWJsZSBoYXMgYW4gSUQgLSByZXF1aXJlZCBmb3IgYWNjZXNzaWJpbGl0eSAqL1xuXHRcdGlmICggc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIiApXG5cdFx0e1xuXHRcdFx0c0lkID0gXCJEYXRhVGFibGVzX1RhYmxlX1wiKyhEYXRhVGFibGUuZXh0Ll91bmlxdWUrKyk7XG5cdFx0XHR0aGlzLmlkID0gc0lkO1xuXHRcdH1cblx0XHRcblx0XHQvKiBDcmVhdGUgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB0YWJsZSBhbmQgc2V0IHNvbWUgb2YgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyAqL1xuXHRcdHZhciBvU2V0dGluZ3MgPSAkLmV4dGVuZCggdHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLCB7XG5cdFx0XHRcInNEZXN0cm95V2lkdGhcIjogJHRoaXNbMF0uc3R5bGUud2lkdGgsXG5cdFx0XHRcInNJbnN0YW5jZVwiOiAgICAgc0lkLFxuXHRcdFx0XCJzVGFibGVJZFwiOiAgICAgIHNJZCxcblx0XHRcdGNvbGdyb3VwOiAkKCc8Y29sZ3JvdXA+JykucHJlcGVuZFRvKHRoaXMpLFxuXHRcdFx0ZmFzdERhdGE6IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwgdHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuR2V0Q2VsbERhdGEob1NldHRpbmdzLCByb3csIGNvbHVtbiwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdG9TZXR0aW5ncy5uVGFibGUgPSB0aGlzO1xuXHRcdG9TZXR0aW5ncy5vSW5pdCAgPSBvSW5pdDtcblx0XHRcblx0XHRhbGxTZXR0aW5ncy5wdXNoKCBvU2V0dGluZ3MgKTtcblx0XHRcblx0XHQvLyBNYWtlIGEgc2luZ2xlIEFQSSBpbnN0YW5jZSBhdmFpbGFibGUgZm9yIGludGVybmFsIGhhbmRsaW5nXG5cdFx0b1NldHRpbmdzLmFwaSA9IG5ldyBfQXBpKCBvU2V0dGluZ3MgKTtcblx0XHRcblx0XHQvLyBOZWVkIHRvIGFkZCB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gYWRkZWRcblx0XHQvLyB0byB0aGUgc2V0dGluZ3MgYXJyYXksIHNvIHdlIGNhbiBzZWxmIHJlZmVyZW5jZSB0aGUgdGFibGUgaW5zdGFuY2UgaWYgbW9yZSB0aGFuIG9uZVxuXHRcdG9TZXR0aW5ncy5vSW5zdGFuY2UgPSAoX3RoYXQubGVuZ3RoPT09MSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xuXHRcdFxuXHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBiZWZvcmUgd2UgYXBwbHkgYWxsIHRoZSBkZWZhdWx0c1xuXHRcdF9mbkNvbXBhdE9wdHMoIG9Jbml0ICk7XG5cdFx0XG5cdFx0Ly8gSWYgdGhlIGxlbmd0aCBtZW51IGlzIGdpdmVuLCBidXQgdGhlIGluaXQgZGlzcGxheSBsZW5ndGggaXMgbm90LCB1c2UgdGhlIGxlbmd0aCBtZW51XG5cdFx0aWYgKCBvSW5pdC5hTGVuZ3RoTWVudSAmJiAhIG9Jbml0LmlEaXNwbGF5TGVuZ3RoIClcblx0XHR7XG5cdFx0XHRvSW5pdC5pRGlzcGxheUxlbmd0aCA9IEFycmF5LmlzQXJyYXkob0luaXQuYUxlbmd0aE1lbnVbMF0pXG5cdFx0XHRcdD8gb0luaXQuYUxlbmd0aE1lbnVbMF1bMF1cblx0XHRcdFx0OiAkLmlzUGxhaW5PYmplY3QoIG9Jbml0LmFMZW5ndGhNZW51WzBdIClcblx0XHRcdFx0XHQ/IG9Jbml0LmFMZW5ndGhNZW51WzBdLnZhbHVlXG5cdFx0XHRcdFx0OiBvSW5pdC5hTGVuZ3RoTWVudVswXTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gQXBwbHkgdGhlIGRlZmF1bHRzIGFuZCBpbml0IG9wdGlvbnMgdG8gbWFrZSBhIHNpbmdsZSBpbml0IG9iamVjdCB3aWxsIGFsbFxuXHRcdC8vIG9wdGlvbnMgZGVmaW5lZCBmcm9tIGRlZmF1bHRzIGFuZCBpbnN0YW5jZSBvcHRpb25zLlxuXHRcdG9Jbml0ID0gX2ZuRXh0ZW5kKCAkLmV4dGVuZCggdHJ1ZSwge30sIGRlZmF1bHRzICksIG9Jbml0ICk7XG5cdFx0XG5cdFx0XG5cdFx0Ly8gTWFwIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zIG9udG8gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdF9mbk1hcCggb1NldHRpbmdzLm9GZWF0dXJlcywgb0luaXQsIFtcblx0XHRcdFwiYlBhZ2luYXRlXCIsXG5cdFx0XHRcImJMZW5ndGhDaGFuZ2VcIixcblx0XHRcdFwiYkZpbHRlclwiLFxuXHRcdFx0XCJiU29ydFwiLFxuXHRcdFx0XCJiU29ydE11bHRpXCIsXG5cdFx0XHRcImJJbmZvXCIsXG5cdFx0XHRcImJQcm9jZXNzaW5nXCIsXG5cdFx0XHRcImJBdXRvV2lkdGhcIixcblx0XHRcdFwiYlNvcnRDbGFzc2VzXCIsXG5cdFx0XHRcImJTZXJ2ZXJTaWRlXCIsXG5cdFx0XHRcImJEZWZlclJlbmRlclwiXG5cdFx0XSApO1xuXHRcdF9mbk1hcCggb1NldHRpbmdzLCBvSW5pdCwgW1xuXHRcdFx0XCJhamF4XCIsXG5cdFx0XHRcImZuRm9ybWF0TnVtYmVyXCIsXG5cdFx0XHRcInNTZXJ2ZXJNZXRob2RcIixcblx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcImFhU29ydGluZ0ZpeGVkXCIsXG5cdFx0XHRcImFMZW5ndGhNZW51XCIsXG5cdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XCJpU3RhdGVEdXJhdGlvblwiLFxuXHRcdFx0XCJiU29ydENlbGxzVG9wXCIsXG5cdFx0XHRcImlUYWJJbmRleFwiLFxuXHRcdFx0XCJzRG9tXCIsXG5cdFx0XHRcImZuU3RhdGVMb2FkQ2FsbGJhY2tcIixcblx0XHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxuXHRcdFx0XCJyZW5kZXJlclwiLFxuXHRcdFx0XCJzZWFyY2hEZWxheVwiLFxuXHRcdFx0XCJyb3dJZFwiLFxuXHRcdFx0XCJjYXB0aW9uXCIsXG5cdFx0XHRcImxheW91dFwiLFxuXHRcdFx0XCJvcmRlckRlc2NSZXZlcnNlXCIsXG5cdFx0XHRcInR5cGVEZXRlY3RcIixcblx0XHRcdFsgXCJpQ29va2llRHVyYXRpb25cIiwgXCJpU3RhdGVEdXJhdGlvblwiIF0sIC8vIGJhY2t3YXJkcyBjb21wYXRcblx0XHRcdFsgXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCIgXSxcblx0XHRcdFsgXCJhb1NlYXJjaENvbHNcIiwgXCJhb1ByZVNlYXJjaENvbHNcIiBdLFxuXHRcdFx0WyBcImlEaXNwbGF5TGVuZ3RoXCIsIFwiX2lEaXNwbGF5TGVuZ3RoXCIgXVxuXHRcdF0gKTtcblx0XHRfZm5NYXAoIG9TZXR0aW5ncy5vU2Nyb2xsLCBvSW5pdCwgW1xuXHRcdFx0WyBcInNTY3JvbGxYXCIsIFwic1hcIiBdLFxuXHRcdFx0WyBcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCIgXSxcblx0XHRcdFsgXCJzU2Nyb2xsWVwiLCBcInNZXCIgXSxcblx0XHRcdFsgXCJiU2Nyb2xsQ29sbGFwc2VcIiwgXCJiQ29sbGFwc2VcIiBdXG5cdFx0XSApO1xuXHRcdF9mbk1hcCggb1NldHRpbmdzLm9MYW5ndWFnZSwgb0luaXQsIFwiZm5JbmZvQ2FsbGJhY2tcIiApO1xuXHRcdFxuXHRcdC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgICAgICAgb0luaXQuZm5EcmF3Q2FsbGJhY2sgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZVNhdmVQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlU2F2ZVBhcmFtcyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICAgIG9Jbml0LmZuU3RhdGVMb2FkUGFyYW1zICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAgICAgICAgb0luaXQuZm5TdGF0ZUxvYWRlZCApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgICAgICAgIG9Jbml0LmZuUm93Q2FsbGJhY2sgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3cgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsICAgICBvSW5pdC5mbkhlYWRlckNhbGxiYWNrICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5Gb290ZXJDYWxsYmFjayApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0luaXRDb21wbGV0ZScsICAgICAgIG9Jbml0LmZuSW5pdENvbXBsZXRlICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgICAgb0luaXQuZm5QcmVEcmF3Q2FsbGJhY2sgKTtcblx0XHRcblx0XHRvU2V0dGluZ3Mucm93SWRGbiA9IF9mbkdldE9iamVjdERhdGFGbiggb0luaXQucm93SWQgKTtcblx0XHRcblx0XHQvKiBCcm93c2VyIHN1cHBvcnQgZGV0ZWN0aW9uICovXG5cdFx0X2ZuQnJvd3NlckRldGVjdCggb1NldHRpbmdzICk7XG5cdFx0XG5cdFx0dmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHRcdFxuXHRcdCQuZXh0ZW5kKCBvQ2xhc3NlcywgRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCBvSW5pdC5vQ2xhc3NlcyApO1xuXHRcdCR0aGlzLmFkZENsYXNzKCBvQ2xhc3Nlcy50YWJsZSApO1xuXHRcdFxuXHRcdGlmICghIG9TZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlKSB7XG5cdFx0XHRvSW5pdC5pRGlzcGxheVN0YXJ0ID0gMDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCApXG5cdFx0e1xuXHRcdFx0LyogRGlzcGxheSBzdGFydCBwb2ludCwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgc2F2ZSBzYXZpbmcgKi9cblx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHRvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xuXHRcdH1cblx0XHRcblx0XHR2YXIgZGVmZXIgPSBvSW5pdC5pRGVmZXJMb2FkaW5nO1xuXHRcdGlmICggZGVmZXIgIT09IG51bGwgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5kZWZlckxvYWRpbmcgPSB0cnVlO1xuXHRcdFxuXHRcdFx0dmFyIHRtcCA9IEFycmF5LmlzQXJyYXkoZGVmZXIpO1xuXHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBkZWZlclswXSA6IGRlZmVyO1xuXHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc1RvdGFsID0gdG1wID8gZGVmZXJbMV0gOiBkZWZlcjtcblx0XHR9XG5cdFx0XG5cdFx0Lypcblx0XHQgKiBDb2x1bW5zXG5cdFx0ICogU2VlIGlmIHdlIHNob3VsZCBsb2FkIGNvbHVtbnMgYXV0b21hdGljYWxseSBvciB1c2UgZGVmaW5lZCBvbmVzXG5cdFx0ICovXG5cdFx0dmFyIGNvbHVtbnNJbml0ID0gW107XG5cdFx0dmFyIHRoZWFkID0gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGhlYWQnKTtcblx0XHR2YXIgaW5pdEhlYWRlckxheW91dCA9IF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLCB0aGVhZFswXSApO1xuXHRcdFxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgYSBjb2x1bW5zIGFycmF5LCB0aGVuIGdlbmVyYXRlIG9uZSB3aXRoIG51bGxzXG5cdFx0aWYgKCBvSW5pdC5hb0NvbHVtbnMgKSB7XG5cdFx0XHRjb2x1bW5zSW5pdCA9IG9Jbml0LmFvQ29sdW1ucztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGluaXRIZWFkZXJMYXlvdXQubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWluaXRIZWFkZXJMYXlvdXRbMF0ubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW5zSW5pdC5wdXNoKCBudWxsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFkZCB0aGUgY29sdW1uc1xuXHRcdGZvciAoIGk9MCwgaUxlbj1jb2x1bW5zSW5pdC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRcblx0XHQvLyBBcHBseSB0aGUgY29sdW1uIGRlZmluaXRpb25zXG5cdFx0X2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIG9Jbml0LmFvQ29sdW1uRGVmcywgY29sdW1uc0luaXQsIGluaXRIZWFkZXJMYXlvdXQsIGZ1bmN0aW9uIChpQ29sLCBvRGVmKSB7XG5cdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsIG9EZWYgKTtcblx0XHR9ICk7XG5cdFx0XG5cdFx0LyogSFRNTDUgYXR0cmlidXRlIGRldGVjdGlvbiAtIGJ1aWxkIGFuIG1EYXRhIG9iamVjdCBhdXRvbWF0aWNhbGx5IGlmIHRoZVxuXHRcdCAqIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG5cdFx0ICovXG5cdFx0dmFyIHJvd09uZSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpLmZpbmQoJ3RyJykuZXEoMCk7XG5cdFx0XG5cdFx0aWYgKCByb3dPbmUubGVuZ3RoICkge1xuXHRcdFx0dmFyIGEgPSBmdW5jdGlvbiAoIGNlbGwsIG5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBjZWxsLmdldEF0dHJpYnV0ZSggJ2RhdGEtJytuYW1lICkgIT09IG51bGwgPyBuYW1lIDogbnVsbDtcblx0XHRcdH07XG5cdFx0XG5cdFx0XHQkKCByb3dPbmVbMF0gKS5jaGlsZHJlbigndGgsIHRkJykuZWFjaCggZnVuY3Rpb24gKGksIGNlbGwpIHtcblx0XHRcdFx0dmFyIGNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFx0XG5cdFx0XHRcdGlmICghIGNvbCkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW5jb3JyZWN0IGNvbHVtbiBjb3VudCcsIDE4ICk7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0aWYgKCBjb2wubURhdGEgPT09IGkgKSB7XG5cdFx0XHRcdFx0dmFyIHNvcnQgPSBhKCBjZWxsLCAnc29ydCcgKSB8fCBhKCBjZWxsLCAnb3JkZXInICk7XG5cdFx0XHRcdFx0dmFyIGZpbHRlciA9IGEoIGNlbGwsICdmaWx0ZXInICkgfHwgYSggY2VsbCwgJ3NlYXJjaCcgKTtcblx0XHRcblx0XHRcdFx0XHRpZiAoIHNvcnQgIT09IG51bGwgfHwgZmlsdGVyICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0Y29sLm1EYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRfOiAgICAgIGkrJy5kaXNwbGF5Jyxcblx0XHRcdFx0XHRcdFx0c29ydDogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdHR5cGU6ICAgc29ydCAhPT0gbnVsbCAgID8gaSsnLkBkYXRhLScrc29ydCAgIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRmaWx0ZXI6IGZpbHRlciAhPT0gbnVsbCA/IGkrJy5AZGF0YS0nK2ZpbHRlciA6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNvbC5faXNBcnJheUhvc3QgPSB0cnVlO1xuXHRcdFxuXHRcdFx0XHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIE11c3QgYmUgZG9uZSBhZnRlciBldmVyeXRoaW5nIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdGF0ZSBzYXZpbmchXG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgX2ZuU2F2ZVN0YXRlICk7XG5cdFx0XG5cdFx0dmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblx0XHRpZiAoIG9Jbml0LmJTdGF0ZVNhdmUgKVxuXHRcdHtcblx0XHRcdGZlYXR1cmVzLmJTdGF0ZVNhdmUgPSB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvLyBJZiBhYVNvcnRpbmcgaXMgbm90IGRlZmluZWQsIHRoZW4gd2UgdXNlIHRoZSBmaXJzdCBpbmRpY2F0b3IgaW4gYXNTb3J0aW5nXG5cdFx0Ly8gaW4gY2FzZSB0aGF0IGhhcyBiZWVuIGFsdGVyZWQsIHNvIHRoZSBkZWZhdWx0IHNvcnQgcmVmbGVjdHMgdGhhdCBvcHRpb25cblx0XHRpZiAoIG9Jbml0LmFhU29ydGluZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFyIHNvcnRpbmcgPSBvU2V0dGluZ3MuYWFTb3J0aW5nO1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPXNvcnRpbmcubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRzb3J0aW5nW2ldWzFdID0gb1NldHRpbmdzLmFvQ29sdW1uc1sgaSBdLmFzU29ydGluZ1swXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gRG8gYSBmaXJzdCBwYXNzIG9uIHRoZSBzb3J0aW5nIGNsYXNzZXMgKGFsbG93cyBhbnkgc2l6ZSBjaGFuZ2VzIHRvIGJlIHRha2VuIGludG9cblx0XHQvLyBhY2NvdW50LCBhbmQgYWxzbyB3aWxsIGFwcGx5IHNvcnRpbmcgZGlzYWJsZWQgY2xhc3NlcyBpZiBkaXNhYmxlZFxuXHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09PSAnc3NwJyB8fCBmZWF0dXJlcy5iRGVmZXJSZW5kZXIgKSB7XG5cdFx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0XG5cdFx0XG5cdFx0Lypcblx0XHQgKiBUYWJsZSBIVE1MIGluaXRcblx0XHQgKiBDYWNoZSB0aGUgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIgYXMgcmVxdWlyZWQsIGNyZWF0aW5nIHRoZW0gaWYgbmVlZGVkXG5cdFx0ICovXG5cdFx0dmFyIGNhcHRpb24gPSAkdGhpcy5jaGlsZHJlbignY2FwdGlvbicpO1xuXHRcdFxuXHRcdGlmICggb1NldHRpbmdzLmNhcHRpb24gKSB7XG5cdFx0XHRpZiAoIGNhcHRpb24ubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRjYXB0aW9uID0gJCgnPGNhcHRpb24vPicpLmFwcGVuZFRvKCAkdGhpcyApO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0Y2FwdGlvbi5odG1sKCBvU2V0dGluZ3MuY2FwdGlvbiApO1xuXHRcdH1cblx0XHRcblx0XHQvLyBTdG9yZSB0aGUgY2FwdGlvbiBzaWRlLCBzbyB3ZSBjYW4gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50XG5cdFx0Ly8gd2hlbiBjcmVhdGluZyB0aGUgZWxlbWVudFxuXHRcdGlmIChjYXB0aW9uLmxlbmd0aCkge1xuXHRcdFx0Y2FwdGlvblswXS5fY2FwdGlvblNpZGUgPSBjYXB0aW9uLmNzcygnY2FwdGlvbi1zaWRlJyk7XG5cdFx0XHRvU2V0dGluZ3MuY2FwdGlvbk5vZGUgPSBjYXB0aW9uWzBdO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoIHRoZWFkLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRoZWFkID0gJCgnPHRoZWFkLz4nKS5hcHBlbmRUbygkdGhpcyk7XG5cdFx0fVxuXHRcdG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblx0XHRcblx0XHR2YXIgdGJvZHkgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKTtcblx0XHRpZiAoIHRib2R5Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRib2R5ID0gJCgnPHRib2R5Lz4nKS5pbnNlcnRBZnRlcih0aGVhZCk7XG5cdFx0fVxuXHRcdG9TZXR0aW5ncy5uVEJvZHkgPSB0Ym9keVswXTtcblx0XHRcblx0XHR2YXIgdGZvb3QgPSAkdGhpcy5jaGlsZHJlbigndGZvb3QnKTtcblx0XHRpZiAoIHRmb290Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdC8vIElmIHdlIGFyZSBhIHNjcm9sbGluZyB0YWJsZSwgYW5kIG5vIGZvb3RlciBoYXMgYmVlbiBnaXZlbiwgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZVxuXHRcdFx0Ly8gYSB0Zm9vdCBlbGVtZW50IGZvciB0aGUgY2FwdGlvbiBlbGVtZW50IHRvIGJlIGFwcGVuZGVkIHRvXG5cdFx0XHR0Zm9vdCA9ICQoJzx0Zm9vdC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdH1cblx0XHRvU2V0dGluZ3MublRGb290ID0gdGZvb3RbMF07XG5cdFx0XG5cdFx0Ly8gQ29weSB0aGUgZGF0YSBpbmRleCBhcnJheVxuXHRcdG9TZXR0aW5ncy5haURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0XG5cdFx0Ly8gSW5pdGlhbGlzYXRpb24gY29tcGxldGUgLSB0YWJsZSBjYW4gYmUgZHJhd25cblx0XHRvU2V0dGluZ3MuYkluaXRpYWxpc2VkID0gdHJ1ZTtcblx0XHRcblx0XHQvLyBMYW5ndWFnZSBkZWZpbml0aW9uc1xuXHRcdHZhciBvTGFuZ3VhZ2UgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFxuXHRcdGlmICggb0xhbmd1YWdlLnNVcmwgKSB7XG5cdFx0XHQvLyBHZXQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIGZyb20gYSBmaWxlXG5cdFx0XHQkLmFqYXgoIHtcblx0XHRcdFx0ZGF0YVR5cGU6ICdqc29uJyxcblx0XHRcdFx0dXJsOiBvTGFuZ3VhZ2Uuc1VybCxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIGpzb24sIG9TZXR0aW5ncy5vSW5pdC5vTGFuZ3VhZ2UgKTtcblx0XHRcblx0XHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ2kxOG4nLCBbb1NldHRpbmdzXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Ly8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlXG5cdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdpMThuIGZpbGUgbG9hZGluZyBlcnJvcicsIDIxICk7XG5cdFx0XG5cdFx0XHRcdFx0Ly8gQ29udGludWUgb24gYXMgYmVzdCB3ZSBjYW5cblx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnaTE4bicsIFtvU2V0dGluZ3NdLCB0cnVlKTtcblx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0fSApO1xuXHRfdGhhdCA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8qKlxuICogRGF0YVRhYmxlcyBleHRlbnNpb25zXG4gKiBcbiAqIFRoaXMgbmFtZXNwYWNlIGFjdHMgYXMgYSBjb2xsZWN0aW9uIGFyZWEgZm9yIHBsdWctaW5zIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAqIGV4dGVuZCBEYXRhVGFibGVzIGNhcGFiaWxpdGllcy4gSW5kZWVkIG1hbnkgb2YgdGhlIGJ1aWxkIGluIG1ldGhvZHNcbiAqIHVzZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHRoZWlyIG93biBjYXBhYmlsaXRpZXMgKHNvcnRpbmcgbWV0aG9kcyBmb3JcbiAqIGV4YW1wbGUpLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG5hbWVzcGFjZSBpcyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgbGVnYWN5XG4gKiByZWFzb25zXG4gKlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLmV4dCA9IF9leHQgPSB7XG5cdC8qKlxuXHQgKiBCdXR0b25zLiBGb3IgdXNlIHdpdGggdGhlIEJ1dHRvbnMgZXh0ZW5zaW9uIGZvciBEYXRhVGFibGVzLiBUaGlzIGlzXG5cdCAqIGRlZmluZWQgaGVyZSBzbyBvdGhlciBleHRlbnNpb25zIGNhbiBkZWZpbmUgYnV0dG9ucyByZWdhcmRsZXNzIG9mIGxvYWRcblx0ICogb3JkZXIuIEl0IGlzIF9ub3RfIHVzZWQgYnkgRGF0YVRhYmxlcyBjb3JlLlxuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqICBAZGVmYXVsdCB7fVxuXHQgKi9cblx0YnV0dG9uczoge30sXG5cblxuXHQvKipcblx0ICogRWxlbWVudCBjbGFzcyBuYW1lc1xuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqICBAZGVmYXVsdCB7fVxuXHQgKi9cblx0Y2xhc3Nlczoge30sXG5cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBidWlsZCB0eXBlIChleHBhbmRlZCBieSB0aGUgZG93bmxvYWQgYnVpbGRlcilcblx0ICpcblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKi9cblx0YnVpbGRlcjogXCItc291cmNlLVwiLFxuXG5cblx0LyoqXG5cdCAqIEVycm9yIHJlcG9ydGluZy5cblx0ICogXG5cdCAqIEhvdyBzaG91bGQgRGF0YVRhYmxlcyByZXBvcnQgYW4gZXJyb3IuIENhbiB0YWtlIHRoZSB2YWx1ZSAnYWxlcnQnLFxuXHQgKiAndGhyb3cnLCAnbm9uZScgb3IgYSBmdW5jdGlvbi5cblx0ICpcblx0ICogIEB0eXBlIHN0cmluZ3xmdW5jdGlvblxuXHQgKiAgQGRlZmF1bHQgYWxlcnRcblx0ICovXG5cdGVyck1vZGU6IFwiYWxlcnRcIixcblxuXG5cdC8qKlxuXHQgKiBMZWdhY3kgc28gdjEgcGx1Zy1pbnMgZG9uJ3QgdGhyb3cganMgZXJyb3JzIG9uIGxvYWRcblx0ICovXG5cdGZlYXR1cmU6IFtdLFxuXG5cdC8qKlxuXHQgKiBGZWF0dXJlIHBsdWctaW5zLlxuXHQgKiBcblx0ICogVGhpcyBpcyBhbiBvYmplY3Qgb2YgY2FsbGJhY2tzIHdoaWNoIHByb3ZpZGUgdGhlIGZlYXR1cmVzIGZvciBEYXRhVGFibGVzXG5cdCAqIHRvIGJlIGluaXRpYWxpc2VkIHZpYSB0aGUgYGxheW91dGAgb3B0aW9uLlxuXHQgKi9cblx0ZmVhdHVyZXM6IHt9LFxuXG5cblx0LyoqXG5cdCAqIFJvdyBzZWFyY2hpbmcuXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdCAqIHNlYXJjaGluZywgYW5kIGEgbG90IG1vcmUgY29tcHJlaGVuc2l2ZSBhcyBpdCBhbGxvd3MgeW91IGNvbXBsZXRlIGNvbnRyb2xcblx0ICogb3ZlciB0aGUgc2VhcmNoaW5nIGxvZ2ljLiBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBpcyBhIGZ1bmN0aW9uXG5cdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdCAqIGFuZCB5b3VyIGxvZ2ljIGRlY2lkZXMgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBzZWFyY2hpbmcgZGF0YSBzZXRcblx0ICogb3Igbm90LlxuXHQgKlxuXHQgKiBTZWFyY2hpbmcgZnVuY3Rpb25zIGhhdmUgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxuXHQgKlxuXHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKiAyLiBge2FycmF5fG9iamVjdH1gIERhdGEgZm9yIHRoZSByb3cgdG8gYmUgcHJvY2Vzc2VkIChzYW1lIGFzIHRoZVxuXHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0ICogICAgZnJvbSBhIERPTSBkYXRhIHNvdXJjZVxuXHQgKiAzLiBge2ludH1gIFJvdyBpbmRleCAoe0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLmFvRGF0YX0pLCB3aGljaFxuXHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHQgKlxuXHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdCAqXG5cdCAqICoge2Jvb2xlYW59IEluY2x1ZGUgdGhlIHJvdyBpbiB0aGUgc2VhcmNoZWQgcmVzdWx0IHNldCAodHJ1ZSkgb3Igbm90XG5cdCAqICAgKGZhbHNlKVxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgYXMgd2l0aCB0aGUgbWFpbiBzZWFyY2ggYWJpbGl0eSBpbiBEYXRhVGFibGVzLCB0ZWNobmljYWxseSB0aGlzXG5cdCAqIGlzIFwiZmlsdGVyaW5nXCIsIHNpbmNlIGl0IGlzIHN1YnRyYWN0aXZlLiBIb3dldmVyLCBmb3IgY29uc2lzdGVuY3kgaW5cblx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdCAqXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdCAqICAgIC8vIGZvdXJ0aCBjb2x1bW4gKGkuZS4gdGhlIGRhdGFbM10gaW5kZXgpIGJhc2VkIG9uIHR3byBpbnB1dCB2YWx1ZXNcblx0ICogICAgLy8gZnJvbSB0aGUgZW5kLXVzZXIsIG1hdGNoaW5nIHRoZSBkYXRhIGluIGEgY2VydGFpbiByYW5nZS5cblx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHQgKiAgICAgIGZ1bmN0aW9uKCBzZXR0aW5ncywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHQgKiAgICAgICAgdmFyIG1pbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaW4nKS52YWx1ZSAqIDE7XG5cdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0ICogICAgICAgIHZhciB2ZXJzaW9uID0gZGF0YVszXSA9PSBcIi1cIiA/IDAgOiBkYXRhWzNdKjE7XG5cdCAqXG5cdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgKiAgICAgIH1cblx0ICogICAgKTtcblx0ICovXG5cdHNlYXJjaDogW10sXG5cblxuXHQvKipcblx0ICogU2VsZWN0b3IgZXh0ZW5zaW9uc1xuXHQgKlxuXHQgKiBUaGUgYHNlbGVjdG9yYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlXG5cdCAqIHNlbGVjdG9yIG1vZGlmaWVyIG9wdGlvbnMgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IGRhdGEgdHlwZSkgdGhhdFxuXHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHQgKiB0aGVpciBwbHVyYWwgY291bnRlcnBhcnRzKS4gRm9yIGV4YW1wbGUgdGhlIFNlbGVjdCBleHRlbnNpb24gdXNlcyB0aGlzXG5cdCAqIG1lY2hhbmlzbSB0byBwcm92aWRlIGFuIG9wdGlvbiB0byBzZWxlY3Qgb25seSByb3dzLCBjb2x1bW5zIGFuZCBjZWxsc1xuXHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHQgKiB3aGljaCBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBleGlzdGluZyBidWlsdCBpbiBzZWxlY3RvclxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBFYWNoIHByb3BlcnR5IGlzIGFuIGFycmF5IHRvIHdoaWNoIGZ1bmN0aW9ucyBjYW4gYmUgcHVzaGVkLiBUaGUgZnVuY3Rpb25zXG5cdCAqIHRha2UgdGhyZWUgYXR0cmlidXRlczpcblx0ICpcblx0ICogKiBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBob3N0IHRhYmxlXG5cdCAqICogT3B0aW9ucyBvYmplY3QgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IHR5cGUpXG5cdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdCAqXG5cdCAqIFRoZSByZXR1cm4gaXMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdGluZyBpdGVtIGluZGV4ZXMgYWZ0ZXIgdGhlIGN1c3RvbVxuXHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqL1xuXHRzZWxlY3Rvcjoge1xuXHRcdGNlbGw6IFtdLFxuXHRcdGNvbHVtbjogW10sXG5cdFx0cm93OiBbXVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIExlZ2FjeSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEVuYWJsZSBhbmQgZGlzYWJsZSBsZWdhY3kgb3B0aW9ucyB0aGF0XG5cdCAqIGFyZSBhdmFpbGFibGUgaW4gRGF0YVRhYmxlcy5cblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKi9cblx0bGVnYWN5OiB7XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIC8gZGlzYWJsZSBEYXRhVGFibGVzIDEuOSBjb21wYXRpYmxlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0XHQgKiByZXF1ZXN0c1xuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdGFqYXg6IG51bGxcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBQYWdpbmF0aW9uIHBsdWctaW4gbWV0aG9kcy5cblx0ICogXG5cdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHQgKiBiZSBzaG93biBieSB0aGUgcGFnaW5hdGlvbiByZW5kZXJpbmcgbWV0aG9kIHRoYXQgaXMgdXNlZCBmb3IgdGhlIHRhYmxlOlxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5yZW5kZXJlci5wYWdlQnV0dG9ufS4gVGhlIHJlbmRlcmVyIGFkZHJlc3NlcyBob3cgdGhlXG5cdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdCAqIHdoYXQgYnV0dG9ucyB0byBkaXNwbGF5LiBUaGlzIGlzIGRvbmUgYnkgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGJ1dHRvblxuXHQgKiBkZXNjcmlwdGlvbnMgKHdoYXQgZWFjaCBidXR0b24gd2lsbCBkbykuXG5cdCAqXG5cdCAqIFBhZ2luYXRpb24gdHlwZXMgKHRoZSBmb3VyIGJ1aWx0IGluIG9wdGlvbnMgYW5kIGFueSBhZGRpdGlvbmFsIHBsdWctaW5cblx0ICogb3B0aW9ucyBkZWZpbmVkIGhlcmUpIGNhbiBiZSB1c2VkIHRocm91Z2ggdGhlIGBwYWdpbmF0aW9uVHlwZWBcblx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0ICpcblx0ICogMS4gYHtpbnR9IHBhZ2VgIFRoZSBjdXJyZW50IHBhZ2UgaW5kZXhcblx0ICogMi4gYHtpbnR9IHBhZ2VzYCBUaGUgbnVtYmVyIG9mIHBhZ2VzIGluIHRoZSB0YWJsZVxuXHQgKlxuXHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgb2YgdGhlXG5cdCAqIGFycmF5IGNhbiBiZSBvbmUgb2Y6XG5cdCAqXG5cdCAqICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGBsYXN0YCAtIEp1bXAgdG8gbGFzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGBuZXh0YCAtIFNob3cgbmV4dCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdCAqICogYHtpbnR9YCAtIFNob3cgcGFnZSBvZiB0aGUgaW5kZXggZ2l2ZW5cblx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHQgKiAgIGNvbnRhaW5pbmcgJ0RJVicgZWxlbWVudCAobWlnaHQgYmUgdXNlZnVsIGZvciBzdHlsaW5nKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdCAqIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMgd291bGQgYmUgZGVmaW5lZCBmb3IgZWFjaCBwbHVnLWluLiBUaGF0XG5cdCAqIGFiaWxpdHkgaXMgc3RpbGwgc3VwcG9ydGVkIGJ5IERhdGFUYWJsZXMgMS4xMCsgdG8gcHJvdmlkZSBiYWNrd2FyZHNcblx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHQgKiBkb2N1bWVudGVkIGluIERhdGFUYWJsZXMgMS4xMCsuXG5cdCAqXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IHt9XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBTaG93IHByZXZpb3VzLCBuZXh0IGFuZCBjdXJyZW50IHBhZ2UgYnV0dG9ucyBvbmx5XG5cdCAqICAgICQuZm4uZGF0YVRhYmxlRXh0Lm9QYWdpbmF0aW9uLmN1cnJlbnQgPSBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHQgKiAgICB9O1xuXHQgKi9cblx0cGFnZXI6IHt9LFxuXG5cblx0cmVuZGVyZXI6IHtcblx0XHRwYWdlQnV0dG9uOiB7fSxcblx0XHRoZWFkZXI6IHt9XG5cdH0sXG5cblxuXHQvKipcblx0ICogT3JkZXJpbmcgcGx1Zy1pbnMgLSBjdXN0b20gZGF0YSBzb3VyY2Vcblx0ICogXG5cdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdCAqIHRvIHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb3JkZXJpbmcgdGhhdCBEYXRhVGFibGVzIHR5cGljYWxseSB1c2VzLiBJdFxuXHQgKiBhbGxvd3MgbXVjaCBncmVhdGVyIGNvbnRyb2wgb3ZlciB0aGUgdGhlIGRhdGEgdGhhdCBpcyBiZWluZyB1c2VkIHRvXG5cdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0ICogXG5cdCAqIFRoaXMgdHlwZSBvZiBvcmRlcmluZyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZG8gb3JkZXJpbmcgYmFzZWQgb24gZGF0YVxuXHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdCAqIHRoYW4ganVzdCB0aGUgc3RhdGljIHN0cmluZyB0aGF0IERhdGFUYWJsZXMga25vd3Mgb2YuXG5cdCAqIFxuXHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdCAqIHdpc2ggdG8gYmUgb3JkZXJpbmcgZm9yIHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gYW5kIHRoZW4gcmV0dXJuIHRoYXRcblx0ICogYXJyYXkuIFRoZSBkYXRhIGluIHRoZSBhcnJheSBtdWNoIGJlIGluIHRoZSBpbmRleCBvcmRlciBvZiB0aGUgcm93cyBpblxuXHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdCAqIGZ1bmN0aW9uIGlzIHJ1biBoZXJlIGRlcGVuZHMgb24gdGhlIGBkdC1pbml0IGNvbHVtbnMub3JkZXJEYXRhVHlwZWBcblx0ICogcGFyYW1ldGVyIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGNvbHVtbiAoaWYgYW55KS5cblx0ICpcblx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdCAqXG5cdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqIDIuIGB7aW50fWAgVGFyZ2V0IGNvbHVtbiBpbmRleFxuXHQgKlxuXHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheTpcblx0ICpcblx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdCAqXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gT3JkZXJpbmcgdXNpbmcgYGlucHV0YCBub2RlIHZhbHVlc1xuXHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0ICogICAge1xuXHQgKiAgICAgIHJldHVybiB0aGlzLmFwaSgpLmNvbHVtbiggY29sLCB7b3JkZXI6J2luZGV4J30gKS5ub2RlcygpLm1hcCggZnVuY3Rpb24gKCB0ZCwgaSApIHtcblx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH1cblx0ICovXG5cdG9yZGVyOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBUeXBlIGJhc2VkIHBsdWctaW5zLlxuXHQgKlxuXHQgKiBFYWNoIGNvbHVtbiBpbiBEYXRhVGFibGVzIGhhcyBhIHR5cGUgYXNzaWduZWQgdG8gaXQsIGVpdGhlciBieSBhdXRvbWF0aWNcblx0ICogZGV0ZWN0aW9uIG9yIGJ5IGRpcmVjdCBhc3NpZ25tZW50IHVzaW5nIHRoZSBgdHlwZWAgb3B0aW9uIGZvciB0aGUgY29sdW1uLlxuXHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0ICogY2FuIGFsc28gbWFrZSB1c2Ugb2YgdGhlIGNvbHVtbiB0eXBlIGlmIHJlcXVpcmVkKS5cblx0ICpcblx0ICogQG5hbWVzcGFjZVxuXHQgKi9cblx0dHlwZToge1xuXHRcdC8qKlxuXHRcdCAqIEF1dG9tYXRpYyBjb2x1bW4gY2xhc3MgYXNzaWdubWVudFxuXHRcdCAqL1xuXHRcdGNsYXNzTmFtZToge30sXG5cblx0XHQvKipcblx0XHQgKiBUeXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3QgYXJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBkZXRlY3Rcblx0XHQgKiBhIGNvbHVtbidzIHR5cGUsIG1ha2luZyBpbml0aWFsaXNhdGlvbiBvZiBEYXRhVGFibGVzIHN1cGVyIGVhc3ksIGV2ZW5cblx0XHQgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHQgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgYW5hbHlzZWRcblx0ICAgICAqICAyLiBge3NldHRpbmdzfWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWQgdG9cblx0ICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cblx0ICAgICAqICAgICBiYXNlZCBvbiBsYW5ndWFnZSBzZXR0aW5ncyBzdWNoIGFzIHVzaW5nIGEgY29tbWEgZm9yIGEgZGVjaW1hbFxuXHQgICAgICogICAgIHBsYWNlLiBHZW5lcmFsbHkgc3BlYWtpbmcgdGhlIG9wdGlvbnMgZnJvbSB0aGUgc2V0dGluZ3Mgd2lsbCBub3Rcblx0ICAgICAqICAgICBiZSByZXF1aXJlZFxuXHRcdCAqXG5cdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0ICpcblx0XHQgKiAqIGB7c3RyaW5nfG51bGx9YCBEYXRhIHR5cGUgZGV0ZWN0ZWQsIG9yIG51bGwgaWYgdW5rbm93biAoYW5kIHRodXNcblx0XHQgKiAgIHBhc3MgaXQgb24gdG8gdGhlIG90aGVyIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQ3VycmVuY3kgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbjpcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5kZXRlY3QucHVzaChcblx0XHQgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XG5cdFx0ICogICAgICAgIC8vIENoZWNrIHRoZSBudW1lcmljIHBhcnRcblx0XHQgKiAgICAgICAgaWYgKCAhIGRhdGEuc3Vic3RyaW5nKDEpLm1hdGNoKC9bMC05XS8pICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICpcblx0XHQgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcblx0XHQgKiAgICAgICAgaWYgKCBkYXRhLmNoYXJBdCgwKSA9PSAnJCcgfHwgZGF0YS5jaGFyQXQoMCkgPT0gJyZwb3VuZDsnICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiAnY3VycmVuY3knO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgICk7XG5cdFx0ICovXG5cdFx0ZGV0ZWN0OiBbXSxcblxuXHRcdC8qKlxuXHRcdCAqIEF1dG9tYXRpYyByZW5kZXJlciBhc3NpZ25tZW50XG5cdFx0ICovXG5cdFx0cmVuZGVyOiB7fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cblx0XHQgKlxuXHRcdCAqIFRoZSB0eXBlIGJhc2VkIHNlYXJjaGluZyBmdW5jdGlvbnMgY2FuIGJlIHVzZWQgdG8gcHJlLWZvcm1hdCB0aGVcblx0XHQgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcblx0XHQgKiB0YWdzIG9yIHRvIGRlLWZvcm1hdCB0ZWxlcGhvbmUgbnVtYmVycyBmb3IgbnVtZXJpYyBvbmx5IHNlYXJjaGluZy5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxuXHRcdCAqIG5vIHNlYXJjaCBmb3JtYXR0aW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuXHRcdCAqIFxuXHRcdCAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxuXHRcdCAqIGZvciBhIGNvbHVtbiAob3IgaGF2ZSBpdCBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIGZvciB5b3UgYnkgRGF0YVRhYmxlc1xuXHRcdCAqIG9yIGEgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbiksIHlvdSB3aWxsIHR5cGljYWxseSBiZSB1c2luZyB0aGlzIGZvclxuXHRcdCAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcblx0XHQgKiBieSBhbGxvd2luZyB5b3UgdG8gcHJlLXByb2Nlc3NpbmcgdGhlIGRhdGEgYW5kIHJldHVybmluZyB0aGUgZGF0YSBpblxuXHRcdCAqIHRoZSBmb3JtYXQgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgdXBvbi4gVGhpcyBpcyBkb25lIGJ5IGFkZGluZ1xuXHRcdCAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcblx0XHQgKiBmb3IgdGhhdCB0YXJnZXQgY29sdW1uLiBUaGlzIGlzIHRoZSBjb3JvbGxhcnkgb2YgPGk+YWZuU29ydERhdGE8L2k+XG5cdFx0ICogZm9yIHNlYXJjaGluZyBkYXRhLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxuXHRcdCAqXG5cdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXG5cdFx0ICpcblx0XHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybjpcblx0XHQgKlxuXHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIEZvcm1hdHRlZCBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBzZWFyY2hpbmcuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5zZWFyY2hbJ3RpdGxlLW51bWVyaWMnXSA9IGZ1bmN0aW9uICggZCApIHtcblx0XHQgKiAgICAgIHJldHVybiBkLnJlcGxhY2UoL1xcbi9nLFwiIFwiKS5yZXBsYWNlKCAvPC4qPz4vZywgXCJcIiApO1xuXHRcdCAqICAgIH1cblx0XHQgKi9cblx0XHRzZWFyY2g6IHt9LFxuXG5cblx0XHQvKipcblx0XHQgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxuXHRcdCAqXG5cdFx0ICogVGhlIGNvbHVtbiB0eXBlIHRlbGxzIERhdGFUYWJsZXMgd2hhdCBvcmRlcmluZyB0byBhcHBseSB0byB0aGUgdGFibGVcblx0XHQgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXG5cdFx0ICogaXMgZGVmaW5lZCBieSB0aGUgZnVuY3Rpb25zIGF2YWlsYWJsZSBpbiB0aGlzIG9iamVjdC5cblx0XHQgKlxuXHRcdCAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xuXHRcdCAqIHRoaXMgb2JqZWN0OlxuXHRcdCAqXG5cdFx0ICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxuXHRcdCAqICogYHt0eXBlfS1hc2NgIC0gQXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXG5cdFx0ICogKiBge3R5cGV9LWRlc2NgIC0gRGVzY2VuZGluZyBvcmRlciBmdW5jdGlvblxuXHRcdCAqXG5cdFx0ICogQWxsIHRocmVlIGNhbiBiZSB1c2VkIHRvZ2V0aGVyLCBvbmx5IGB7dHlwZX0tcHJlYCBvciBvbmx5XG5cdFx0ICogYHt0eXBlfS1hc2NgIGFuZCBge3R5cGV9LWRlc2NgIHRvZ2V0aGVyLiBJdCBpcyBnZW5lcmFsbHkgcmVjb21tZW5kZWRcblx0XHQgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcblx0XHQgKiBpbXBsZW1lbnRhdGlvbiBpbiB0ZXJtcyBvZiBzcGVlZCwgYWx0aG91Z2ggdGhlIG90aGVycyBhcmUgcHJvdmlkZWRcblx0XHQgKiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIEphdmFzY3JpcHQgc29ydCBmdW5jdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBge3R5cGV9LXByZWA6IEZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxuXHRcdCAqXG5cdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcblx0XHQgKlxuXHRcdCAqIEFuZCByZXR1cm46XG5cdFx0ICpcblx0XHQgKiAqIGB7Kn1gIERhdGEgdG8gYmUgc29ydGVkIHVwb25cblx0XHQgKlxuXHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuXHRcdCAqIGZ1bmN0aW9ucywgdGFraW5nIHR3byBwYXJhbWV0ZXJzOlxuXHRcdCAqXG5cdCAgICAgKiAgMS4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG5cdCAgICAgKiAgMi4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBmaXJzdCBwYXJhbWV0ZXJcblx0XHQgKlxuXHRcdCAqIEFuZCByZXR1cm5pbmc6XG5cdFx0ICpcblx0XHQgKiAqIGB7Kn1gIE9yZGVyaW5nIG1hdGNoOiA8MCBpZiBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNvcnRlZCBsb3dlclxuXHRcdCAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxuXHRcdCAqICAgPjAgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGhlaWdodCB0aGFuIHRoZSBzZWNvbmRcblx0XHQgKiAgIHBhcmFtZXRlci5cblx0XHQgKiBcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBOdW1lcmljIG9yZGVyaW5nIG9mIGZvcm1hdHRlZCBudW1iZXJzIHdpdGggYSBwcmUtZm9ybWF0dGVyXG5cdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XG5cdFx0ICogICAgICBcInN0cmluZy1wcmVcIjogZnVuY3Rpb24oeCkge1xuXHRcdCAqICAgICAgICBhID0gKGEgPT09IFwiLVwiIHx8IGEgPT09IFwiXCIpID8gMCA6IGEucmVwbGFjZSggL1teXFxkXFwtXFwuXS9nLCBcIlwiICk7XG5cdFx0ICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XG5cdFx0ICogICAgICB9XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQ2FzZS1zZW5zaXRpdmUgc3RyaW5nIG9yZGVyaW5nLCB3aXRoIG5vIHByZS1mb3JtYXR0aW5nIG1ldGhvZFxuXHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcblx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtYXNjXCI6IGZ1bmN0aW9uKHgseSkge1xuXHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcblx0XHQgKiAgICAgIH0sXG5cdFx0ICogICAgICBcInN0cmluZy1jYXNlLWRlc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0ICogICAgICAgIHJldHVybiAoKHggPCB5KSA/IDEgOiAoKHggPiB5KSA/IC0xIDogMCkpO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRvcmRlcjoge31cblx0fSxcblxuXHQvKipcblx0ICogVW5pcXVlIERhdGFUYWJsZXMgaW5zdGFuY2UgY291bnRlclxuXHQgKlxuXHQgKiBAdHlwZSBpbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF91bmlxdWU6IDAsXG5cblxuXHQvL1xuXHQvLyBEZXByZWNpYXRlZFxuXHQvLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBvbmx5LlxuXHQvLyBUaGUgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlXG5cdC8vIHZlcnNpb25cblx0Ly9cblxuXHQvKipcblx0ICogVmVyc2lvbiBjaGVjayBmdW5jdGlvbi5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAZGVwcmVjaWF0ZWQgU2luY2UgMS4xMFxuXHQgKi9cblx0Zm5WZXJzaW9uQ2hlY2s6IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayxcblxuXG5cdC8qKlxuXHQgKiBJbmRleCBmb3Igd2hhdCAndGhpcycgaW5kZXggQVBJIGZ1bmN0aW9ucyBzaG91bGQgdXNlXG5cdCAqICBAdHlwZSBpbnRcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqL1xuXHRpQXBpSW5kZXg6IDAsXG5cblxuXHQvKipcblx0ICogU29mdHdhcmUgdmVyc2lvblxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKi9cblx0c1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG59O1xuXG5cbi8vXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gQWxpYXMgdG8gcHJlIDEuMTAgSHVuZ2FyaWFuIG5vdGF0aW9uIGNvdW50ZXIgcGFydHNcbi8vXG4kLmV4dGVuZCggX2V4dCwge1xuXHRhZm5GaWx0ZXJpbmc6IF9leHQuc2VhcmNoLFxuXHRhVHlwZXM6ICAgICAgIF9leHQudHlwZS5kZXRlY3QsXG5cdG9mblNlYXJjaDogICAgX2V4dC50eXBlLnNlYXJjaCxcblx0b1NvcnQ6ICAgICAgICBfZXh0LnR5cGUub3JkZXIsXG5cdGFmblNvcnREYXRhOiAgX2V4dC5vcmRlcixcblx0YW9GZWF0dXJlczogICBfZXh0LmZlYXR1cmUsXG5cdG9TdGRDbGFzc2VzOiAgX2V4dC5jbGFzc2VzLFxuXHRvUGFnaW5hdGlvbjogIF9leHQucGFnZXJcbn0gKTtcblxuXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdGNvbnRhaW5lcjogJ2R0LWNvbnRhaW5lcicsXG5cdGVtcHR5OiB7XG5cdFx0cm93OiAnZHQtZW1wdHknXG5cdH0sXG5cdGluZm86IHtcblx0XHRjb250YWluZXI6ICdkdC1pbmZvJ1xuXHR9LFxuXHRsYXlvdXQ6IHtcblx0XHRyb3c6ICdkdC1sYXlvdXQtcm93Jyxcblx0XHRjZWxsOiAnZHQtbGF5b3V0LWNlbGwnLFxuXHRcdHRhYmxlUm93OiAnZHQtbGF5b3V0LXRhYmxlJyxcblx0XHR0YWJsZUNlbGw6ICcnLFxuXHRcdHN0YXJ0OiAnZHQtbGF5b3V0LXN0YXJ0Jyxcblx0XHRlbmQ6ICdkdC1sYXlvdXQtZW5kJyxcblx0XHRmdWxsOiAnZHQtbGF5b3V0LWZ1bGwnXG5cdH0sXG5cdGxlbmd0aDoge1xuXHRcdGNvbnRhaW5lcjogJ2R0LWxlbmd0aCcsXG5cdFx0c2VsZWN0OiAnZHQtaW5wdXQnXG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0Y2FuQXNjOiAnZHQtb3JkZXJhYmxlLWFzYycsXG5cdFx0Y2FuRGVzYzogJ2R0LW9yZGVyYWJsZS1kZXNjJyxcblx0XHRpc0FzYzogJ2R0LW9yZGVyaW5nLWFzYycsXG5cdFx0aXNEZXNjOiAnZHQtb3JkZXJpbmctZGVzYycsXG5cdFx0bm9uZTogJ2R0LW9yZGVyYWJsZS1ub25lJyxcblx0XHRwb3NpdGlvbjogJ3NvcnRpbmdfJ1xuXHR9LFxuXHRwcm9jZXNzaW5nOiB7XG5cdFx0Y29udGFpbmVyOiAnZHQtcHJvY2Vzc2luZydcblx0fSxcblx0c2Nyb2xsaW5nOiB7XG5cdFx0Ym9keTogJ2R0LXNjcm9sbC1ib2R5Jyxcblx0XHRjb250YWluZXI6ICdkdC1zY3JvbGwnLFxuXHRcdGZvb3Rlcjoge1xuXHRcdFx0c2VsZjogJ2R0LXNjcm9sbC1mb290Jyxcblx0XHRcdGlubmVyOiAnZHQtc2Nyb2xsLWZvb3RJbm5lcidcblx0XHR9LFxuXHRcdGhlYWRlcjoge1xuXHRcdFx0c2VsZjogJ2R0LXNjcm9sbC1oZWFkJyxcblx0XHRcdGlubmVyOiAnZHQtc2Nyb2xsLWhlYWRJbm5lcidcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDoge1xuXHRcdGNvbnRhaW5lcjogJ2R0LXNlYXJjaCcsXG5cdFx0aW5wdXQ6ICdkdC1pbnB1dCdcblx0fSxcblx0dGFibGU6ICdkYXRhVGFibGUnLFx0XG5cdHRib2R5OiB7XG5cdFx0Y2VsbDogJycsXG5cdFx0cm93OiAnJ1xuXHR9LFxuXHR0aGVhZDoge1xuXHRcdGNlbGw6ICcnLFxuXHRcdHJvdzogJydcblx0fSxcblx0dGZvb3Q6IHtcblx0XHRjZWxsOiAnJyxcblx0XHRyb3c6ICcnXG5cdH0sXG5cdHBhZ2luZzoge1xuXHRcdGFjdGl2ZTogJ2N1cnJlbnQnLFxuXHRcdGJ1dHRvbjogJ2R0LXBhZ2luZy1idXR0b24nLFxuXHRcdGNvbnRhaW5lcjogJ2R0LXBhZ2luZycsXG5cdFx0ZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG5cdFx0bmF2OiAnJ1xuXHR9XG59ICk7XG5cblxuLypcbiAqIEl0IGlzIHVzZWZ1bCB0byBoYXZlIHZhcmlhYmxlcyB3aGljaCBhcmUgc2NvcGVkIGxvY2FsbHkgc28gb25seSB0aGVcbiAqIERhdGFUYWJsZXMgZnVuY3Rpb25zIGNhbiBhY2Nlc3MgdGhlbSBhbmQgdGhleSBkb24ndCBsZWFrIGludG8gZ2xvYmFsIHNwYWNlLlxuICogQXQgdGhlIHNhbWUgdGltZSB0aGVzZSBmdW5jdGlvbnMgYXJlIG9mdGVuIHVzZWZ1bCBvdmVyIG11bHRpcGxlIGZpbGVzIGluIHRoZVxuICogY29yZSBhbmQgQVBJLCBzbyB3ZSBsaXN0LCBvciBhdCBsZWFzdCBkb2N1bWVudCwgYWxsIHZhcmlhYmxlcyB3aGljaCBhcmUgdXNlZFxuICogYnkgRGF0YVRhYmxlcyBhcyBwcml2YXRlIHZhcmlhYmxlcyBoZXJlLiBUaGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vXG4gKiBjbGFzaGluZyBvZiB2YXJpYWJsZSBuYW1lcyBhbmQgdGhhdCB0aGV5IGNhbiBlYXNpbHkgcmVmZXJlbmNlZCBmb3IgcmV1c2UuXG4gKi9cblxuXG4vLyBEZWZpbmVkIGVsc2Ugd2hlcmVcbi8vICBfc2VsZWN0b3JfcnVuXG4vLyAgX3NlbGVjdG9yX29wdHNcbi8vICBfc2VsZWN0b3Jfcm93X2luZGV4ZXNcblxudmFyIF9leHQ7IC8vIERhdGFUYWJsZS5leHRcbnZhciBfQXBpOyAvLyBEYXRhVGFibGUuQXBpXG52YXIgX2FwaV9yZWdpc3RlcjsgLy8gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclxudmFyIF9hcGlfcmVnaXN0ZXJQbHVyYWw7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWxcblxudmFyIF9yZV9kaWMgPSB7fTtcbnZhciBfcmVfbmV3X2xpbmVzID0gL1tcXHJcXG5cXHUyMDI4XS9nO1xudmFyIF9yZV9odG1sID0gLzwoW14+XSo+KS9nO1xudmFyIF9tYXhfc3RyX2xlbiA9IE1hdGgucG93KDIsIDI4KTtcblxuLy8gVGhpcyBpcyBub3Qgc3RyaWN0IElTTzg2MDEgLSBEYXRlLnBhcnNlKCkgaXMgcXVpdGUgbGF4LCBhbHRob3VnaFxuLy8gaW1wbGVtZW50YXRpb25zIGRpZmZlciBiZXR3ZWVuIGJyb3dzZXJzLlxudmFyIF9yZV9kYXRlID0gL15cXGR7Miw0fVsuLy1dXFxkezEsMn1bLi8tXVxcZHsxLDJ9KFtUIF17MX1cXGR7MSwyfVs6Ll1cXGR7Mn0oWy46XVxcZHsyfSk/KT8kLztcblxuLy8gRXNjYXBlIHJlZ3VsYXIgZXhwcmVzc2lvbiBzcGVjaWFsIGNoYXJhY3RlcnNcbnZhciBfcmVfZXNjYXBlX3JlZ2V4ID0gbmV3IFJlZ0V4cCggJyhcXFxcJyArIFsgJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JywgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnLCAnJCcsICdeJywgJy0nIF0uam9pbignfFxcXFwnKSArICcpJywgJ2cnICk7XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcmVpZ25fZXhjaGFuZ2VfbWFya2V0XG4vLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxuLy8gLSBcXHUyMGE5IC0gU291dGggS29yZWFuIFdvblxuLy8gLSBcXHUyMEJBIC0gVHVya2lzaCBMaXJhXG4vLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcbi8vIC0gUiAtIEJyYXppbCAoUiQpIGFuZCBTb3V0aCBBZnJpY2Fcbi8vIC0gZnIgLSBTd2lzcyBGcmFuY1xuLy8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXG4vLyAtIFxcdTIwMDkgaXMgdGhpbiBzcGFjZSBhbmQgXFx1MjAyRiBpcyBuYXJyb3cgbm8tYnJlYWsgc3BhY2UsIGJvdGggdXNlZCBpbiBtYW55XG4vLyAtIMmDIC0gQml0Y29pblxuLy8gLSDOniAtIEV0aGVyZXVtXG4vLyAgIHN0YW5kYXJkcyBhcyB0aG91c2FuZHMgc2VwYXJhdG9ycy5cbnZhciBfcmVfZm9ybWF0dGVkX251bWVyaWMgPSAvWydcXHUwMEEwLCTCo+KCrMKlJVxcdTIwMDlcXHUyMDJGXFx1MjBCRFxcdTIwYTlcXHUyMEJBcmZryYPOnl0vZ2k7XG5cblxudmFyIF9lbXB0eSA9IGZ1bmN0aW9uICggZCApIHtcblx0cmV0dXJuICFkIHx8IGQgPT09IHRydWUgfHwgZCA9PT0gJy0nID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuXG52YXIgX2ludFZhbCA9IGZ1bmN0aW9uICggcyApIHtcblx0dmFyIGludGVnZXIgPSBwYXJzZUludCggcywgMTAgKTtcblx0cmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xufTtcblxuLy8gQ29udmVydCBmcm9tIGEgZm9ybWF0dGVkIG51bWJlciB3aXRoIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBgLmAgYXMgdGhlXG4vLyBkZWNpbWFsIHBsYWNlLCB0byBhIEphdmFzY3JpcHQgbnVtYmVyXG52YXIgX251bVRvRGVjaW1hbCA9IGZ1bmN0aW9uICggbnVtLCBkZWNpbWFsUG9pbnQgKSB7XG5cdC8vIENhY2hlIGNyZWF0ZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3BlZWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb2Z0ZW5cblx0aWYgKCAhIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdICkge1xuXHRcdF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdID0gbmV3IFJlZ0V4cCggX2ZuRXNjYXBlUmVnZXgoIGRlY2ltYWxQb2ludCApLCAnZycgKTtcblx0fVxuXHRyZXR1cm4gdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgJiYgZGVjaW1hbFBvaW50ICE9PSAnLicgP1xuXHRcdG51bS5yZXBsYWNlKCAvXFwuL2csICcnICkucmVwbGFjZSggX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0sICcuJyApIDpcblx0XHRudW07XG59O1xuXG5cbnZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiAoIGQsIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkLCBhbGxvd0VtcHR5ICkge1xuXHR2YXIgdHlwZSA9IHR5cGVvZiBkO1xuXHR2YXIgc3RyVHlwZSA9IHR5cGUgPT09ICdzdHJpbmcnO1xuXG5cdGlmICggdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ2JpZ2ludCcpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcblx0Ly8gZm9ybWF0dGVkIHN0cmluZyAodGhpcyBzdG9wcyB0aGUgc3RyaW5nIFwia1wiLCBvciBcImtyXCIsIGV0YyBiZWluZyBkZXRlY3RlZFxuXHQvLyBhcyBhIGZvcm1hdHRlZCBudW1iZXIgZm9yIGN1cnJlbmN5XG5cdGlmICggYWxsb3dFbXB0eSAmJiBfZW1wdHkoIGQgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGVjaW1hbFBvaW50ICYmIHN0clR5cGUgKSB7XG5cdFx0ZCA9IF9udW1Ub0RlY2ltYWwoIGQsIGRlY2ltYWxQb2ludCApO1xuXHR9XG5cblx0aWYgKCBmb3JtYXR0ZWQgJiYgc3RyVHlwZSApIHtcblx0XHRkID0gZC5yZXBsYWNlKCBfcmVfZm9ybWF0dGVkX251bWVyaWMsICcnICk7XG5cdH1cblxuXHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KGQpICkgJiYgaXNGaW5pdGUoIGQgKTtcbn07XG5cblxuLy8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcbnZhciBfaXNIdG1sID0gZnVuY3Rpb24gKCBkICkge1xuXHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xufTtcblxuLy8gSXMgYSBzdHJpbmcgYSBudW1iZXIgc3Vycm91bmRlZCBieSBIVE1MP1xudmFyIF9odG1sTnVtZXJpYyA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQsIGFsbG93RW1wdHkgKSB7XG5cdGlmICggYWxsb3dFbXB0eSAmJiBfZW1wdHkoIGQgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIGlucHV0IGFuZCBzZWxlY3Qgc3RyaW5ncyBtZWFuIHRoYXQgdGhpcyBpc24ndCBqdXN0IGEgbnVtYmVyXG5cdGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5tYXRjaCgvPChpbnB1dHxzZWxlY3QpL2kpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaHRtbCA9IF9pc0h0bWwoIGQgKTtcblx0cmV0dXJuICEgaHRtbCA/XG5cdFx0bnVsbCA6XG5cdFx0X2lzTnVtYmVyKCBfc3RyaXBIdG1sKCBkICksIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkLCBhbGxvd0VtcHR5ICkgP1xuXHRcdFx0dHJ1ZSA6XG5cdFx0XHRudWxsO1xufTtcblxuXG52YXIgX3BsdWNrID0gZnVuY3Rpb24gKCBhLCBwcm9wLCBwcm9wMiApIHtcblx0dmFyIG91dCA9IFtdO1xuXHR2YXIgaT0wLCBpZW49YS5sZW5ndGg7XG5cblx0Ly8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcblx0Ly8gaXMgZXNzZW50aWFsIGhlcmVcblx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gJiYgYVtpXVsgcHJvcCBdICkge1xuXHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdWyBwcm9wMiBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBhW2ldWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufTtcblxuXG4vLyBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgX3BsdWNrLCBidXQgcmF0aGVyIHRoYW4gbG9vcGluZyBvdmVyIGBhYCB3ZSB1c2UgYG9yZGVyYFxuLy8gYXMgdGhlIGluZGV4ZXMgdG8gcGljayBmcm9tIGBhYFxudmFyIF9wbHVja19vcmRlciA9IGZ1bmN0aW9uICggYSwgb3JkZXIsIHByb3AsIHByb3AyIClcbntcblx0dmFyIG91dCA9IFtdO1xuXHR2YXIgaT0wLCBpZW49b3JkZXIubGVuZ3RoO1xuXG5cdC8vIENvdWxkIGhhdmUgdGhlIHRlc3QgaW4gdGhlIGxvb3AgZm9yIHNsaWdodGx5IHNtYWxsZXIgY29kZSwgYnV0IHNwZWVkXG5cdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdGlmICggcHJvcDIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdICYmIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdICkge1xuXHRcdFx0XHRvdXQucHVzaCggYVsgb3JkZXJbaV0gXVsgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn07XG5cblxudmFyIF9yYW5nZSA9IGZ1bmN0aW9uICggbGVuLCBzdGFydCApXG57XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGVuZDtcblxuXHRpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0c3RhcnQgPSAwO1xuXHRcdGVuZCA9IGxlbjtcblx0fVxuXHRlbHNlIHtcblx0XHRlbmQgPSBzdGFydDtcblx0XHRzdGFydCA9IGxlbjtcblx0fVxuXG5cdGZvciAoIHZhciBpPXN0YXJ0IDsgaTxlbmQgOyBpKysgKSB7XG5cdFx0b3V0LnB1c2goIGkgKTtcblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG5cbnZhciBfcmVtb3ZlRW1wdHkgPSBmdW5jdGlvbiAoIGEgKVxue1xuXHR2YXIgb3V0ID0gW107XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0aWYgKCBhW2ldICkgeyAvLyBjYXJlZnVsIC0gd2lsbCByZW1vdmUgYWxsIGZhbHN5IHZhbHVlcyFcblx0XHRcdG91dC5wdXNoKCBhW2ldICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn07XG5cbi8vIFJlcGxhY2VhYmxlIGZ1bmN0aW9uIGluIGFwaS51dGlsXG52YXIgX3N0cmlwSHRtbCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHRpZiAoISBpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG5cblx0Ly8gSXJyZWxldmFudCBjaGVjayB0byB3b3JrYXJvdW5kIENvZGVRTCdzIGZhbHNlIHBvc2l0aXZlIG9uIHRoZSByZWdleFxuXHRpZiAoaW5wdXQubGVuZ3RoID4gX21heF9zdHJfbGVuKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdFeGNlZWRlZCBtYXggc3RyIGxlbicpO1xuXHR9XG5cblx0dmFyIHByZXZpb3VzO1xuXG5cdGlucHV0ID0gaW5wdXQucmVwbGFjZShfcmVfaHRtbCwgJycpOyAvLyBDb21wbGV0ZSB0YWdzXG5cblx0Ly8gU2FmZXR5IGZvciBpbmNvbXBsZXRlIHNjcmlwdCB0YWcgLSB1c2UgZG8gLyB3aGlsZSB0byBlbnN1cmUgdGhhdFxuXHQvLyB3ZSBnZXQgYWxsIGluc3RhbmNlc1xuXHRkbyB7XG5cdFx0cHJldmlvdXMgPSBpbnB1dDtcblx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoLzxzY3JpcHQvaSwgJycpO1xuXHR9IHdoaWxlIChpbnB1dCAhPT0gcHJldmlvdXMpO1xuXG5cdHJldHVybiBwcmV2aW91cztcbn07XG5cbi8vIFJlcGxhY2VhYmxlIGZ1bmN0aW9uIGluIGFwaS51dGlsXG52YXIgX2VzY2FwZUh0bWwgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGQpKSB7XG5cdFx0ZCA9IGQuam9pbignLCcpO1xuXHR9XG5cblx0cmV0dXJuIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/XG5cdFx0ZFxuXHRcdFx0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHRcdC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgOlxuXHRcdGQ7XG59O1xuXG4vLyBSZW1vdmUgZGlhY3JpdGljcyBmcm9tIGEgc3RyaW5nIGJ5IGRlY29tcG9zaW5nIGl0IGFuZCB0aGVuIHJlbW92aW5nXG4vLyBub24tYXNjaWkgY2hhcmFjdGVyc1xudmFyIF9ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyLCBib3RoKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblxuXHQvLyBJdCBpcyBmYXN0ZXIgdG8ganVzdCBydW4gYG5vcm1hbGl6ZWAgdGhhbiBpdCBpcyB0byBjaGVjayBpZlxuXHQvLyB3ZSBuZWVkIHRvIHdpdGggYSByZWdleCEgKENoZWNrIGFzIGl0IGlzbid0IGF2YWlsYWJsZSBpbiBvbGRcblx0Ly8gU2FmYXJpKVxuXHR2YXIgcmVzID0gc3RyLm5vcm1hbGl6ZVxuXHRcdD8gc3RyLm5vcm1hbGl6ZShcIk5GRFwiKVxuXHRcdDogc3RyO1xuXG5cdC8vIEVxdWFsbHksIGhlcmUgd2UgY2hlY2sgaWYgYSByZWdleCBpcyBuZWVkZWQgb3Igbm90XG5cdHJldHVybiByZXMubGVuZ3RoICE9PSBzdHIubGVuZ3RoXG5cdFx0PyAoYm90aCA9PT0gdHJ1ZSA/IHN0ciArICcgJyA6ICcnICkgKyByZXMucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcblx0XHQ6IHJlcztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYWxsIHZhbHVlcyBpbiB0aGUgYXJyYXkgYXJlIHVuaXF1ZS4gVGhpcyBtZWFucyB3ZSBjYW4gc2hvcnRcbiAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxuICogdG8gZWFzaWx5IGNoZWNrIHRoZSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYWxsIHVuaXF1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfYXJlQWxsVW5pcXVlID0gZnVuY3Rpb24gKCBzcmMgKSB7XG5cdGlmICggc3JjLmxlbmd0aCA8IDIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuXHR2YXIgbGFzdCA9IHNvcnRlZFswXTtcblxuXHRmb3IgKCB2YXIgaT0xLCBpZW49c29ydGVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGlmICggc29ydGVkW2ldID09PSBsYXN0ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGxhc3QgPSBzb3J0ZWRbaV07XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSB1bmlxdWUgZWxlbWVudHMgaW4gYSBzb3VyY2UgYXJyYXkuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcbiAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB1bmlxdWUgaXRlbXNcbiAqIEBpZ25vcmVcbiAqL1xudmFyIF91bmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApXG57XG5cdGlmIChBcnJheS5mcm9tICYmIFNldCkge1xuXHRcdHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoc3JjKSk7XG5cdH1cblxuXHRpZiAoIF9hcmVBbGxVbmlxdWUoIHNyYyApICkge1xuXHRcdHJldHVybiBzcmMuc2xpY2UoKTtcblx0fVxuXG5cdC8vIEEgZmFzdGVyIHVuaXF1ZSBtZXRob2QgaXMgdG8gdXNlIG9iamVjdCBrZXlzIHRvIGlkZW50aWZ5IHVzZWQgdmFsdWVzLFxuXHQvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXG5cdC8vIGNvbnNpZGVyLiBTZWUganNwZXJmLmFwcC9jb21wYXJlLWFycmF5LXVuaXF1ZS12ZXJzaW9ucy80IGZvciBtb3JlXG5cdC8vIGluZm9ybWF0aW9uLlxuXHR2YXJcblx0XHRvdXQgPSBbXSxcblx0XHR2YWwsXG5cdFx0aSwgaWVuPXNyYy5sZW5ndGgsXG5cdFx0aiwgaz0wO1xuXG5cdGFnYWluOiBmb3IgKCBpPTAgOyBpPGllbiA7IGkrKyApIHtcblx0XHR2YWwgPSBzcmNbaV07XG5cblx0XHRmb3IgKCBqPTAgOyBqPGsgOyBqKysgKSB7XG5cdFx0XHRpZiAoIG91dFtqXSA9PT0gdmFsICkge1xuXHRcdFx0XHRjb250aW51ZSBhZ2Fpbjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdXQucHVzaCggdmFsICk7XG5cdFx0aysrO1xuXHR9XG5cblx0cmV0dXJuIG91dDtcbn07XG5cbi8vIFN1cnByaXNpbmdseSB0aGlzIGlzIGZhc3RlciB0aGFuIFtdLmNvbmNhdC5hcHBseVxuLy8gaHR0cHM6Ly9qc3BlcmYuY29tL2ZsYXR0ZW4tYW4tYXJyYXktbG9vcC12cy1yZWR1Y2UvMlxudmFyIF9mbGF0dGVuID0gZnVuY3Rpb24gKG91dCwgdmFsKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRmb3IgKHZhciBpPTAgOyBpPHZhbC5sZW5ndGggOyBpKyspIHtcblx0XHRcdF9mbGF0dGVuKG91dCwgdmFsW2ldKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0b3V0LnB1c2godmFsKTtcblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbi8vIFNpbWlsYXIgdG8galF1ZXJ5J3MgYWRkQ2xhc3MsIGJ1dCB1c2UgY2xhc3NMaXN0LmFkZFxuZnVuY3Rpb24gX2FkZENsYXNzKGVsLCBuYW1lKSB7XG5cdGlmIChuYW1lKSB7XG5cdFx0bmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcblx0XHRcdGlmIChuKSB7XG5cdFx0XHRcdC8vIGBhZGRgIGRvZXMgZGVkdXBsaWNhdGlvbiwgc28gbm8gbmVlZCB0byBjaGVjayBgY29udGFpbnNgXG5cdFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQobik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBEYXRhVGFibGVzIHV0aWxpdHkgbWV0aG9kc1xuICogXG4gKiBUaGlzIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgbWV0aG9kcyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbnRlcm5hbGx5IHRvXG4gKiBjcmVhdGUgYSBEYXRhVGFibGUsIGJ1dCB3aGljaCBhcmUgbm90IGV4Y2x1c2l2ZWx5IHVzZWQgb25seSBmb3IgRGF0YVRhYmxlcy5cbiAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2ZcbiAqIGNvZGUuXG4gKlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLnV0aWwgPSB7XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBzdHJpbmcgd2l0aCBkaWFjcml0aWMgY2hhcmFjdGVycyBkZWNvbXBvc2VkXG5cdCAqIEBwYXJhbSB7Kn0gbWl4ZWQgRnVuY3Rpb24gb3Igc3RyaW5nIHRvIG5vcm1hbGl6ZVxuXHQgKiBAcGFyYW0geyp9IGJvdGggUmV0dXJuIG9yaWdpbmFsIHN0cmluZyBhbmQgdGhlIG5vcm1hbGl6ZWQgc3RyaW5nXG5cdCAqIEByZXR1cm5zIFN0cmluZyBvciB1bmRlZmluZWRcblx0ICovXG5cdGRpYWNyaXRpY3M6IGZ1bmN0aW9uIChtaXhlZCwgYm90aCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIG1peGVkO1xuXG5cdFx0aWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBfbm9ybWFsaXplKG1peGVkLCBib3RoKTtcblx0XHR9XG5cdFx0X25vcm1hbGl6ZSA9IG1peGVkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWJvdW5jZSBhIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IGZyZXEgQ2FsbCBmcmVxdWVuY3kgaW4gbVNcblx0ICogQHJldHVybiB7ZnVuY3Rpb259IFdyYXBwZWQgZnVuY3Rpb25cblx0ICovXG5cdGRlYm91bmNlOiBmdW5jdGlvbiAoIGZuLCB0aW1lb3V0ICkge1xuXHRcdHZhciB0aW1lcjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXHRcdFx0fSwgdGltZW91dCB8fCAyNTAgKTtcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkXG5cdCAqIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBmcmVxIENhbGwgZnJlcXVlbmN5IGluIG1TXG5cdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdCAqL1xuXHR0aHJvdHRsZTogZnVuY3Rpb24gKCBmbiwgZnJlcSApIHtcblx0XHR2YXJcblx0XHRcdGZyZXF1ZW5jeSA9IGZyZXEgIT09IHVuZGVmaW5lZCA/IGZyZXEgOiAyMDAsXG5cdFx0XHRsYXN0LFxuXHRcdFx0dGltZXI7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyXG5cdFx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRub3cgID0gK25ldyBEYXRlKCksXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHRcdGlmICggbGFzdCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5ICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bGFzdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHR9LCBmcmVxdWVuY3kgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsYXN0ID0gbm93O1xuXHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cblx0ICpcblx0ICogIEBwYXJhbSB7c3RyaW5nfSB2YWwgc3RyaW5nIHRvIGVzY2FwZVxuXHQgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcblx0ICovXG5cdGVzY2FwZVJlZ2V4OiBmdW5jdGlvbiAoIHZhbCApIHtcblx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoIF9yZV9lc2NhcGVfcmVnZXgsICdcXFxcJDEnICk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB3cml0ZSB0byBhIG5lc3RlZCBvYmplY3Qgb3IgYXJyYXlcblx0ICogQHBhcmFtIHsqfSBzb3VyY2UgSlNPTiBub3RhdGlvbiBzdHJpbmdcblx0ICogQHJldHVybnMgV3JpdGUgZnVuY3Rpb25cblx0ICovXG5cdHNldDogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNvdXJjZSApICkge1xuXHRcdFx0LyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXG5cdFx0XHQgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3Rcblx0XHRcdCAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xuXHRcdFx0ICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXG5cdFx0XHQgKi9cblx0XHRcdHJldHVybiBEYXRhVGFibGUudXRpbC5zZXQoIHNvdXJjZS5fICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzb3VyY2UgPT09IG51bGwgKSB7XG5cdFx0XHQvLyBOb3RoaW5nIHRvIGRvIHdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGxcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCwgbWV0YSkge1xuXHRcdFx0XHRzb3VyY2UoIGRhdGEsICdzZXQnLCB2YWwsIG1ldGEgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0dHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgKHNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHRzb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBzb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSlcblx0XHQpIHtcblx0XHRcdC8vIExpa2UgdGhlIGdldCwgd2UgbmVlZCB0byBnZXQgZGF0YSBmcm9tIGEgbmVzdGVkIG9iamVjdFxuXHRcdFx0dmFyIHNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdmFsLCBzcmMpIHtcblx0XHRcdFx0dmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKCBzcmMgKSwgYjtcblx0XHRcdFx0dmFyIGFMYXN0ID0gYVthLmxlbmd0aC0xXTtcblx0XHRcdFx0dmFyIGFycmF5Tm90YXRpb24sIGZ1bmNOb3RhdGlvbiwgbywgaW5uZXJTcmM7XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoLTEgOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gJ19fcHJvdG9fXycgfHwgYVtpXSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHByb3RvdHlwZSB2YWx1ZXMnKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXkgbm90YXRpb24gcmVxdWVzdFxuXHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRpZiAoIGFycmF5Tm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVBcnJheSwgJycpO1xuXHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0gW107XG5cdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSByZW1haW5kZXIgb2YgdGhlIG5lc3RlZCBvYmplY3QgdG8gc2V0IHNvIHdlIGNhbiByZWN1cnNlXG5cdFx0XHRcdFx0XHRiID0gYS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0Yi5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0aW5uZXJTcmMgPSBiLmpvaW4oJy4nKTtcblx0XG5cdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBzZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj12YWwubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzZXREYXRhKCBvLCB2YWxbal0sIGlubmVyU3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdlJ3ZlIGJlZW4gYXNrZWQgdG8gc2F2ZSBkYXRhIHRvIGFuIGFycmF5LCBidXQgaXRcblx0XHRcdFx0XHRcdFx0Ly8gaXNuJ3QgYXJyYXkgZGF0YSB0byBiZSBzYXZlZC4gQmVzdCB0aGF0IGNhbiBiZSBkb25lXG5cdFx0XHRcdFx0XHRcdC8vIGlzIHRvIGp1c3Qgc2F2ZSB0aGUgdmFsdWUuXG5cdFx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXSA9IHZhbDtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHQvLyBUaGUgaW5uZXIgY2FsbCB0byBzZXREYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdC8vIG9mIHRoZSBzb3VyY2UgYW5kIGhhcyBzZXQgdGhlIGRhdGEsIHRodXMgd2UgY2FuIGV4aXQgaGVyZVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggZnVuY05vdGF0aW9uICkge1xuXHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oIHZhbCApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5lc3RlZCBvYmplY3QgZG9lc24ndCBjdXJyZW50bHkgZXhpc3QgLSBzaW5jZSB3ZSBhcmVcblx0XHRcdFx0XHQvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxuXHRcdFx0XHRcdGlmICggZGF0YVsgYVtpXSBdID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIExhc3QgaXRlbSBpbiB0aGUgaW5wdXQgLSBpLmUsIHRoZSBhY3R1YWwgc2V0XG5cdFx0XHRcdGlmICggYUxhc3QubWF0Y2goX19yZUZuICkgKSB7XG5cdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhTGFzdC5yZXBsYWNlKF9fcmVGbiwgJycpIF0oIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGFycmF5IG5vdGF0aW9uIGlzIHVzZWQsIHdlIGp1c3Qgd2FudCB0byBzdHJpcCBpdCBhbmQgdXNlIHRoZSBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdFx0Ly8gYW5kIGFzc2lnbiB0aGUgdmFsdWUuIElmIGl0IGlzbid0IHVzZWQsIHRoZW4gd2UgZ2V0IHRoZSByZXN1bHQgd2Ugd2FudCBhbnl3YXlcblx0XHRcdFx0XHRkYXRhWyBhTGFzdC5yZXBsYWNlKF9fcmVBcnJheSwgJycpIF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBzZXREYXRhKCBkYXRhLCB2YWwsIHNvdXJjZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0ZGF0YVtzb3VyY2VdID0gdmFsO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWFkIG5lc3RlZCBvYmplY3RzIGZyb20gYXJyYXlzLCBiYXNlZCBvbiBKU09OIG5vdGF0aW9uXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIEpTT04gbm90YXRpb24gc3RyaW5nXG5cdCAqIEByZXR1cm5zIFZhbHVlIHJlYWRcblx0ICovXG5cdGdldDogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNvdXJjZSApICkge1xuXHRcdFx0Ly8gQnVpbGQgYW4gb2JqZWN0IG9mIGdldCBmdW5jdGlvbnMsIGFuZCB3cmFwIHRoZW0gaW4gYSBzaW5nbGUgY2FsbFxuXHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdCQuZWFjaCggc291cmNlLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0b1trZXldID0gRGF0YVRhYmxlLnV0aWwuZ2V0KCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdHZhciB0ID0gb1t0eXBlXSB8fCBvLl87XG5cdFx0XHRcdHJldHVybiB0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzb3VyY2UgPT09IG51bGwgKSB7XG5cdFx0XHQvLyBHaXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgcmVuZGVyaW5nIC8gc29ydGluZyBldGNcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyAvLyB0eXBlLCByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0cmV0dXJuIHNvdXJjZSggZGF0YSwgdHlwZSwgcm93LCBtZXRhICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIChzb3VyY2UuaW5kZXhPZignLicpICE9PSAtMSB8fFxuXHRcdFx0c291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgc291cmNlLmluZGV4T2YoJygnKSAhPT0gLTEpXG5cdFx0KSB7XG5cdFx0XHQvKiBJZiB0aGVyZSBpcyBhIC4gaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlbiB0aGUgZGF0YSBzb3VyY2UgaXMgaW4gYVxuXHRcdFx0ICogbmVzdGVkIG9iamVjdCBzbyB3ZSBsb29wIG92ZXIgdGhlIGRhdGEgZm9yIGVhY2ggbGV2ZWwgdG8gZ2V0IHRoZSBuZXh0XG5cdFx0XHQgKiBsZXZlbCBkb3duLiBPbiBlYWNoIGxvb3Agd2UgdGVzdCBmb3IgdW5kZWZpbmVkLCBhbmQgaWYgZm91bmQgaW1tZWRpYXRlbHlcblx0XHRcdCAqIHJldHVybi4gVGhpcyBhbGxvd3MgZW50aXJlIG9iamVjdHMgdG8gYmUgbWlzc2luZyBhbmQgc0RlZmF1bHRDb250ZW50IHRvXG5cdFx0XHQgKiBiZSB1c2VkIGlmIGRlZmluZWQsIHJhdGhlciB0aGFuIHRocm93aW5nIGFuIGVycm9yXG5cdFx0XHQgKi9cblx0XHRcdHZhciBmZXRjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgc3JjKSB7XG5cdFx0XHRcdHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG91dCwgaW5uZXJTcmM7XG5cdFxuXHRcdFx0XHRpZiAoIHNyYyAhPT0gXCJcIiApIHtcblx0XHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApO1xuXHRcblx0XHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBzcGVjaWFsIG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRcdGlmICggYXJyYXlOb3RhdGlvbiApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQXJyYXkgbm90YXRpb25cblx0XHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIENvbmRpdGlvbiBhbGxvd3Mgc2ltcGx5IFtdIHRvIGJlIHBhc3NlZCBpblxuXHRcdFx0XHRcdFx0XHRpZiAoIGFbaV0gIT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRvdXQgPSBbXTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIGdldFxuXHRcdFx0XHRcdFx0XHRhLnNwbGljZSggMCwgaSsxICk7XG5cdFx0XHRcdFx0XHRcdGlubmVyU3JjID0gYS5qb2luKCcuJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBnZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPWRhdGEubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0LnB1c2goIGZldGNoRGF0YSggZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMgKSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxuXHRcdFx0XHRcdFx0XHQvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHR2YXIgam9pbiA9IGFycmF5Tm90YXRpb25bMF0uc3Vic3RyaW5nKDEsIGFycmF5Tm90YXRpb25bMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gKGpvaW49PT1cIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSByZXF1ZXN0ZWQsIHNvIHdlIGV4aXQgZnJvbSB0aGUgbG9vcFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXSgpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhWyBhW2ldIF0gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9O1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZmV0Y2hEYXRhKCBkYXRhLCB0eXBlLCBzb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZ1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBkYXRhW3NvdXJjZV07XG5cdFx0XHR9O1xuXHRcdH1cblx0fSxcblxuXHRzdHJpcEh0bWw6IGZ1bmN0aW9uIChtaXhlZCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIG1peGVkO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdF9zdHJpcEh0bWwgPSBtaXhlZDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBfc3RyaXBIdG1sKG1peGVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1peGVkO1xuXHR9LFxuXG5cdGVzY2FwZUh0bWw6IGZ1bmN0aW9uIChtaXhlZCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIG1peGVkO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdF9lc2NhcGVIdG1sID0gbWl4ZWQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkobWl4ZWQpKSB7XG5cdFx0XHRyZXR1cm4gX2VzY2FwZUh0bWwobWl4ZWQpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWl4ZWQ7XG5cdH0sXG5cblx0dW5pcXVlOiBfdW5pcXVlXG59O1xuXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBtYXBwaW5nIG9iamVjdCB0aGF0IGFsbG93cyBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gYmUgbG9va2VkIHVwXG4gKiBmb3IgdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0cy4gVGhlIG1hcHBpbmcgaXMgc3RvcmVkIGluIGEgcHJpdmF0ZVxuICogcGFyYW1ldGVyIGNhbGxlZCBgX2h1bmdhcmlhbk1hcGAgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIG9uIHRoZSBzb3VyY2Ugb2JqZWN0LlxuICogIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkh1bmdhcmlhbk1hcCAoIG8gKVxue1xuXHR2YXJcblx0XHRodW5nYXJpYW4gPSAnYSBhYSBhaSBhbyBhcyBiIGZuIGkgbSBvIHMgJyxcblx0XHRtYXRjaCxcblx0XHRuZXdLZXksXG5cdFx0bWFwID0ge307XG5cblx0JC5lYWNoKCBvLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0bWF0Y2ggPSBrZXkubWF0Y2goL14oW15BLVpdKz8pKFtBLVpdKS8pO1xuXG5cdFx0aWYgKCBtYXRjaCAmJiBodW5nYXJpYW4uaW5kZXhPZihtYXRjaFsxXSsnICcpICE9PSAtMSApXG5cdFx0e1xuXHRcdFx0bmV3S2V5ID0ga2V5LnJlcGxhY2UoIG1hdGNoWzBdLCBtYXRjaFsyXS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRtYXBbIG5ld0tleSBdID0ga2V5O1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdID09PSAnbycgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5IdW5nYXJpYW5NYXAoIG9ba2V5XSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdG8uX2h1bmdhcmlhbk1hcCA9IG1hcDtcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuLCBiYXNlZCBvbiBhIEh1bmdhcmlhbiBtYXBcbiAqIGNyZWF0ZWQgYnkgX2ZuSHVuZ2FyaWFuTWFwLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxuICogICAgbWFwcGVkLlxuICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXG4gKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcbiAqICAgIHdvbid0IGJlLlxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DYW1lbFRvSHVuZ2FyaWFuICggc3JjLCB1c2VyLCBmb3JjZSApXG57XG5cdGlmICggISBzcmMuX2h1bmdhcmlhbk1hcCApIHtcblx0XHRfZm5IdW5nYXJpYW5NYXAoIHNyYyApO1xuXHR9XG5cblx0dmFyIGh1bmdhcmlhbktleTtcblxuXHQkLmVhY2goIHVzZXIsIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRodW5nYXJpYW5LZXkgPSBzcmMuX2h1bmdhcmlhbk1hcFsga2V5IF07XG5cblx0XHRpZiAoIGh1bmdhcmlhbktleSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCB1c2VyW2h1bmdhcmlhbktleV0gPT09IHVuZGVmaW5lZCkgKVxuXHRcdHtcblx0XHRcdC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXG5cdFx0XHRpZiAoIGh1bmdhcmlhbktleS5jaGFyQXQoMCkgPT09ICdvJyApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIENvcHkgdGhlIGNhbWVsQ2FzZSBvcHRpb25zIG92ZXIgdG8gdGhlIGh1bmdhcmlhblxuXHRcdFx0XHRpZiAoICEgdXNlclsgaHVuZ2FyaWFuS2V5IF0gKSB7XG5cdFx0XHRcdFx0dXNlclsgaHVuZ2FyaWFuS2V5IF0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgdXNlcltodW5nYXJpYW5LZXldLCB1c2VyW2tleV0gKTtcblxuXHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBzcmNbaHVuZ2FyaWFuS2V5XSwgdXNlcltodW5nYXJpYW5LZXldLCBmb3JjZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHVzZXJbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG4vKipcbiAqIE1hcCBvbmUgcGFyYW1ldGVyIG9udG8gYW5vdGhlclxuICogIEBwYXJhbSB7b2JqZWN0fSBvIE9iamVjdCB0byBtYXBcbiAqICBAcGFyYW0geyp9IGtuZXcgVGhlIG5ldyBwYXJhbWV0ZXIgbmFtZVxuICogIEBwYXJhbSB7Kn0gb2xkIFRoZSBvbGQgcGFyYW1ldGVyIG5hbWVcbiAqL1xudmFyIF9mbkNvbXBhdE1hcCA9IGZ1bmN0aW9uICggbywga25ldywgb2xkICkge1xuXHRpZiAoIG9bIGtuZXcgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdG9bIG9sZCBdID0gb1sga25ldyBdO1xuXHR9XG59O1xuXG5cbi8qKlxuICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIG1haW4gRFQgb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXdcbiAqIG9wdGlvbnMgYXJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgcGFyYW1ldGVycywgc28gdGhpcyBpcyBhbiBleHRlcm5hbCBpbnRlcmZhY2VcbiAqIGNoYW5nZSBvbmx5LlxuICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcbiAqL1xuZnVuY3Rpb24gX2ZuQ29tcGF0T3B0cyAoIGluaXQgKVxue1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcmluZycsICAgICAgJ2JTb3J0JyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlck11bHRpJywgICAgJ2JTb3J0TXVsdGknICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2xhc3NlcycsICAnYlNvcnRDbGFzc2VzJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckNlbGxzVG9wJywgJ2JTb3J0Q2VsbHNUb3AnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyJywgICAgICAgICAnYWFTb3J0aW5nJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckZpeGVkJywgICAgJ2FhU29ydGluZ0ZpeGVkJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdwYWdpbmcnLCAgICAgICAgJ2JQYWdpbmF0ZScgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nVHlwZScsICAgICdzUGFnaW5hdGlvblR5cGUnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2VMZW5ndGgnLCAgICAnaURpc3BsYXlMZW5ndGgnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3NlYXJjaGluZycsICAgICAnYkZpbHRlcicgKTtcblxuXHQvLyBCb29sZWFuIGluaXRpYWxpc2F0aW9uIG9mIHgtc2Nyb2xsaW5nXG5cdGlmICggdHlwZW9mIGluaXQuc1Njcm9sbFggPT09ICdib29sZWFuJyApIHtcblx0XHRpbml0LnNTY3JvbGxYID0gaW5pdC5zU2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHR9XG5cdGlmICggdHlwZW9mIGluaXQuc2Nyb2xsWCA9PT0gJ2Jvb2xlYW4nICkge1xuXHRcdGluaXQuc2Nyb2xsWCA9IGluaXQuc2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHR9XG5cblx0Ly8gQ29sdW1uIHNlYXJjaCBvYmplY3RzIGFyZSBpbiBhbiBhcnJheSwgc28gaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG5cdC8vIGVsZW1lbnQgYnkgZWxlbWVudFxuXHR2YXIgc2VhcmNoQ29scyA9IGluaXQuYW9TZWFyY2hDb2xzO1xuXG5cdGlmICggc2VhcmNoQ29scyApIHtcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c2VhcmNoQ29scy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggc2VhcmNoQ29sc1tpXSApIHtcblx0XHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gRW5hYmxlIHNlYXJjaCBkZWxheSBpZiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGlzIGVuYWJsZWRcblx0aWYgKGluaXQuc2VydmVyU2lkZSAmJiAhIGluaXQuc2VhcmNoRGVsYXkpIHtcblx0XHRpbml0LnNlYXJjaERlbGF5ID0gNDAwO1xuXHR9XG59XG5cblxuLyoqXG4gKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBjb2x1bW4gb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXcgb3B0aW9uc1xuICogYXJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgcGFyYW1ldGVycywgc28gdGhpcyBpcyBhbiBleHRlcm5hbCBpbnRlcmZhY2UgY2hhbmdlXG4gKiBvbmx5LlxuICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcbiAqL1xuZnVuY3Rpb24gX2ZuQ29tcGF0Q29scyAoIGluaXQgKVxue1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcmFibGUnLCAgICAgJ2JTb3J0YWJsZScgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJEYXRhJywgICAgICdhRGF0YVNvcnQnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyU2VxdWVuY2UnLCAnYXNTb3J0aW5nJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckRhdGFUeXBlJywgJ3NvcnREYXRhVHlwZScgKTtcblxuXHQvLyBvcmRlckRhdGEgY2FuIGJlIGdpdmVuIGFzIGFuIGludGVnZXJcblx0dmFyIGRhdGFTb3J0ID0gaW5pdC5hRGF0YVNvcnQ7XG5cdGlmICggdHlwZW9mIGRhdGFTb3J0ID09PSAnbnVtYmVyJyAmJiAhIEFycmF5LmlzQXJyYXkoIGRhdGFTb3J0ICkgKSB7XG5cdFx0aW5pdC5hRGF0YVNvcnQgPSBbIGRhdGFTb3J0IF07XG5cdH1cbn1cblxuXG4vKipcbiAqIEJyb3dzZXIgZmVhdHVyZSBkZXRlY3Rpb24gZm9yIGNhcGFiaWxpdGllcywgcXVpcmtzXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkJyb3dzZXJEZXRlY3QoIHNldHRpbmdzIClcbntcblx0Ly8gV2UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzIGV2ZXJ5IHRpbWUgRGF0YVRhYmxlcyBpcyBjb25zdHJ1Y3RlZCwgdGhlIHZhbHVlc1xuXHQvLyBjYWxjdWxhdGVkIGFyZSBzcGVjaWZpYyB0byB0aGUgYnJvd3NlciBhbmQgT1MgY29uZmlndXJhdGlvbiB3aGljaCB3ZVxuXHQvLyBkb24ndCBleHBlY3QgdG8gY2hhbmdlIGJldHdlZW4gaW5pdGlhbGlzYXRpb25zXG5cdGlmICggISBEYXRhVGFibGUuX19icm93c2VyICkge1xuXHRcdHZhciBicm93c2VyID0ge307XG5cdFx0RGF0YVRhYmxlLl9fYnJvd3NlciA9IGJyb3dzZXI7XG5cblx0XHQvLyBTY3JvbGxpbmcgZmVhdHVyZSAvIHF1aXJrcyBkZXRlY3Rpb25cblx0XHR2YXIgbiA9ICQoJzxkaXYvPicpXG5cdFx0XHQuY3NzKCB7XG5cdFx0XHRcdHBvc2l0aW9uOiAnZml4ZWQnLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IC0xICogd2luZG93LnBhZ2VYT2Zmc2V0LCAvLyBhbGxvdyBmb3Igc2Nyb2xsaW5nXG5cdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAxLFxuXHRcdFx0XHRcdFx0bGVmdDogMSxcblx0XHRcdFx0XHRcdHdpZHRoOiAxMDAsXG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ3Njcm9sbCdcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAxMFxuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHQuYXBwZW5kVG8oICdib2R5JyApO1xuXG5cdFx0dmFyIG91dGVyID0gbi5jaGlsZHJlbigpO1xuXHRcdHZhciBpbm5lciA9IG91dGVyLmNoaWxkcmVuKCk7XG5cblx0XHQvLyBHZXQgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0YnJvd3Nlci5iYXJXaWR0aCA9IG91dGVyWzBdLm9mZnNldFdpZHRoIC0gb3V0ZXJbMF0uY2xpZW50V2lkdGg7XG5cblx0XHQvLyBJbiBydGwgdGV4dCBsYXlvdXQsIHNvbWUgYnJvd3NlcnMgKG1vc3QsIGJ1dCBub3QgYWxsKSB3aWxsIHBsYWNlIHRoZVxuXHRcdC8vIHNjcm9sbGJhciBvbiB0aGUgbGVmdCwgcmF0aGVyIHRoYW4gdGhlIHJpZ2h0LlxuXHRcdGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPSBNYXRoLnJvdW5kKCBpbm5lci5vZmZzZXQoKS5sZWZ0ICkgIT09IDE7XG5cblx0XHRuLnJlbW92ZSgpO1xuXHR9XG5cblx0JC5leHRlbmQoIHNldHRpbmdzLm9Ccm93c2VyLCBEYXRhVGFibGUuX19icm93c2VyICk7XG5cdHNldHRpbmdzLm9TY3JvbGwuaUJhcldpZHRoID0gRGF0YVRhYmxlLl9fYnJvd3Nlci5iYXJXaWR0aDtcbn1cblxuLyoqXG4gKiBBZGQgYSBjb2x1bW4gdG8gdGhlIGxpc3QgdXNlZCBmb3IgdGhlIHRhYmxlIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFkZENvbHVtbiggb1NldHRpbmdzIClcbntcblx0Ly8gQWRkIGNvbHVtbiB0byBhb0NvbHVtbnMgYXJyYXlcblx0dmFyIG9EZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW47XG5cdHZhciBpQ29sID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG5cdHZhciBvQ29sID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4sIG9EZWZhdWx0cywge1xuXHRcdFwiYURhdGFTb3J0XCI6IG9EZWZhdWx0cy5hRGF0YVNvcnQgPyBvRGVmYXVsdHMuYURhdGFTb3J0IDogW2lDb2xdLFxuXHRcdFwibURhdGFcIjogb0RlZmF1bHRzLm1EYXRhID8gb0RlZmF1bHRzLm1EYXRhIDogaUNvbCxcblx0XHRpZHg6IGlDb2wsXG5cdFx0c2VhcmNoRml4ZWQ6IHt9LFxuXHRcdGNvbEVsOiAkKCc8Y29sPicpLmF0dHIoJ2RhdGEtZHQtY29sdW1uJywgaUNvbClcblx0fSApO1xuXHRvU2V0dGluZ3MuYW9Db2x1bW5zLnB1c2goIG9Db2wgKTtcblxuXHQvLyBBZGQgc2VhcmNoIG9iamVjdCBmb3IgY29sdW1uIHNwZWNpZmljIHNlYXJjaC4gTm90ZSB0aGF0IHRoZSBgc2VhcmNoQ29sc1sgaUNvbCBdYFxuXHQvLyBwYXNzZWQgaW50byBleHRlbmQgY2FuIGJlIHVuZGVmaW5lZC4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZ2l2ZSBhIGRlZmF1bHRcblx0Ly8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XG5cdHZhciBzZWFyY2hDb2xzID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0c2VhcmNoQ29sc1sgaUNvbCBdID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbIGlDb2wgXSApO1xufVxuXG5cbi8qKlxuICogQXBwbHkgb3B0aW9ucyBmb3IgYSBjb2x1bW5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9PcHRpb25zIG9iamVjdCB3aXRoIHNUeXBlLCBiVmlzaWJsZSBhbmQgYlNlYXJjaGFibGUgZXRjXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgb09wdGlvbnMgKVxue1xuXHR2YXIgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGlDb2wgXTtcblxuXHQvKiBVc2VyIHNwZWNpZmllZCBjb2x1bW4gb3B0aW9ucyAqL1xuXHRpZiAoIG9PcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb09wdGlvbnMgIT09IG51bGwgKVxuXHR7XG5cdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRfZm5Db21wYXRDb2xzKCBvT3B0aW9ucyApO1xuXG5cdFx0Ly8gTWFwIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzXG5cdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiwgb09wdGlvbnMsIHRydWUgKTtcblxuXHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtRGF0YVByb3AgKi9cblx0XHRpZiAoIG9PcHRpb25zLm1EYXRhUHJvcCAhPT0gdW5kZWZpbmVkICYmICFvT3B0aW9ucy5tRGF0YSApXG5cdFx0e1xuXHRcdFx0b09wdGlvbnMubURhdGEgPSBvT3B0aW9ucy5tRGF0YVByb3A7XG5cdFx0fVxuXG5cdFx0aWYgKCBvT3B0aW9ucy5zVHlwZSApXG5cdFx0e1xuXHRcdFx0b0NvbC5fc01hbnVhbFR5cGUgPSBvT3B0aW9ucy5zVHlwZTtcblx0XHR9XG5cdFxuXHRcdC8vIGBjbGFzc2AgaXMgYSByZXNlcnZlZCB3b3JkIGluIEphdmFzY3JpcHQsIHNvIHdlIG5lZWQgdG8gcHJvdmlkZVxuXHRcdC8vIHRoZSBhYmlsaXR5IHRvIHVzZSBhIHZhbGlkIG5hbWUgZm9yIHRoZSBjYW1lbCBjYXNlIGlucHV0XG5cdFx0aWYgKCBvT3B0aW9ucy5jbGFzc05hbWUgJiYgISBvT3B0aW9ucy5zQ2xhc3MgKVxuXHRcdHtcblx0XHRcdG9PcHRpb25zLnNDbGFzcyA9IG9PcHRpb25zLmNsYXNzTmFtZTtcblx0XHR9XG5cblx0XHR2YXIgb3JpZ0NsYXNzID0gb0NvbC5zQ2xhc3M7XG5cblx0XHQkLmV4dGVuZCggb0NvbCwgb09wdGlvbnMgKTtcblx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcInNXaWR0aFwiLCBcInNXaWR0aE9yaWdcIiApO1xuXG5cdFx0Ly8gTWVyZ2UgY2xhc3MgZnJvbSBwcmV2aW91c2x5IGRlZmluZWQgY2xhc3NlcyB3aXRoIHRoaXMgb25lLCByYXRoZXIgdGhhbiBqdXN0XG5cdFx0Ly8gb3ZlcndyaXRpbmcgaXQgaW4gdGhlIGV4dGVuZCBhYm92ZVxuXHRcdGlmIChvcmlnQ2xhc3MgIT09IG9Db2wuc0NsYXNzKSB7XG5cdFx0XHRvQ29sLnNDbGFzcyA9IG9yaWdDbGFzcyArICcgJyArIG9Db2wuc0NsYXNzO1xuXHRcdH1cblxuXHRcdC8qIGlEYXRhU29ydCB0byBiZSBhcHBsaWVkIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSksIGJ1dCBhRGF0YVNvcnQgd2lsbCB0YWtlXG5cdFx0ICogcHJpb3JpdHkgaWYgZGVmaW5lZFxuXHRcdCAqL1xuXHRcdGlmICggb09wdGlvbnMuaURhdGFTb3J0ICE9PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdG9Db2wuYURhdGFTb3J0ID0gWyBvT3B0aW9ucy5pRGF0YVNvcnQgXTtcblx0XHR9XG5cdFx0X2ZuTWFwKCBvQ29sLCBvT3B0aW9ucywgXCJhRGF0YVNvcnRcIiApO1xuXHR9XG5cblx0LyogQ2FjaGUgdGhlIGRhdGEgZ2V0IGFuZCBzZXQgZnVuY3Rpb25zIGZvciBzcGVlZCAqL1xuXHR2YXIgbURhdGFTcmMgPSBvQ29sLm1EYXRhO1xuXHR2YXIgbURhdGEgPSBfZm5HZXRPYmplY3REYXRhRm4oIG1EYXRhU3JjICk7XG5cblx0Ly8gVGhlIGByZW5kZXJgIG9wdGlvbiBjYW4gYmUgZ2l2ZW4gYXMgYW4gYXJyYXkgdG8gYWNjZXNzIHRoZSBoZWxwZXIgcmVuZGVyaW5nIG1ldGhvZHMuXG5cdC8vIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSByZW5kZXJpbmcgbWV0aG9kIHRvIHVzZSwgdGhlIHJlc3QgYXJlIHRoZSBwYXJhbWV0ZXJzIHRvIHBhc3Ncblx0aWYgKCBvQ29sLm1SZW5kZXIgJiYgQXJyYXkuaXNBcnJheSggb0NvbC5tUmVuZGVyICkgKSB7XG5cdFx0dmFyIGNvcHkgPSBvQ29sLm1SZW5kZXIuc2xpY2UoKTtcblx0XHR2YXIgbmFtZSA9IGNvcHkuc2hpZnQoKTtcblxuXHRcdG9Db2wubVJlbmRlciA9IERhdGFUYWJsZS5yZW5kZXJbbmFtZV0uYXBwbHkod2luZG93LCBjb3B5KTtcblx0fVxuXG5cdG9Db2wuX3JlbmRlciA9IG9Db2wubVJlbmRlciA/IF9mbkdldE9iamVjdERhdGFGbiggb0NvbC5tUmVuZGVyICkgOiBudWxsO1xuXG5cdHZhciBhdHRyVGVzdCA9IGZ1bmN0aW9uKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyYy5pbmRleE9mKCdAJykgIT09IC0xO1xuXHR9O1xuXHRvQ29sLl9iQXR0clNyYyA9ICQuaXNQbGFpbk9iamVjdCggbURhdGFTcmMgKSAmJiAoXG5cdFx0YXR0clRlc3QobURhdGFTcmMuc29ydCkgfHwgYXR0clRlc3QobURhdGFTcmMudHlwZSkgfHwgYXR0clRlc3QobURhdGFTcmMuZmlsdGVyKVxuXHQpO1xuXHRvQ29sLl9zZXR0ZXIgPSBudWxsO1xuXG5cdG9Db2wuZm5HZXREYXRhID0gZnVuY3Rpb24gKHJvd0RhdGEsIHR5cGUsIG1ldGEpIHtcblx0XHR2YXIgaW5uZXJEYXRhID0gbURhdGEoIHJvd0RhdGEsIHR5cGUsIHVuZGVmaW5lZCwgbWV0YSApO1xuXG5cdFx0cmV0dXJuIG9Db2wuX3JlbmRlciAmJiB0eXBlID9cblx0XHRcdG9Db2wuX3JlbmRlciggaW5uZXJEYXRhLCB0eXBlLCByb3dEYXRhLCBtZXRhICkgOlxuXHRcdFx0aW5uZXJEYXRhO1xuXHR9O1xuXHRvQ29sLmZuU2V0RGF0YSA9IGZ1bmN0aW9uICggcm93RGF0YSwgdmFsLCBtZXRhICkge1xuXHRcdHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4oIG1EYXRhU3JjICkoIHJvd0RhdGEsIHZhbCwgbWV0YSApO1xuXHR9O1xuXG5cdC8vIEluZGljYXRlIGlmIERhdGFUYWJsZXMgc2hvdWxkIHJlYWQgRE9NIGRhdGEgYXMgYW4gb2JqZWN0IG9yIGFycmF5XG5cdC8vIFVzZWQgaW4gX2ZuR2V0Um93RWxlbWVudHNcblx0aWYgKCB0eXBlb2YgbURhdGFTcmMgIT09ICdudW1iZXInICYmICEgb0NvbC5faXNBcnJheUhvc3QgKSB7XG5cdFx0b1NldHRpbmdzLl9yb3dSZWFkT2JqZWN0ID0gdHJ1ZTtcblx0fVxuXG5cdC8qIEZlYXR1cmUgc29ydGluZyBvdmVycmlkZXMgY29sdW1uIHNwZWNpZmljIHdoZW4gb2ZmICovXG5cdGlmICggIW9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQgKVxuXHR7XG5cdFx0b0NvbC5iU29ydGFibGUgPSBmYWxzZTtcblx0fVxufVxuXG5cbi8qKlxuICogQWRqdXN0IHRoZSB0YWJsZSBjb2x1bW4gd2lkdGhzIGZvciBuZXcgZGF0YS4gTm90ZTogeW91IHdvdWxkIHByb2JhYmx5IHdhbnQgdG9cbiAqIGRvIGEgcmVkcmF3IGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiFcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRqdXN0Q29sdW1uU2l6aW5nICggc2V0dGluZ3MgKVxue1xuXHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoIHNldHRpbmdzICk7XG5cdF9mbkNvbHVtblNpemVzKCBzZXR0aW5ncyApO1xuXG5cdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRpZiAoIHNjcm9sbC5zWSAhPT0gJycgfHwgc2Nyb2xsLnNYICE9PSAnJykge1xuXHRcdF9mblNjcm9sbERyYXcoIHNldHRpbmdzICk7XG5cdH1cblxuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXNpemluZycsIFtzZXR0aW5nc10gKTtcbn1cblxuLyoqXG4gKiBBcHBseSBjb2x1bW4gc2l6ZXNcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9mbkNvbHVtblNpemVzICggc2V0dGluZ3MgKVxue1xuXHR2YXIgY29scyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblxuXHRmb3IgKHZhciBpPTAgOyBpPGNvbHMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0dmFyIHdpZHRoID0gX2ZuQ29sdW1uc1N1bVdpZHRoKHNldHRpbmdzLCBbaV0sIGZhbHNlLCBmYWxzZSk7XG5cblx0XHRjb2xzW2ldLmNvbEVsLmNzcygnd2lkdGgnLCB3aWR0aCk7XG5cblx0XHRpZiAoc2V0dGluZ3Mub1Njcm9sbC5zWCkge1xuXHRcdFx0Y29sc1tpXS5jb2xFbC5jc3MoJ21pbi13aWR0aCcsIHdpZHRoKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGluZGV4IG9mIGEgdmlzaWJsZSBjb2x1bW4gdG8gdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5ICh0YWtlIGFjY291bnRcbiAqIG9mIGhpZGRlbiBjb2x1bW5zKVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2ludH0gaU1hdGNoIFZpc2libGUgY29sdW1uIGluZGV4IHRvIGxvb2t1cFxuICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaU1hdGNoIClcbntcblx0dmFyIGFpVmlzID0gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCAnYlZpc2libGUnICk7XG5cblx0cmV0dXJuIHR5cGVvZiBhaVZpc1tpTWF0Y2hdID09PSAnbnVtYmVyJyA/XG5cdFx0YWlWaXNbaU1hdGNoXSA6XG5cdFx0bnVsbDtcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGluZGV4IG9mIGFuIGluZGV4IGluIHRoZSBkYXRhIGFycmF5IGFuZCBjb252ZXJ0IGl0IHRvIHRoZSB2aXNpYmxlXG4gKiAgIGNvbHVtbiBpbmRleCAodGFrZSBhY2NvdW50IG9mIGhpZGRlbiBjb2x1bW5zKVxuICogIEBwYXJhbSB7aW50fSBpTWF0Y2ggQ29sdW1uIGluZGV4IHRvIGxvb2t1cFxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBvU2V0dGluZ3MsIGlNYXRjaCApXG57XG5cdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXHR2YXIgaVBvcyA9IGFpVmlzLmluZGV4T2YoaU1hdGNoKTtcblxuXHRyZXR1cm4gaVBvcyAhPT0gLTEgPyBpUG9zIDogbnVsbDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBudW1iZXIgb2YgdmlzaWJsZSBjb2x1bW5zXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblZpc2JsZUNvbHVtbnMoIHNldHRpbmdzIClcbntcblx0dmFyIGxheW91dCA9IHNldHRpbmdzLmFvSGVhZGVyO1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIHZpcyA9IDA7XG5cblx0aWYgKCBsYXlvdXQubGVuZ3RoICkge1xuXHRcdGZvciAoIHZhciBpPTAsIGllbj1sYXlvdXRbMF0ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGNvbHVtbnNbaV0uYlZpc2libGUgJiYgJChsYXlvdXRbMF1baV0uY2VsbCkuY3NzKCdkaXNwbGF5JykgIT09ICdub25lJyApIHtcblx0XHRcdFx0dmlzKys7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZpcztcbn1cblxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyB0aGF0IG1hdGNoIGEgZ2l2ZW4gcHJvcGVydHlcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtzdHJpbmd9IHNQYXJhbSBQYXJhbWV0ZXIgaW4gYW9Db2x1bW5zIHRvIGxvb2sgZm9yIC0gdHlwaWNhbGx5XG4gKiAgICBiVmlzaWJsZSBvciBiU2VhcmNoYWJsZVxuICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyB3aXRoIG1hdGNoZWQgcHJvcGVydGllc1xuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsIHNQYXJhbSApXG57XG5cdHZhciBhID0gW107XG5cblx0b1NldHRpbmdzLmFvQ29sdW1ucy5tYXAoIGZ1bmN0aW9uKHZhbCwgaSkge1xuXHRcdGlmICggdmFsW3NQYXJhbV0gKSB7XG5cdFx0XHRhLnB1c2goIGkgKTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBBbGxvdyB0aGUgcmVzdWx0IGZyb20gYSB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbiB0byBiZSBgdHJ1ZWAgd2hpbGVcbiAqIHRyYW5zbGF0aW5nIHRoYXQgaW50byBhIHN0cmluZy4gT2xkIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucyB3aWxsXG4gKiByZXR1cm4gdGhlIHR5cGUgbmFtZSBpZiBpdCBwYXNzZXMuIEFuIG9iZWN0IHN0b3JlIHdvdWxkIGJlIGJldHRlcixcbiAqIGJ1dCBub3QgYmFja3dhcmRzIGNvbXBhdGlibGUuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlRGV0ZWN0IE9iamVjdCBvciBmdW5jdGlvbiBmb3IgdHlwZSBkZXRlY3Rpb25cbiAqIEBwYXJhbSB7Kn0gcmVzIFJlc3VsdCBmcm9tIHRoZSB0eXBlIGRldGVjdGlvbiBmdW5jdGlvblxuICogQHJldHVybnMgVHlwZSBuYW1lIG9yIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIF90eXBlUmVzdWx0ICh0eXBlRGV0ZWN0LCByZXMpIHtcblx0cmV0dXJuIHJlcyA9PT0gdHJ1ZVxuXHRcdD8gdHlwZURldGVjdC5fbmFtZVxuXHRcdDogcmVzO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgJ3R5cGUnIG9mIGEgY29sdW1uXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbHVtblR5cGVzICggc2V0dGluZ3MgKVxue1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdHZhciB0eXBlcyA9IERhdGFUYWJsZS5leHQudHlwZS5kZXRlY3Q7XG5cdHZhciBpLCBpZW4sIGosIGplbiwgaywga2VuO1xuXHR2YXIgY29sLCBkZXRlY3RlZFR5cGUsIGNhY2hlO1xuXG5cdC8vIEZvciBlYWNoIGNvbHVtbiwgc3BpbiBvdmVyIHRoZSBkYXRhIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucywgc2VlaW5nIGlmIG9uZSBtYXRjaGVzXG5cdGZvciAoIGk9MCwgaWVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0Y29sID0gY29sdW1uc1tpXTtcblx0XHRjYWNoZSA9IFtdO1xuXG5cdFx0aWYgKCAhIGNvbC5zVHlwZSAmJiBjb2wuX3NNYW51YWxUeXBlICkge1xuXHRcdFx0Y29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0Ly8gV2l0aCBTU1AgdHlwZSBkZXRlY3Rpb24gY2FuIGJlIHVucmVsaWFibGUgYW5kIGVycm9yIHByb25lLCBzbyB3ZSBwcm92aWRlIGEgd2F5XG5cdFx0XHQvLyB0byB0dXJuIGl0IG9mZi5cblx0XHRcdGlmICghIHNldHRpbmdzLnR5cGVEZXRlY3QpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBqPTAsIGplbj10eXBlcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0dmFyIHR5cGVEZXRlY3QgPSB0eXBlc1tqXTtcblxuXHRcdFx0XHQvLyBUaGVyZSBjYW4gYmUgZWl0aGVyIG9uZSwgb3IgdGhyZWUgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zXG5cdFx0XHRcdHZhciBvbmVPZiA9IHR5cGVEZXRlY3Qub25lT2Y7XG5cdFx0XHRcdHZhciBhbGxPZiA9IHR5cGVEZXRlY3QuYWxsT2YgfHwgdHlwZURldGVjdDtcblx0XHRcdFx0dmFyIGluaXQgPSB0eXBlRGV0ZWN0LmluaXQ7XG5cdFx0XHRcdHZhciBvbmUgPSBmYWxzZTtcblxuXHRcdFx0XHRkZXRlY3RlZFR5cGUgPSBudWxsO1xuXG5cdFx0XHRcdC8vIEZhc3QgZGV0ZWN0IGJhc2VkIG9uIGNvbHVtbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmIChpbml0KSB7XG5cdFx0XHRcdFx0ZGV0ZWN0ZWRUeXBlID0gX3R5cGVSZXN1bHQodHlwZURldGVjdCwgaW5pdChzZXR0aW5ncywgY29sLCBpKSk7XG5cblx0XHRcdFx0XHRpZiAoZGV0ZWN0ZWRUeXBlKSB7XG5cdFx0XHRcdFx0XHRjb2wuc1R5cGUgPSBkZXRlY3RlZFR5cGU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBrPTAsIGtlbj1kYXRhLmxlbmd0aCA7IGs8a2VuIDsgaysrICkge1xuXHRcdFx0XHRcdGlmICghIGRhdGFba10pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFVzZSBhIGNhY2hlIGFycmF5IHNvIHdlIG9ubHkgbmVlZCB0byBnZXQgdGhlIHR5cGUgZGF0YVxuXHRcdFx0XHRcdC8vIGZyb20gdGhlIGZvcm1hdHRlciBvbmNlICh3aGVuIHVzaW5nIG11bHRpcGxlIGRldGVjdG9ycylcblx0XHRcdFx0XHRpZiAoIGNhY2hlW2tdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRjYWNoZVtrXSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaywgaSwgJ3R5cGUnICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBvbmUgZGF0YSBwb2ludCBpbiB0aGUgY29sdW1uIG5lZWRzIHRvIG1hdGNoIHRoaXMgZnVuY3Rpb25cblx0XHRcdFx0XHRpZiAob25lT2YgJiYgISBvbmUpIHtcblx0XHRcdFx0XHRcdG9uZSA9IF90eXBlUmVzdWx0KHR5cGVEZXRlY3QsIG9uZU9mKCBjYWNoZVtrXSwgc2V0dGluZ3MgKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWxsIGRhdGEgcG9pbnRzIG5lZWQgdG8gbWF0Y2ggdGhpcyBmdW5jdGlvblxuXHRcdFx0XHRcdGRldGVjdGVkVHlwZSA9IF90eXBlUmVzdWx0KHR5cGVEZXRlY3QsIGFsbE9mKCBjYWNoZVtrXSwgc2V0dGluZ3MgKSk7XG5cblx0XHRcdFx0XHQvLyBJZiBudWxsLCB0aGVuIHRoaXMgdHlwZSBjYW4ndCBhcHBseSB0byB0aGlzIGNvbHVtbiwgc29cblx0XHRcdFx0XHQvLyByYXRoZXIgdGhhbiB0ZXN0aW5nIGFsbCBjZWxscywgYnJlYWsgb3V0LiBUaGVyZSBpcyBhblxuXHRcdFx0XHRcdC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cblx0XHRcdFx0XHQvLyBzY2FuIGFsbCByb3dzIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIG1peCBzdHJpbmcgYW5kIEhUTUxcblx0XHRcdFx0XHQvLyB0eXBlc1xuXHRcdFx0XHRcdGlmICggISBkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoLTMgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGEgc2luZ2xlIG1hdGNoIGlzIG5lZWRlZCBmb3IgaHRtbCB0eXBlIHNpbmNlIGl0IGlzXG5cdFx0XHRcdFx0Ly8gYm90dG9tIG9mIHRoZSBwaWxlIGFuZCB2ZXJ5IHNpbWlsYXIgdG8gc3RyaW5nIC0gYnV0IGl0XG5cdFx0XHRcdFx0Ly8gbXVzdCBub3QgYmUgZW1wdHlcblx0XHRcdFx0XHRpZiAoIGRldGVjdGVkVHlwZSA9PT0gJ2h0bWwnICYmICEgX2VtcHR5KGNhY2hlW2tdKSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgaXMgdmFsaWQgZm9yIGFsbCBkYXRhIHBvaW50cyBpbiB0aGUgY29sdW1uIC0gdXNlIHRoaXNcblx0XHRcdFx0Ly8gdHlwZVxuXHRcdFx0XHRpZiAoIChvbmVPZiAmJiBvbmUgJiYgZGV0ZWN0ZWRUeXBlKSB8fCAoIW9uZU9mICYmIGRldGVjdGVkVHlwZSkgKSB7XG5cdFx0XHRcdFx0Y29sLnNUeXBlID0gZGV0ZWN0ZWRUeXBlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGwgYmFjayAtIGlmIG5vIHR5cGUgd2FzIGRldGVjdGVkLCBhbHdheXMgdXNlIHN0cmluZ1xuXHRcdFx0aWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0Y29sLnNUeXBlID0gJ3N0cmluZyc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGNsYXNzIG5hbWVzIGZvciBoZWFkZXIgLyBmb290ZXIgZm9yIGF1dG8gdHlwZSBjbGFzc2VzXG5cdFx0dmFyIGF1dG9DbGFzcyA9IF9leHQudHlwZS5jbGFzc05hbWVbY29sLnNUeXBlXTtcblxuXHRcdGlmIChhdXRvQ2xhc3MpIHtcblx0XHRcdF9jb2x1bW5BdXRvQ2xhc3Moc2V0dGluZ3MuYW9IZWFkZXIsIGksIGF1dG9DbGFzcyk7XG5cdFx0XHRfY29sdW1uQXV0b0NsYXNzKHNldHRpbmdzLmFvRm9vdGVyLCBpLCBhdXRvQ2xhc3MpO1xuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlciA9IF9leHQudHlwZS5yZW5kZXJbY29sLnNUeXBlXTtcblxuXHRcdC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIG9uY2UhIFRoZXJlIGlzIG5vIHdheSB0byByZW1vdmVcblx0XHQvLyBhIHJlbmRlcmVyLiBBZnRlciB0aGUgZmlyc3QgdGltZSB0aGUgcmVuZGVyZXIgaGFzXG5cdFx0Ly8gYWxyZWFkeSBiZWVuIHNldCBzbyBjcmVhdGVUciB3aWxsIHJ1biB0aGUgcmVuZGVyZXIgaXRzZWxmLlxuXHRcdGlmIChyZW5kZXJlciAmJiAhIGNvbC5fcmVuZGVyKSB7XG5cdFx0XHRjb2wuX3JlbmRlciA9IERhdGFUYWJsZS51dGlsLmdldChyZW5kZXJlcik7XG5cblx0XHRcdF9jb2x1bW5BdXRvUmVuZGVyKHNldHRpbmdzLCBpKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBcHBseSBhbiBhdXRvIGRldGVjdGVkIHJlbmRlcmVyIHRvIGRhdGEgd2hpY2ggZG9lc24ndCB5ZXQgaGF2ZVxuICogYSByZW5kZXJlclxuICovXG5mdW5jdGlvbiBfY29sdW1uQXV0b1JlbmRlcihzZXR0aW5ncywgY29sSWR4KSB7XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXG5cdGZvciAodmFyIGk9MCA7IGk8ZGF0YS5sZW5ndGggOyBpKyspIHtcblx0XHRpZiAoZGF0YVtpXS5uVHIpIHtcblx0XHRcdC8vIFdlIGhhdmUgdG8gdXBkYXRlIHRoZSBkaXNwbGF5IGhlcmUgc2luY2UgdGhlcmUgaXMgbm9cblx0XHRcdC8vIGludmFsaWRhdGlvbiBjaGVjayBmb3IgdGhlIGRhdGFcblx0XHRcdHZhciBkaXNwbGF5ID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApO1xuXG5cdFx0XHRkYXRhW2ldLmRpc3BsYXlEYXRhW2NvbElkeF0gPSBkaXNwbGF5O1xuXHRcdFx0X2ZuV3JpdGVDZWxsKGRhdGFbaV0uYW5DZWxsc1tjb2xJZHhdLCBkaXNwbGF5KTtcblxuXHRcdFx0Ly8gTm8gbmVlZCB0byB1cGRhdGUgc29ydCAvIGZpbHRlciBkYXRhIHNpbmNlIGl0IGhhc1xuXHRcdFx0Ly8gYmVlbiBpbnZhbGlkYXRlZCBhbmQgd2lsbCBiZSByZS1yZWFkIHdpdGggdGhlXG5cdFx0XHQvLyByZW5kZXJlciBub3cgYXBwbGllZFxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEFwcGx5IGEgY2xhc3MgbmFtZSB0byBhIGNvbHVtbidzIGhlYWRlciBjZWxsc1xuICovXG5mdW5jdGlvbiBfY29sdW1uQXV0b0NsYXNzKGNvbnRhaW5lciwgY29sSWR4LCBjbGFzc05hbWUpIHtcblx0Y29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuXHRcdGlmIChyb3dbY29sSWR4XSAmJiByb3dbY29sSWR4XS51bmlxdWUpIHtcblx0XHRcdF9hZGRDbGFzcyhyb3dbY29sSWR4XS5jZWxsLCBjbGFzc05hbWUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogVGFrZSB0aGUgY29sdW1uIGRlZmluaXRpb25zIGFuZCBzdGF0aWMgY29sdW1ucyBhcnJheXMgYW5kIGNhbGN1bGF0ZSBob3dcbiAqIHRoZXkgcmVsYXRlIHRvIGNvbHVtbiBpbmRleGVzLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCB0aGVuIGFwcGx5IHRoZVxuICogZGVmaW5pdGlvbiBmb3VuZCBmb3IgYSBjb2x1bW4gdG8gYSBzdWl0YWJsZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHthcnJheX0gYW9Db2xEZWZzIFRoZSBhb0NvbHVtbkRlZnMgYXJyYXkgdGhhdCBpcyB0byBiZSBhcHBsaWVkXG4gKiAgQHBhcmFtIHthcnJheX0gYW9Db2xzIFRoZSBhb0NvbHVtbnMgYXJyYXkgdGhhdCBkZWZpbmVzIGNvbHVtbnMgaW5kaXZpZHVhbGx5XG4gKiAgQHBhcmFtIHthcnJheX0gaGVhZGVyTGF5b3V0IExheW91dCBmb3IgaGVhZGVyIGFzIGl0IHdhcyBsb2FkZWRcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiAtIHRha2VzIHR3byBwYXJhbWV0ZXJzLCB0aGUgY2FsY3VsYXRlZFxuICogICAgY29sdW1uIGluZGV4IGFuZCB0aGUgZGVmaW5pdGlvbiBmb3IgdGhhdCBjb2x1bW4uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFwcGx5Q29sdW1uRGVmcyggb1NldHRpbmdzLCBhb0NvbERlZnMsIGFvQ29scywgaGVhZGVyTGF5b3V0LCBmbiApXG57XG5cdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBkZWY7XG5cdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblxuXHRpZiAoIGFvQ29scyApIHtcblx0XHRmb3IgKCBpPTAsIGlMZW49YW9Db2xzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdGlmIChhb0NvbHNbaV0gJiYgYW9Db2xzW2ldLm5hbWUpIHtcblx0XHRcdFx0Y29sdW1uc1tpXS5zTmFtZSA9IGFvQ29sc1tpXS5uYW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbHVtbiBkZWZpbml0aW9ucyB3aXRoIGFUYXJnZXRzXG5cdGlmICggYW9Db2xEZWZzIClcblx0e1xuXHRcdC8qIExvb3Agb3ZlciB0aGUgZGVmaW5pdGlvbnMgYXJyYXkgLSBsb29wIGluIHJldmVyc2Ugc28gZmlyc3QgaW5zdGFuY2UgaGFzIHByaW9yaXR5ICovXG5cdFx0Zm9yICggaT1hb0NvbERlZnMubGVuZ3RoLTEgOyBpPj0wIDsgaS0tIClcblx0XHR7XG5cdFx0XHRkZWYgPSBhb0NvbERlZnNbaV07XG5cblx0XHRcdC8qIEVhY2ggZGVmaW5pdGlvbiBjYW4gdGFyZ2V0IG11bHRpcGxlIGNvbHVtbnMsIGFzIGl0IGlzIGFuIGFycmF5ICovXG5cdFx0XHR2YXIgYVRhcmdldHMgPSBkZWYudGFyZ2V0ICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBkZWYudGFyZ2V0XG5cdFx0XHRcdDogZGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdD8gZGVmLnRhcmdldHNcblx0XHRcdFx0XHQ6IGRlZi5hVGFyZ2V0cztcblxuXHRcdFx0aWYgKCAhIEFycmF5LmlzQXJyYXkoIGFUYXJnZXRzICkgKVxuXHRcdFx0e1xuXHRcdFx0XHRhVGFyZ2V0cyA9IFsgYVRhcmdldHMgXTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaj0wLCBqTGVuPWFUYXJnZXRzLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBhVGFyZ2V0c1tqXTtcblxuXHRcdFx0XHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInICYmIHRhcmdldCA+PSAwIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8qIEFkZCBjb2x1bW5zIHRoYXQgd2UgZG9uJ3QgeWV0IGtub3cgYWJvdXQgKi9cblx0XHRcdFx0XHR3aGlsZSggY29sdW1ucy5sZW5ndGggPD0gdGFyZ2V0IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEludGVnZXIsIGJhc2ljIGluZGV4ICovXG5cdFx0XHRcdFx0Zm4oIHRhcmdldCwgZGVmICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInICYmIHRhcmdldCA8IDAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogTmVnYXRpdmUgaW50ZWdlciwgcmlnaHQgdG8gbGVmdCBjb2x1bW4gY291bnRpbmcgKi9cblx0XHRcdFx0XHRmbiggY29sdW1ucy5sZW5ndGgrdGFyZ2V0LCBkZWYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yICggaz0wLCBrTGVuPWNvbHVtbnMubGVuZ3RoIDsgazxrTGVuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gJ19hbGwnKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEFwcGx5IHRvIGFsbCBjb2x1bW5zXG5cdFx0XHRcdFx0XHRcdGZuKCBrLCBkZWYgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHRhcmdldC5pbmRleE9mKCc6bmFtZScpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHQvLyBDb2x1bW4gc2VsZWN0b3Jcblx0XHRcdFx0XHRcdFx0aWYgKGNvbHVtbnNba10uc05hbWUgPT09IHRhcmdldC5yZXBsYWNlKCc6bmFtZScsICcnKSkge1xuXHRcdFx0XHRcdFx0XHRcdGZuKCBrLCBkZWYgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIENlbGwgc2VsZWN0b3Jcblx0XHRcdFx0XHRcdFx0aGVhZGVyTGF5b3V0LmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyb3dba10pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjZWxsID0gJChyb3dba10uY2VsbCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIExlZ2FjeSBzdXBwb3J0LiBOb3RlIHRoYXQgaXQgbWVhbnMgdGhhdCB3ZSBkb24ndCBzdXBwb3J0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhbiBlbGVtZW50IG5hbWUgc2VsZWN0b3Igb25seSwgc2luY2UgdGhleSBhcmUgdHJlYXRlZCBhc1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gY2xhc3MgbmFtZXMgZm9yIDEueCBjb21wYXQuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0Lm1hdGNoKC9eW2Etel1bXFx3LV0qJC9pKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSAnLicgKyB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChjZWxsLmlzKCB0YXJnZXQgKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiggaywgZGVmICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTdGF0aWNhbGx5IGRlZmluZWQgY29sdW1ucyBhcnJheVxuXHRpZiAoIGFvQ29scyApIHtcblx0XHRmb3IgKCBpPTAsIGlMZW49YW9Db2xzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdGZuKCBpLCBhb0NvbHNbaV0gKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggZm9yIGEgZ2l2ZW4gc2V0IG9mIGNvbHVtbnNcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0geyp9IHRhcmdldHMgQ29sdW1ucyAtIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb3IgYXJyYXkgb2YgbnVtYmVyc1xuICogQHBhcmFtIHsqfSBvcmlnaW5hbCBVc2UgdGhlIG9yaWdpbmFsIHdpZHRoICh0cnVlKSBvciBjYWxjdWxhdGVkIChmYWxzZSlcbiAqIEBwYXJhbSB7Kn0gaW5jVmlzaWJsZSBJbmNsdWRlIHZpc2libGUgY29sdW1ucyAodHJ1ZSkgb3Igbm90IChmYWxzZSlcbiAqIEByZXR1cm5zIENvbWJpbmVkIENTUyB2YWx1ZVxuICovXG5mdW5jdGlvbiBfZm5Db2x1bW5zU3VtV2lkdGgoIHNldHRpbmdzLCB0YXJnZXRzLCBvcmlnaW5hbCwgaW5jVmlzaWJsZSApIHtcblx0aWYgKCAhIEFycmF5LmlzQXJyYXkoIHRhcmdldHMgKSApIHtcblx0XHR0YXJnZXRzID0gX2ZuQ29sdW1uc0Zyb21IZWFkZXIoIHRhcmdldHMgKTtcblx0fVxuXG5cdHZhciBzdW0gPSAwO1xuXHR2YXIgdW5pdDtcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRmb3IgKCB2YXIgaT0wLCBpZW49dGFyZ2V0cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHR2YXIgY29sdW1uID0gY29sdW1uc1sgdGFyZ2V0c1tpXSBdO1xuXHRcdHZhciBkZWZpbmVkV2lkdGggPSBvcmlnaW5hbCA/XG5cdFx0XHRjb2x1bW4uc1dpZHRoT3JpZyA6XG5cdFx0XHRjb2x1bW4uc1dpZHRoO1xuXG5cdFx0aWYgKCAhIGluY1Zpc2libGUgJiYgY29sdW1uLmJWaXNpYmxlID09PSBmYWxzZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICggZGVmaW5lZFdpZHRoID09PSBudWxsIHx8IGRlZmluZWRXaWR0aCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIG51bGw7IC8vIGNhbid0IGRldGVybWluZSBhIGRlZmluZWQgd2lkdGggLSBicm93c2VyIGRlZmluZWRcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmVkV2lkdGggPT09ICdudW1iZXInICkge1xuXHRcdFx0dW5pdCA9ICdweCc7XG5cdFx0XHRzdW0gKz0gZGVmaW5lZFdpZHRoO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZhciBtYXRjaGVkID0gZGVmaW5lZFdpZHRoLm1hdGNoKC8oW1xcZFxcLl0rKShbXlxcZF0qKS8pO1xuXG5cdFx0XHRpZiAoIG1hdGNoZWQgKSB7XG5cdFx0XHRcdHN1bSArPSBtYXRjaGVkWzFdICogMTtcblx0XHRcdFx0dW5pdCA9IG1hdGNoZWQubGVuZ3RoID09PSAzID9cblx0XHRcdFx0XHRtYXRjaGVkWzJdIDpcblx0XHRcdFx0XHQncHgnO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdW0gKyB1bml0O1xufVxuXG5mdW5jdGlvbiBfZm5Db2x1bW5zRnJvbUhlYWRlciggY2VsbCApXG57XG5cdHZhciBhdHRyID0gJChjZWxsKS5jbG9zZXN0KCdbZGF0YS1kdC1jb2x1bW5dJykuYXR0cignZGF0YS1kdC1jb2x1bW4nKTtcblxuXHRpZiAoICEgYXR0ciApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRyZXR1cm4gYXR0ci5zcGxpdCgnLCcpLm1hcCggZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB2YWwgKiAxO1xuXHR9ICk7XG59XG4vKipcbiAqIEFkZCBhIGRhdGEgYXJyYXkgdG8gdGhlIHRhYmxlLCBjcmVhdGluZyBET00gbm9kZSBldGMuIFRoaXMgaXMgdGhlIHBhcmFsbGVsIHRvXG4gKiBfZm5HYXRoZXJEYXRhLCBidXQgZm9yIGFkZGluZyByb3dzIGZyb20gYSBKYXZhc2NyaXB0IHNvdXJjZSwgcmF0aGVyIHRoYW4gYVxuICogRE9NIHNvdXJjZS5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2FycmF5fSBkYXRhIGRhdGEgYXJyYXkgdG8gYmUgYWRkZWRcbiAqICBAcGFyYW0ge25vZGV9IFt0cl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcbiAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuICogIEBwYXJhbSB7YXJyYXl9IFt0ZHNdIEFycmF5IG9mIFREfFRIIGVsZW1lbnRzIGZvciB0aGUgcm93IC0gbXVzdCBiZSBnaXZlblxuICogICAgaWYgblRyIGlzLlxuICogIEByZXR1cm5zIHtpbnR9ID49MCBpZiBzdWNjZXNzZnVsIChpbmRleCBvZiBuZXcgYW9EYXRhIGVudHJ5KSwgLTEgaWYgZmFpbGVkXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFkZERhdGEgKCBzZXR0aW5ncywgZGF0YUluLCB0ciwgdGRzIClcbntcblx0LyogQ3JlYXRlIHRoZSBvYmplY3QgZm9yIHN0b3JpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBuZXcgcm93ICovXG5cdHZhciByb3dJZHggPSBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoO1xuXHR2YXIgcm93TW9kZWwgPSAkLmV4dGVuZCggdHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1Jvdywge1xuXHRcdHNyYzogdHIgPyAnZG9tJyA6ICdkYXRhJyxcblx0XHRpZHg6IHJvd0lkeFxuXHR9ICk7XG5cblx0cm93TW9kZWwuX2FEYXRhID0gZGF0YUluO1xuXHRzZXR0aW5ncy5hb0RhdGEucHVzaCggcm93TW9kZWwgKTtcblxuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblxuXHRmb3IgKCB2YXIgaT0wLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0e1xuXHRcdC8vIEludmFsaWRhdGUgdGhlIGNvbHVtbiB0eXBlcyBhcyB0aGUgbmV3IGRhdGEgbmVlZHMgdG8gYmUgcmV2YWxpZGF0ZWRcblx0XHRjb2x1bW5zW2ldLnNUeXBlID0gbnVsbDtcblx0fVxuXG5cdC8qIEFkZCB0byB0aGUgZGlzcGxheSBhcnJheSAqL1xuXHRzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIucHVzaCggcm93SWR4ICk7XG5cblx0dmFyIGlkID0gc2V0dGluZ3Mucm93SWRGbiggZGF0YUluICk7XG5cdGlmICggaWQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRzZXR0aW5ncy5hSWRzWyBpZCBdID0gcm93TW9kZWw7XG5cdH1cblxuXHQvKiBDcmVhdGUgdGhlIERPTSBpbmZvcm1hdGlvbiwgb3IgcmVnaXN0ZXIgaXQgaWYgYWxyZWFkeSBwcmVzZW50ICovXG5cdGlmICggdHIgfHwgISBzZXR0aW5ncy5vRmVhdHVyZXMuYkRlZmVyUmVuZGVyIClcblx0e1xuXHRcdF9mbkNyZWF0ZVRyKCBzZXR0aW5ncywgcm93SWR4LCB0ciwgdGRzICk7XG5cdH1cblxuXHRyZXR1cm4gcm93SWR4O1xufVxuXG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIFRSIGVsZW1lbnRzIHRvIHRoZSB0YWJsZS4gR2VuZXJhbGx5IHdlJ2QgZXhwZWN0IHRvXG4gKiB1c2UgdGhpcyBmb3IgcmVhZGluZyBkYXRhIGZyb20gYSBET00gc291cmNlZCB0YWJsZSwgYnV0IGl0IGNvdWxkIGJlXG4gKiB1c2VkIGZvciBhbiBUUiBlbGVtZW50LiBOb3RlIHRoYXQgaWYgYSBUUiBpcyBnaXZlbiwgaXQgaXMgdXNlZCAoaS5lLlxuICogaXQgaXMgbm90IGNsb25lZCkuXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHthcnJheXxub2RlfGpRdWVyeX0gdHJzIFRoZSBUUiBlbGVtZW50KHMpIHRvIGFkZCB0byB0aGUgdGFibGVcbiAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgZm9yIHRoZSBhZGRlZCByb3dzXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFkZFRyKCBzZXR0aW5ncywgdHJzIClcbntcblx0dmFyIHJvdztcblxuXHQvLyBBbGxvdyBhbiBpbmRpdmlkdWFsIG5vZGUgdG8gYmUgcGFzc2VkIGluXG5cdGlmICggISAodHJzIGluc3RhbmNlb2YgJCkgKSB7XG5cdFx0dHJzID0gJCh0cnMpO1xuXHR9XG5cblx0cmV0dXJuIHRycy5tYXAoIGZ1bmN0aW9uIChpLCBlbCkge1xuXHRcdHJvdyA9IF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgZWwgKTtcblx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdy5kYXRhLCBlbCwgcm93LmNlbGxzICk7XG5cdH0gKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgZGF0YSBmb3IgYSBnaXZlbiBjZWxsIGZyb20gdGhlIGludGVybmFsIGNhY2hlLCB0YWtpbmcgaW50byBhY2NvdW50IGRhdGEgbWFwcGluZ1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxuICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG4gKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgZGF0YSBnZXQgdHlwZSAoJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcnxzZWFyY2gnICdzb3J0fG9yZGVyJylcbiAqICBAcmV0dXJucyB7Kn0gQ2VsbCBkYXRhXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHR5cGUgKVxue1xuXHRpZiAodHlwZSA9PT0gJ3NlYXJjaCcpIHtcblx0XHR0eXBlID0gJ2ZpbHRlcic7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ29yZGVyJykge1xuXHRcdHR5cGUgPSAnc29ydCc7XG5cdH1cblxuXHR2YXIgcm93ID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF07XG5cblx0aWYgKCEgcm93KSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdHZhciBkcmF3ICAgICAgICAgICA9IHNldHRpbmdzLmlEcmF3O1xuXHR2YXIgY29sICAgICAgICAgICAgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcblx0dmFyIHJvd0RhdGEgICAgICAgID0gcm93Ll9hRGF0YTtcblx0dmFyIGRlZmF1bHRDb250ZW50ID0gY29sLnNEZWZhdWx0Q29udGVudDtcblx0dmFyIGNlbGxEYXRhICAgICAgID0gY29sLmZuR2V0RGF0YSggcm93RGF0YSwgdHlwZSwge1xuXHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRyb3c6ICAgICAgcm93SWR4LFxuXHRcdGNvbDogICAgICBjb2xJZHhcblx0fSApO1xuXG5cdC8vIEFsbG93IGZvciBhIG5vZGUgYmVpbmcgcmV0dXJuZWQgZm9yIG5vbi1kaXNwbGF5IHR5cGVzXG5cdGlmICh0eXBlICE9PSAnZGlzcGxheScgJiYgY2VsbERhdGEgJiYgdHlwZW9mIGNlbGxEYXRhID09PSAnb2JqZWN0JyAmJiBjZWxsRGF0YS5ub2RlTmFtZSkge1xuXHRcdGNlbGxEYXRhID0gY2VsbERhdGEuaW5uZXJIVE1MO1xuXHR9XG5cblx0aWYgKCBjZWxsRGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGlmICggc2V0dGluZ3MuaURyYXdFcnJvciAhPSBkcmF3ICYmIGRlZmF1bHRDb250ZW50ID09PSBudWxsICkge1xuXHRcdFx0X2ZuTG9nKCBzZXR0aW5ncywgMCwgXCJSZXF1ZXN0ZWQgdW5rbm93biBwYXJhbWV0ZXIgXCIrXG5cdFx0XHRcdCh0eXBlb2YgY29sLm1EYXRhPT0nZnVuY3Rpb24nID8gJ3tmdW5jdGlvbn0nIDogXCInXCIrY29sLm1EYXRhK1wiJ1wiKStcblx0XHRcdFx0XCIgZm9yIHJvdyBcIityb3dJZHgrXCIsIGNvbHVtbiBcIitjb2xJZHgsIDQgKTtcblx0XHRcdHNldHRpbmdzLmlEcmF3RXJyb3IgPSBkcmF3O1xuXHRcdH1cblx0XHRyZXR1cm4gZGVmYXVsdENvbnRlbnQ7XG5cdH1cblxuXHQvLyBXaGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsIGFuZCBhIHNwZWNpZmljIGRhdGEgdHlwZSBpcyByZXF1ZXN0ZWQgKGkuZS5cblx0Ly8gbm90IHRoZSBvcmlnaW5hbCBkYXRhKSwgd2UgY2FuIHVzZSBkZWZhdWx0IGNvbHVtbiBkYXRhXG5cdGlmICggKGNlbGxEYXRhID09PSByb3dEYXRhIHx8IGNlbGxEYXRhID09PSBudWxsKSAmJiBkZWZhdWx0Q29udGVudCAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2VsbERhdGEgPSBkZWZhdWx0Q29udGVudDtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGNlbGxEYXRhID09PSAnZnVuY3Rpb24nICkge1xuXHRcdC8vIElmIHRoZSBkYXRhIHNvdXJjZSBpcyBhIGZ1bmN0aW9uLCB0aGVuIHdlIHJ1biBpdCBhbmQgdXNlIHRoZSByZXR1cm4sXG5cdFx0Ly8gZXhlY3V0aW5nIGluIHRoZSBzY29wZSBvZiB0aGUgZGF0YSBvYmplY3QgKGZvciBpbnN0YW5jZXMpXG5cdFx0cmV0dXJuIGNlbGxEYXRhLmNhbGwoIHJvd0RhdGEgKTtcblx0fVxuXG5cdGlmICggY2VsbERhdGEgPT09IG51bGwgJiYgdHlwZSA9PT0gJ2Rpc3BsYXknICkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdGlmICggdHlwZSA9PT0gJ2ZpbHRlcicgKSB7XG5cdFx0dmFyIGZvbWF0dGVycyA9IERhdGFUYWJsZS5leHQudHlwZS5zZWFyY2g7XG5cblx0XHRpZiAoIGZvbWF0dGVyc1sgY29sLnNUeXBlIF0gKSB7XG5cdFx0XHRjZWxsRGF0YSA9IGZvbWF0dGVyc1sgY29sLnNUeXBlIF0oIGNlbGxEYXRhICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNlbGxEYXRhO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBmb3IgYSBzcGVjaWZpYyBjZWxsLCBpbnRvIHRoZSBpbnRlcm5hbCBkYXRhIGNhY2hlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG4gKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcbiAqICBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byBzZXRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdmFsIClcbntcblx0dmFyIGNvbCAgICAgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcblx0dmFyIHJvd0RhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XS5fYURhdGE7XG5cblx0Y29sLmZuU2V0RGF0YSggcm93RGF0YSwgdmFsLCB7XG5cdFx0c2V0dGluZ3M6IHNldHRpbmdzLFxuXHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0Y29sOiAgICAgIGNvbElkeFxuXHR9ICApO1xufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFsdWUgdG8gYSBjZWxsXG4gKiBAcGFyYW0geyp9IHRkIENlbGxcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlXG4gKi9cbmZ1bmN0aW9uIF9mbldyaXRlQ2VsbCh0ZCwgdmFsKVxue1xuXHRpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlTmFtZSkge1xuXHRcdCQodGQpXG5cdFx0XHQuZW1wdHkoKVxuXHRcdFx0LmFwcGVuZCh2YWwpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHRkLmlubmVySFRNTCA9IHZhbDtcblx0fVxufVxuXG5cbi8vIFByaXZhdGUgdmFyaWFibGUgdGhhdCBpcyB1c2VkIHRvIG1hdGNoIGFjdGlvbiBzeW50YXggaW4gdGhlIGRhdGEgcHJvcGVydHkgb2JqZWN0XG52YXIgX19yZUFycmF5ID0gL1xcWy4qP1xcXSQvO1xudmFyIF9fcmVGbiA9IC9cXChcXCkkLztcblxuLyoqXG4gKiBTcGxpdCBzdHJpbmcgb24gcGVyaW9kcywgdGFraW5nIGludG8gYWNjb3VudCBlc2NhcGVkIHBlcmlvZHNcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdFxuICogQHJldHVybiB7YXJyYXl9IFNwbGl0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBfZm5TcGxpdE9iak5vdGF0aW9uKCBzdHIgKVxue1xuXHR2YXIgcGFydHMgPSBzdHIubWF0Y2goLyhcXFxcLnxbXi5dKSsvZykgfHwgWycnXTtcblxuXHRyZXR1cm4gcGFydHMubWFwKCBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0cmV0dXJuIHMucmVwbGFjZSgvXFxcXFxcLi9nLCAnLicpO1xuXHR9ICk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGdldCBkYXRhIGZyb20gYSBzb3VyY2Ugb2JqZWN0LCB0YWtpbmdcbiAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcbiAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG4gKiAgQHJldHVybnMge2Z1bmN0aW9ufSBEYXRhIGdldCBmdW5jdGlvblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG52YXIgX2ZuR2V0T2JqZWN0RGF0YUZuID0gRGF0YVRhYmxlLnV0aWwuZ2V0O1xuXG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG4gKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG4gKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxuICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBzZXQgZnVuY3Rpb25cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xudmFyIF9mblNldE9iamVjdERhdGFGbiA9IERhdGFUYWJsZS51dGlsLnNldDtcblxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBmdWxsIHRhYmxlIGRhdGFcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyICggc2V0dGluZ3MgKVxue1xuXHRyZXR1cm4gX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdfYURhdGEnICk7XG59XG5cblxuLyoqXG4gKiBOdWtlIHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ2xlYXJUYWJsZSggc2V0dGluZ3MgKVxue1xuXHRzZXR0aW5ncy5hb0RhdGEubGVuZ3RoID0gMDtcblx0c2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aCA9IDA7XG5cdHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xuXHRzZXR0aW5ncy5hSWRzID0ge307XG59XG5cblxuLyoqXG4gKiBNYXJrIGNhY2hlZCBkYXRhIGFzIGludmFsaWQgc3VjaCB0aGF0IGEgcmUtcmVhZCBvZiB0aGUgZGF0YSB3aWxsIG9jY3VyIHdoZW5cbiAqIHRoZSBjYWNoZWQgZGF0YSBpcyBuZXh0IHJlcXVlc3RlZC4gQWxzbyB1cGRhdGUgZnJvbSB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHtpbnR9ICAgIHJvd0lkeCAgIFJvdyBpbmRleCB0byBpbnZhbGlkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gICAgU291cmNlIHRvIGludmFsaWRhdGUgZnJvbTogdW5kZWZpbmVkLCAnYXV0bycsICdkb20nXG4gKiAgICAgb3IgJ2RhdGEnXG4gKiBAcGFyYW0ge2ludH0gICAgW2NvbElkeF0gQ29sdW1uIGluZGV4IHRvIGludmFsaWRhdGUuIElmIHVuZGVmaW5lZCB0aGUgd2hvbGVcbiAqICAgICByb3cgd2lsbCBiZSBpbnZhbGlkYXRlZFxuICogQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKlxuICogQHRvZG8gRm9yIHRoZSBtb2R1bGFyaXNhdGlvbiBvZiB2MS4xMSB0aGlzIHdpbGwgbmVlZCB0byBiZWNvbWUgYSBjYWxsYmFjaywgc29cbiAqICAgdGhlIHNvcnQgYW5kIGZpbHRlciBtZXRob2RzIGNhbiBzdWJzY3JpYmUgdG8gaXQuIFRoYXQgd2lsbCByZXF1aXJlZFxuICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nLCB3aGljaCBpcyB3aHkgaXQgaXMgbm90IGFscmVhZHkgYmFrZWQgaW5cbiAqL1xuZnVuY3Rpb24gX2ZuSW52YWxpZGF0ZSggc2V0dGluZ3MsIHJvd0lkeCwgc3JjLCBjb2xJZHggKVxue1xuXHR2YXIgcm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblx0dmFyIGksIGllbjtcblxuXHQvLyBSZW1vdmUgdGhlIGNhY2hlZCBkYXRhIGZvciB0aGUgcm93XG5cdHJvdy5fYVNvcnREYXRhID0gbnVsbDtcblx0cm93Ll9hRmlsdGVyRGF0YSA9IG51bGw7XG5cdHJvdy5kaXNwbGF5RGF0YSA9IG51bGw7XG5cblx0Ly8gQXJlIHdlIHJlYWRpbmcgbGFzdCBkYXRhIGZyb20gRE9NIG9yIHRoZSBkYXRhIG9iamVjdD9cblx0aWYgKCBzcmMgPT09ICdkb20nIHx8ICgoISBzcmMgfHwgc3JjID09PSAnYXV0bycpICYmIHJvdy5zcmMgPT09ICdkb20nKSApIHtcblx0XHQvLyBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIERPTVxuXHRcdHJvdy5fYURhdGEgPSBfZm5HZXRSb3dFbGVtZW50cyhcblx0XHRcdFx0c2V0dGluZ3MsIHJvdywgY29sSWR4LCBjb2xJZHggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJvdy5fYURhdGFcblx0XHRcdClcblx0XHRcdC5kYXRhO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIFJlYWRpbmcgZnJvbSBkYXRhIG9iamVjdCwgdXBkYXRlIHRoZSBET01cblx0XHR2YXIgY2VsbHMgPSByb3cuYW5DZWxscztcblx0XHR2YXIgZGlzcGxheSA9IF9mbkdldFJvd0Rpc3BsYXkoc2V0dGluZ3MsIHJvd0lkeCk7XG5cblx0XHRpZiAoIGNlbGxzICkge1xuXHRcdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0X2ZuV3JpdGVDZWxsKGNlbGxzW2NvbElkeF0sIGRpc3BsYXlbY29sSWR4XSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49Y2VsbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0X2ZuV3JpdGVDZWxsKGNlbGxzW2ldLCBkaXNwbGF5W2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbHVtbiBzcGVjaWZpYyBpbnZhbGlkYXRpb25cblx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdGlmICggY29sSWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gVHlwZSAtIHRoZSBkYXRhIG1pZ2h0IGhhdmUgY2hhbmdlZFxuXHRcdGNvbHNbIGNvbElkeCBdLnNUeXBlID0gbnVsbDtcblxuXHRcdC8vIE1heCBsZW5ndGggc3RyaW5nLiBJdHMgYSBmYWlybHkgY2hlZXAgcmVjYWxjdWxhdGlvbiwgc28gbm90IHdvcnRoXG5cdFx0Ly8gc29tZXRoaW5nIG1vcmUgY29tcGxpY2F0ZWRcblx0XHRjb2xzWyBjb2xJZHggXS5tYXhMZW5TdHJpbmcgPSBudWxsO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAoIGk9MCwgaWVuPWNvbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRjb2xzW2ldLnNUeXBlID0gbnVsbDtcblx0XHRcdGNvbHNbaV0ubWF4TGVuU3RyaW5nID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgRGF0YVRhYmxlcyBzcGVjaWFsIGBEVF8qYCBhdHRyaWJ1dGVzIGZvciB0aGUgcm93XG5cdFx0X2ZuUm93QXR0cmlidXRlcyggc2V0dGluZ3MsIHJvdyApO1xuXHR9XG59XG5cblxuLyoqXG4gKiBCdWlsZCBhIGRhdGEgc291cmNlIG9iamVjdCBmcm9tIGFuIEhUTUwgcm93LCByZWFkaW5nIHRoZSBjb250ZW50cyBvZiB0aGVcbiAqIGNlbGxzIHRoYXQgYXJlIGluIHRoZSByb3cuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0ge25vZGV8b2JqZWN0fSBUUiBlbGVtZW50IGZyb20gd2hpY2ggdG8gcmVhZCBkYXRhIG9yIGV4aXN0aW5nIHJvd1xuICogICBvYmplY3QgZnJvbSB3aGljaCB0byByZS1yZWFkIHRoZSBkYXRhIGZyb20gdGhlIGNlbGxzXG4gKiBAcGFyYW0ge2ludH0gW2NvbElkeF0gT3B0aW9uYWwgY29sdW1uIGluZGV4XG4gKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gW2RdIERhdGEgc291cmNlIG9iamVjdC4gSWYgYGNvbElkeGAgaXMgZ2l2ZW4gdGhlbiB0aGlzXG4gKiAgIHBhcmFtZXRlciBzaG91bGQgYWxzbyBiZSBnaXZlbiBhbmQgd2lsbCBiZSB1c2VkIHRvIHdyaXRlIHRoZSBkYXRhIGludG8uXG4gKiAgIE9ubHkgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiB3aWxsIGJlIHdyaXR0ZW5cbiAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCB3aXRoIHR3byBwYXJhbWV0ZXJzOiBgZGF0YWAgdGhlIGRhdGEgcmVhZCwgaW5cbiAqICAgZG9jdW1lbnQgb3JkZXIsIGFuZCBgY2VsbHNgIGFuZCBhcnJheSBvZiBub2RlcyAodGhleSBjYW4gYmUgdXNlZnVsIHRvIHRoZVxuICogICBjYWxsZXIsIHNvIHJhdGhlciB0aGFuIG5lZWRpbmcgYSBzZWNvbmQgdHJhdmVyc2FsIHRvIGdldCB0aGVtLCBqdXN0IHJldHVyblxuICogICB0aGVtIGZyb20gaGVyZSkuXG4gKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0Um93RWxlbWVudHMoIHNldHRpbmdzLCByb3csIGNvbElkeCwgZCApXG57XG5cdHZhclxuXHRcdHRkcyA9IFtdLFxuXHRcdHRkID0gcm93LmZpcnN0Q2hpbGQsXG5cdFx0bmFtZSwgY29sLCBpPTAsIGNvbnRlbnRzLFxuXHRcdGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0b2JqZWN0UmVhZCA9IHNldHRpbmdzLl9yb3dSZWFkT2JqZWN0O1xuXG5cdC8vIEFsbG93IHRoZSBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgaW4sIG9yIGNvbnN0cnVjdFxuXHRkID0gZCAhPT0gdW5kZWZpbmVkID9cblx0XHRkIDpcblx0XHRvYmplY3RSZWFkID9cblx0XHRcdHt9IDpcblx0XHRcdFtdO1xuXG5cdHZhciBhdHRyID0gZnVuY3Rpb24gKCBzdHIsIHRkICApIHtcblx0XHRpZiAoIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0dmFyIGlkeCA9IHN0ci5pbmRleE9mKCdAJyk7XG5cblx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0dmFyIGF0dHIgPSBzdHIuc3Vic3RyaW5nKCBpZHgrMSApO1xuXHRcdFx0XHR2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBzdHIgKTtcblx0XHRcdFx0c2V0dGVyKCBkLCB0ZC5nZXRBdHRyaWJ1dGUoIGF0dHIgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBSZWFkIGRhdGEgZnJvbSBhIGNlbGwgYW5kIHN0b3JlIGludG8gdGhlIGRhdGEgb2JqZWN0XG5cdHZhciBjZWxsUHJvY2VzcyA9IGZ1bmN0aW9uICggY2VsbCApIHtcblx0XHRpZiAoIGNvbElkeCA9PT0gdW5kZWZpbmVkIHx8IGNvbElkeCA9PT0gaSApIHtcblx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRjb250ZW50cyA9IChjZWxsLmlubmVySFRNTCkudHJpbSgpO1xuXG5cdFx0XHRpZiAoIGNvbCAmJiBjb2wuX2JBdHRyU3JjICkge1xuXHRcdFx0XHR2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBjb2wubURhdGEuXyApO1xuXHRcdFx0XHRzZXR0ZXIoIGQsIGNvbnRlbnRzICk7XG5cblx0XHRcdFx0YXR0ciggY29sLm1EYXRhLnNvcnQsIGNlbGwgKTtcblx0XHRcdFx0YXR0ciggY29sLm1EYXRhLnR5cGUsIGNlbGwgKTtcblx0XHRcdFx0YXR0ciggY29sLm1EYXRhLmZpbHRlciwgY2VsbCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIERlcGVuZGluZyBvbiB0aGUgYGRhdGFgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbnMgdGhlIGRhdGEgY2FuXG5cdFx0XHRcdC8vIGJlIHJlYWQgdG8gZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheS5cblx0XHRcdFx0aWYgKCBvYmplY3RSZWFkICkge1xuXHRcdFx0XHRcdGlmICggISBjb2wuX3NldHRlciApIHtcblx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBzZXR0ZXIgZnVuY3Rpb25cblx0XHRcdFx0XHRcdGNvbC5fc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBjb2wubURhdGEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29sLl9zZXR0ZXIoIGQsIGNvbnRlbnRzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZFtpXSA9IGNvbnRlbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aSsrO1xuXHR9O1xuXG5cdGlmICggdGQgKSB7XG5cdFx0Ly8gYHRyYCBlbGVtZW50IHdhcyBwYXNzZWQgaW5cblx0XHR3aGlsZSAoIHRkICkge1xuXHRcdFx0bmFtZSA9IHRkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbmFtZSA9PSBcIlREXCIgfHwgbmFtZSA9PSBcIlRIXCIgKSB7XG5cdFx0XHRcdGNlbGxQcm9jZXNzKCB0ZCApO1xuXHRcdFx0XHR0ZHMucHVzaCggdGQgKTtcblx0XHRcdH1cblxuXHRcdFx0dGQgPSB0ZC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRXhpc3Rpbmcgcm93IG9iamVjdCBwYXNzZWQgaW5cblx0XHR0ZHMgPSByb3cuYW5DZWxscztcblxuXHRcdGZvciAoIHZhciBqPTAsIGplbj10ZHMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRjZWxsUHJvY2VzcyggdGRzW2pdICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVhZCB0aGUgSUQgZnJvbSB0aGUgRE9NIGlmIHByZXNlbnRcblx0dmFyIHJvd05vZGUgPSByb3cuZmlyc3RDaGlsZCA/IHJvdyA6IHJvdy5uVHI7XG5cblx0aWYgKCByb3dOb2RlICkge1xuXHRcdHZhciBpZCA9IHJvd05vZGUuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cblx0XHRpZiAoIGlkICkge1xuXHRcdFx0X2ZuU2V0T2JqZWN0RGF0YUZuKCBzZXR0aW5ncy5yb3dJZCApKCBkLCBpZCApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0ZGF0YTogZCxcblx0XHRjZWxsczogdGRzXG5cdH07XG59XG5cbi8qKlxuICogUmVuZGVyIGFuZCBjYWNoZSBhIHJvdydzIGRpc3BsYXkgZGF0YSBmb3IgdGhlIGNvbHVtbnMsIGlmIHJlcXVpcmVkXG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0Um93RGlzcGxheSAoc2V0dGluZ3MsIHJvd0lkeCkge1xuXHR2YXIgcm93TW9kYWwgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XTtcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0aWYgKCEgcm93TW9kYWwuZGlzcGxheURhdGEpIHtcblx0XHQvLyBOZWVkIHRvIHJlbmRlciBhbmQgY2FjaGVcblx0XHRyb3dNb2RhbC5kaXNwbGF5RGF0YSA9IFtdO1xuXHRcblx0XHRmb3IgKCB2YXIgY29sSWR4PTAsIGxlbj1jb2x1bW5zLmxlbmd0aCA7IGNvbElkeDxsZW4gOyBjb2xJZHgrKyApIHtcblx0XHRcdHJvd01vZGFsLmRpc3BsYXlEYXRhLnB1c2goXG5cdFx0XHRcdF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsICdkaXNwbGF5JyApXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByb3dNb2RhbC5kaXNwbGF5RGF0YTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVFIgZWxlbWVudCAoYW5kIGl0J3MgVEQgY2hpbGRyZW4pIGZvciBhIHJvd1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2ludH0gaVJvdyBSb3cgdG8gY29uc2lkZXJcbiAqICBAcGFyYW0ge25vZGV9IFtuVHJJbl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcbiAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG4gKiAgICBpZiBuVHIgaXMuXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNyZWF0ZVRyICggb1NldHRpbmdzLCBpUm93LCBuVHJJbiwgYW5UZHMgKVxue1xuXHR2YXJcblx0XHRyb3cgPSBvU2V0dGluZ3MuYW9EYXRhW2lSb3ddLFxuXHRcdHJvd0RhdGEgPSByb3cuX2FEYXRhLFxuXHRcdGNlbGxzID0gW10sXG5cdFx0blRyLCBuVGQsIG9Db2wsXG5cdFx0aSwgaUxlbiwgY3JlYXRlLFxuXHRcdHRyQ2xhc3MgPSBvU2V0dGluZ3Mub0NsYXNzZXMudGJvZHkucm93O1xuXG5cdGlmICggcm93Lm5UciA9PT0gbnVsbCApXG5cdHtcblx0XHRuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG5cdFx0cm93Lm5UciA9IG5Ucjtcblx0XHRyb3cuYW5DZWxscyA9IGNlbGxzO1xuXG5cdFx0X2FkZENsYXNzKG5UciwgdHJDbGFzcyk7XG5cblx0XHQvKiBVc2UgYSBwcml2YXRlIHByb3BlcnR5IG9uIHRoZSBub2RlIHRvIGFsbG93IHJlc2VydmUgbWFwcGluZyBmcm9tIHRoZSBub2RlXG5cdFx0ICogdG8gdGhlIGFvRGF0YSBhcnJheSBmb3IgZmFzdCBsb29rIHVwXG5cdFx0ICovXG5cdFx0blRyLl9EVF9Sb3dJbmRleCA9IGlSb3c7XG5cblx0XHQvKiBTcGVjaWFsIHBhcmFtZXRlcnMgY2FuIGJlIGdpdmVuIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBiZSB1c2VkIG9uIHRoZSByb3cgKi9cblx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCBvU2V0dGluZ3MsIHJvdyApO1xuXG5cdFx0LyogUHJvY2VzcyBlYWNoIGNvbHVtbiAqL1xuXHRcdGZvciAoIGk9MCwgaUxlbj1vU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0b0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFx0XHRjcmVhdGUgPSBuVHJJbiAmJiBhblRkc1tpXSA/IGZhbHNlIDogdHJ1ZTtcblxuXHRcdFx0blRkID0gY3JlYXRlID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggb0NvbC5zQ2VsbFR5cGUgKSA6IGFuVGRzW2ldO1xuXG5cdFx0XHRpZiAoISBuVGQpIHtcblx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdJbmNvcnJlY3QgY29sdW1uIGNvdW50JywgMTggKTtcblx0XHRcdH1cblxuXHRcdFx0blRkLl9EVF9DZWxsSW5kZXggPSB7XG5cdFx0XHRcdHJvdzogaVJvdyxcblx0XHRcdFx0Y29sdW1uOiBpXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjZWxscy5wdXNoKCBuVGQgKTtcblx0XHRcdFxuXHRcdFx0dmFyIGRpc3BsYXkgPSBfZm5HZXRSb3dEaXNwbGF5KG9TZXR0aW5ncywgaVJvdyk7XG5cblx0XHRcdC8vIE5lZWQgdG8gY3JlYXRlIHRoZSBIVE1MIGlmIG5ldywgb3IgaWYgYSByZW5kZXJpbmcgZnVuY3Rpb24gaXMgZGVmaW5lZFxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjcmVhdGUgfHxcblx0XHRcdFx0KFxuXHRcdFx0XHRcdChvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkgJiZcblx0XHRcdFx0XHQoISQuaXNQbGFpbk9iamVjdChvQ29sLm1EYXRhKSB8fCBvQ29sLm1EYXRhLl8gIT09IGkrJy5kaXNwbGF5Jylcblx0XHRcdFx0KVxuXHRcdFx0KSB7XG5cdFx0XHRcdF9mbldyaXRlQ2VsbChuVGQsIGRpc3BsYXlbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb2x1bW4gY2xhc3Ncblx0XHRcdF9hZGRDbGFzcyhuVGQsIG9Db2wuc0NsYXNzKTtcblxuXHRcdFx0Ly8gVmlzaWJpbGl0eSAtIGFkZCBvciByZW1vdmUgYXMgcmVxdWlyZWRcblx0XHRcdGlmICggb0NvbC5iVmlzaWJsZSAmJiBjcmVhdGUgKVxuXHRcdFx0e1xuXHRcdFx0XHRuVHIuYXBwZW5kQ2hpbGQoIG5UZCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICEgb0NvbC5iVmlzaWJsZSAmJiAhIGNyZWF0ZSApXG5cdFx0XHR7XG5cdFx0XHRcdG5UZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBuVGQgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvQ29sLmZuQ3JlYXRlZENlbGwgKVxuXHRcdFx0e1xuXHRcdFx0XHRvQ29sLmZuQ3JlYXRlZENlbGwuY2FsbCggb1NldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdFx0XHRuVGQsIF9mbkdldENlbGxEYXRhKCBvU2V0dGluZ3MsIGlSb3csIGkgKSwgcm93RGF0YSwgaVJvdywgaVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCAncm93LWNyZWF0ZWQnLCBbblRyLCByb3dEYXRhLCBpUm93LCBjZWxsc10gKTtcblx0fVxuXHRlbHNlIHtcblx0XHRfYWRkQ2xhc3Mocm93Lm5UciwgdHJDbGFzcyk7XG5cdH1cbn1cblxuXG4vKipcbiAqIEFkZCBhdHRyaWJ1dGVzIHRvIGEgcm93IGJhc2VkIG9uIHRoZSBzcGVjaWFsIGBEVF8qYCBwYXJhbWV0ZXJzIGluIGEgZGF0YVxuICogc291cmNlIG9iamVjdC5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gRGF0YVRhYmxlcyByb3cgb2JqZWN0IGZvciB0aGUgcm93IHRvIGJlIG1vZGlmaWVkXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKVxue1xuXHR2YXIgdHIgPSByb3cublRyO1xuXHR2YXIgZGF0YSA9IHJvdy5fYURhdGE7XG5cblx0aWYgKCB0ciApIHtcblx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCBkYXRhICk7XG5cblx0XHRpZiAoIGlkICkge1xuXHRcdFx0dHIuaWQgPSBpZDtcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuRFRfUm93Q2xhc3MgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYW55IGNsYXNzZXMgYWRkZWQgYnkgRFRfUm93Q2xhc3MgYmVmb3JlXG5cdFx0XHR2YXIgYSA9IGRhdGEuRFRfUm93Q2xhc3Muc3BsaXQoJyAnKTtcblx0XHRcdHJvdy5fX3Jvd2MgPSByb3cuX19yb3djID9cblx0XHRcdFx0X3VuaXF1ZSggcm93Ll9fcm93Yy5jb25jYXQoIGEgKSApIDpcblx0XHRcdFx0YTtcblxuXHRcdFx0JCh0cilcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCByb3cuX19yb3djLmpvaW4oJyAnKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggZGF0YS5EVF9Sb3dDbGFzcyApO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YS5EVF9Sb3dBdHRyICkge1xuXHRcdFx0JCh0cikuYXR0ciggZGF0YS5EVF9Sb3dBdHRyICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLkRUX1Jvd0RhdGEgKSB7XG5cdFx0XHQkKHRyKS5kYXRhKCBkYXRhLkRUX1Jvd0RhdGEgKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQnVpbGRIZWFkKCBzZXR0aW5ncywgc2lkZSApXG57XG5cdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgaSwgaWVuLCByb3c7XG5cdHZhciB0YXJnZXQgPSBzaWRlID09PSAnaGVhZGVyJ1xuXHRcdD8gc2V0dGluZ3MublRIZWFkXG5cdFx0OiBzZXR0aW5ncy5uVEZvb3Q7XG5cdHZhciB0aXRsZVByb3AgPSBzaWRlID09PSAnaGVhZGVyJyA/ICdzVGl0bGUnIDogc2lkZTtcblxuXHQvLyBGb290ZXIgbWlnaHQgYmUgZGVmaW5lZFxuXHRpZiAoISB0YXJnZXQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBJZiBubyBjZWxscyB5ZXQgYW5kIHdlIGhhdmUgY29udGVudCBmb3IgdGhlbSwgdGhlbiBjcmVhdGVcblx0aWYgKHNpZGUgPT09ICdoZWFkZXInIHx8IF9wbHVjayhzZXR0aW5ncy5hb0NvbHVtbnMsIHRpdGxlUHJvcCkuam9pbignJykpIHtcblx0XHRyb3cgPSAkKCd0cicsIHRhcmdldCk7XG5cblx0XHQvLyBBZGQgYSByb3cgaWYgbmVlZGVkXG5cdFx0aWYgKCEgcm93Lmxlbmd0aCkge1xuXHRcdFx0cm93ID0gJCgnPHRyLz4nKS5hcHBlbmRUbyh0YXJnZXQpXG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSBudW1iZXIgb2YgY2VsbHMgbmVlZGVkIHRvIG1ha2UgdXAgdG8gdGhlIG51bWJlciBvZiBjb2x1bW5zXG5cdFx0aWYgKHJvdy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjZWxsQ291bnQgPSAwO1xuXHRcdFx0XG5cdFx0XHQkKCd0ZCwgdGgnLCByb3cpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjZWxsQ291bnQgKz0gdGhpcy5jb2xTcGFuO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoIGk9Y2VsbENvdW50LCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0JCgnPHRoLz4nKVxuXHRcdFx0XHRcdC5odG1sKCBjb2x1bW5zW2ldW3RpdGxlUHJvcF0gfHwgJycgKVxuXHRcdFx0XHRcdC5hcHBlbmRUbyggcm93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGRldGVjdGVkID0gX2ZuRGV0ZWN0SGVhZGVyKCBzZXR0aW5ncywgdGFyZ2V0LCB0cnVlICk7XG5cblx0aWYgKHNpZGUgPT09ICdoZWFkZXInKSB7XG5cdFx0c2V0dGluZ3MuYW9IZWFkZXIgPSBkZXRlY3RlZDtcblx0XHQkKCd0cicsIHRhcmdldCkuYWRkQ2xhc3MoY2xhc3Nlcy50aGVhZC5yb3cpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHNldHRpbmdzLmFvRm9vdGVyID0gZGV0ZWN0ZWQ7XG5cdFx0JCgndHInLCB0YXJnZXQpLmFkZENsYXNzKGNsYXNzZXMudGZvb3Qucm93KTtcblx0fVxuXG5cdC8vIEV2ZXJ5IGNlbGwgbmVlZHMgdG8gYmUgcGFzc2VkIHRocm91Z2ggdGhlIHJlbmRlcmVyXG5cdCQodGFyZ2V0KS5jaGlsZHJlbigndHInKS5jaGlsZHJlbigndGgsIHRkJylcblx0XHQuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0X2ZuUmVuZGVyZXIoIHNldHRpbmdzLCBzaWRlICkoXG5cdFx0XHRcdHNldHRpbmdzLCAkKHRoaXMpLCBjbGFzc2VzXG5cdFx0XHQpO1xuXHRcdH0gKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGxheW91dCBzdHJ1Y3R1cmUgZm9yIGEgaGVhZGVyIG9yIGZvb3RlclxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5nc1xuICogQHBhcmFtIHsqfSBzb3VyY2UgU291cmNlIGxheW91dCBhcnJheVxuICogQHBhcmFtIHsqfSBpbmNDb2x1bW5zIFdoYXQgY29sdW1ucyBzaG91bGQgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIExheW91dCBhcnJheVxuICovXG5mdW5jdGlvbiBfZm5IZWFkZXJMYXlvdXQoIHNldHRpbmdzLCBzb3VyY2UsIGluY0NvbHVtbnMgKVxue1xuXHR2YXIgcm93LCBjb2x1bW4sIGNlbGw7XG5cdHZhciBsb2NhbCA9IFtdO1xuXHR2YXIgc3RydWN0dXJlID0gW107XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcblx0dmFyIHJvd3NwYW4sIGNvbHNwYW47XG5cblx0aWYgKCAhIHNvdXJjZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBEZWZhdWx0IGlzIHRvIHdvcmsgb24gb25seSB2aXNpYmxlIGNvbHVtbnNcblx0aWYgKCAhIGluY0NvbHVtbnMgKSB7XG5cdFx0aW5jQ29sdW1ucyA9IF9yYW5nZShjb2x1bW5Db3VudClcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gY29sdW1uc1tpZHhdLmJWaXNpYmxlO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvLyBNYWtlIGEgY29weSBvZiB0aGUgbWFzdGVyIGxheW91dCBhcnJheSwgYnV0IHdpdGggb25seSB0aGUgY29sdW1ucyB3ZSB3YW50XG5cdGZvciAoIHJvdz0wIDsgcm93PHNvdXJjZS5sZW5ndGggOyByb3crKyApIHtcblx0XHQvLyBSZW1vdmUgYW55IGNvbHVtbnMgd2UgaGF2ZW4ndCBzZWxlY3RlZFxuXHRcdGxvY2FsW3Jvd10gPSBzb3VyY2Vbcm93XS5zbGljZSgpLmZpbHRlcihmdW5jdGlvbiAoY2VsbCwgaSkge1xuXHRcdFx0cmV0dXJuIGluY0NvbHVtbnMuaW5jbHVkZXMoaSk7XG5cdFx0fSk7XG5cblx0XHQvLyBQcmVwIHRoZSBzdHJ1Y3R1cmUgYXJyYXkgLSBpdCBuZWVkcyBhbiBlbGVtZW50IGZvciBlYWNoIHJvd1xuXHRcdHN0cnVjdHVyZS5wdXNoKCBbXSApO1xuXHR9XG5cblx0Zm9yICggcm93PTAgOyByb3c8bG9jYWwubGVuZ3RoIDsgcm93KysgKSB7XG5cdFx0Zm9yICggY29sdW1uPTAgOyBjb2x1bW48bG9jYWxbcm93XS5sZW5ndGggOyBjb2x1bW4rKyApIHtcblx0XHRcdHJvd3NwYW4gPSAxO1xuXHRcdFx0Y29sc3BhbiA9IDE7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2VsbCAocm93L2NvbHNwYW4pIGNvdmVyaW5nIG91ciB0YXJnZXRcblx0XHRcdC8vIGluc2VydCBwb2ludC4gSWYgdGhlcmUgaXMsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkby5cblx0XHRcdGlmICggc3RydWN0dXJlW3Jvd11bY29sdW1uXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRjZWxsID0gbG9jYWxbcm93XVtjb2x1bW5dLmNlbGw7XG5cblx0XHRcdFx0Ly8gRXhwYW5kIGZvciByb3dzcGFuXG5cdFx0XHRcdHdoaWxlIChcblx0XHRcdFx0XHRsb2NhbFtyb3crcm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdGxvY2FsW3Jvd11bY29sdW1uXS5jZWxsID09IGxvY2FsW3Jvdytyb3dzcGFuXVtjb2x1bW5dLmNlbGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0c3RydWN0dXJlW3Jvdytyb3dzcGFuXVtjb2x1bW5dID0gbnVsbDtcblx0XHRcdFx0XHRyb3dzcGFuKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBbmQgZm9yIGNvbHNwYW5cblx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdGxvY2FsW3Jvd11bY29sdW1uK2NvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHRsb2NhbFtyb3ddW2NvbHVtbl0uY2VsbCA9PSBsb2NhbFtyb3ddW2NvbHVtbitjb2xzcGFuXS5jZWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIFdoaWNoIGFsc28gbmVlZHMgdG8gZ28gb3ZlciByb3dzXG5cdFx0XHRcdFx0Zm9yICggdmFyIGs9MCA7IGs8cm93c3BhbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdHN0cnVjdHVyZVtyb3cra11bY29sdW1uK2NvbHNwYW5dID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb2xzcGFuKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGl0bGVTcGFuID0gJCgnc3Bhbi5kdC1jb2x1bW4tdGl0bGUnLCBjZWxsKTtcblxuXHRcdFx0XHRzdHJ1Y3R1cmVbcm93XVtjb2x1bW5dID0ge1xuXHRcdFx0XHRcdGNlbGw6IGNlbGwsXG5cdFx0XHRcdFx0Y29sc3BhbjogY29sc3Bhbixcblx0XHRcdFx0XHRyb3dzcGFuOiByb3dzcGFuLFxuXHRcdFx0XHRcdHRpdGxlOiB0aXRsZVNwYW4ubGVuZ3RoXG5cdFx0XHRcdFx0XHQ/IHRpdGxlU3Bhbi5odG1sKClcblx0XHRcdFx0XHRcdDogJChjZWxsKS5odG1sKClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RydWN0dXJlO1xufVxuXG5cbi8qKlxuICogRHJhdyB0aGUgaGVhZGVyIChvciBmb290ZXIpIGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbiB2aXNpYmlsaXR5IHN0YXRlcy5cbiAqXG4gKiAgQHBhcmFtIG9iamVjdCBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0gYXJyYXkgYW9Tb3VyY2UgTGF5b3V0IGFycmF5IGZyb20gX2ZuRGV0ZWN0SGVhZGVyXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc291cmNlIClcbntcblx0dmFyIGxheW91dCA9IF9mbkhlYWRlckxheW91dChzZXR0aW5ncywgc291cmNlKTtcblx0dmFyIHRyLCBuO1xuXG5cdGZvciAoIHZhciByb3c9MCA7IHJvdzxzb3VyY2UubGVuZ3RoIDsgcm93KysgKSB7XG5cdFx0dHIgPSBzb3VyY2Vbcm93XS5yb3c7XG5cblx0XHQvLyBBbGwgY2VsbHMgYXJlIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBzbyBlbXB0eSBvdXQgdGhlIHJvd1xuXHRcdC8vIENhbid0IHVzZSAkKCkuZW1wdHkoKSBhcyB0aGF0IGtpbGxzIGV2ZW50IGhhbmRsZXJzXG5cdFx0aWYgKHRyKSB7XG5cdFx0XHR3aGlsZSggKG4gPSB0ci5maXJzdENoaWxkKSApIHtcblx0XHRcdFx0dHIucmVtb3ZlQ2hpbGQoIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgY29sdW1uPTAgOyBjb2x1bW48bGF5b3V0W3Jvd10ubGVuZ3RoIDsgY29sdW1uKysgKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBsYXlvdXRbcm93XVtjb2x1bW5dO1xuXG5cdFx0XHRpZiAocG9pbnQpIHtcblx0XHRcdFx0JChwb2ludC5jZWxsKVxuXHRcdFx0XHRcdC5hcHBlbmRUbyh0cilcblx0XHRcdFx0XHQuYXR0cigncm93c3BhbicsIHBvaW50LnJvd3NwYW4pXG5cdFx0XHRcdFx0LmF0dHIoJ2NvbHNwYW4nLCBwb2ludC5jb2xzcGFuKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIGFqYXhDb21wbGV0ZSB0cnVlIGFmdGVyIGFqYXggY2FsbCB0byBjb21wbGV0ZSByZW5kZXJpbmdcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRHJhdyggb1NldHRpbmdzLCBhamF4Q29tcGxldGUgKVxue1xuXHQvLyBBbGxvdyBmb3Igc3RhdGUgc2F2aW5nIGFuZCBhIGN1c3RvbSBzdGFydCBwb3NpdGlvblxuXHRfZm5TdGFydCggb1NldHRpbmdzICk7XG5cblx0LyogUHJvdmlkZSBhIHByZS1jYWxsYmFjayBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcgaXMgZmFsc2UgaXMgcmV0dXJuZWQgKi9cblx0dmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10gKTtcblx0aWYgKCBhUHJlRHJhdy5pbmRleE9mKGZhbHNlKSAhPT0gLTEgKVxuXHR7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgYW5Sb3dzID0gW107XG5cdHZhciBpUm93Q291bnQgPSAwO1xuXHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0dmFyIGFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXk7XG5cdHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuXHR2YXIgaURpc3BsYXlFbmQgPSBvU2V0dGluZ3MuZm5EaXNwbGF5RW5kKCk7XG5cdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIGJvZHkgPSAkKG9TZXR0aW5ncy5uVEJvZHkpO1xuXG5cdG9TZXR0aW5ncy5iRHJhd2luZyA9IHRydWU7XG5cblx0LyogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBkcmF3IGludGVyY2VwdCAqL1xuXHRpZiAoIG9TZXR0aW5ncy5kZWZlckxvYWRpbmcgKVxuXHR7XG5cdFx0b1NldHRpbmdzLmRlZmVyTG9hZGluZyA9IGZhbHNlO1xuXHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdH1cblx0ZWxzZSBpZiAoICFiU2VydmVyU2lkZSApXG5cdHtcblx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0fVxuXHRlbHNlIGlmICggIW9TZXR0aW5ncy5iRGVzdHJveWluZyAmJiAhYWpheENvbXBsZXRlKVxuXHR7XG5cdFx0Ly8gU2hvdyBsb2FkaW5nIG1lc3NhZ2UgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0XHRpZiAob1NldHRpbmdzLmlEcmF3ID09PSAwKSB7XG5cdFx0XHRib2R5LmVtcHR5KCkuYXBwZW5kKF9lbXB0eVJvdyhvU2V0dGluZ3MpKTtcblx0XHR9XG5cblx0XHRfZm5BamF4VXBkYXRlKCBvU2V0dGluZ3MgKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIGFpRGlzcGxheS5sZW5ndGggIT09IDAgKVxuXHR7XG5cdFx0dmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XG5cdFx0dmFyIGlFbmQgPSBiU2VydmVyU2lkZSA/IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDogaURpc3BsYXlFbmQ7XG5cblx0XHRmb3IgKCB2YXIgaj1pU3RhcnQgOyBqPGlFbmQgOyBqKysgKVxuXHRcdHtcblx0XHRcdHZhciBpRGF0YUluZGV4ID0gYWlEaXNwbGF5W2pdO1xuXHRcdFx0dmFyIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGFbIGlEYXRhSW5kZXggXTtcblx0XHRcdGlmICggYW9EYXRhLm5UciA9PT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkNyZWF0ZVRyKCBvU2V0dGluZ3MsIGlEYXRhSW5kZXggKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5Sb3cgPSBhb0RhdGEublRyO1xuXG5cdFx0XHQvLyBBZGQgdmFyaW91cyBjbGFzc2VzIGFzIG5lZWRlZFxuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTxjb2x1bW5zLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0XHR2YXIgY29sID0gY29sdW1uc1tpXTtcblx0XHRcdFx0dmFyIHRkID0gYW9EYXRhLmFuQ2VsbHNbaV07XG5cblx0XHRcdFx0X2FkZENsYXNzKHRkLCBfZXh0LnR5cGUuY2xhc3NOYW1lW2NvbC5zVHlwZV0pOyAvLyBhdXRvIGNsYXNzXG5cdFx0XHRcdF9hZGRDbGFzcyh0ZCwgb1NldHRpbmdzLm9DbGFzc2VzLnRib2R5LmNlbGwpOyAvLyBhbGwgY2VsbHNcblx0XHRcdH1cblxuXHRcdFx0Ly8gUm93IGNhbGxiYWNrIGZ1bmN0aW9ucyAtIG1pZ2h0IHdhbnQgdG8gbWFuaXB1bGF0ZSB0aGUgcm93XG5cdFx0XHQvLyBpUm93Q291bnQgYW5kIGogYXJlIG5vdCBjdXJyZW50bHkgZG9jdW1lbnRlZC4gQXJlIHRoZXkgYXQgYWxsXG5cdFx0XHQvLyB1c2VmdWw/XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCBudWxsLFxuXHRcdFx0XHRbblJvdywgYW9EYXRhLl9hRGF0YSwgaVJvd0NvdW50LCBqLCBpRGF0YUluZGV4XSApO1xuXG5cdFx0XHRhblJvd3MucHVzaCggblJvdyApO1xuXHRcdFx0aVJvd0NvdW50Kys7XG5cdFx0fVxuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGFuUm93c1sgMCBdID0gX2VtcHR5Um93KG9TZXR0aW5ncyk7XG5cdH1cblxuXHQvKiBIZWFkZXIgYW5kIGZvb3RlciBjYWxsYmFja3MgKi9cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgJ2hlYWRlcicsIFsgJChvU2V0dGluZ3MublRIZWFkKS5jaGlsZHJlbigndHInKVswXSxcblx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgJ2Zvb3RlcicsIFsgJChvU2V0dGluZ3MublRGb290KS5jaGlsZHJlbigndHInKVswXSxcblx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cblx0Ly8gcmVwbGFjZUNoaWxkcmVuIGlzIGZhc3RlciwgYnV0IG9ubHkgYmVjYW1lIHdpZGVzcHJlYWQgaW4gMjAyMCxcblx0Ly8gc28gYSBmYWxsIGJhY2sgaW4galF1ZXJ5IGlzIHByb3ZpZGVkIGZvciBvbGRlciBicm93c2Vycy5cblx0aWYgKGJvZHlbMF0ucmVwbGFjZUNoaWxkcmVuKSB7XG5cdFx0Ym9keVswXS5yZXBsYWNlQ2hpbGRyZW4uYXBwbHkoYm9keVswXSwgYW5Sb3dzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0Ym9keS5hcHBlbmQoICQoYW5Sb3dzKSApO1xuXHR9XG5cblx0Ly8gRW1wdHkgdGFibGUgbmVlZHMgYSBzcGVjaWZpYyBjbGFzc1xuXHQkKG9TZXR0aW5ncy5uVGFibGVXcmFwcGVyKS50b2dnbGVDbGFzcygnZHQtZW1wdHktZm9vdGVyJywgJCgndHInLCBvU2V0dGluZ3MublRGb290KS5sZW5ndGggPT09IDApO1xuXG5cdC8qIENhbGwgYWxsIHJlcXVpcmVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGVuZCBvZiBhIGRyYXcgKi9cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICdkcmF3JywgW29TZXR0aW5nc10sIHRydWUgKTtcblxuXHQvKiBEcmF3IGlzIGNvbXBsZXRlLCBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgbXVzdCBiZSBhcyB3ZWxsICovXG5cdG9TZXR0aW5ncy5iU29ydGVkID0gZmFsc2U7XG5cdG9TZXR0aW5ncy5iRmlsdGVyZWQgPSBmYWxzZTtcblx0b1NldHRpbmdzLmJEcmF3aW5nID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBSZWRyYXcgdGhlIHRhYmxlIC0gdGFraW5nIGFjY291bnQgb2YgdGhlIHZhcmlvdXMgZmVhdHVyZXMgd2hpY2ggYXJlIGVuYWJsZWRcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtib29sZWFufSBbaG9sZFBvc2l0aW9uXSBLZWVwIHRoZSBjdXJyZW50IHBhZ2luZyBwb3NpdGlvbi4gQnkgZGVmYXVsdFxuICogICAgdGhlIHBhZ2luZyBpcyByZXNldCB0byB0aGUgZmlyc3QgcGFnZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24sIHJlY29tcHV0ZSApXG57XG5cdHZhclxuXHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdHNvcnQgICAgID0gZmVhdHVyZXMuYlNvcnQsXG5cdFx0ZmlsdGVyICAgPSBmZWF0dXJlcy5iRmlsdGVyO1xuXG5cdGlmIChyZWNvbXB1dGUgPT09IHVuZGVmaW5lZCB8fCByZWNvbXB1dGUgPT09IHRydWUpIHtcblx0XHQvLyBSZXNvbHZlIGFueSBjb2x1bW4gdHlwZXMgdGhhdCBhcmUgdW5rbm93biBkdWUgdG8gYWRkaXRpb24gb3IgaW52YWxpZGF0aW9uXG5cdFx0X2ZuQ29sdW1uVHlwZXMoIHNldHRpbmdzICk7XG5cblx0XHRpZiAoIHNvcnQgKSB7XG5cdFx0XHRfZm5Tb3J0KCBzZXR0aW5ncyApO1xuXHRcdH1cblxuXHRcdGlmICggZmlsdGVyICkge1xuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBmaWx0ZXJpbmcsIHNvIHdlIHdhbnQgdG8ganVzdCB1c2UgdGhlIGRpc3BsYXkgbWFzdGVyXG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIGhvbGRQb3NpdGlvbiAhPT0gdHJ1ZSApIHtcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XG5cdH1cblxuXHQvLyBMZXQgYW55IG1vZHVsZXMga25vdyBhYm91dCB0aGUgZHJhdyBob2xkIHBvc2l0aW9uIHN0YXRlICh1c2VkIGJ5XG5cdC8vIHNjcm9sbGluZyBpbnRlcm5hbGx5KVxuXHRzZXR0aW5ncy5fZHJhd0hvbGQgPSBob2xkUG9zaXRpb247XG5cblx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblxuXHRzZXR0aW5ncy5fZHJhd0hvbGQgPSBmYWxzZTtcbn1cblxuXG4vKlxuICogVGFibGUgaXMgZW1wdHkgLSBjcmVhdGUgYSByb3cgd2l0aCBhbiBlbXB0eSBtZXNzYWdlIGluIGl0XG4gKi9cbmZ1bmN0aW9uIF9lbXB0eVJvdyAoIHNldHRpbmdzICkge1xuXHR2YXIgb0xhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdHZhciB6ZXJvID0gb0xhbmcuc1plcm9SZWNvcmRzO1xuXHR2YXIgZGF0YVNyYyA9IF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICk7XG5cblx0aWYgKFxuXHRcdChzZXR0aW5ncy5pRHJhdyA8IDEgJiYgZGF0YVNyYyA9PT0gJ3NzcCcpIHx8XG5cdFx0KHNldHRpbmdzLmlEcmF3IDw9IDEgJiYgZGF0YVNyYyA9PT0gJ2FqYXgnKVxuXHQpIHtcblx0XHR6ZXJvID0gb0xhbmcuc0xvYWRpbmdSZWNvcmRzO1xuXHR9XG5cdGVsc2UgaWYgKCBvTGFuZy5zRW1wdHlUYWJsZSAmJiBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpID09PSAwIClcblx0e1xuXHRcdHplcm8gPSBvTGFuZy5zRW1wdHlUYWJsZTtcblx0fVxuXG5cdHJldHVybiAkKCAnPHRyLz4nIClcblx0XHQuYXBwZW5kKCAkKCc8dGQgLz4nLCB7XG5cdFx0XHQnY29sU3Bhbic6IF9mblZpc2JsZUNvbHVtbnMoIHNldHRpbmdzICksXG5cdFx0XHQnY2xhc3MnOiAgIHNldHRpbmdzLm9DbGFzc2VzLmVtcHR5LnJvd1xuXHRcdH0gKS5odG1sKCB6ZXJvICkgKVswXTtcbn1cblxuXG4vKipcbiAqIEV4cGFuZCB0aGUgbGF5b3V0IGl0ZW1zIGludG8gYW4gb2JqZWN0IGZvciB0aGUgcmVuZGVyaW5nIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIF9sYXlvdXRJdGVtcyAocm93LCBhbGlnbiwgaXRlbXMpIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuXHRcdGZvciAodmFyIGk9MCA7IGk8aXRlbXMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRfbGF5b3V0SXRlbXMocm93LCBhbGlnbiwgaXRlbXNbaV0pO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciByb3dDZWxsID0gcm93W2FsaWduXTtcblxuXHQvLyBJZiBpdCBpcyBhbiBvYmplY3QsIHRoZW4gdGhlcmUgY2FuIGJlIG11bHRpcGxlIGZlYXR1cmVzIGNvbnRhaW5lZCBpbiBpdFxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggaXRlbXMgKSApIHtcblx0XHQvLyBBIGZlYXR1cmUgcGx1Z2luIGNhbm5vdCBiZSBuYW1lZCBcImZlYXR1cmVzXCIgZHVlIHRvIHRoaXMgY2hlY2tcblx0XHRpZiAoaXRlbXMuZmVhdHVyZXMpIHtcblx0XHRcdGlmIChpdGVtcy5yb3dJZCkge1xuXHRcdFx0XHRyb3cuaWQgPSBpdGVtcy5yb3dJZDtcblx0XHRcdH1cblx0XHRcdGlmIChpdGVtcy5yb3dDbGFzcykge1xuXHRcdFx0XHRyb3cuY2xhc3NOYW1lID0gaXRlbXMucm93Q2xhc3M7XG5cdFx0XHR9XG5cblx0XHRcdHJvd0NlbGwuaWQgPSBpdGVtcy5pZDtcblx0XHRcdHJvd0NlbGwuY2xhc3NOYW1lID0gaXRlbXMuY2xhc3NOYW1lO1xuXG5cdFx0XHRfbGF5b3V0SXRlbXMocm93LCBhbGlnbiwgaXRlbXMuZmVhdHVyZXMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdE9iamVjdC5rZXlzKGl0ZW1zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRyb3dDZWxsLmNvbnRlbnRzLnB1c2goIHtcblx0XHRcdFx0XHRmZWF0dXJlOiBrZXksXG5cdFx0XHRcdFx0b3B0czogaXRlbXNba2V5XVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRyb3dDZWxsLmNvbnRlbnRzLnB1c2goaXRlbXMpO1xuXHR9XG59XG5cbi8qKlxuICogRmluZCwgb3IgY3JlYXRlIGEgbGF5b3V0IHJvd1xuICovXG5mdW5jdGlvbiBfbGF5b3V0R2V0Um93KHJvd3MsIHJvd051bSwgYWxpZ24pIHtcblx0dmFyIHJvdztcblxuXHQvLyBGaW5kIGV4aXN0aW5nIHJvd3Ncblx0Zm9yICh2YXIgaT0wOyBpPHJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRyb3cgPSByb3dzW2ldO1xuXG5cdFx0aWYgKHJvdy5yb3dOdW0gPT09IHJvd051bSkge1xuXHRcdFx0Ly8gZnVsbCBpcyBvbiBpdHMgb3duLCBidXQgc3RhcnQgYW5kIGVuZCBzaGFyZSBhIHJvd1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQoYWxpZ24gPT09ICdmdWxsJyAmJiByb3cuZnVsbCkgfHxcblx0XHRcdFx0KChhbGlnbiA9PT0gJ3N0YXJ0JyB8fCBhbGlnbiA9PT0gJ2VuZCcpICYmIChyb3cuc3RhcnQgfHwgcm93LmVuZCkpXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKCEgcm93W2FsaWduXSkge1xuXHRcdFx0XHRcdHJvd1thbGlnbl0gPSB7XG5cdFx0XHRcdFx0XHRjb250ZW50czogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJvdztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBnZXQgdGhpcyBmYXIsIHRoZW4gdGhlcmUgd2FzIG5vIG1hdGNoLCBjcmVhdGUgYSBuZXcgcm93XG5cdHJvdyA9IHtcblx0XHRyb3dOdW06IHJvd051bVx0XG5cdH07XG5cblx0cm93W2FsaWduXSA9IHtcblx0XHRjb250ZW50czogW11cblx0fTtcblxuXHRyb3dzLnB1c2gocm93KTtcblxuXHRyZXR1cm4gcm93O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBgbGF5b3V0YCBvYmplY3QgZ2l2ZW4gYnkgYSB1c2VyIHRvIHRoZSBvYmplY3Qgc3RydWN0dXJlIG5lZWRlZFxuICogZm9yIHRoZSByZW5kZXJlci4gVGhpcyBpcyBkb25lIHR3aWNlLCBvbmNlIGZvciBhYm92ZSBhbmQgb25jZSBmb3IgYmVsb3dcbiAqIHRoZSB0YWJsZS4gT3JkZXJpbmcgbXVzdCBhbHNvIGJlIGNvbnNpZGVyZWQuXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBsYXlvdXQgTGF5b3V0IG9iamVjdCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2lkZSBgdG9wYCBvciBgYm90dG9tYFxuICogQHJldHVybnMgQ29udmVydGVkIGFycmF5IHN0cnVjdHVyZSAtIG9uZSBpdGVtIGZvciBlYWNoIHJvdy5cbiAqL1xuZnVuY3Rpb24gX2xheW91dEFycmF5ICggc2V0dGluZ3MsIGxheW91dCwgc2lkZSApIHtcblx0dmFyIHJvd3MgPSBbXTtcblx0XG5cdC8vIFNwbGl0IG91dCBpbnRvIGFuIGFycmF5XG5cdCQuZWFjaCggbGF5b3V0LCBmdW5jdGlvbiAoIHBvcywgaXRlbXMgKSB7XG5cdFx0aWYgKGl0ZW1zID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gcG9zLm1hdGNoKC9eKFthLXpdKykoWzAtOV0qKShbQS1aYS16XSopJC8pO1xuXHRcdHZhciByb3dOdW0gPSBwYXJ0c1syXVxuXHRcdFx0PyBwYXJ0c1syXSAqIDFcblx0XHRcdDogMDtcblx0XHR2YXIgYWxpZ24gPSBwYXJ0c1szXVxuXHRcdFx0PyBwYXJ0c1szXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHQ6ICdmdWxsJztcblxuXHRcdC8vIEZpbHRlciBvdXQgdGhlIHNpZGUgd2UgYXJlbid0IGludGVyZXN0ZWQgaW5cblx0XHRpZiAocGFydHNbMV0gIT09IHNpZGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBHZXQgb3IgY3JlYXRlIHRoZSByb3cgd2Ugc2hvdWxkIGF0dGFjaCB0b1xuXHRcdHZhciByb3cgPSBfbGF5b3V0R2V0Um93KHJvd3MsIHJvd051bSwgYWxpZ24pO1xuXG5cdFx0X2xheW91dEl0ZW1zKHJvdywgYWxpZ24sIGl0ZW1zKTtcblx0fSk7XG5cblx0Ly8gT3JkZXIgYnkgaXRlbSBpZGVudGlmaWVyXG5cdHJvd3Muc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdHZhciBvcmRlcjEgPSBhLnJvd051bTtcblx0XHR2YXIgb3JkZXIyID0gYi5yb3dOdW07XG5cblx0XHQvLyBJZiBib3RoIGluIHRoZSBzYW1lIHJvdywgdGhlbiB0aGUgcm93IHdpdGggYGZ1bGxgIGNvbWVzIGZpcnN0XG5cdFx0aWYgKG9yZGVyMSA9PT0gb3JkZXIyKSB7XG5cdFx0XHR2YXIgcmV0ID0gYS5mdWxsICYmICEgYi5mdWxsID8gLTEgOiAxO1xuXG5cdFx0XHRyZXR1cm4gc2lkZSA9PT0gJ2JvdHRvbSdcblx0XHRcdFx0PyByZXQgKiAtMVxuXHRcdFx0XHQ6IHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3JkZXIyIC0gb3JkZXIxO1xuXHR9ICk7XG5cblx0Ly8gSW52ZXJ0IGZvciBiZWxvdyB0aGUgdGFibGVcblx0aWYgKCBzaWRlID09PSAnYm90dG9tJyApIHtcblx0XHRyb3dzLnJldmVyc2UoKTtcblx0fVxuXG5cdGZvciAodmFyIHJvdyA9IDA7IHJvdzxyb3dzLmxlbmd0aDsgcm93KyspIHtcblx0XHRkZWxldGUgcm93c1tyb3ddLnJvd051bTtcblxuXHRcdF9sYXlvdXRSZXNvbHZlKHNldHRpbmdzLCByb3dzW3Jvd10pO1xuXHR9XG5cblx0cmV0dXJuIHJvd3M7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBjb250ZW50cyBvZiBhIHJvdydzIGxheW91dCBvYmplY3QgdG8gbm9kZXMgdGhhdCBjYW4gYmUgaW5zZXJ0ZWRcbiAqIGludG8gdGhlIGRvY3VtZW50IGJ5IGEgcmVuZGVyZXIuIEV4ZWN1dGUgZnVuY3Rpb25zLCBsb29rIHVwIHBsdWctaW5zLCBldGMuXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSByb3cgTGF5b3V0IG9iamVjdCBmb3IgdGhpcyByb3dcbiAqL1xuZnVuY3Rpb24gX2xheW91dFJlc29sdmUoIHNldHRpbmdzLCByb3cgKSB7XG5cdHZhciBnZXRGZWF0dXJlID0gZnVuY3Rpb24gKGZlYXR1cmUsIG9wdHMpIHtcblx0XHRpZiAoICEgX2V4dC5mZWF0dXJlc1sgZmVhdHVyZSBdICkge1xuXHRcdFx0X2ZuTG9nKCBzZXR0aW5ncywgMCwgJ1Vua25vd24gZmVhdHVyZTogJysgZmVhdHVyZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBfZXh0LmZlYXR1cmVzWyBmZWF0dXJlIF0uYXBwbHkoIHRoaXMsIFtzZXR0aW5ncywgb3B0c10gKTtcblx0fTtcblxuXHR2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uICggaXRlbSApIHtcblx0XHRpZiAoISByb3dbIGl0ZW0gXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsaW5lID0gcm93WyBpdGVtIF0uY29udGVudHM7XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49bGluZS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggISBsaW5lW2ldICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgbGluZVtpXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGxpbmVbaV0gPSBnZXRGZWF0dXJlKCBsaW5lW2ldLCBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggJC5pc1BsYWluT2JqZWN0KGxpbmVbaV0pICkge1xuXHRcdFx0XHQvLyBJZiBpdCdzIGFuIG9iamVjdCwgaXQganVzdCBoYXMgZmVhdHVyZSBhbmQgb3B0cyBwcm9wZXJ0aWVzIGZyb21cblx0XHRcdFx0Ly8gdGhlIHRyYW5zZm9ybSBpbiBfbGF5b3V0QXJyYXlcblx0XHRcdFx0bGluZVtpXSA9IGdldEZlYXR1cmUobGluZVtpXS5mZWF0dXJlLCBsaW5lW2ldLm9wdHMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBsaW5lW2ldLm5vZGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGxpbmVbaV0gPSBsaW5lW2ldLm5vZGUoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIGxpbmVbaV0gPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHZhciBpbnN0ID0gbGluZVtpXSggc2V0dGluZ3MgKTtcblxuXHRcdFx0XHRsaW5lW2ldID0gdHlwZW9mIGluc3Qubm9kZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdFx0aW5zdC5ub2RlKCkgOlxuXHRcdFx0XHRcdGluc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHJlc29sdmUoJ3N0YXJ0Jyk7XG5cdHJlc29sdmUoJ2VuZCcpO1xuXHRyZXNvbHZlKCdmdWxsJyk7XG59XG5cblxuLyoqXG4gKiBBZGQgdGhlIG9wdGlvbnMgdG8gdGhlIHBhZ2UgSFRNTCBmb3IgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFkZE9wdGlvbnNIdG1sICggc2V0dGluZ3MgKVxue1xuXHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHR2YXIgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSk7XG5cblx0Ly8gV3JhcHBlciBkaXYgYXJvdW5kIGV2ZXJ5dGhpbmcgRGF0YVRhYmxlcyBjb250cm9sc1xuXHR2YXIgaW5zZXJ0ID0gJCgnPGRpdi8+Jylcblx0XHQuYXR0cih7XG5cdFx0XHRpZDogICAgICBzZXR0aW5ncy5zVGFibGVJZCsnX3dyYXBwZXInLFxuXHRcdFx0J2NsYXNzJzogY2xhc3Nlcy5jb250YWluZXJcblx0XHR9KVxuXHRcdC5pbnNlcnRCZWZvcmUodGFibGUpO1xuXG5cdHNldHRpbmdzLm5UYWJsZVdyYXBwZXIgPSBpbnNlcnRbMF07XG5cblx0aWYgKHNldHRpbmdzLnNEb20pIHtcblx0XHQvLyBMZWdhY3lcblx0XHRfZm5MYXlvdXREb20oc2V0dGluZ3MsIHNldHRpbmdzLnNEb20sIGluc2VydCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dmFyIHRvcCA9IF9sYXlvdXRBcnJheSggc2V0dGluZ3MsIHNldHRpbmdzLmxheW91dCwgJ3RvcCcgKTtcblx0XHR2YXIgYm90dG9tID0gX2xheW91dEFycmF5KCBzZXR0aW5ncywgc2V0dGluZ3MubGF5b3V0LCAnYm90dG9tJyApO1xuXHRcdHZhciByZW5kZXJlciA9IF9mblJlbmRlcmVyKCBzZXR0aW5ncywgJ2xheW91dCcgKTtcblx0XG5cdFx0Ly8gRXZlcnl0aGluZyBhYm92ZSAtIHRoZSByZW5kZXJlciB3aWxsIGFjdHVhbGx5IGluc2VydCB0aGUgY29udGVudHMgaW50byB0aGUgZG9jdW1lbnRcblx0XHR0b3AuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0cmVuZGVyZXIoIHNldHRpbmdzLCBpbnNlcnQsIGl0ZW0gKTtcblx0XHR9KTtcblxuXHRcdC8vIFRoZSB0YWJsZSAtIGFsd2F5cyB0aGUgY2VudGVyIG9mIGF0dGVudGlvblxuXHRcdHJlbmRlcmVyKCBzZXR0aW5ncywgaW5zZXJ0LCB7XG5cdFx0XHRmdWxsOiB7XG5cdFx0XHRcdHRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb250ZW50czogWyBfZm5GZWF0dXJlSHRtbFRhYmxlKHNldHRpbmdzKSBdXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gRXZlcnl0aGluZyBiZWxvd1xuXHRcdGJvdHRvbS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRyZW5kZXJlciggc2V0dGluZ3MsIGluc2VydCwgaXRlbSApO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gUHJvY2Vzc2luZyBmbG9hdHMgb24gdG9wLCBzbyBpdCBpc24ndCBhbiBpbnNlcnRlZCBmZWF0dXJlXG5cdF9wcm9jZXNzaW5nSHRtbCggc2V0dGluZ3MgKTtcbn1cblxuLyoqXG4gKiBEcmF3IHRoZSB0YWJsZSB3aXRoIHRoZSBsZWdhY3kgRE9NIHByb3BlcnR5XG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERUIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBkb20gRE9NIHN0cmluZ1xuICogQHBhcmFtIHsqfSBpbnNlcnQgSW5zZXJ0IHBvaW50XG4gKi9cbmZ1bmN0aW9uIF9mbkxheW91dERvbSggc2V0dGluZ3MsIGRvbSwgaW5zZXJ0IClcbntcblx0dmFyIHBhcnRzID0gZG9tLm1hdGNoKC8oXCIuKj9cIil8KCcuKj8nKXwuL2cpO1xuXHR2YXIgZmVhdHVyZU5vZGUsIG9wdGlvbiwgbmV3Tm9kZSwgbmV4dCwgYXR0cjtcblxuXHRmb3IgKCB2YXIgaT0wIDsgaTxwYXJ0cy5sZW5ndGggOyBpKysgKSB7XG5cdFx0ZmVhdHVyZU5vZGUgPSBudWxsO1xuXHRcdG9wdGlvbiA9IHBhcnRzW2ldO1xuXG5cdFx0aWYgKCBvcHRpb24gPT0gJzwnICkge1xuXHRcdFx0Ly8gTmV3IGNvbnRhaW5lciBkaXZcblx0XHRcdG5ld05vZGUgPSAkKCc8ZGl2Lz4nKTtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBhcHBlbmQgYW4gaWQgYW5kL29yIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyXG5cdFx0XHRuZXh0ID0gcGFydHNbaSsxXTtcblxuXHRcdFx0aWYgKCBuZXh0WzBdID09IFwiJ1wiIHx8IG5leHRbMF0gPT0gJ1wiJyApIHtcblx0XHRcdFx0YXR0ciA9IG5leHQucmVwbGFjZSgvWydcIl0vZywgJycpO1xuXG5cdFx0XHRcdHZhciBpZCA9ICcnLCBjbGFzc05hbWU7XG5cblx0XHRcdFx0LyogVGhlIGF0dHJpYnV0ZSBjYW4gYmUgaW4gdGhlIGZvcm1hdCBvZiBcIiNpZC5jbGFzc1wiLCBcIiNpZFwiIG9yIFwiY2xhc3NcIiBUaGlzIGxvZ2ljXG5cdFx0XHRcdCAqIGJyZWFrcyB0aGUgc3RyaW5nIGludG8gcGFydHMgYW5kIGFwcGxpZXMgdGhlbSBhcyBuZWVkZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggYXR0ci5pbmRleE9mKCcuJykgIT0gLTEgKSB7XG5cdFx0XHRcdFx0dmFyIHNwbGl0ID0gYXR0ci5zcGxpdCgnLicpO1xuXG5cdFx0XHRcdFx0aWQgPSBzcGxpdFswXTtcblx0XHRcdFx0XHRjbGFzc05hbWUgPSBzcGxpdFsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggYXR0clswXSA9PSBcIiNcIiApIHtcblx0XHRcdFx0XHRpZCA9IGF0dHI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lID0gYXR0cjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld05vZGVcblx0XHRcdFx0XHQuYXR0cignaWQnLCBpZC5zdWJzdHJpbmcoMSkpXG5cdFx0XHRcdFx0LmFkZENsYXNzKGNsYXNzTmFtZSk7XG5cblx0XHRcdFx0aSsrOyAvLyBNb3ZlIGFsb25nIHRoZSBwb3NpdGlvbiBhcnJheVxuXHRcdFx0fVxuXG5cdFx0XHRpbnNlcnQuYXBwZW5kKCBuZXdOb2RlICk7XG5cdFx0XHRpbnNlcnQgPSBuZXdOb2RlO1xuXHRcdH1cblx0XHRlbHNlIGlmICggb3B0aW9uID09ICc+JyApIHtcblx0XHRcdC8vIEVuZCBjb250YWluZXIgZGl2XG5cdFx0XHRpbnNlcnQgPSBpbnNlcnQucGFyZW50KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcHRpb24gPT0gJ3QnICkge1xuXHRcdFx0Ly8gVGFibGVcblx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxUYWJsZSggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdERhdGFUYWJsZS5leHQuZmVhdHVyZS5mb3JFYWNoKGZ1bmN0aW9uKGZlYXR1cmUpIHtcblx0XHRcdFx0aWYgKCBvcHRpb24gPT0gZmVhdHVyZS5jRmVhdHVyZSApIHtcblx0XHRcdFx0XHRmZWF0dXJlTm9kZSA9IGZlYXR1cmUuZm5Jbml0KCBzZXR0aW5ncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBZGQgdG8gdGhlIGRpc3BsYXlcblx0XHRpZiAoIGZlYXR1cmVOb2RlICkge1xuXHRcdFx0aW5zZXJ0LmFwcGVuZCggZmVhdHVyZU5vZGUgKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIFVzZSB0aGUgRE9NIHNvdXJjZSB0byBjcmVhdGUgdXAgYW4gYXJyYXkgb2YgaGVhZGVyIGNlbGxzLiBUaGUgaWRlYSBoZXJlIGlzIHRvXG4gKiBjcmVhdGUgYSBsYXlvdXQgZ3JpZCAoYXJyYXkpIG9mIHJvd3MgeCBjb2x1bW5zLCB3aGljaCBjb250YWlucyBhIHJlZmVyZW5jZVxuICogdG8gdGhlIGNlbGwgdGhhdCB0aGF0IHBvaW50IGluIHRoZSBncmlkIChyZWdhcmRsZXNzIG9mIGNvbC9yb3dzcGFuKSwgc3VjaCB0aGF0XG4gKiBhbnkgY29sdW1uIC8gcm93IGNvdWxkIGJlIHJlbW92ZWQgYW5kIHRoZSBuZXcgZ3JpZCBjb25zdHJ1Y3RlZFxuICogIEBwYXJhbSB7bm9kZX0gdGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXG4gKiAgQHJldHVybnMge2FycmF5fSBDYWxjdWxhdGVkIGxheW91dCBhcnJheVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5EZXRlY3RIZWFkZXIgKCBzZXR0aW5ncywgdGhlYWQsIHdyaXRlIClcbntcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciByb3dzID0gJCh0aGVhZCkuY2hpbGRyZW4oJ3RyJyk7XG5cdHZhciByb3csIGNlbGw7XG5cdHZhciBpLCBrLCBsLCBpTGVuLCBzaGlmdGVkLCBjb2x1bW4sIGNvbHNwYW4sIHJvd3NwYW47XG5cdHZhciBpc0hlYWRlciA9IHRoZWFkICYmIHRoZWFkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0aGVhZCc7XG5cdHZhciBsYXlvdXQgPSBbXTtcblx0dmFyIHVuaXF1ZTtcblx0dmFyIHNoaWZ0ID0gZnVuY3Rpb24gKCBhLCBpLCBqICkge1xuXHRcdHZhciBrID0gYVtpXTtcblx0XHR3aGlsZSAoIGtbal0gKSB7XG5cdFx0XHRqKys7XG5cdFx0fVxuXHRcdHJldHVybiBqO1xuXHR9O1xuXG5cdC8vIFdlIGtub3cgaG93IG1hbnkgcm93cyB0aGVyZSBhcmUgaW4gdGhlIGxheW91dCAtIHNvIHByZXAgaXRcblx0Zm9yICggaT0wLCBpTGVuPXJvd3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdGxheW91dC5wdXNoKCBbXSApO1xuXHR9XG5cblx0Zm9yICggaT0wLCBpTGVuPXJvd3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdHJvdyA9IHJvd3NbaV07XG5cdFx0Y29sdW1uID0gMDtcblxuXHRcdC8vIEZvciBldmVyeSBjZWxsIGluIHRoZSByb3cuLlxuXHRcdGNlbGwgPSByb3cuZmlyc3RDaGlsZDtcblx0XHR3aGlsZSAoIGNlbGwgKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnVEQnIHx8XG5cdFx0XHRcdGNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnVEgnXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIGNvbHMgPSBbXTtcblxuXHRcdFx0XHQvLyBHZXQgdGhlIGNvbCBhbmQgcm93c3BhbiBhdHRyaWJ1dGVzIGZyb20gdGhlIERPTSBhbmQgc2FuaXRpc2UgdGhlbVxuXHRcdFx0XHRjb2xzcGFuID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSAqIDE7XG5cdFx0XHRcdHJvd3NwYW4gPSBjZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpICogMTtcblx0XHRcdFx0Y29sc3BhbiA9ICghY29sc3BhbiB8fCBjb2xzcGFuPT09MCB8fCBjb2xzcGFuPT09MSkgPyAxIDogY29sc3Bhbjtcblx0XHRcdFx0cm93c3BhbiA9ICghcm93c3BhbiB8fCByb3dzcGFuPT09MCB8fCByb3dzcGFuPT09MSkgPyAxIDogcm93c3BhbjtcblxuXHRcdFx0XHQvLyBUaGVyZSBtaWdodCBiZSBjb2xzcGFuIGNlbGxzIGFscmVhZHkgaW4gdGhpcyByb3csIHNvIHNoaWZ0IG91ciB0YXJnZXRcblx0XHRcdFx0Ly8gYWNjb3JkaW5nbHlcblx0XHRcdFx0c2hpZnRlZCA9IHNoaWZ0KCBsYXlvdXQsIGksIGNvbHVtbiApO1xuXG5cdFx0XHRcdC8vIENhY2hlIGNhbGN1bGF0aW9uIGZvciB1bmlxdWUgY29sdW1uc1xuXHRcdFx0XHR1bmlxdWUgPSBjb2xzcGFuID09PSAxID9cblx0XHRcdFx0XHR0cnVlIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFBlcmZvcm0gaGVhZGVyIHNldHVwXG5cdFx0XHRcdGlmICggd3JpdGUgKSB7XG5cdFx0XHRcdFx0aWYgKHVuaXF1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gQWxsb3cgY29sdW1uIG9wdGlvbnMgdG8gYmUgc2V0IGZyb20gSFRNTCBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBzZXR0aW5ncywgc2hpZnRlZCwgJChjZWxsKS5kYXRhKCkgKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSB3aWR0aCBmb3IgdGhlIGNvbHVtbi4gVGhpcyBjYW4gYmUgZGVmaW5lZCBmcm9tIHRoZVxuXHRcdFx0XHRcdFx0Ly8gd2lkdGggYXR0cmlidXRlLCBzdHlsZSBhdHRyaWJ1dGUgb3IgYGNvbHVtbnMud2lkdGhgIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFyIGNvbHVtbkRlZiA9IGNvbHVtbnNbc2hpZnRlZF07XG5cdFx0XHRcdFx0XHR2YXIgd2lkdGggPSBjZWxsLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCBudWxsO1xuXHRcdFx0XHRcdFx0dmFyIHQgPSBjZWxsLnN0eWxlLndpZHRoLm1hdGNoKC93aWR0aDpcXHMqKFxcZCtbcHhlbSVdKykvKTtcblx0XHRcdFx0XHRcdGlmICggdCApIHtcblx0XHRcdFx0XHRcdFx0d2lkdGggPSB0WzFdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb2x1bW5EZWYuc1dpZHRoT3JpZyA9IGNvbHVtbkRlZi5zV2lkdGggfHwgd2lkdGg7XG5cblx0XHRcdFx0XHRcdGlmIChpc0hlYWRlcikge1xuXHRcdFx0XHRcdFx0XHQvLyBDb2x1bW4gdGl0bGUgaGFuZGxpbmcgLSBjYW4gYmUgdXNlciBzZXQsIG9yIHJlYWQgZnJvbSB0aGUgRE9NXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaGFwcGVucyBiZWZvcmUgdGhlIHJlbmRlciwgc28gdGhlIG9yaWdpbmFsIGlzIHN0aWxsIGluIHBsYWNlXG5cdFx0XHRcdFx0XHRcdGlmICggY29sdW1uRGVmLnNUaXRsZSAhPT0gbnVsbCAmJiAhIGNvbHVtbkRlZi5hdXRvVGl0bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2VsbC5pbm5lckhUTUwgPSBjb2x1bW5EZWYuc1RpdGxlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCEgY29sdW1uRGVmLnNUaXRsZSAmJiB1bmlxdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW5EZWYuc1RpdGxlID0gX3N0cmlwSHRtbChjZWxsLmlubmVySFRNTCk7XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uRGVmLmF1dG9UaXRsZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBGb290ZXIgc3BlY2lmaWMgb3BlcmF0aW9uc1xuXHRcdFx0XHRcdFx0XHRpZiAoY29sdW1uRGVmLmZvb3Rlcikge1xuXHRcdFx0XHRcdFx0XHRcdGNlbGwuaW5uZXJIVE1MID0gY29sdW1uRGVmLmZvb3Rlcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgdG8gdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9uIHRoZSB0YWJsZSBoZWFkZXIgaWYgbm8gYXJpYVRpdGxlIGlzXG5cdFx0XHRcdFx0XHQvLyBwcm92aWRlZC5cblx0XHRcdFx0XHRcdGlmICghIGNvbHVtbkRlZi5hcmlhVGl0bGUpIHtcblx0XHRcdFx0XHRcdFx0Y29sdW1uRGVmLmFyaWFUaXRsZSA9ICQoY2VsbCkuYXR0cihcImFyaWEtbGFiZWxcIikgfHwgY29sdW1uRGVmLnNUaXRsZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQ29sdW1uIHNwZWNpZmljIGNsYXNzIG5hbWVzXG5cdFx0XHRcdFx0XHRpZiAoIGNvbHVtbkRlZi5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0XHRcdCQoY2VsbCkuYWRkQ2xhc3MoIGNvbHVtbkRlZi5jbGFzc05hbWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBXcmFwIHRoZSBjb2x1bW4gdGl0bGUgc28gd2UgY2FuIHdyaXRlIHRvIGl0IGluIGZ1dHVyZVxuXHRcdFx0XHRcdGlmICggJCgnc3Bhbi5kdC1jb2x1bW4tdGl0bGUnLCBjZWxsKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdCQoJzxzcGFuPicpXG5cdFx0XHRcdFx0XHRcdC5hZGRDbGFzcygnZHQtY29sdW1uLXRpdGxlJylcblx0XHRcdFx0XHRcdFx0LmFwcGVuZChjZWxsLmNoaWxkTm9kZXMpXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyhjZWxsKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGlzSGVhZGVyICYmICQoJ3NwYW4uZHQtY29sdW1uLW9yZGVyJywgY2VsbCkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHQkKCc8c3Bhbj4nKVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoJ2R0LWNvbHVtbi1vcmRlcicpXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyhjZWxsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBjb2wgLyByb3dzcGFuLCBjb3B5IHRoZSBpbmZvcm1hdGlvbiBpbnRvIHRoZSBsYXlvdXQgZ3JpZFxuXHRcdFx0XHRmb3IgKCBsPTAgOyBsPGNvbHNwYW4gOyBsKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggaz0wIDsgazxyb3dzcGFuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0bGF5b3V0W2kra11bc2hpZnRlZCtsXSA9IHtcblx0XHRcdFx0XHRcdFx0Y2VsbDogY2VsbCxcblx0XHRcdFx0XHRcdFx0dW5pcXVlOiB1bmlxdWVcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGxheW91dFtpK2tdLnJvdyA9IHJvdztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb2xzLnB1c2goIHNoaWZ0ZWQrbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXNzaWduIGFuIGF0dHJpYnV0ZSBzbyBzcGFubmluZyBjZWxscyBjYW4gc3RpbGwgYmUgaWRlbnRpZmllZFxuXHRcdFx0XHQvLyBhcyBiZWxvbmdpbmcgdG8gYSBjb2x1bW5cblx0XHRcdFx0Y2VsbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZHQtY29sdW1uJywgX3VuaXF1ZShjb2xzKS5qb2luKCcsJykpO1xuXHRcdFx0fVxuXG5cdFx0XHRjZWxsID0gY2VsbC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbGF5b3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gZm9yIGRyYXdcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9mblN0YXJ0KCBvU2V0dGluZ3MgKVxue1xuXHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0dmFyIGlJbml0RGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xuXG5cdC8vIENoZWNrIGFuZCBzZWUgaWYgd2UgaGF2ZSBhbiBpbml0aWFsIGRyYXcgcG9zaXRpb24gZnJvbSBzdGF0ZSBzYXZpbmdcblx0aWYgKCBpSW5pdERpc3BsYXlTdGFydCAhPT0gdW5kZWZpbmVkICYmIGlJbml0RGlzcGxheVN0YXJ0ICE9PSAtMSApXG5cdHtcblx0XHRvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBiU2VydmVyU2lkZSA/XG5cdFx0XHRpSW5pdERpc3BsYXlTdGFydCA6XG5cdFx0XHRpSW5pdERpc3BsYXlTdGFydCA+PSBvU2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpID9cblx0XHRcdFx0MCA6XG5cdFx0XHRcdGlJbml0RGlzcGxheVN0YXJ0O1xuXG5cdFx0b1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gLTE7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gQWpheCBjYWxsIGJhc2VkIG9uIHRoZSB0YWJsZSdzIHNldHRpbmdzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXRcbiAqIHBhcmFtZXRlcnMgY2FuIGhhdmUgbXVsdGlwbGUgZm9ybXMsIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyLCByZXF1aXJlZCBieVxuICogICAgIERhdGFUYWJsZXMgLSBtYXkgYmUgYXVnbWVudGVkIGJ5IGRldmVsb3BlciBjYWxsYmFja3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRhdGEgaXMgb2J0YWluZWRcbiAqL1xuZnVuY3Rpb24gX2ZuQnVpbGRBamF4KCBvU2V0dGluZ3MsIGRhdGEsIGZuIClcbntcblx0dmFyIGFqYXhEYXRhO1xuXHR2YXIgYWpheCA9IG9TZXR0aW5ncy5hamF4O1xuXHR2YXIgaW5zdGFuY2UgPSBvU2V0dGluZ3Mub0luc3RhbmNlO1xuXHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0dmFyIHN0YXR1cyA9IG9TZXR0aW5ncy5qcVhIUlxuXHRcdFx0PyBvU2V0dGluZ3MuanFYSFIuc3RhdHVzXG5cdFx0XHQ6IG51bGw7XG5cblx0XHRpZiAoIGpzb24gPT09IG51bGwgfHwgKHR5cGVvZiBzdGF0dXMgPT09ICdudW1iZXInICYmIHN0YXR1cyA9PSAyMDQgKSApIHtcblx0XHRcdGpzb24gPSB7fTtcblx0XHRcdF9mbkFqYXhEYXRhU3JjKCBvU2V0dGluZ3MsIGpzb24sIFtdICk7XG5cdFx0fVxuXG5cdFx0dmFyIGVycm9yID0ganNvbi5lcnJvciB8fCBqc29uLnNFcnJvcjtcblx0XHRpZiAoIGVycm9yICkge1xuXHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsIGVycm9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWljcm9zb2Z0IG9mdGVuIHdyYXAgSlNPTiBhcyBhIHN0cmluZyBpbiBhbm90aGVyIEpTT04gb2JqZWN0XG5cdFx0Ly8gTGV0J3MgaGFuZGxlIHRoYXQgYXV0b21hdGljYWxseVxuXHRcdGlmIChqc29uLmQgJiYgdHlwZW9mIGpzb24uZCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKGpzb24uZCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBub29wXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b1NldHRpbmdzLmpzb24gPSBqc29uO1xuXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBqc29uLCBvU2V0dGluZ3MuanFYSFJdLCB0cnVlICk7XG5cdFx0Zm4oIGpzb24gKTtcblx0fTtcblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggYWpheCApICYmIGFqYXguZGF0YSApXG5cdHtcblx0XHRhamF4RGF0YSA9IGFqYXguZGF0YTtcblxuXHRcdHZhciBuZXdEYXRhID0gdHlwZW9mIGFqYXhEYXRhID09PSAnZnVuY3Rpb24nID9cblx0XHRcdGFqYXhEYXRhKCBkYXRhLCBvU2V0dGluZ3MgKSA6ICAvLyBmbiBjYW4gbWFuaXB1bGF0ZSBkYXRhIG9yIHJldHVyblxuXHRcdFx0YWpheERhdGE7ICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvYmplY3Qgb3IgYXJyYXkgdG8gbWVyZ2VcblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcsIHVzZSB0aGF0IGFsb25lXG5cdFx0ZGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXdEYXRhID9cblx0XHRcdG5ld0RhdGEgOlxuXHRcdFx0JC5leHRlbmQoIHRydWUsIGRhdGEsIG5ld0RhdGEgKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgZGF0YSBwcm9wZXJ0eSBhcyB3ZSd2ZSByZXNvbHZlZCBpdCBhbHJlYWR5IGFuZCBkb24ndCB3YW50XG5cdFx0Ly8galF1ZXJ5IHRvIGRvIGl0IGFnYWluIChpdCBpcyByZXN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbilcblx0XHRkZWxldGUgYWpheC5kYXRhO1xuXHR9XG5cblx0dmFyIGJhc2VBamF4ID0ge1xuXHRcdFwidXJsXCI6IHR5cGVvZiBhamF4ID09PSAnc3RyaW5nJyA/XG5cdFx0XHRhamF4IDpcblx0XHRcdCcnLFxuXHRcdFwiZGF0YVwiOiBkYXRhLFxuXHRcdFwic3VjY2Vzc1wiOiBjYWxsYmFjayxcblx0XHRcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdFwiY2FjaGVcIjogZmFsc2UsXG5cdFx0XCJ0eXBlXCI6IG9TZXR0aW5ncy5zU2VydmVyTWV0aG9kLFxuXHRcdFwiZXJyb3JcIjogZnVuY3Rpb24gKHhociwgZXJyb3IpIHtcblx0XHRcdHZhciByZXQgPSBfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIG51bGwsIG9TZXR0aW5ncy5qcVhIUl0sIHRydWUgKTtcblxuXHRcdFx0aWYgKCByZXQuaW5kZXhPZih0cnVlKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGlmICggZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiICkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW52YWxpZCBKU09OIHJlc3BvbnNlJywgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0FqYXggZXJyb3InLCA3ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gSWYgYGFqYXhgIG9wdGlvbiBpcyBhbiBvYmplY3QsIGV4dGVuZCBhbmQgb3ZlcnJpZGUgb3VyIGRlZmF1bHQgYmFzZVxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggYWpheCApICkge1xuXHRcdCQuZXh0ZW5kKCBiYXNlQWpheCwgYWpheCApXG5cdH1cblxuXHQvLyBTdG9yZSB0aGUgZGF0YSBzdWJtaXR0ZWQgZm9yIHRoZSBBUElcblx0b1NldHRpbmdzLm9BamF4RGF0YSA9IGRhdGE7XG5cblx0Ly8gQWxsb3cgcGx1Zy1pbnMgYW5kIGV4dGVybmFsIHByb2Nlc3NlcyB0byBtb2RpZnkgdGhlIGRhdGFcblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdwcmVYaHInLCBbb1NldHRpbmdzLCBkYXRhLCBiYXNlQWpheF0sIHRydWUgKTtcblxuXHRpZiAoIHR5cGVvZiBhamF4ID09PSAnZnVuY3Rpb24nIClcblx0e1xuXHRcdC8vIElzIGEgZnVuY3Rpb24gLSBsZXQgdGhlIGNhbGxlciBkZWZpbmUgd2hhdCBuZWVkcyB0byBiZSBkb25lXG5cdFx0b1NldHRpbmdzLmpxWEhSID0gYWpheC5jYWxsKCBpbnN0YW5jZSwgZGF0YSwgY2FsbGJhY2ssIG9TZXR0aW5ncyApO1xuXHR9XG5cdGVsc2UgaWYgKGFqYXgudXJsID09PSAnJykge1xuXHRcdC8vIE5vIHVybCwgc28gZG9uJ3QgbG9hZCBhbnkgZGF0YS4gSnVzdCBhcHBseSBhbiBlbXB0eSBkYXRhIGFycmF5XG5cdFx0Ly8gdG8gdGhlIG9iamVjdCBmb3IgdGhlIGNhbGxiYWNrLlxuXHRcdHZhciBlbXB0eSA9IHt9O1xuXG5cdFx0RGF0YVRhYmxlLnV0aWwuc2V0KGFqYXguZGF0YVNyYykoZW1wdHksIFtdKTtcblx0XHRjYWxsYmFjayhlbXB0eSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gT2JqZWN0IHRvIGV4dGVuZCB0aGUgYmFzZSBzZXR0aW5nc1xuXHRcdG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCggYmFzZUFqYXggKTtcblx0fVxuXG5cdC8vIFJlc3RvcmUgZm9yIG5leHQgdGltZSBhcm91bmRcblx0aWYgKCBhamF4RGF0YSApIHtcblx0XHRhamF4LmRhdGEgPSBhamF4RGF0YTtcblx0fVxufVxuXG5cbi8qKlxuICogVXBkYXRlIHRoZSB0YWJsZSB1c2luZyBhbiBBamF4IGNhbGxcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyB7Ym9vbGVhbn0gQmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFqYXhVcGRhdGUoIHNldHRpbmdzIClcbntcblx0c2V0dGluZ3MuaURyYXcrKztcblx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cblx0X2ZuQnVpbGRBamF4KFxuXHRcdHNldHRpbmdzLFxuXHRcdF9mbkFqYXhQYXJhbWV0ZXJzKCBzZXR0aW5ncyApLFxuXHRcdGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdF9mbkFqYXhVcGRhdGVEcmF3KCBzZXR0aW5ncywganNvbiApO1xuXHRcdH1cblx0KTtcbn1cblxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBwYXJhbWV0ZXJzIGluIGFuIG9iamVjdCBuZWVkZWQgZm9yIGEgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuICogcmVxdWVzdC5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge2Jvb2x9IGJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdHByZVNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCxcblx0XHRwcmVDb2xTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHMsXG5cdFx0Y29sRGF0YSA9IGZ1bmN0aW9uICggaWR4LCBwcm9wICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBjb2x1bW5zW2lkeF1bcHJvcF0gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQnZnVuY3Rpb24nIDpcblx0XHRcdFx0Y29sdW1uc1tpZHhdW3Byb3BdO1xuXHRcdH07XG5cblx0cmV0dXJuIHtcblx0XHRkcmF3OiBzZXR0aW5ncy5pRHJhdyxcblx0XHRjb2x1bW5zOiBjb2x1bW5zLm1hcCggZnVuY3Rpb24gKCBjb2x1bW4sIGkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBjb2xEYXRhKGksICdtRGF0YScpLFxuXHRcdFx0XHRuYW1lOiBjb2x1bW4uc05hbWUsXG5cdFx0XHRcdHNlYXJjaGFibGU6IGNvbHVtbi5iU2VhcmNoYWJsZSxcblx0XHRcdFx0b3JkZXJhYmxlOiBjb2x1bW4uYlNvcnRhYmxlLFxuXHRcdFx0XHRzZWFyY2g6IHtcblx0XHRcdFx0XHR2YWx1ZTogcHJlQ29sU2VhcmNoW2ldLnNlYXJjaCxcblx0XHRcdFx0XHRyZWdleDogcHJlQ29sU2VhcmNoW2ldLnJlZ2V4LFxuXHRcdFx0XHRcdGZpeGVkOiBPYmplY3Qua2V5cyhjb2x1bW4uc2VhcmNoRml4ZWQpLm1hcCggZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdFx0dGVybTogY29sdW1uLnNlYXJjaEZpeGVkW25hbWVdLnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gKSxcblx0XHRvcmRlcjogX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICkubWFwKCBmdW5jdGlvbiAoIHZhbCApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvbHVtbjogdmFsLmNvbCxcblx0XHRcdFx0ZGlyOiB2YWwuZGlyLFxuXHRcdFx0XHRuYW1lOiBjb2xEYXRhKHZhbC5jb2wsICdzTmFtZScpXG5cdFx0XHR9O1xuXHRcdH0gKSxcblx0XHRzdGFydDogc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuZ3RoOiBmZWF0dXJlcy5iUGFnaW5hdGUgP1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDpcblx0XHRcdC0xLFxuXHRcdHNlYXJjaDoge1xuXHRcdFx0dmFsdWU6IHByZVNlYXJjaC5zZWFyY2gsXG5cdFx0XHRyZWdleDogcHJlU2VhcmNoLnJlZ2V4LFxuXHRcdFx0Zml4ZWQ6IE9iamVjdC5rZXlzKHNldHRpbmdzLnNlYXJjaEZpeGVkKS5tYXAoIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdHRlcm06IHNldHRpbmdzLnNlYXJjaEZpeGVkW25hbWVdLnRvU3RyaW5nKClcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdH07XG59XG5cblxuLyoqXG4gKiBEYXRhIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciAobnVraW5nIHRoZSBvbGQpIGFuZCByZWRyYXcgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIGpzb24gZGF0YSByZXR1cm4gZnJvbSB0aGUgc2VydmVyLlxuICogIEBwYXJhbSB7c3RyaW5nfSBqc29uLnNFY2hvIFRyYWNraW5nIGZsYWcgZm9yIERhdGFUYWJsZXMgdG8gbWF0Y2ggcmVxdWVzdHNcbiAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgbm90IGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuICogIEBwYXJhbSB7aW50fSBqc29uLmlUb3RhbERpc3BsYXlSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgYWNjb3VudGluZyBmb3IgZmlsdGVyaW5nXG4gKiAgQHBhcmFtIHthcnJheX0ganNvbi5hYURhdGEgVGhlIGRhdGEgdG8gZGlzcGxheSBvbiB0aGlzIHBhZ2VcbiAqICBAcGFyYW0ge3N0cmluZ30gW2pzb24uc0NvbHVtbnNdIENvbHVtbiBvcmRlcmluZyAoc05hbWUsIGNvbW1hIHNlcGFyYXRlZClcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZURyYXcgKCBzZXR0aW5ncywganNvbiApXG57XG5cdHZhciBkYXRhID0gX2ZuQWpheERhdGFTcmMoc2V0dGluZ3MsIGpzb24pO1xuXHR2YXIgZHJhdyA9IF9mbkFqYXhEYXRhU3JjUGFyYW0oc2V0dGluZ3MsICdkcmF3JywganNvbik7XG5cdHZhciByZWNvcmRzVG90YWwgPSBfZm5BamF4RGF0YVNyY1BhcmFtKHNldHRpbmdzLCAncmVjb3Jkc1RvdGFsJywganNvbik7XG5cdHZhciByZWNvcmRzRmlsdGVyZWQgPSBfZm5BamF4RGF0YVNyY1BhcmFtKHNldHRpbmdzLCAncmVjb3Jkc0ZpbHRlcmVkJywganNvbik7XG5cblx0aWYgKCBkcmF3ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IG91dCBvZiBzZXF1ZW5jZSByZXR1cm5zXG5cdFx0aWYgKCBkcmF3KjEgPCBzZXR0aW5ncy5pRHJhdyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c2V0dGluZ3MuaURyYXcgPSBkcmF3ICogMTtcblx0fVxuXG5cdC8vIE5vIGRhdGEgaW4gcmV0dXJuZWQgb2JqZWN0LCBzbyByYXRoZXIgdGhhbiBhbiBhcnJheSwgd2Ugc2hvdyBhbiBlbXB0eSB0YWJsZVxuXHRpZiAoICEgZGF0YSApIHtcblx0XHRkYXRhID0gW107XG5cdH1cblxuXHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRzZXR0aW5ncy5faVJlY29yZHNUb3RhbCAgID0gcGFyc2VJbnQocmVjb3Jkc1RvdGFsLCAxMCk7XG5cdHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSBwYXJzZUludChyZWNvcmRzRmlsdGVyZWQsIDEwKTtcblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHR9XG5cdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXG5cdF9mbkNvbHVtblR5cGVzKHNldHRpbmdzKTtcblx0X2ZuRHJhdyggc2V0dGluZ3MsIHRydWUgKTtcblx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncyApO1xuXHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgSlNPTiBkYXRhIHNvdXJjZSB0byB1c2UgZm9yIGRyYXdpbmcgYSB0YWJsZS4gVXNpbmdcbiAqIGBfZm5HZXRPYmplY3REYXRhRm5gIGFsbG93cyB0aGUgZGF0YSB0byBiZSBzb3VyY2VkIGZyb20gYSBwcm9wZXJ0eSBvZiB0aGVcbiAqIHNvdXJjZSBvYmplY3QsIG9yIGZyb20gYSBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSAge29iamVjdH0ganNvbiBEYXRhIHNvdXJjZSBvYmplY3QgLyBhcnJheSBmcm9tIHRoZSBzZXJ2ZXJcbiAqICBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgZGF0YSB0byB1c2VcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheERhdGFTcmMgKCBzZXR0aW5ncywganNvbiwgd3JpdGUgKVxue1xuXHR2YXIgZGF0YVByb3AgPSAnZGF0YSc7XG5cblx0aWYgKCQuaXNQbGFpbk9iamVjdCggc2V0dGluZ3MuYWpheCApICYmIHNldHRpbmdzLmFqYXguZGF0YVNyYyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gQ291bGQgaW4gaW5zaWRlIGEgYGRhdGFTcmNgIG9iamVjdCwgb3Igbm90IVxuXHRcdHZhciBkYXRhU3JjID0gc2V0dGluZ3MuYWpheC5kYXRhU3JjO1xuXG5cdFx0Ly8gc3RyaW5nLCBmdW5jdGlvbiBhbmQgb2JqZWN0IGFyZSB2YWxpZCB0eXBlc1xuXHRcdGlmICh0eXBlb2YgZGF0YVNyYyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGFTcmMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGRhdGFQcm9wID0gZGF0YVNyYztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZGF0YVNyYy5kYXRhICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGFQcm9wID0gZGF0YVNyYy5kYXRhO1xuXHRcdH1cblx0fVxuXG5cdGlmICggISB3cml0ZSApIHtcblx0XHRpZiAoIGRhdGFQcm9wID09PSAnZGF0YScgKSB7XG5cdFx0XHQvLyBJZiB0aGUgZGVmYXVsdCwgdGhlbiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnQgdGhlIG9sZCBzdHlsZSwgYW5kIHNhZmVseSBpZ25vcmVcblx0XHRcdC8vIGl0IGlmIHBvc3NpYmxlXG5cdFx0XHRyZXR1cm4ganNvbi5hYURhdGEgfHwganNvbltkYXRhUHJvcF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGFQcm9wICE9PSBcIlwiID9cblx0XHRcdF9mbkdldE9iamVjdERhdGFGbiggZGF0YVByb3AgKSgganNvbiApIDpcblx0XHRcdGpzb247XG5cdH1cblx0XG5cdC8vIHNldFxuXHRfZm5TZXRPYmplY3REYXRhRm4oIGRhdGFQcm9wICkoIGpzb24sIHdyaXRlICk7XG59XG5cbi8qKlxuICogVmVyeSBzaW1pbGFyIHRvIF9mbkFqYXhEYXRhU3JjLCBidXQgZm9yIHRoZSBvdGhlciBTU1AgcHJvcGVydGllc1xuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBwYXJhbSBUYXJnZXQgcGFyYW1ldGVyXG4gKiBAcGFyYW0geyp9IGpzb24gSlNPTiBkYXRhXG4gKiBAcmV0dXJucyBSZXNvbHZlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBfZm5BamF4RGF0YVNyY1BhcmFtIChzZXR0aW5ncywgcGFyYW0sIGpzb24pIHtcblx0dmFyIGRhdGFTcmMgPSAkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKVxuXHRcdD8gc2V0dGluZ3MuYWpheC5kYXRhU3JjXG5cdFx0OiBudWxsO1xuXG5cdGlmIChkYXRhU3JjICYmIGRhdGFTcmNbcGFyYW1dKSB7XG5cdFx0Ly8gR2V0IGZyb20gY3VzdG9tIGxvY2F0aW9uXG5cdFx0cmV0dXJuIF9mbkdldE9iamVjdERhdGFGbiggZGF0YVNyY1twYXJhbV0gKSgganNvbiApO1xuXHR9XG5cblx0Ly8gZWxzZSAtIERlZmF1bHQgYmVoYXZpb3VyXG5cdHZhciBvbGQgPSAnJztcblxuXHQvLyBMZWdhY3kgc3VwcG9ydFxuXHRpZiAocGFyYW0gPT09ICdkcmF3Jykge1xuXHRcdG9sZCA9ICdzRWNobyc7XG5cdH1cblx0ZWxzZSBpZiAocGFyYW0gPT09ICdyZWNvcmRzVG90YWwnKSB7XG5cdFx0b2xkID0gJ2lUb3RhbFJlY29yZHMnO1xuXHR9XG5cdGVsc2UgaWYgKHBhcmFtID09PSAncmVjb3Jkc0ZpbHRlcmVkJykge1xuXHRcdG9sZCA9ICdpVG90YWxEaXNwbGF5UmVjb3Jkcyc7XG5cdH1cblxuXHRyZXR1cm4ganNvbltvbGRdICE9PSB1bmRlZmluZWRcblx0XHQ/IGpzb25bb2xkXVxuXHRcdDoganNvbltwYXJhbV07XG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIHRhYmxlIHVzaW5nIGJvdGggdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGNvbHVtbiBiYXNlZCBmaWx0ZXJpbmdcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gaW5wdXQgc2VhcmNoIGluZm9ybWF0aW9uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlckNvbXBsZXRlICggc2V0dGluZ3MsIGlucHV0IClcbntcblx0dmFyIGNvbHVtbnNTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cblx0Ly8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBhbGwgZmlsdGVyaW5nIGlzIGRvbmUgYnkgdGhlIHNlcnZlciwgc28gbm8gcG9pbnQgaGFuZ2luZyBhcm91bmQgaGVyZVxuXHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgIT0gJ3NzcCcgKVxuXHR7XG5cdFx0Ly8gQ2hlY2sgaWYgYW55IG9mIHRoZSByb3dzIHdlcmUgaW52YWxpZGF0ZWRcblx0XHRfZm5GaWx0ZXJEYXRhKCBzZXR0aW5ncyApO1xuXG5cdFx0Ly8gU3RhcnQgZnJvbSB0aGUgZnVsbCBkYXRhIHNldFxuXHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXG5cdFx0Ly8gR2xvYmFsIGZpbHRlciBmaXJzdFxuXHRcdF9mbkZpbHRlciggc2V0dGluZ3MuYWlEaXNwbGF5LCBzZXR0aW5ncywgaW5wdXQuc2VhcmNoLCBpbnB1dCApO1xuXG5cdFx0JC5lYWNoKHNldHRpbmdzLnNlYXJjaEZpeGVkLCBmdW5jdGlvbiAobmFtZSwgdGVybSkge1xuXHRcdFx0X2ZuRmlsdGVyKHNldHRpbmdzLmFpRGlzcGxheSwgc2V0dGluZ3MsIHRlcm0sIHt9KTtcblx0XHR9KTtcblxuXHRcdC8vIFRoZW4gaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVyc1xuXHRcdGZvciAoIHZhciBpPTAgOyBpPGNvbHVtbnNTZWFyY2gubGVuZ3RoIDsgaSsrIClcblx0XHR7XG5cdFx0XHR2YXIgY29sID0gY29sdW1uc1NlYXJjaFtpXTtcblxuXHRcdFx0X2ZuRmlsdGVyKFxuXHRcdFx0XHRzZXR0aW5ncy5haURpc3BsYXksXG5cdFx0XHRcdHNldHRpbmdzLFxuXHRcdFx0XHRjb2wuc2VhcmNoLFxuXHRcdFx0XHRjb2wsXG5cdFx0XHRcdGlcblx0XHRcdCk7XG5cblx0XHRcdCQuZWFjaChzZXR0aW5ncy5hb0NvbHVtbnNbaV0uc2VhcmNoRml4ZWQsIGZ1bmN0aW9uIChuYW1lLCB0ZXJtKSB7XG5cdFx0XHRcdF9mbkZpbHRlcihzZXR0aW5ncy5haURpc3BsYXksIHNldHRpbmdzLCB0ZXJtLCB7fSwgaSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBbmQgZmluYWxseSBnbG9iYWwgZmlsdGVyaW5nXG5cdFx0X2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApO1xuXHR9XG5cblx0Ly8gVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB3ZSBoYXZlIGJlZW4gZmlsdGVyaW5nXG5cdHNldHRpbmdzLmJGaWx0ZXJlZCA9IHRydWU7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtzZXR0aW5nc10gKTtcbn1cblxuXG4vKipcbiAqIEFwcGx5IGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb25zXG4gKiBcbiAqIFRoaXMgaXMgbGVnYWN5IG5vdyB0aGF0IHdlIGhhdmUgbmFtZWQgZnVuY3Rpb25zLCBidXQgaXQgaXMgd2lkZWx5IHVzZWRcbiAqIGZyb20gMS54LCBzbyBpdCBpcyBub3QgeWV0IGRlcHJlY2F0ZWQuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5GaWx0ZXJDdXN0b20oIHNldHRpbmdzIClcbntcblx0dmFyIGZpbHRlcnMgPSBEYXRhVGFibGUuZXh0LnNlYXJjaDtcblx0dmFyIGRpc3BsYXlSb3dzID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xuXHR2YXIgcm93LCByb3dJZHg7XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWZpbHRlcnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0dmFyIHJvd3MgPSBbXTtcblxuXHRcdC8vIExvb3Agb3ZlciBlYWNoIHJvdyBhbmQgc2VlIGlmIGl0IHNob3VsZCBiZSBpbmNsdWRlZFxuXHRcdGZvciAoIHZhciBqPTAsIGplbj1kaXNwbGF5Um93cy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdHJvd0lkeCA9IGRpc3BsYXlSb3dzWyBqIF07XG5cdFx0XHRyb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXG5cdFx0XHRpZiAoIGZpbHRlcnNbaV0oIHNldHRpbmdzLCByb3cuX2FGaWx0ZXJEYXRhLCByb3dJZHgsIHJvdy5fYURhdGEsIGogKSApIHtcblx0XHRcdFx0cm93cy5wdXNoKCByb3dJZHggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG5cdFx0Ly8gZXhpc3RpbmcgYXJyYXlcblx0XHRkaXNwbGF5Um93cy5sZW5ndGggPSAwO1xuXHRcdF9mbkFycmF5QXBwbHkoZGlzcGxheVJvd3MsIHJvd3MpO1xuXHR9XG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIGRhdGEgdGFibGUgYmFzZWQgb24gdXNlciBpbnB1dCBhbmQgZHJhdyB0aGUgdGFibGVcbiAqL1xuZnVuY3Rpb24gX2ZuRmlsdGVyKCBzZWFyY2hSb3dzLCBzZXR0aW5ncywgaW5wdXQsIG9wdGlvbnMsIGNvbHVtbiApXG57XG5cdGlmICggaW5wdXQgPT09ICcnICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBpID0gMDtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHQvLyBTZWFyY2ggdGVybSBjYW4gYmUgYSBmdW5jdGlvbiwgcmVnZXggb3Igc3RyaW5nIC0gaWYgYSBzdHJpbmcgd2UgYXBwbHkgb3VyXG5cdC8vIHNtYXJ0IGZpbHRlcmluZyByZWdleCAoYXNzdW1pbmcgdGhlIG9wdGlvbnMgcmVxdWlyZSB0aGF0KVxuXHR2YXIgc2VhcmNoRnVuYyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/IGlucHV0IDogbnVsbDtcblx0dmFyIHJwU2VhcmNoID0gaW5wdXQgaW5zdGFuY2VvZiBSZWdFeHBcblx0XHQ/IGlucHV0XG5cdFx0OiBzZWFyY2hGdW5jXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBpbnB1dCwgb3B0aW9ucyApO1xuXG5cdC8vIFRoZW4gZm9yIGVhY2ggcm93LCBkb2VzIHRoZSB0ZXN0IHBhc3MuIElmIG5vdCwgbG9wIHRoZSByb3cgZnJvbSB0aGUgYXJyYXlcblx0Zm9yIChpPTAgOyBpPHNlYXJjaFJvd3MubGVuZ3RoIDsgaSsrKSB7XG5cdFx0dmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVsgc2VhcmNoUm93c1tpXSBdO1xuXHRcdHZhciBkYXRhID0gY29sdW1uID09PSB1bmRlZmluZWRcblx0XHRcdD8gcm93Ll9zRmlsdGVyUm93XG5cdFx0XHQ6IHJvdy5fYUZpbHRlckRhdGFbIGNvbHVtbiBdO1xuXG5cdFx0aWYgKCAoc2VhcmNoRnVuYyAmJiBzZWFyY2hGdW5jKGRhdGEsIHJvdy5fYURhdGEsIHNlYXJjaFJvd3NbaV0sIGNvbHVtbikpIHx8IChycFNlYXJjaCAmJiBycFNlYXJjaC50ZXN0KGRhdGEpKSApIHtcblx0XHRcdG1hdGNoZWQucHVzaChzZWFyY2hSb3dzW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBNdXRhdGUgdGhlIHNlYXJjaFJvd3MgYXJyYXlcblx0c2VhcmNoUm93cy5sZW5ndGggPSBtYXRjaGVkLmxlbmd0aDtcblxuXHRmb3IgKGk9MCA7IGk8bWF0Y2hlZC5sZW5ndGggOyBpKyspIHtcblx0XHRzZWFyY2hSb3dzW2ldID0gbWF0Y2hlZFtpXTtcblx0fVxufVxuXG5cbi8qKlxuICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxuICogIEBwYXJhbSB7c3RyaW5nfSBzU2VhcmNoIHN0cmluZyB0byBzZWFyY2ggZm9yXG4gKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG4gKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG4gKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmcgb3Igbm90XG4gKiAgQHJldHVybnMge1JlZ0V4cH0gY29uc3RydWN0ZWQgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggc2VhcmNoLCBpbk9wdHMgKVxue1xuXHR2YXIgbm90ID0gW107XG5cdHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIHtcblx0XHRib3VuZGFyeTogZmFsc2UsXG5cdFx0Y2FzZUluc2Vuc2l0aXZlOiB0cnVlLFxuXHRcdGV4YWN0OiBmYWxzZSxcblx0XHRyZWdleDogZmFsc2UsXG5cdFx0c21hcnQ6IHRydWVcblx0fSwgaW5PcHRzKTtcblxuXHRpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3N0cmluZycpIHtcblx0XHRzZWFyY2ggPSBzZWFyY2gudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8vIFJlbW92ZSBkaWFjcml0aWNzIGlmIG5vcm1hbGl6ZSBpcyBzZXQgdXAgdG8gZG8gc29cblx0c2VhcmNoID0gX25vcm1hbGl6ZShzZWFyY2gpO1xuXG5cdGlmIChvcHRpb25zLmV4YWN0KSB7XG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAoXG5cdFx0XHQnXicrX2ZuRXNjYXBlUmVnZXgoc2VhcmNoKSsnJCcsXG5cdFx0XHRvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnXG5cdFx0KTtcblx0fVxuXG5cdHNlYXJjaCA9IG9wdGlvbnMucmVnZXggP1xuXHRcdHNlYXJjaCA6XG5cdFx0X2ZuRXNjYXBlUmVnZXgoIHNlYXJjaCApO1xuXHRcblx0aWYgKCBvcHRpb25zLnNtYXJ0ICkge1xuXHRcdC8qIEZvciBzbWFydCBmaWx0ZXJpbmcgd2Ugd2FudCB0byBhbGxvdyB0aGUgc2VhcmNoIHRvIHdvcmsgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHdvcmQgb3JkZXIuIFdlIGFsc28gd2FudCBkb3VibGUgcXVvdGVkIHRleHQgdG8gYmUgcHJlc2VydmVkLCBzbyB3b3JkXG5cdFx0ICogb3JkZXIgaXMgaW1wb3J0YW50IC0gYSBsYSBnb29nbGUuIEFuZCBhIG5lZ2F0aXZlIGxvb2sgYXJvdW5kIGZvclxuXHRcdCAqIGZpbmRpbmcgcm93cyB3aGljaCBkb24ndCBjb250YWluIGEgZ2l2ZW4gc3RyaW5nLlxuXHRcdCAqIFxuXHRcdCAqIFNvIHRoaXMgaXMgdGhlIHNvcnQgb2YgdGhpbmcgd2Ugd2FudCB0byBnZW5lcmF0ZTpcblx0XHQgKiBcblx0XHQgKiBeKD89Lio/XFxib25lXFxiKSg/PS4qP1xcYnR3byB0aHJlZVxcYikoPz0uKj9cXGJmb3VyXFxiKS4qJFxuXHRcdCAqL1xuXHRcdHZhciBwYXJ0cyA9IHNlYXJjaC5tYXRjaCggLyE/W1wiXFx1MjAxQ11bXlwiXFx1MjAxRF0rW1wiXFx1MjAxRF18W14gXSsvZyApIHx8IFsnJ107XG5cdFx0dmFyIGEgPSBwYXJ0cy5tYXAoIGZ1bmN0aW9uICggd29yZCApIHtcblx0XHRcdHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xuXHRcdFx0dmFyIG07XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBpdCBpcyBhIFwiZG9lcyBub3QgaW5jbHVkZVwiXG5cdFx0XHRpZiAoIHdvcmQuY2hhckF0KDApID09PSAnIScgKSB7XG5cdFx0XHRcdG5lZ2F0aXZlID0gdHJ1ZTtcblx0XHRcdFx0d29yZCA9IHdvcmQuc3Vic3RyaW5nKDEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdHJpcCB0aGUgcXVvdGVzIGZyb20gYXJvdW5kIG1hdGNoZWQgcGhyYXNlc1xuXHRcdFx0aWYgKCB3b3JkLmNoYXJBdCgwKSA9PT0gJ1wiJyApIHtcblx0XHRcdFx0bSA9IHdvcmQubWF0Y2goIC9eXCIoLiopXCIkLyApO1xuXHRcdFx0XHR3b3JkID0gbSA/IG1bMV0gOiB3b3JkO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHdvcmQuY2hhckF0KDApID09PSAnXFx1MjAxQycgKSB7XG5cdFx0XHRcdC8vIFNtYXJ0IHF1b3RlIG1hdGNoIChpUGhvbmUgdXNlcnMpXG5cdFx0XHRcdG0gPSB3b3JkLm1hdGNoKCAvXlxcdTIwMUMoLiopXFx1MjAxRCQvICk7XG5cdFx0XHRcdHdvcmQgPSBtID8gbVsxXSA6IHdvcmQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBvdXIgXCJub3RcIiBjYXNlLCB3ZSBuZWVkIHRvIG1vZGlmeSB0aGUgc3RyaW5nIHRoYXQgaXNcblx0XHRcdC8vIGFsbG93ZWQgdG8gbWF0Y2ggYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvbi5cblx0XHRcdGlmIChuZWdhdGl2ZSkge1xuXHRcdFx0XHRpZiAod29yZC5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0bm90LnB1c2goJyg/IScrd29yZCsnKScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d29yZCA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gd29yZC5yZXBsYWNlKC9cIi9nLCAnJyk7XG5cdFx0fSApO1xuXG5cdFx0dmFyIG1hdGNoID0gbm90Lmxlbmd0aFxuXHRcdFx0PyBub3Quam9pbignJylcblx0XHRcdDogJyc7XG5cblx0XHR2YXIgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5XG5cdFx0XHQ/ICdcXFxcYidcblx0XHRcdDogJyc7XG5cblx0XHRzZWFyY2ggPSAnXig/PS4qPycrYm91bmRhcnkrYS5qb2luKCAnKSg/PS4qPycrYm91bmRhcnkgKSsnKSgnK21hdGNoKycuKSokJztcblx0fVxuXG5cdHJldHVybiBuZXcgUmVnRXhwKCBzZWFyY2gsIG9wdGlvbnMuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogJycgKTtcbn1cblxuXG4vKipcbiAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAqICBAcGFyYW0ge3N0cmluZ30gc1ZhbCBzdHJpbmcgdG8gZXNjYXBlXG4gKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xudmFyIF9mbkVzY2FwZVJlZ2V4ID0gRGF0YVRhYmxlLnV0aWwuZXNjYXBlUmVnZXg7XG5cbnZhciBfX2ZpbHRlcl9kaXYgPSAkKCc8ZGl2PicpWzBdO1xudmFyIF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA9IF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkO1xuXG4vLyBVcGRhdGUgdGhlIGZpbHRlcmluZyBkYXRhIGZvciBlYWNoIHJvdyBpZiBuZWVkZWQgKGJ5IGludmFsaWRhdGlvbiBvciBmaXJzdCBydW4pXG5mdW5jdGlvbiBfZm5GaWx0ZXJEYXRhICggc2V0dGluZ3MgKVxue1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdHZhciBjb2x1bW47XG5cdHZhciBqLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XG5cdHZhciB3YXNJbnZhbGlkYXRlZCA9IGZhbHNlO1xuXG5cdGZvciAoIHZhciByb3dJZHg9MCA7IHJvd0lkeDxkYXRhLmxlbmd0aCA7IHJvd0lkeCsrICkge1xuXHRcdGlmICghIGRhdGFbcm93SWR4XSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0cm93ID0gZGF0YVtyb3dJZHhdO1xuXG5cdFx0aWYgKCAhIHJvdy5fYUZpbHRlckRhdGEgKSB7XG5cdFx0XHRmaWx0ZXJEYXRhID0gW107XG5cblx0XHRcdGZvciAoIGo9MCwgamVuPWNvbHVtbnMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbal07XG5cblx0XHRcdFx0aWYgKCBjb2x1bW4uYlNlYXJjaGFibGUgKSB7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgaiwgJ2ZpbHRlcicgKTtcblxuXHRcdFx0XHRcdC8vIFNlYXJjaCBpbiBEYXRhVGFibGVzIGlzIHN0cmluZyBiYXNlZFxuXHRcdFx0XHRcdGlmICggY2VsbERhdGEgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdHlwZW9mIGNlbGxEYXRhICE9PSAnc3RyaW5nJyAmJiBjZWxsRGF0YS50b1N0cmluZyApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEudG9TdHJpbmcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGl0IGxvb2tzIGxpa2UgdGhlcmUgaXMgYW4gSFRNTCBlbnRpdHkgaW4gdGhlIHN0cmluZyxcblx0XHRcdFx0Ly8gYXR0ZW1wdCB0byBkZWNvZGUgaXQgc28gc29ydGluZyB3b3JrcyBhcyBleHBlY3RlZC4gTm90ZSB0aGF0XG5cdFx0XHRcdC8vIHdlIGNvdWxkIHVzZSBhIHNpbmdsZSBsaW5lIG9mIGpRdWVyeSB0byBkbyB0aGlzLCBidXQgdGhlIERPTVxuXHRcdFx0XHQvLyBtZXRob2QgdXNlZCBoZXJlIGlzIG11Y2ggZmFzdGVyIGh0dHBzOi8vanNwZXJmLmNvbS9odG1sLWRlY29kZVxuXHRcdFx0XHRpZiAoIGNlbGxEYXRhLmluZGV4T2YgJiYgY2VsbERhdGEuaW5kZXhPZignJicpICE9PSAtMSApIHtcblx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJIVE1MID0gY2VsbERhdGE7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgP1xuXHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LnRleHRDb250ZW50IDpcblx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi5pbm5lclRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNlbGxEYXRhLnJlcGxhY2UgKSB7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS5yZXBsYWNlKC9bXFxyXFxuXFx1MjAyOF0vZywgJycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmlsdGVyRGF0YS5wdXNoKCBjZWxsRGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyb3cuX2FGaWx0ZXJEYXRhID0gZmlsdGVyRGF0YTtcblx0XHRcdHJvdy5fc0ZpbHRlclJvdyA9IGZpbHRlckRhdGEuam9pbignICAnKTtcblx0XHRcdHdhc0ludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gd2FzSW52YWxpZGF0ZWQ7XG59XG5cblxuLyoqXG4gKiBEcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGZpcnN0IHRpbWUsIGFkZGluZyBhbGwgcmVxdWlyZWQgZmVhdHVyZXNcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuSW5pdGlhbGlzZSAoIHNldHRpbmdzIClcbntcblx0dmFyIGk7XG5cdHZhciBpbml0ID0gc2V0dGluZ3Mub0luaXQ7XG5cdHZhciBkZWZlckxvYWRpbmcgPSBzZXR0aW5ncy5kZWZlckxvYWRpbmc7XG5cdHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKTtcblxuXHQvLyBFbnN1cmUgdGhhdCB0aGUgdGFibGUgZGF0YSBpcyBmdWxseSBpbml0aWFsaXNlZFxuXHRpZiAoICEgc2V0dGluZ3MuYkluaXRpYWxpc2VkICkge1xuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7IF9mbkluaXRpYWxpc2UoIHNldHRpbmdzICk7IH0sIDIwMCApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEJ1aWxkIHRoZSBoZWFkZXIgLyBmb290ZXIgZm9yIHRoZSB0YWJsZVxuXHRfZm5CdWlsZEhlYWQoIHNldHRpbmdzLCAnaGVhZGVyJyApO1xuXHRfZm5CdWlsZEhlYWQoIHNldHRpbmdzLCAnZm9vdGVyJyApO1xuXG5cdC8vIExvYWQgdGhlIHRhYmxlJ3Mgc3RhdGUgKGlmIG5lZWRlZCkgYW5kIHRoZW4gcmVuZGVyIGFyb3VuZCBpdCBhbmQgZHJhd1xuXHRfZm5Mb2FkU3RhdGUoIHNldHRpbmdzLCBpbml0LCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlbiBkcmF3IHRoZSBoZWFkZXIgLyBmb290ZXJcblx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyICk7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3RlciApO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIHBhZ2luZyBzdGFydCBwb2ludCwgYXMgdGhlIGZpcnN0IHJlZHJhdyB3aWxsIHJlc2V0IGl0XG5cdFx0dmFyIGlBamF4U3RhcnQgPSBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydFxuXG5cdFx0Ly8gTG9jYWwgZGF0YSBsb2FkXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlcmUgaXMgZGF0YSBwYXNzaW5nIGludG8gdGhlIGNvbnN0cnVjdG9yXG5cdFx0aWYgKCBpbml0LmFhRGF0YSApIHtcblx0XHRcdGZvciAoIGk9MCA7IGk8aW5pdC5hYURhdGEubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgaW5pdC5hYURhdGFbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggZGVmZXJMb2FkaW5nIHx8IGRhdGFTcmMgPT0gJ2RvbScgKSB7XG5cdFx0XHQvLyBHcmFiIHRoZSBkYXRhIGZyb20gdGhlIHBhZ2Vcblx0XHRcdF9mbkFkZFRyKCBzZXR0aW5ncywgJChzZXR0aW5ncy5uVEJvZHkpLmNoaWxkcmVuKCd0cicpICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyIG5vdCB5ZXQgYXBwbGllZCAtIGNvcHkgdGhlIGRpc3BsYXkgbWFzdGVyXG5cdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cblx0XHQvLyBFbmFibGUgZmVhdHVyZXNcblx0XHRfZm5BZGRPcHRpb25zSHRtbCggc2V0dGluZ3MgKTtcblx0XHRfZm5Tb3J0SW5pdCggc2V0dGluZ3MgKTtcblxuXHRcdF9jb2xHcm91cCggc2V0dGluZ3MgKTtcblxuXHRcdC8qIE9rYXkgdG8gc2hvdyB0aGF0IHNvbWV0aGluZyBpcyBnb2luZyBvbiBub3cgKi9cblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcmVJbml0JywgW3NldHRpbmdzXSwgdHJ1ZSApO1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgZGVmYXVsdCBzb3J0aW5nIHJlcXVpcmVkIC0gbGV0J3MgZG8gaXQuIFRoZSBzb3J0IGZ1bmN0aW9uXG5cdFx0Ly8gd2lsbCBkbyB0aGUgZHJhd2luZyBmb3IgdXMuIE90aGVyd2lzZSB3ZSBkcmF3IHRoZSB0YWJsZSByZWdhcmRsZXNzIG9mIHRoZVxuXHRcdC8vIEFqYXggc291cmNlIC0gdGhpcyBhbGxvd3MgdGhlIHRhYmxlIHRvIGxvb2sgaW5pdGlhbGlzZWQgZm9yIEFqYXggc291cmNpbmdcblx0XHQvLyBkYXRhIChzaG93ICdsb2FkaW5nJyBtZXNzYWdlIHBvc3NpYmx5KVxuXHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblxuXHRcdC8vIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgaW5pdCBjb21wbGV0ZSBpcyBkb25lIGJ5IF9mbkFqYXhVcGRhdGVEcmF3XG5cdFx0aWYgKCBkYXRhU3JjICE9ICdzc3AnIHx8IGRlZmVyTG9hZGluZyApIHtcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIGFqYXggc291cmNlIGxvYWQgdGhlIGRhdGFcblx0XHRcdGlmICggZGF0YVNyYyA9PSAnYWpheCcgKSB7XG5cdFx0XHRcdF9mbkJ1aWxkQWpheCggc2V0dGluZ3MsIHt9LCBmdW5jdGlvbihqc29uKSB7XG5cdFx0XHRcdFx0dmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoIHNldHRpbmdzLCBqc29uICk7XG5cblx0XHRcdFx0XHQvLyBHb3QgdGhlIGRhdGEgLSBhZGQgaXQgdG8gdGhlIHRhYmxlXG5cdFx0XHRcdFx0Zm9yICggaT0wIDsgaTxhRGF0YS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgYURhdGFbaV0gKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZXNldCB0aGUgaW5pdCBkaXNwbGF5IGZvciBjb29raWUgc2F2aW5nLiBXZSd2ZSBhbHJlYWR5IGRvbmVcblx0XHRcdFx0XHQvLyBhIGZpbHRlciwgYW5kIHRoZXJlZm9yZSBjbGVhcmVkIGl0IGJlZm9yZS4gU28gd2UgbmVlZCB0byBtYWtlXG5cdFx0XHRcdFx0Ly8gaXQgYXBwZWFyICdmcmVzaCdcblx0XHRcdFx0XHRzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IGlBamF4U3RhcnQ7XG5cblx0XHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cdFx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MgKTtcblx0XHRcdFx0fSwgc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzICk7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuXG4vKipcbiAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Jbml0Q29tcGxldGUgKCBzZXR0aW5ncyApXG57XG5cdGlmIChzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBhcmdzID0gW3NldHRpbmdzLCBzZXR0aW5ncy5qc29uXTtcblxuXHRzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSA9IHRydWU7XG5cblx0Ly8gVGFibGUgaXMgZnVsbHkgc2V0IHVwIGFuZCB3ZSBoYXZlIGRhdGEsIHNvIGNhbGN1bGF0ZSB0aGVcblx0Ly8gY29sdW1uIHdpZHRoc1xuXHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3BsdWdpbi1pbml0JywgYXJncywgdHJ1ZSApO1xuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAnaW5pdCcsIGFyZ3MsIHRydWUgKTtcbn1cblxuZnVuY3Rpb24gX2ZuTGVuZ3RoQ2hhbmdlICggc2V0dGluZ3MsIHZhbCApXG57XG5cdHZhciBsZW4gPSBwYXJzZUludCggdmFsLCAxMCApO1xuXHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggPSBsZW47XG5cblx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cblx0Ly8gRmlyZSBsZW5ndGggY2hhbmdlIGV2ZW50XG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdsZW5ndGgnLCBbc2V0dGluZ3MsIGxlbl0gKTtcbn1cblxuLyoqXG4gKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2VcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IGFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLFxuICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcbiAqICBAcGFyYW0gW2Jvb2xdIHJlZHJhdyBBdXRvbWF0aWNhbGx5IGRyYXcgdGhlIHVwZGF0ZSBvciBub3RcbiAqICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBwYWdlIGhhcyBjaGFuZ2VkLCBmYWxzZSAtIG5vIGNoYW5nZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5QYWdlQ2hhbmdlICggc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3IClcbntcblx0dmFyXG5cdFx0c3RhcnQgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdHJlY29yZHMgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKTtcblxuXHRpZiAoIHJlY29yZHMgPT09IDAgfHwgbGVuID09PSAtMSApXG5cdHtcblx0XHRzdGFydCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBhY3Rpb24gPT09IFwibnVtYmVyXCIgKVxuXHR7XG5cdFx0c3RhcnQgPSBhY3Rpb24gKiBsZW47XG5cblx0XHRpZiAoIHN0YXJ0ID4gcmVjb3JkcyApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggYWN0aW9uID09IFwiZmlyc3RcIiApXG5cdHtcblx0XHRzdGFydCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcInByZXZpb3VzXCIgKVxuXHR7XG5cdFx0c3RhcnQgPSBsZW4gPj0gMCA/XG5cdFx0XHRzdGFydCAtIGxlbiA6XG5cdFx0XHQwO1xuXG5cdFx0aWYgKCBzdGFydCA8IDAgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcIm5leHRcIiApXG5cdHtcblx0XHRpZiAoIHN0YXJ0ICsgbGVuIDwgcmVjb3JkcyApXG5cdFx0e1xuXHRcdFx0c3RhcnQgKz0gbGVuO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggYWN0aW9uID09IFwibGFzdFwiIClcblx0e1xuXHRcdHN0YXJ0ID0gTWF0aC5mbG9vciggKHJlY29yZHMtMSkgLyBsZW4pICogbGVuO1xuXHR9XG5cdGVsc2UgaWYgKCBhY3Rpb24gPT09ICdlbGxpcHNpcycgKVxuXHR7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiVW5rbm93biBwYWdpbmcgYWN0aW9uOiBcIithY3Rpb24sIDUgKTtcblx0fVxuXG5cdHZhciBjaGFuZ2VkID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgIT09IHN0YXJ0O1xuXHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsIGNoYW5nZWQgPyAncGFnZScgOiAncGFnZS1uYycsIFtzZXR0aW5nc10gKTtcblxuXHRpZiAoIGNoYW5nZWQgJiYgcmVkcmF3ICkge1xuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdH1cblxuXHRyZXR1cm4gY2hhbmdlZDtcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgcHJvY2Vzc2luZyBub2RlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9wcm9jZXNzaW5nSHRtbCAoIHNldHRpbmdzIClcbntcblx0dmFyIHRhYmxlID0gc2V0dGluZ3MublRhYmxlO1xuXHR2YXIgc2Nyb2xsaW5nID0gc2V0dGluZ3Mub1Njcm9sbC5zWCAhPT0gJycgfHwgc2V0dGluZ3Mub1Njcm9sbC5zWSAhPT0gJyc7XG5cblx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcgKSB7XG5cdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdpZCc6IHNldHRpbmdzLnNUYWJsZUlkICsgJ19wcm9jZXNzaW5nJyxcblx0XHRcdFx0J2NsYXNzJzogc2V0dGluZ3Mub0NsYXNzZXMucHJvY2Vzc2luZy5jb250YWluZXIsXG5cdFx0XHRcdCdyb2xlJzogJ3N0YXR1cydcblx0XHRcdH0gKVxuXHRcdFx0Lmh0bWwoIHNldHRpbmdzLm9MYW5ndWFnZS5zUHJvY2Vzc2luZyApXG5cdFx0XHQuYXBwZW5kKCc8ZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PC9kaXY+Jyk7XG5cblx0XHQvLyBEaWZmZXJlbnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIGlmIHNjcm9sbGluZyBpcyBlbmFibGVkIG9yIG5vdFxuXHRcdGlmIChzY3JvbGxpbmcpIHtcblx0XHRcdG4ucHJlcGVuZFRvKCAkKCdkaXYuZHQtc2Nyb2xsJywgc2V0dGluZ3MublRhYmxlV3JhcHBlcikgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRuLmluc2VydEJlZm9yZSggdGFibGUgKTtcblx0XHR9XG5cblx0XHQkKHRhYmxlKS5vbiggJ3Byb2Nlc3NpbmcuZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgc2hvdykge1xuXHRcdFx0bi5jc3MoICdkaXNwbGF5Jywgc2hvdyA/ICdibG9jaycgOiAnbm9uZScgKTtcblx0XHR9ICk7XG5cdH1cbn1cblxuXG4vKipcbiAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3JcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2Jvb2x9IHNob3cgU2hvdyB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3IgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG4gKi9cbmZ1bmN0aW9uIF9mblByb2Nlc3NpbmdEaXNwbGF5ICggc2V0dGluZ3MsIHNob3cgKVxue1xuXHQvLyBJZ25vcmUgY2FzZXMgd2hlbiB3ZSBhcmUgc3RpbGwgcmVkcmF3aW5nXG5cdGlmIChzZXR0aW5ncy5iRHJhd2luZyAmJiBzaG93ID09PSBmYWxzZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcm9jZXNzaW5nJywgW3NldHRpbmdzLCBzaG93XSApO1xufVxuXG4vKipcbiAqIFNob3cgdGhlIHByb2Nlc3NpbmcgZWxlbWVudCBpZiBhbiBhY3Rpb24gdGFrZXMgbG9uZ2VyIHRoYW4gYSBnaXZlbiB0aW1lXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBlbmFibGUgRG8gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFzeW5jIHByb2Nlc3NpbmcgKGxvY2FsIGZlYXR1cmUgZW5hYmxlbWVudClcbiAqIEBwYXJhbSB7Kn0gcnVuIEZ1bmN0aW9uIHRvIHJ1blxuICovXG5mdW5jdGlvbiBfZm5Qcm9jZXNzaW5nUnVuKCBzZXR0aW5ncywgZW5hYmxlLCBydW4gKSB7XG5cdGlmICghIGVuYWJsZSkge1xuXHRcdC8vIEltbWVkaWF0ZSBleGVjdXRpb24sIHN5bmNocm9ub3VzXG5cdFx0cnVuKCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIHRydWUpO1xuXHRcdFxuXHRcdC8vIEFsbG93IHRoZSBwcm9jZXNzaW5nIGRpc3BsYXkgdG8gc2hvdyBpZiBuZWVkZWRcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHJ1bigpO1xuXG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xuXHRcdH0sIDApO1xuXHR9XG59XG4vKipcbiAqIEFkZCBhbnkgY29udHJvbCBlbGVtZW50cyBmb3IgdGhlIHRhYmxlIC0gc3BlY2lmaWNhbGx5IHNjcm9sbGluZ1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtub2RlfSBOb2RlIHRvIGFkZCB0byB0aGUgRE9NXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sVGFibGUgKCBzZXR0aW5ncyApXG57XG5cdHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblxuXHQvLyBTY3JvbGxpbmcgZnJvbSBoZXJlIG9uIGluXG5cdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXG5cdGlmICggc2Nyb2xsLnNYID09PSAnJyAmJiBzY3JvbGwuc1kgPT09ICcnICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5uVGFibGU7XG5cdH1cblxuXHR2YXIgc2Nyb2xsWCA9IHNjcm9sbC5zWDtcblx0dmFyIHNjcm9sbFkgPSBzY3JvbGwuc1k7XG5cdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMuc2Nyb2xsaW5nO1xuXHR2YXIgY2FwdGlvbiA9IHNldHRpbmdzLmNhcHRpb25Ob2RlO1xuXHR2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uID8gY2FwdGlvbi5fY2FwdGlvblNpZGUgOiBudWxsO1xuXHR2YXIgaGVhZGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdHZhciBmb290ZXJDbG9uZSA9ICQoIHRhYmxlWzBdLmNsb25lTm9kZShmYWxzZSkgKTtcblx0dmFyIGZvb3RlciA9IHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpO1xuXHR2YXIgX2RpdiA9ICc8ZGl2Lz4nO1xuXHR2YXIgc2l6ZSA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRyZXR1cm4gIXMgPyBudWxsIDogX2ZuU3RyaW5nVG9Dc3MoIHMgKTtcblx0fTtcblxuXHRpZiAoICEgZm9vdGVyLmxlbmd0aCApIHtcblx0XHRmb290ZXIgPSBudWxsO1xuXHR9XG5cblx0Lypcblx0ICogVGhlIEhUTUwgc3RydWN0dXJlIHRoYXQgd2Ugd2FudCB0byBnZW5lcmF0ZSBpbiB0aGlzIGZ1bmN0aW9uIGlzOlxuXHQgKiAgZGl2IC0gc2Nyb2xsZXJcblx0ICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcblx0ICogICAgICBkaXYgLSBzY3JvbGwgaGVhZCBpbm5lclxuXHQgKiAgICAgICAgdGFibGUgLSBzY3JvbGwgaGVhZCB0YWJsZVxuXHQgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXG5cdCAqICAgIGRpdiAtIHNjcm9sbCBib2R5XG5cdCAqICAgICAgdGFibGUgLSB0YWJsZSAobWFzdGVyIHRhYmxlKVxuXHQgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXG5cdCAqICAgICAgICB0Ym9keSAtIHRib2R5XG5cdCAqICAgIGRpdiAtIHNjcm9sbCBmb290XG5cdCAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcblx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGZvb3QgdGFibGVcblx0ICogICAgICAgICAgdGZvb3QgLSB0Zm9vdFxuXHQgKi9cblx0dmFyIHNjcm9sbGVyID0gJCggX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLmNvbnRhaW5lciB9IClcblx0XHQuYXBwZW5kKFxuXHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuaGVhZGVyLnNlbGYgfSApXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0cG9zaXRpb246ICdyZWxhdGl2ZScsXG5cdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5oZWFkZXIuaW5uZXIgfSApXG5cdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdCdib3gtc2l6aW5nJzogJ2NvbnRlbnQtYm94Jyxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHNjcm9sbC5zWElubmVyIHx8ICcxMDAlJ1xuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRoZWFkZXJDbG9uZVxuXHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggY2FwdGlvblNpZGUgPT09ICd0b3AnID8gY2FwdGlvbiA6IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGhlYWQnKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0KVxuXHRcdClcblx0XHQuYXBwZW5kKFxuXHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuYm9keSB9IClcblx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bycsXG5cdFx0XHRcdFx0d2lkdGg6IHNpemUoIHNjcm9sbFggKVxuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZCggdGFibGUgKVxuXHRcdCk7XG5cblx0aWYgKCBmb290ZXIgKSB7XG5cdFx0c2Nyb2xsZXIuYXBwZW5kKFxuXHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuZm9vdGVyLnNlbGYgfSApXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5mb290ZXIuaW5uZXIgfSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRmb290ZXJDbG9uZVxuXHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggY2FwdGlvblNpZGUgPT09ICdib3R0b20nID8gY2FwdGlvbiA6IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0KVxuXHRcdCk7XG5cdH1cblxuXHR2YXIgY2hpbGRyZW4gPSBzY3JvbGxlci5jaGlsZHJlbigpO1xuXHR2YXIgc2Nyb2xsSGVhZCA9IGNoaWxkcmVuWzBdO1xuXHR2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xuXHR2YXIgc2Nyb2xsRm9vdCA9IGZvb3RlciA/IGNoaWxkcmVuWzJdIDogbnVsbDtcblxuXHQvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcblx0JChzY3JvbGxCb2R5KS5vbiggJ3Njcm9sbC5EVCcsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcblxuXHRcdHNjcm9sbEhlYWQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cblx0XHRpZiAoIGZvb3RlciApIHtcblx0XHRcdHNjcm9sbEZvb3Quc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gV2hlbiBmb2N1cyBpcyBwdXQgb24gdGhlIGhlYWRlciBjZWxscywgd2UgbWlnaHQgbmVlZCB0byBzY3JvbGwgdGhlIGJvZHlcblx0JCgndGgsIHRkJywgc2Nyb2xsSGVhZCkub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzY3JvbGxMZWZ0ID0gc2Nyb2xsSGVhZC5zY3JvbGxMZWZ0O1xuXG5cdFx0c2Nyb2xsQm9keS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2Nyb2xsQm9keS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0XHR9XG5cdH0pO1xuXG5cdCQoc2Nyb2xsQm9keSkuY3NzKCdtYXgtaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdGlmICghIHNjcm9sbC5iQ29sbGFwc2UpIHtcblx0XHQkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdH1cblxuXHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdHNldHRpbmdzLm5TY3JvbGxCb2R5ID0gc2Nyb2xsQm9keTtcblx0c2V0dGluZ3MublNjcm9sbEZvb3QgPSBzY3JvbGxGb290O1xuXG5cdC8vIE9uIHJlZHJhdyAtIGFsaWduIGNvbHVtbnNcblx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaChfZm5TY3JvbGxEcmF3KTtcblxuXHRyZXR1cm4gc2Nyb2xsZXJbMF07XG59XG5cblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaGVhZGVyLCBmb290ZXIgYW5kIGJvZHkgdGFibGVzIGZvciByZXNpemluZyAtIGkuZS4gY29sdW1uXG4gKiBhbGlnbm1lbnQuXG4gKlxuICogV2VsY29tZSB0byB0aGUgbW9zdCBob3JyaWJsZSBmdW5jdGlvbiBEYXRhVGFibGVzLiBUaGUgcHJvY2VzcyB0aGF0IHRoaXNcbiAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxuICogICAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuICogICAyLiBDb3JyZWN0IGNvbGdyb3VwID4gY29sIHZhbHVlcyBpZiBuZWVkZWRcbiAqICAgMy4gQ29weSBjb2xncm91cCA+IGNvbCBvdmVyIHRvIGhlYWRlciBhbmQgZm9vdGVyXG4gKiAgIDQuIENsZWFuIHVwXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5TY3JvbGxEcmF3ICggc2V0dGluZ3MgKVxue1xuXHQvLyBHaXZlbiB0aGF0IHRoaXMgaXMgc3VjaCBhIG1vbnN0ZXIgZnVuY3Rpb24sIGEgbG90IG9mIHZhcmlhYmxlcyBhcmUgdXNlXG5cdC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcblx0dmFyXG5cdFx0c2Nyb2xsICAgICAgICAgPSBzZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdGJhcldpZHRoICAgICAgID0gc2Nyb2xsLmlCYXJXaWR0aCxcblx0XHRkaXZIZWFkZXIgICAgICA9ICQoc2V0dGluZ3MublNjcm9sbEhlYWQpLFxuXHRcdGRpdkhlYWRlcklubmVyID0gZGl2SGVhZGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRkaXZIZWFkZXJUYWJsZSA9IGRpdkhlYWRlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxuXHRcdGRpdkJvZHlFbCAgICAgID0gc2V0dGluZ3MublNjcm9sbEJvZHksXG5cdFx0ZGl2Qm9keSAgICAgICAgPSAkKGRpdkJvZHlFbCksXG5cdFx0ZGl2Rm9vdGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcblx0XHRkaXZGb290ZXJJbm5lciA9IGRpdkZvb3Rlci5jaGlsZHJlbignZGl2JyksXG5cdFx0ZGl2Rm9vdGVyVGFibGUgPSBkaXZGb290ZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRoZWFkZXIgICAgICAgICA9ICQoc2V0dGluZ3MublRIZWFkKSxcblx0XHR0YWJsZSAgICAgICAgICA9ICQoc2V0dGluZ3MublRhYmxlKSxcblx0XHRmb290ZXIgICAgICAgICA9IHNldHRpbmdzLm5URm9vdCAmJiAkKCd0aCwgdGQnLCBzZXR0aW5ncy5uVEZvb3QpLmxlbmd0aCA/ICQoc2V0dGluZ3MublRGb290KSA6IG51bGwsXG5cdFx0YnJvd3NlciAgICAgICAgPSBzZXR0aW5ncy5vQnJvd3Nlcixcblx0XHRoZWFkZXJDb3B5LCBmb290ZXJDb3B5O1xuXG5cdC8vIElmIHRoZSBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGRyYXcsIHdlIG5lZWQgdG9cblx0Ly8gYWRqdXN0IHRoZSBjb2x1bW4gc2l6ZXMgYXMgdGhlIHRhYmxlIHdpZHRoIHdpbGwgaGF2ZSBjaGFuZ2VkIHRvIGFjY291bnRcblx0Ly8gZm9yIHRoZSBzY3JvbGxiYXJcblx0dmFyIHNjcm9sbEJhclZpcyA9IGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0O1xuXHRcblx0aWYgKCBzZXR0aW5ncy5zY3JvbGxCYXJWaXMgIT09IHNjcm9sbEJhclZpcyAmJiBzZXR0aW5ncy5zY3JvbGxCYXJWaXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdFx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nKCBzZXR0aW5ncyApO1xuXHRcdHJldHVybjsgLy8gYWRqdXN0IGNvbHVtbiBzaXppbmcgd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW5cblx0fVxuXHRlbHNlIHtcblx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdH1cblxuXHQvLyAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuXHQvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuXHR0YWJsZS5jaGlsZHJlbigndGhlYWQsIHRmb290JykucmVtb3ZlKCk7XG5cblx0Ly8gQ2xvbmUgdGhlIGN1cnJlbnQgaGVhZGVyIGFuZCBmb290ZXIgZWxlbWVudHMgYW5kIHRoZW4gcGxhY2UgaXQgaW50byB0aGUgaW5uZXIgdGFibGVcblx0aGVhZGVyQ29weSA9IGhlYWRlci5jbG9uZSgpLnByZXBlbmRUbyggdGFibGUgKTtcblx0aGVhZGVyQ29weS5maW5kKCd0aCwgdGQnKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuXHRoZWFkZXJDb3B5LmZpbmQoJ1tpZF0nKS5yZW1vdmVBdHRyKCdpZCcpO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdGZvb3RlckNvcHkgPSBmb290ZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0Zm9vdGVyQ29weS5maW5kKCdbaWRdJykucmVtb3ZlQXR0cignaWQnKTtcblx0fVxuXG5cdC8vIDIuIENvcnJlY3QgY29sZ3JvdXAgPiBjb2wgdmFsdWVzIGlmIG5lZWRlZFxuXHQvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBjZWxsIHNpemVzIGFyZSBzbWFsbGVyIHRoYW4gdGhlIGNvbnRlbnQsIHNvIHdlIG5lZWQgdG9cblx0Ly8gY29ycmVjdCBjb2xncm91cD5jb2wgZm9yIHN1Y2ggY2FzZXMuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgYXV0byB3aWR0aCBkZXRlY3Rpb25cblx0Ly8gdXNlcyBhIGNlbGwgd2hpY2ggaGFzIGEgbG9uZ2VyIHN0cmluZywgYnV0IGlzbid0IHRoZSB3aWRlc3QhIEZvciBleGFtcGxlIFxuXHQvLyBcIkNoaWVmIEV4ZWN1dGl2ZSBPZmZpY2VyIChDRU8pXCIgaXMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIHRoZSBkZW1vLCBidXRcblx0Ly8gXCJTeXN0ZW1zIEFkbWluaXN0cmF0b3JcIiBpcyBhY3R1YWxseSB0aGUgd2lkZXN0IHN0cmluZyBzaW5jZSBpdCBkb2Vzbid0IGNvbGxhcHNlLlxuXHQvLyBOb3RlIHRoZSB1c2Ugb2YgdHJhbnNsYXRpbmcgaW50byBhIGNvbHVtbiBpbmRleCB0byBnZXQgdGhlIGBjb2xgIGVsZW1lbnQuIFRoaXNcblx0Ly8gaXMgYmVjYXVzZSBvZiBSZXNwb25zaXZlIHdoaWNoIG1pZ2h0IHJlbW92ZSBgY29sYCBlbGVtZW50cywga25vY2tpbmcgdGhlIGFsaWdubWVudFxuXHQvLyBvZiB0aGUgaW5kZXhlcyBvdXQuXG5cdGlmIChzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoKSB7XG5cdFx0Ly8gR2V0IHRoZSBjb2x1bW4gc2l6ZXMgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZS4gVGhpcyBzaG91bGQgcmVhbGx5IGJlIGFcblx0XHQvLyBbXS5maW5kLCBidXQgaXQgd2Fzbid0IHN1cHBvcnRlZCBpbiBDaHJvbWUgdW50aWwgU2VwdCAyMDE1LCBhbmQgRFQgaGFzIDEwIHllYXJcblx0XHQvLyBicm93c2VyIHN1cHBvcnRcblx0XHR2YXIgZmlyc3RUciA9IG51bGw7XG5cdFx0dmFyIHN0YXJ0ID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSAhPT0gJ3NzcCdcblx0XHRcdD8gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnRcblx0XHRcdDogMDtcblxuXHRcdGZvciAoaT1zdGFydCA7IGk8c3RhcnQgKyBzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHR2YXIgaWR4ID0gc2V0dGluZ3MuYWlEaXNwbGF5W2ldO1xuXHRcdFx0dmFyIHRyID0gc2V0dGluZ3MuYW9EYXRhW2lkeF0ublRyO1xuXG5cdFx0XHRpZiAodHIpIHtcblx0XHRcdFx0Zmlyc3RUciA9IHRyO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZmlyc3RUcikge1xuXHRcdFx0dmFyIGNvbFNpemVzID0gJChmaXJzdFRyKS5jaGlsZHJlbigndGgsIHRkJykubWFwKGZ1bmN0aW9uICh2aXMpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZHg6IF9mblZpc2libGVUb0NvbHVtbkluZGV4KHNldHRpbmdzLCB2aXMpLFxuXHRcdFx0XHRcdHdpZHRoOiAkKHRoaXMpLm91dGVyV2lkdGgoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIENoZWNrIGFnYWluc3Qgd2hhdCB0aGUgY29sZ3JvdXAgPiBjb2wgaXMgc2V0IHRvIGFuZCBjb3JyZWN0IGlmIG5lZWRlZFxuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTxjb2xTaXplcy5sZW5ndGggOyBpKyspIHtcblx0XHRcdFx0dmFyIGNvbEVsID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xTaXplc1tpXS5pZHggXS5jb2xFbFswXTtcblx0XHRcdFx0dmFyIGNvbFdpZHRoID0gY29sRWwuc3R5bGUud2lkdGgucmVwbGFjZSgncHgnLCAnJyk7XG5cblx0XHRcdFx0aWYgKGNvbFdpZHRoICE9PSBjb2xTaXplc1tpXS53aWR0aCkge1xuXHRcdFx0XHRcdGNvbEVsLnN0eWxlLndpZHRoID0gY29sU2l6ZXNbaV0ud2lkdGggKyAncHgnO1xuXG5cdFx0XHRcdFx0aWYgKHNjcm9sbC5zWCkge1xuXHRcdFx0XHRcdFx0Y29sRWwuc3R5bGUubWluV2lkdGggPSBjb2xTaXplc1tpXS53aWR0aCArICdweCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMy4gQ29weSB0aGUgY29sZ3JvdXAgb3ZlciB0byB0aGUgaGVhZGVyIGFuZCBmb290ZXJcblx0ZGl2SGVhZGVyVGFibGVcblx0XHQuZmluZCgnY29sZ3JvdXAnKVxuXHRcdC5yZW1vdmUoKTtcblxuXHRkaXZIZWFkZXJUYWJsZS5hcHBlbmQoc2V0dGluZ3MuY29sZ3JvdXAuY2xvbmUoKSk7XG5cblx0aWYgKCBmb290ZXIgKSB7XG5cdFx0ZGl2Rm9vdGVyVGFibGVcblx0XHRcdC5maW5kKCdjb2xncm91cCcpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRkaXZGb290ZXJUYWJsZS5hcHBlbmQoc2V0dGluZ3MuY29sZ3JvdXAuY2xvbmUoKSk7XG5cdH1cblxuXHQvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcblx0Ly8gdGhlIGNvbnRlbnQgb2YgdGhlIGNlbGwgc28gdGhhdCB0aGUgd2lkdGggYXBwbGllZCB0byB0aGUgaGVhZGVyIGFuZCBib2R5XG5cdC8vIGJvdGggbWF0Y2gsIGJ1dCB3ZSB3YW50IHRvIGhpZGUgaXQgY29tcGxldGVseS5cblx0JCgndGgsIHRkJywgaGVhZGVyQ29weSkuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0JCh0aGlzLmNoaWxkTm9kZXMpLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJkdC1zY3JvbGwtc2l6aW5nXCI+Jyk7XG5cdH0pO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdCQoJ3RoLCB0ZCcsIGZvb3RlckNvcHkpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0JCh0aGlzLmNoaWxkTm9kZXMpLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJkdC1zY3JvbGwtc2l6aW5nXCI+Jyk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyA0LiBDbGVhbiB1cFxuXHQvLyBGaWd1cmUgb3V0IGlmIHRoZXJlIGFyZSBzY3JvbGxiYXIgcHJlc2VudCAtIGlmIHNvIHRoZW4gd2UgbmVlZCBhIHRoZSBoZWFkZXIgYW5kIGZvb3RlciB0b1xuXHQvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG5cdHZhciBpc1Njcm9sbGluZyA9IE1hdGguZmxvb3IodGFibGUuaGVpZ2h0KCkpID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodCB8fCBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCI7XG5cdHZhciBwYWRkaW5nU2lkZSA9ICdwYWRkaW5nJyArIChicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID8gJ0xlZnQnIDogJ1JpZ2h0JyApO1xuXG5cdC8vIFNldCB0aGUgd2lkdGgncyBvZiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGFibGVzXG5cdHZhciBvdXRlcldpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXG5cdGRpdkhlYWRlclRhYmxlLmNzcygnd2lkdGgnLCBfZm5TdHJpbmdUb0Nzcyggb3V0ZXJXaWR0aCApKTtcblx0ZGl2SGVhZGVySW5uZXJcblx0XHQuY3NzKCd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCBvdXRlcldpZHRoICkpXG5cdFx0LmNzcyhwYWRkaW5nU2lkZSwgaXNTY3JvbGxpbmcgPyBiYXJXaWR0aCtcInB4XCIgOiBcIjBweFwiKTtcblxuXHRpZiAoIGZvb3RlciApIHtcblx0XHRkaXZGb290ZXJUYWJsZS5jc3MoJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3MoIG91dGVyV2lkdGggKSk7XG5cdFx0ZGl2Rm9vdGVySW5uZXJcblx0XHRcdC5jc3MoJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3MoIG91dGVyV2lkdGggKSlcblx0XHRcdC5jc3MocGFkZGluZ1NpZGUsIGlzU2Nyb2xsaW5nID8gYmFyV2lkdGgrXCJweFwiIDogXCIwcHhcIik7XG5cdH1cblxuXHQvLyBDb3JyZWN0IERPTSBvcmRlcmluZyBmb3IgY29sZ3JvdXAgLSBjb21lcyBiZWZvcmUgdGhlIHRoZWFkXG5cdHRhYmxlLmNoaWxkcmVuKCdjb2xncm91cCcpLnByZXBlbmRUbyh0YWJsZSk7XG5cblx0Ly8gQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyXG5cdGRpdkJvZHkudHJpZ2dlcignc2Nyb2xsJyk7XG5cblx0Ly8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXG5cdC8vIG9ubHkgaWYgd2UgYXJlbid0IGhvbGRpbmcgdGhlIHBvc2l0aW9uXG5cdGlmICggKHNldHRpbmdzLmJTb3J0ZWQgfHwgc2V0dGluZ3MuYkZpbHRlcmVkKSAmJiAhIHNldHRpbmdzLl9kcmF3SG9sZCApIHtcblx0XHRkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcblx0fVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgY29sdW1ucyBmb3IgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyAoIHNldHRpbmdzIClcbntcblx0Ly8gTm90IGludGVyZXN0ZWQgaW4gZG9pbmcgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uIGlmIGF1dG8td2lkdGggaXMgZGlzYWJsZWRcblx0aWYgKCEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJBdXRvV2lkdGgpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHR0YWJsZSA9IHNldHRpbmdzLm5UYWJsZSxcblx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGwsXG5cdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRzY3JvbGxYID0gc2Nyb2xsLnNYLFxuXHRcdHNjcm9sbFhJbm5lciA9IHNjcm9sbC5zWElubmVyLFxuXHRcdHZpc2libGVDb2x1bW5zID0gX2ZuR2V0Q29sdW1ucyggc2V0dGluZ3MsICdiVmlzaWJsZScgKSxcblx0XHR0YWJsZVdpZHRoQXR0ciA9IHRhYmxlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgLy8gZnJvbSBET00gZWxlbWVudFxuXHRcdHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcblx0XHRpLCBjb2x1bW4sIGNvbHVtbklkeDtcblx0XHRcblx0dmFyIHN0eWxlV2lkdGggPSB0YWJsZS5zdHlsZS53aWR0aDtcblx0dmFyIGNvbnRhaW5lcldpZHRoID0gX2ZuV3JhcHBlcldpZHRoKHNldHRpbmdzKTtcblxuXHQvLyBEb24ndCByZS1ydW4gZm9yIHRoZSBzYW1lIHdpZHRoIGFzIHRoZSBsYXN0IHRpbWVcblx0aWYgKGNvbnRhaW5lcldpZHRoID09PSBzZXR0aW5ncy5jb250YWluZXJXaWR0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHNldHRpbmdzLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG5cblx0Ly8gSWYgdGhlcmUgaXMgbm8gd2lkdGggYXBwbGllZCBhcyBhIENTUyBzdHlsZSBvciBhcyBhbiBhdHRyaWJ1dGUsIHdlIGFzc3VtZSB0aGF0XG5cdC8vIHRoZSB3aWR0aCBpcyBpbnRlbmRlZCB0byBiZSAxMDAlLCB3aGljaCBpcyB1c3VhbGx5IGlzIGluIENTUywgYnV0IGl0IGlzIHZlcnlcblx0Ly8gZGlmZmljdWx0IHRvIGNvcnJlY3RseSBwYXJzZSB0aGUgcnVsZXMgdG8gZ2V0IHRoZSBmaW5hbCByZXN1bHQuXG5cdGlmICggISBzdHlsZVdpZHRoICYmICEgdGFibGVXaWR0aEF0dHIpIHtcblx0XHR0YWJsZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcblx0XHRzdHlsZVdpZHRoID0gJzEwMCUnO1xuXHR9XG5cblx0aWYgKCBzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSApIHtcblx0XHR0YWJsZVdpZHRoQXR0ciA9IHN0eWxlV2lkdGg7XG5cdH1cblxuXHQvLyBMZXQgcGx1Zy1pbnMga25vdyB0aGF0IHdlIGFyZSBkb2luZyBhIHJlY2FsYywgaW4gY2FzZSB0aGV5IGhhdmUgY2hhbmdlZCBhbnkgb2YgdGhlXG5cdC8vIHZpc2libGUgY29sdW1ucyB0aGVpciBvd24gd2F5IChlLmcuIFJlc3BvbnNpdmUgdXNlcyBkaXNwbGF5Om5vbmUpLlxuXHRfZm5DYWxsYmFja0ZpcmUoXG5cdFx0c2V0dGluZ3MsXG5cdFx0bnVsbCxcblx0XHQnY29sdW1uLWNhbGMnLFxuXHRcdHt2aXNpYmxlOiB2aXNpYmxlQ29sdW1uc30sXG5cdFx0ZmFsc2Vcblx0KTtcblxuXHQvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgcm93LCB3b3JzdCBjYXNlLCB0YWJsZSB3aXRoIHRoZSB3aWRlc3Rcblx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdC8vIHRoZSBET00gYW5kIGFsbG93IHRoZSBicm93c2VyIHRvIGRvIGFsbCB0aGUgaGFyZCB3b3JrIG9mIGNhbGN1bGF0aW5nXG5cdC8vIHRhYmxlIHdpZHRoc1xuXHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlLmNsb25lTm9kZSgpKVxuXHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdC5yZW1vdmVBdHRyKCAnaWQnICk7XG5cblx0Ly8gQ2xlYW4gdXAgdGhlIHRhYmxlIGJvZHlcblx0dG1wVGFibGUuYXBwZW5kKCc8dGJvZHk+Jylcblx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXG5cdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdC8vIGZyb20gdGhlIGNsb25lZCB0YWJsZSwgc2luY2UgaWYgc2Nyb2xsaW5nIGlzIGFjdGl2ZSwgdGhlIHRhYmxlJ3Ncblx0Ly8gcmVhbCBoZWFkZXIgYW5kIGZvb3RlciBhcmUgY29udGFpbmVkIGluIGRpZmZlcmVudCB0YWJsZSB0YWdzXG5cdHRtcFRhYmxlXG5cdFx0LmFwcGVuZCggJChzZXR0aW5ncy5uVEhlYWQpLmNsb25lKCkgKVxuXHRcdC5hcHBlbmQoICQoc2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cblx0Ly8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcblx0dG1wVGFibGUuZmluZCgndGZvb3QgdGgsIHRmb290IHRkJykuY3NzKCd3aWR0aCcsICcnKTtcblxuXHQvLyBBcHBseSBjdXN0b20gc2l6aW5nIHRvIHRoZSBjbG9uZWQgaGVhZGVyXG5cdHRtcFRhYmxlLmZpbmQoJ3RoZWFkIHRoLCB0aGVhZCB0ZCcpLmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBHZXQgdGhlIGB3aWR0aGAgZnJvbSB0aGUgaGVhZGVyIGxheW91dFxuXHRcdHZhciB3aWR0aCA9IF9mbkNvbHVtbnNTdW1XaWR0aCggc2V0dGluZ3MsIHRoaXMsIHRydWUsIGZhbHNlICk7XG5cblx0XHRpZiAoIHdpZHRoICkge1xuXHRcdFx0dGhpcy5zdHlsZS53aWR0aCA9IHdpZHRoO1xuXG5cdFx0XHQvLyBGb3Igc2Nyb2xsWCB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBjb2x1bW4gd2lkdGggb3RoZXJ3aXNlIHRoZVxuXHRcdFx0Ly8gYnJvd3NlciB3aWxsIGNvbGxhcHNlIGl0LiBJZiB0aGlzIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdC8vIHdpZHRoIHRoZSBjb2x1bW4gcmVxdWlyZXMsIHRoZW4gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0aWYgKCBzY3JvbGxYICkge1xuXHRcdFx0XHR0aGlzLnN0eWxlLm1pbldpZHRoID0gd2lkdGg7XG5cblx0XHRcdFx0JCggdGhpcyApLmFwcGVuZCggJCgnPGRpdi8+JykuY3NzKCB7XG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdFx0XHRwYWRkaW5nOiAwLFxuXHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRoZWlnaHQ6IDFcblx0XHRcdFx0fSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5zdHlsZS53aWR0aCA9ICcnO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIEZpbmQgdGhlIHdpZGVzdCBwaWVjZSBvZiBkYXRhIGZvciBlYWNoIGNvbHVtbiBhbmQgcHV0IGl0IGludG8gdGhlIHRhYmxlXG5cdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXG5cdFx0dmFyIGxvbmdlc3QgPSBfZm5HZXRNYXhMZW5TdHJpbmcoc2V0dGluZ3MsIGNvbHVtbklkeCk7XG5cdFx0dmFyIGF1dG9DbGFzcyA9IF9leHQudHlwZS5jbGFzc05hbWVbY29sdW1uLnNUeXBlXTtcblx0XHR2YXIgdGV4dCA9IGxvbmdlc3QgKyBjb2x1bW4uc0NvbnRlbnRQYWRkaW5nO1xuXHRcdHZhciBpbnNlcnQgPSBsb25nZXN0LmluZGV4T2YoJzwnKSA9PT0gLTFcblx0XHRcdD8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcblx0XHRcdDogdGV4dFxuXHRcdFxuXHRcdCQoJzx0ZC8+Jylcblx0XHRcdC5hZGRDbGFzcyhhdXRvQ2xhc3MpXG5cdFx0XHQuYWRkQ2xhc3MoY29sdW1uLnNDbGFzcylcblx0XHRcdC5hcHBlbmQoaW5zZXJ0KVxuXHRcdFx0LmFwcGVuZFRvKHRyKTtcblx0fVxuXG5cdC8vIFRpZHkgdGhlIHRlbXBvcmFyeSB0YWJsZSAtIHJlbW92ZSBuYW1lIGF0dHJpYnV0ZXMgc28gdGhlcmUgYXJlbid0XG5cdC8vIGR1cGxpY2F0ZWQgaW4gdGhlIGRvbSAocmFkaW8gZWxlbWVudHMgZm9yIGV4YW1wbGUpXG5cdCQoJ1tuYW1lXScsIHRtcFRhYmxlKS5yZW1vdmVBdHRyKCduYW1lJyk7XG5cblx0Ly8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdC5cblx0Ly8gQSBob2xkaW5nIGVsZW1lbnQgaXMgdXNlZCwgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mIHRoZSBjb250YWluZXJcblx0Ly8gd2l0aCBtaW5pbWFsIGhlaWdodCwgc28gaXQgaGFzIG5vIGVmZmVjdCBvbiBpZiB0aGUgY29udGFpbmVyIHNjcm9sbHNcblx0Ly8gb3Igbm90LiBPdGhlcndpc2UgaXQgbWlnaHQgdHJpZ2dlciBzY3JvbGxpbmcgd2hlbiBpdCBhY3R1YWxseSBpc24ndFxuXHQvLyBuZWVkZWRcblx0dmFyIGhvbGRlciA9ICQoJzxkaXYvPicpLmNzcyggc2Nyb2xsWCB8fCBzY3JvbGxZID9cblx0XHRcdHtcblx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHR9IDpcblx0XHRcdHt9XG5cdFx0KVxuXHRcdC5hcHBlbmQoIHRtcFRhYmxlIClcblx0XHQuYXBwZW5kVG8oIHRhYmxlQ29udGFpbmVyICk7XG5cblx0Ly8gV2hlbiBzY3JvbGxpbmcgKFggb3IgWSkgd2Ugd2FudCB0byBzZXQgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSBhcyBcblx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0Ly8gaXMuIFRoaXMgcmVzdWx0cyBpbiBzbGlnaHRseSBkaWZmZXJlbnQsIGJ1dCBJIHRoaW5rIGNvcnJlY3QgYmVoYXZpb3VyXG5cdGlmICggc2Nyb2xsWCAmJiBzY3JvbGxYSW5uZXIgKSB7XG5cdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHR9XG5cdGVsc2UgaWYgKCBzY3JvbGxYICkge1xuXHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0dG1wVGFibGUucmVtb3ZlQXR0cignd2lkdGgnKTtcblxuXHRcdC8vIElmIHRoZXJlIGlzIG5vIHdpZHRoIGF0dHJpYnV0ZSBvciBzdHlsZSwgdGhlbiBhbGxvdyB0aGUgdGFibGUgdG9cblx0XHQvLyBjb2xsYXBzZVxuXHRcdGlmICggdG1wVGFibGUub3V0ZXJXaWR0aCgpIDwgdGFibGVDb250YWluZXIuY2xpZW50V2lkdGggJiYgdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0bXBUYWJsZS5vdXRlcldpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHR0bXBUYWJsZS5vdXRlcldpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHR9XG5cdGVsc2UgaWYgKCB0YWJsZVdpZHRoQXR0ciApIHtcblx0XHR0bXBUYWJsZS5vdXRlcldpZHRoKCB0YWJsZVdpZHRoQXR0ciApO1xuXHR9XG5cblx0Ly8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGNvbHVtbiBpbiB0aGUgY29uc3RydWN0ZWQgdGFibGVcblx0dmFyIHRvdGFsID0gMDtcblx0dmFyIGJvZHlDZWxscyA9IHRtcFRhYmxlLmZpbmQoJ3Rib2R5IHRyJykuZXEoMCkuY2hpbGRyZW4oKTtcblxuXHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHQvLyBVc2UgZ2V0Qm91bmRpbmcgZm9yIHN1Yi1waXhlbCBhY2N1cmFjeSwgd2hpY2ggd2UgdGhlbiB3YW50IHRvIHJvdW5kIHVwIVxuXHRcdHZhciBib3VuZGluZyA9IGJvZHlDZWxsc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuXHRcdC8vIFRvdGFsIGlzIHRyYWNrZWQgdG8gcmVtb3ZlIGFueSBzdWItcGl4ZWwgZXJyb3JzIGFzIHRoZSBvdXRlcldpZHRoXG5cdFx0Ly8gb2YgdGhlIHRhYmxlIG1pZ2h0IG5vdCBlcXVhbCB0aGUgdG90YWwgZ2l2ZW4gaGVyZVxuXHRcdHRvdGFsICs9IGJvdW5kaW5nO1xuXG5cdFx0Ly8gV2lkdGggZm9yIGVhY2ggY29sdW1uIHRvIHVzZVxuXHRcdGNvbHVtbnNbIHZpc2libGVDb2x1bW5zW2ldIF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGJvdW5kaW5nICk7XG5cdH1cblxuXHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApO1xuXG5cdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0aG9sZGVyLnJlbW92ZSgpO1xuXG5cdC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcblx0Ly8gYWxsb3dzIHRoZSB0YWJsZSBzaXppbmcgdG8gYXV0b21hdGljYWxseSBhZGp1c3Qgd2hlbiB0aGUgd2luZG93IGlzXG5cdC8vIHJlc2l6ZWQuIFVzZSB0aGUgd2lkdGggYXR0ciByYXRoZXIgdGhhbiBDU1MsIHNpbmNlIHdlIGNhbid0IGtub3cgaWYgdGhlXG5cdC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxuXHRpZiAoIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRhYmxlV2lkdGhBdHRyICk7XG5cdH1cblxuXHRpZiAoICh0YWJsZVdpZHRoQXR0ciB8fCBzY3JvbGxYKSAmJiAhIHNldHRpbmdzLl9yZXN6RXZ0ICkge1xuXHRcdHZhciByZXNpemUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG5ld1dpZHRoID0gX2ZuV3JhcHBlcldpZHRoKHNldHRpbmdzKTtcblxuXHRcdFx0Ly8gRG9uJ3QgZG8gaXQgaWYgZGVzdHJveWluZyBvciB0aGUgY29udGFpbmVyIHdpZHRoIGlzIDBcblx0XHRcdGlmICghIHNldHRpbmdzLmJEZXN0cm95aW5nICYmIG5ld1dpZHRoICE9PSAwKSB7XG5cdFx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0ICh+MjAyMCBvbndhcmRzIGZvciB3aWRlIHN1cHBvcnQpIHdlIGNhbiB3YXRjaCBmb3IgdGhlXG5cdFx0Ly8gY29udGFpbmVyIGNoYW5naW5nIHdpZHRoLlxuXHRcdGlmICh3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcblx0XHRcdC8vIFRoaXMgaXMgYSB0cmlja3kgYmVhc3QgLSBpZiB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIHdoZW4gYC5vYnNlcnZlKClgIGlzIGNhbGxlZCxcblx0XHRcdC8vIHRoZW4gdGhlIGNhbGxiYWNrIGlzIGltbWVkaWF0ZWx5IHJ1bi4gV2hpY2ggd2UgZG9uJ3Qgd2FudC4gSWYgdGhlIGVsZW1lbnQgaXNuJ3Rcblx0XHRcdC8vIHZpc2libGUsIHRoZW4gaXQgaXNuJ3QgcnVuLCBidXQgd2Ugd2FudCBpdCB0byBydW4gd2hlbiBpdCBpcyB0aGVuIG1hZGUgdmlzaWJsZS5cblx0XHRcdC8vIFRoaXMgZmxhZyBhbGxvd3MgdGhlIGFib3ZlIHRvIGJlIHNhdGlzZmllZC5cblx0XHRcdHZhciBmaXJzdCA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcikuaXMoJzp2aXNpYmxlJyk7XG5cblx0XHRcdC8vIFVzZSBhbiBlbXB0eSBkaXYgdG8gYXR0YWNoIHRoZSBvYnNlcnZlciBzbyBpdCBpc24ndCBpbXBhY3RlZCBieSBoZWlnaHQgY2hhbmdlc1xuXHRcdFx0dmFyIHJlc2l6ZXIgPSAkKCc8ZGl2PicpXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGRDbGFzcygnZHQtYXV0b3NpemUnKVxuXHRcdFx0XHQuYXBwZW5kVG8oc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XG5cblx0XHRcdHNldHRpbmdzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cmVzaXplKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRzZXR0aW5ncy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlc2l6ZXJbMF0pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEZvciBvbGQgYnJvd3NlcnMsIHRoZSBiZXN0IHdlIGNhbiBkbyBpcyBsaXN0ZW4gZm9yIGEgd2luZG93IHJlc2l6ZVxuXHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytzZXR0aW5ncy5zSW5zdGFuY2UsIHJlc2l6ZSk7XG5cdFx0fVxuXG5cdFx0c2V0dGluZ3MuX3Jlc3pFdnQgPSB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgRGF0YVRhYmxlcyB3cmFwcGVyIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcmV0dXJucyBXaWR0aFxuICovXG5mdW5jdGlvbiBfZm5XcmFwcGVyV2lkdGgoc2V0dGluZ3MpIHtcblx0cmV0dXJuICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcikuaXMoJzp2aXNpYmxlJylcblx0XHQ/ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcikud2lkdGgoKVxuXHRcdDogMDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0gc3RybGVuIGZvciBlYWNoIGRhdGEgY29sdW1uXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3RcbiAqICBAcmV0dXJucyB7c3RyaW5nfSBzdHJpbmcgb2YgdGhlIG1heCBsZW5ndGhcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4IClcbntcblx0dmFyIGNvbHVtbiA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXG5cdGlmICghIGNvbHVtbi5tYXhMZW5TdHJpbmcpIHtcblx0XHR2YXIgcywgbWF4PScnLCBtYXhMZW4gPSAtMTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhciByb3dJZHggPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXJbaV07XG5cdFx0XHR2YXIgZGF0YSA9IF9mbkdldFJvd0Rpc3BsYXkoc2V0dGluZ3MsIHJvd0lkeClbY29sSWR4XTtcblxuXHRcdFx0dmFyIGNlbGxTdHJpbmcgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhLm5vZGVUeXBlXG5cdFx0XHRcdD8gZGF0YS5pbm5lckhUTUxcblx0XHRcdFx0OiBkYXRhKycnO1xuXG5cdFx0XHQvLyBSZW1vdmUgaWQgLyBuYW1lIGF0dHJpYnV0ZXMgZnJvbSBlbGVtZW50cyBzbyB0aGV5XG5cdFx0XHQvLyBkb24ndCBpbnRlcmZlcmUgd2l0aCBleGlzdGluZyBlbGVtZW50c1xuXHRcdFx0Y2VsbFN0cmluZyA9IGNlbGxTdHJpbmdcblx0XHRcdFx0LnJlcGxhY2UoL2lkPVwiLio/XCIvZywgJycpXG5cdFx0XHRcdC5yZXBsYWNlKC9uYW1lPVwiLio/XCIvZywgJycpO1xuXG5cdFx0XHRzID0gX3N0cmlwSHRtbChjZWxsU3RyaW5nKVxuXHRcdFx0XHQucmVwbGFjZSggLyZuYnNwOy9nLCAnICcgKTtcblx0XG5cdFx0XHRpZiAoIHMubGVuZ3RoID4gbWF4TGVuICkge1xuXHRcdFx0XHQvLyBXZSB3YW50IHRoZSBIVE1MIGluIHRoZSBzdHJpbmcsIGJ1dCB0aGUgbGVuZ3RoIHRoYXRcblx0XHRcdFx0Ly8gaXMgaW1wb3J0YW50IGlzIHRoZSBzdHJpcHBlZCBzdHJpbmdcblx0XHRcdFx0bWF4ID0gY2VsbFN0cmluZztcblx0XHRcdFx0bWF4TGVuID0gcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29sdW1uLm1heExlblN0cmluZyA9IG1heDtcblx0fVxuXG5cdHJldHVybiBjb2x1bW4ubWF4TGVuU3RyaW5nO1xufVxuXG5cbi8qKlxuICogQXBwZW5kIGEgQ1NTIHVuaXQgKG9ubHkgaWYgcmVxdWlyZWQpIHRvIGEgc3RyaW5nXG4gKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcbiAqICBAcmV0dXJucyB7c3RyaW5nfSB2YWx1ZSB3aXRoIGNzcyB1bml0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblN0cmluZ1RvQ3NzKCBzIClcbntcblx0aWYgKCBzID09PSBudWxsICkge1xuXHRcdHJldHVybiAnMHB4Jztcblx0fVxuXG5cdGlmICggdHlwZW9mIHMgPT0gJ251bWJlcicgKSB7XG5cdFx0cmV0dXJuIHMgPCAwID9cblx0XHRcdCcwcHgnIDpcblx0XHRcdHMrJ3B4Jztcblx0fVxuXG5cdC8vIENoZWNrIGl0IGhhcyBhIHVuaXQgY2hhcmFjdGVyIGFscmVhZHlcblx0cmV0dXJuIHMubWF0Y2goL1xcZCQvKSA/XG5cdFx0cysncHgnIDpcblx0XHRzO1xufVxuXG4vKipcbiAqIFJlLWluc2VydCB0aGUgYGNvbGAgZWxlbWVudHMgZm9yIGN1cnJlbnQgdmlzaWJpbGl0eVxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRFQgc2V0dGluZ3NcbiAqL1xuZnVuY3Rpb24gX2NvbEdyb3VwKCBzZXR0aW5ncyApIHtcblx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0c2V0dGluZ3MuY29sZ3JvdXAuZW1wdHkoKTtcblxuXHRmb3IgKGk9MCA7IGk8Y29scy5sZW5ndGggOyBpKyspIHtcblx0XHRpZiAoY29sc1tpXS5iVmlzaWJsZSkge1xuXHRcdFx0c2V0dGluZ3MuY29sZ3JvdXAuYXBwZW5kKGNvbHNbaV0uY29sRWwpO1xuXHRcdH1cblx0fVxufVxuXG5cbmZ1bmN0aW9uIF9mblNvcnRJbml0KCBzZXR0aW5ncyApIHtcblx0dmFyIHRhcmdldCA9IHNldHRpbmdzLm5USGVhZDtcblx0dmFyIGhlYWRlclJvd3MgPSB0YXJnZXQucXVlcnlTZWxlY3RvckFsbCgndHInKTtcblx0dmFyIGxlZ2FjeVRvcCA9IHNldHRpbmdzLmJTb3J0Q2VsbHNUb3A7XG5cdHZhciBub3RTZWxlY3RvciA9ICc6bm90KFtkYXRhLWR0LW9yZGVyPVwiZGlzYWJsZVwiXSk6bm90KFtkYXRhLWR0LW9yZGVyPVwiaWNvbi1vbmx5XCJdKSc7XG5cdFxuXHQvLyBMZWdhY3kgc3VwcG9ydCBmb3IgYG9yZGVyQ2VsbHNUb3BgXG5cdGlmIChsZWdhY3lUb3AgPT09IHRydWUpIHtcblx0XHR0YXJnZXQgPSBoZWFkZXJSb3dzWzBdO1xuXHR9XG5cdGVsc2UgaWYgKGxlZ2FjeVRvcCA9PT0gZmFsc2UpIHtcblx0XHR0YXJnZXQgPSBoZWFkZXJSb3dzWyBoZWFkZXJSb3dzLmxlbmd0aCAtIDEgXTtcblx0fVxuXG5cdF9mblNvcnRBdHRhY2hMaXN0ZW5lcihcblx0XHRzZXR0aW5ncyxcblx0XHR0YXJnZXQsXG5cdFx0dGFyZ2V0ID09PSBzZXR0aW5ncy5uVEhlYWRcblx0XHRcdD8gJ3RyJytub3RTZWxlY3RvcisnIHRoJytub3RTZWxlY3RvcisnLCB0cicrbm90U2VsZWN0b3IrJyB0ZCcrbm90U2VsZWN0b3Jcblx0XHRcdDogJ3RoJytub3RTZWxlY3RvcisnLCB0ZCcrbm90U2VsZWN0b3Jcblx0KTtcblxuXHQvLyBOZWVkIHRvIHJlc29sdmUgdGhlIHVzZXIgaW5wdXQgYXJyYXkgaW50byBvdXIgaW50ZXJuYWwgc3RydWN0dXJlXG5cdHZhciBvcmRlciA9IFtdO1xuXHRfZm5Tb3J0UmVzb2x2ZSggc2V0dGluZ3MsIG9yZGVyLCBzZXR0aW5ncy5hYVNvcnRpbmcgKTtcblxuXHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBvcmRlcjtcbn1cblxuXG5mdW5jdGlvbiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoc2V0dGluZ3MsIG5vZGUsIHNlbGVjdG9yLCBjb2x1bW4sIGNhbGxiYWNrKSB7XG5cdF9mbkJpbmRBY3Rpb24oIG5vZGUsIHNlbGVjdG9yLCBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBydW4gPSBmYWxzZTtcblx0XHR2YXIgY29sdW1ucyA9IGNvbHVtbiA9PT0gdW5kZWZpbmVkXG5cdFx0XHQ/IF9mbkNvbHVtbnNGcm9tSGVhZGVyKCBlLnRhcmdldCApXG5cdFx0XHQ6IFtjb2x1bW5dO1xuXG5cdFx0aWYgKCBjb2x1bW5zLmxlbmd0aCApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHR2YXIgcmV0ID0gX2ZuU29ydEFkZCggc2V0dGluZ3MsIGNvbHVtbnNbaV0sIGksIGUuc2hpZnRLZXkgKTtcblxuXHRcdFx0XHRpZiAocmV0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJ1biA9IHRydWU7XG5cdFx0XHRcdH1cdFx0XHRcdFx0XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGZpcnN0IGVudHJ5IGlzIG5vIHNvcnQsIHRoZW4gc3Vic2VxdWVudFxuXHRcdFx0XHQvLyBzb3J0IGNvbHVtbnMgYXJlIGlnbm9yZWRcblx0XHRcdFx0aWYgKHNldHRpbmdzLmFhU29ydGluZy5sZW5ndGggPT09IDEgJiYgc2V0dGluZ3MuYWFTb3J0aW5nWzBdWzFdID09PSAnJykge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChydW4pIHtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ1J1bihzZXR0aW5ncywgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF9mblNvcnQoIHNldHRpbmdzICk7XG5cdFx0XHRcdFx0X2ZuU29ydERpc3BsYXkoIHNldHRpbmdzLCBzZXR0aW5ncy5haURpc3BsYXkgKTtcblxuXHRcdFx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIGZhbHNlLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8qKlxuICogU29ydCB0aGUgZGlzcGxheSBhcnJheSB0byBtYXRjaCB0aGUgbWFzdGVyJ3Mgb3JkZXJcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3NcbiAqL1xuZnVuY3Rpb24gX2ZuU29ydERpc3BsYXkoc2V0dGluZ3MsIGRpc3BsYXkpIHtcblx0aWYgKGRpc3BsYXkubGVuZ3RoIDwgMikge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBtYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cdHZhciBtYXN0ZXJNYXAgPSB7fTtcblx0dmFyIG1hcCA9IHt9O1xuXHR2YXIgaTtcblxuXHQvLyBSYXRoZXIgdGhhbiBuZWVkaW5nIGFuIGBpbmRleE9mYCBvbiBtYXN0ZXIgYXJyYXksIHdlIGNhbiBjcmVhdGUgYSBtYXBcblx0Zm9yIChpPTAgOyBpPG1hc3Rlci5sZW5ndGggOyBpKyspIHtcblx0XHRtYXN0ZXJNYXBbbWFzdGVyW2ldXSA9IGk7XG5cdH1cblxuXHQvLyBBbmQgdGhlbiBjYWNoZSB3aGF0IHdvdWxkIGJlIHRoZSBpbmRleE9mIGZvbSB0aGUgZGlzcGxheVxuXHRmb3IgKGk9MCA7IGk8ZGlzcGxheS5sZW5ndGggOyBpKyspIHtcblx0XHRtYXBbZGlzcGxheVtpXV0gPSBtYXN0ZXJNYXBbZGlzcGxheVtpXV07XG5cdH1cblxuXHRkaXNwbGF5LnNvcnQoZnVuY3Rpb24oYSwgYil7XG5cdFx0Ly8gU2hvcnQgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uIGlzIHNpbXBseSBgbWFzdGVyLmluZGV4T2YoYSkgLSBtYXN0ZXIuaW5kZXhPZihiKTtgXG5cdFx0cmV0dXJuIG1hcFthXSAtIG1hcFtiXTtcblx0fSk7XG59XG5cblxuZnVuY3Rpb24gX2ZuU29ydFJlc29sdmUgKHNldHRpbmdzLCBuZXN0ZWRTb3J0LCBzb3J0KSB7XG5cdHZhciBwdXNoID0gZnVuY3Rpb24gKCBhICkge1xuXHRcdGlmICgkLmlzUGxhaW5PYmplY3QoYSkpIHtcblx0XHRcdGlmIChhLmlkeCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIEluZGV4IGJhc2VkIG9yZGVyaW5nXG5cdFx0XHRcdG5lc3RlZFNvcnQucHVzaChbYS5pZHgsIGEuZGlyXSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChhLm5hbWUpIHtcblx0XHRcdFx0Ly8gTmFtZSBiYXNlZCBvcmRlcmluZ1xuXHRcdFx0XHR2YXIgY29scyA9IF9wbHVjayggc2V0dGluZ3MuYW9Db2x1bW5zLCAnc05hbWUnKTtcblx0XHRcdFx0dmFyIGlkeCA9IGNvbHMuaW5kZXhPZihhLm5hbWUpO1xuXG5cdFx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdFx0bmVzdGVkU29ydC5wdXNoKFtpZHgsIGEuZGlyXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBQbGFpbiBjb2x1bW4gaW5kZXggYW5kIGRpcmVjdGlvbiBwYWlyXG5cdFx0XHRuZXN0ZWRTb3J0LnB1c2goYSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KHNvcnQpICkge1xuXHRcdC8vIE9iamVjdFxuXHRcdHB1c2goc29ydCk7XG5cdH1cblx0ZWxzZSBpZiAoIHNvcnQubGVuZ3RoICYmIHR5cGVvZiBzb3J0WzBdID09PSAnbnVtYmVyJyApIHtcblx0XHQvLyAxRCBhcnJheVxuXHRcdHB1c2goc29ydCk7XG5cdH1cblx0ZWxzZSBpZiAoIHNvcnQubGVuZ3RoICkge1xuXHRcdC8vIDJEIGFycmF5XG5cdFx0Zm9yICh2YXIgej0wOyB6PHNvcnQubGVuZ3RoOyB6KyspIHtcblx0XHRcdHB1c2goc29ydFt6XSk7IC8vIE9iamVjdCBvciBhcnJheVxuXHRcdH1cblx0fVxufVxuXG5cbmZ1bmN0aW9uIF9mblNvcnRGbGF0dGVuICggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRpLCBrLCBrTGVuLFxuXHRcdGFTb3J0ID0gW10sXG5cdFx0ZXh0U29ydCA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlcixcblx0XHRhb0NvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0YURhdGFTb3J0LCBpQ29sLCBzVHlwZSwgc3JjQ29sLFxuXHRcdGZpeGVkID0gc2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQsXG5cdFx0Zml4ZWRPYmogPSAkLmlzUGxhaW5PYmplY3QoIGZpeGVkICksXG5cdFx0bmVzdGVkU29ydCA9IFtdO1xuXHRcblx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iU29ydCApIHtcblx0XHRyZXR1cm4gYVNvcnQ7XG5cdH1cblxuXHQvLyBCdWlsZCB0aGUgc29ydCBhcnJheSwgd2l0aCBwcmUtZml4IGFuZCBwb3N0LWZpeCBvcHRpb25zIGlmIHRoZXkgaGF2ZSBiZWVuXG5cdC8vIHNwZWNpZmllZFxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGZpeGVkICkgKSB7XG5cdFx0X2ZuU29ydFJlc29sdmUoIHNldHRpbmdzLCBuZXN0ZWRTb3J0LCBmaXhlZCApO1xuXHR9XG5cblx0aWYgKCBmaXhlZE9iaiAmJiBmaXhlZC5wcmUgKSB7XG5cdFx0X2ZuU29ydFJlc29sdmUoIHNldHRpbmdzLCBuZXN0ZWRTb3J0LCBmaXhlZC5wcmUgKTtcblx0fVxuXG5cdF9mblNvcnRSZXNvbHZlKCBzZXR0aW5ncywgbmVzdGVkU29ydCwgc2V0dGluZ3MuYWFTb3J0aW5nICk7XG5cblx0aWYgKGZpeGVkT2JqICYmIGZpeGVkLnBvc3QgKSB7XG5cdFx0X2ZuU29ydFJlc29sdmUoIHNldHRpbmdzLCBuZXN0ZWRTb3J0LCBmaXhlZC5wb3N0ICk7XG5cdH1cblxuXHRmb3IgKCBpPTAgOyBpPG5lc3RlZFNvcnQubGVuZ3RoIDsgaSsrIClcblx0e1xuXHRcdHNyY0NvbCA9IG5lc3RlZFNvcnRbaV1bMF07XG5cblx0XHRpZiAoIGFvQ29sdW1uc1sgc3JjQ29sIF0gKSB7XG5cdFx0XHRhRGF0YVNvcnQgPSBhb0NvbHVtbnNbIHNyY0NvbCBdLmFEYXRhU29ydDtcblxuXHRcdFx0Zm9yICggaz0wLCBrTGVuPWFEYXRhU29ydC5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpQ29sID0gYURhdGFTb3J0W2tdO1xuXHRcdFx0XHRzVHlwZSA9IGFvQ29sdW1uc1sgaUNvbCBdLnNUeXBlIHx8ICdzdHJpbmcnO1xuXG5cdFx0XHRcdGlmICggbmVzdGVkU29ydFtpXS5faWR4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0bmVzdGVkU29ydFtpXS5faWR4ID0gYW9Db2x1bW5zW2lDb2xdLmFzU29ydGluZy5pbmRleE9mKG5lc3RlZFNvcnRbaV1bMV0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXN0ZWRTb3J0W2ldWzFdICkge1xuXHRcdFx0XHRcdGFTb3J0LnB1c2goIHtcblx0XHRcdFx0XHRcdHNyYzogICAgICAgc3JjQ29sLFxuXHRcdFx0XHRcdFx0Y29sOiAgICAgICBpQ29sLFxuXHRcdFx0XHRcdFx0ZGlyOiAgICAgICBuZXN0ZWRTb3J0W2ldWzFdLFxuXHRcdFx0XHRcdFx0aW5kZXg6ICAgICBuZXN0ZWRTb3J0W2ldLl9pZHgsXG5cdFx0XHRcdFx0XHR0eXBlOiAgICAgIHNUeXBlLFxuXHRcdFx0XHRcdFx0Zm9ybWF0dGVyOiBleHRTb3J0WyBzVHlwZStcIi1wcmVcIiBdLFxuXHRcdFx0XHRcdFx0c29ydGVyOiAgICBleHRTb3J0WyBzVHlwZStcIi1cIituZXN0ZWRTb3J0W2ldWzFdIF1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYVNvcnQ7XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgdGFibGVcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblNvcnQgKCBvU2V0dGluZ3MsIGNvbCwgZGlyIClcbntcblx0dmFyXG5cdFx0aSwgaWVuLCBpTGVuLFxuXHRcdGFpT3JpZyA9IFtdLFxuXHRcdGV4dFNvcnQgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXIsXG5cdFx0YW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YSxcblx0XHRzb3J0Q29sLFxuXHRcdGRpc3BsYXlNYXN0ZXIgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLFxuXHRcdGFTb3J0O1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGUgY29sdW1ucyBhbGwgaGF2ZSB0eXBlcyBkZWZpbmVkXG5cdF9mbkNvbHVtblR5cGVzKG9TZXR0aW5ncyk7XG5cblx0Ly8gQWxsb3cgYSBzcGVjaWZpYyBjb2x1bW4gdG8gYmUgc29ydGVkLCB3aGljaCB3aWxsIF9ub3RfIGFsdGVyIHRoZSBkaXNwbGF5XG5cdC8vIG1hc3RlclxuXHRpZiAoY29sICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc3JjQ29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tjb2xdO1xuXG5cdFx0YVNvcnQgPSBbe1xuXHRcdFx0c3JjOiAgICAgICBjb2wsXG5cdFx0XHRjb2w6ICAgICAgIGNvbCxcblx0XHRcdGRpcjogICAgICAgZGlyLFxuXHRcdFx0aW5kZXg6ICAgICAwLFxuXHRcdFx0dHlwZTogICAgICBzcmNDb2wuc1R5cGUsXG5cdFx0XHRmb3JtYXR0ZXI6IGV4dFNvcnRbIHNyY0NvbC5zVHlwZStcIi1wcmVcIiBdLFxuXHRcdFx0c29ydGVyOiAgICBleHRTb3J0WyBzcmNDb2wuc1R5cGUrXCItXCIrZGlyIF1cblx0XHR9XTtcblx0XHRkaXNwbGF5TWFzdGVyID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIG9TZXR0aW5ncyApO1xuXHR9XG5cblx0Zm9yICggaT0wLCBpZW49YVNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0c29ydENvbCA9IGFTb3J0W2ldO1xuXG5cdFx0Ly8gTG9hZCB0aGUgZGF0YSBuZWVkZWQgZm9yIHRoZSBzb3J0LCBmb3IgZWFjaCBjZWxsXG5cdFx0X2ZuU29ydERhdGEoIG9TZXR0aW5ncywgc29ydENvbC5jb2wgKTtcblx0fVxuXG5cdC8qIE5vIHNvcnRpbmcgcmVxdWlyZWQgaWYgc2VydmVyLXNpZGUgb3Igbm8gc29ydGluZyBhcnJheSAqL1xuXHRpZiAoIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApICE9ICdzc3AnICYmIGFTb3J0Lmxlbmd0aCAhPT0gMCApXG5cdHtcblx0XHQvLyBSZXNldCB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb24gZWFjaCBwYXNzIHNvIHdlIGdldCBhIHN0YWJsZSBzb3J0XG5cdFx0Zm9yICggaT0wLCBpTGVuPWRpc3BsYXlNYXN0ZXIubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0YWlPcmlnWyBpIF0gPSBpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmaXJzdCBzb3J0IGlzIGRlc2MsIHRoZW4gcmV2ZXJzZSB0aGUgYXJyYXkgdG8gcHJlc2VydmUgb3JpZ2luYWxcblx0XHQvLyBvcmRlciwganVzdCBpbiByZXZlcnNlXG5cdFx0aWYgKGFTb3J0Lmxlbmd0aCAmJiBhU29ydFswXS5kaXIgPT09ICdkZXNjJyAmJiBvU2V0dGluZ3Mub3JkZXJEZXNjUmV2ZXJzZSkge1xuXHRcdFx0YWlPcmlnLnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHQvKiBEbyB0aGUgc29ydCAtIGhlcmUgd2Ugd2FudCBtdWx0aS1jb2x1bW4gc29ydGluZyBiYXNlZCBvbiBhIGdpdmVuIGRhdGEgc291cmNlIChjb2x1bW4pXG5cdFx0ICogYW5kIHNvcnRpbmcgZnVuY3Rpb24gKGZyb20gb1NvcnQpIGluIGEgY2VydGFpbiBkaXJlY3Rpb24uIEl0J3MgcmVhc29uYWJseSBjb21wbGV4IHRvXG5cdFx0ICogZm9sbG93IG9uIGl0J3Mgb3duLCBidXQgdGhpcyBpcyB3aGF0IHdlIHdhbnQgKGV4YW1wbGUgdHdvIGNvbHVtbiBzb3J0aW5nKTpcblx0XHQgKiAgZm5Mb2NhbFNvcnRpbmcgPSBmdW5jdGlvbihhLGIpe1xuXHRcdCAqICAgIHZhciB0ZXN0O1xuXHRcdCAqICAgIHRlc3QgPSBvU29ydFsnc3RyaW5nLWFzYyddKCdkYXRhMTEnLCAnZGF0YTEyJyk7XG5cdFx0ICogICAgICBpZiAodGVzdCAhPT0gMClcblx0XHQgKiAgICAgICAgcmV0dXJuIHRlc3Q7XG5cdFx0ICogICAgdGVzdCA9IG9Tb3J0WydudW1lcmljLWRlc2MnXSgnZGF0YTIxJywgJ2RhdGEyMicpO1xuXHRcdCAqICAgIGlmICh0ZXN0ICE9PSAwKVxuXHRcdCAqICAgICAgcmV0dXJuIHRlc3Q7XG5cdFx0ICogICAgcmV0dXJuIG9Tb3J0WydudW1lcmljLWFzYyddKCBhaU9yaWdbYV0sIGFpT3JpZ1tiXSApO1xuXHRcdCAqICB9XG5cdFx0ICogQmFzaWNhbGx5IHdlIGhhdmUgYSB0ZXN0IGZvciBlYWNoIHNvcnRpbmcgY29sdW1uLCBpZiB0aGUgZGF0YSBpbiB0aGF0IGNvbHVtbiBpcyBlcXVhbCxcblx0XHQgKiB0ZXN0IHRoZSBuZXh0IGNvbHVtbi4gSWYgYWxsIGNvbHVtbnMgbWF0Y2gsIHRoZW4gd2UgdXNlIGEgbnVtZXJpYyBzb3J0IG9uIHRoZSByb3dcblx0XHQgKiBwb3NpdGlvbnMgaW4gdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkgdG8gcHJvdmlkZSBhIHN0YWJsZSBzb3J0LlxuXHRcdCAqL1xuXHRcdGRpc3BsYXlNYXN0ZXIuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0dmFyXG5cdFx0XHRcdHgsIHksIGssIHRlc3QsIHNvcnQsXG5cdFx0XHRcdGxlbj1hU29ydC5sZW5ndGgsXG5cdFx0XHRcdGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXG5cdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cblx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRzb3J0ID0gYVNvcnRba107XG5cblx0XHRcdFx0Ly8gRGF0YSwgd2hpY2ggbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHRocm91Z2ggYSBgLXByZWAgZnVuY3Rpb25cblx0XHRcdFx0eCA9IGRhdGFBWyBzb3J0LmNvbCBdO1xuXHRcdFx0XHR5ID0gZGF0YUJbIHNvcnQuY29sIF07XG5cblx0XHRcdFx0aWYgKHNvcnQuc29ydGVyKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYSBjdXN0b20gc29ydGVyIChgLWFzY2Agb3IgYC1kZXNjYCkgZm9yIHRoaXNcblx0XHRcdFx0XHQvLyBkYXRhIHR5cGUsIHVzZSBpdFxuXHRcdFx0XHRcdHRlc3QgPSBzb3J0LnNvcnRlcih4LCB5KTtcblxuXHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0ZXN0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHVzZSBnZW5lcmljIHNvcnRpbmdcblx0XHRcdFx0XHR0ZXN0ID0geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblxuXHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBzb3J0LmRpciA9PT0gJ2FzYycgPyB0ZXN0IDogLXRlc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHggPSBhaU9yaWdbYV07XG5cdFx0XHR5ID0gYWlPcmlnW2JdO1xuXG5cdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIGFTb3J0Lmxlbmd0aCA9PT0gMCApIHtcblx0XHQvLyBBcHBseSBpbmRleCBvcmRlclxuXHRcdGRpc3BsYXlNYXN0ZXIuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuXHRcdFx0cmV0dXJuIHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoY29sID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgd2UgaGF2ZSBzb3J0ZWQgdGhlIGRhdGFcblx0XHRvU2V0dGluZ3MuYlNvcnRlZCA9IHRydWU7XG5cdFx0b1NldHRpbmdzLnNvcnREZXRhaWxzID0gYVNvcnQ7XG5cblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ29yZGVyJywgW29TZXR0aW5ncywgYVNvcnRdICk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheU1hc3Rlcjtcbn1cblxuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIHJ1biBvbiB1c2VyIHNvcnQgcmVxdWVzdFxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7bm9kZX0gYXR0YWNoVG8gbm9kZSB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG9cbiAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XG4gKiAgQHBhcmFtIHtpbnR9IGFkZEluZGV4IENvdW50ZXJcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFtzaGlmdD1mYWxzZV0gU2hpZnQgY2xpY2sgYWRkXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Tb3J0QWRkICggc2V0dGluZ3MsIGNvbElkeCwgYWRkSW5kZXgsIHNoaWZ0IClcbntcblx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cdHZhciBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nO1xuXHR2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcblx0dmFyIG5leHRTb3J0SWR4O1xuXHR2YXIgbmV4dCA9IGZ1bmN0aW9uICggYSwgb3ZlcmZsb3cgKSB7XG5cdFx0dmFyIGlkeCA9IGEuX2lkeDtcblx0XHRpZiAoIGlkeCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWR4ID0gYXNTb3J0aW5nLmluZGV4T2YoYVsxXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlkeCsxIDwgYXNTb3J0aW5nLmxlbmd0aCA/XG5cdFx0XHRpZHgrMSA6XG5cdFx0XHRvdmVyZmxvdyA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHQwO1xuXHR9O1xuXG5cdGlmICggISBjb2wuYlNvcnRhYmxlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIENvbnZlcnQgdG8gMkQgYXJyYXkgaWYgbmVlZGVkXG5cdGlmICggdHlwZW9mIHNvcnRpbmdbMF0gPT09ICdudW1iZXInICkge1xuXHRcdHNvcnRpbmcgPSBzZXR0aW5ncy5hYVNvcnRpbmcgPSBbIHNvcnRpbmcgXTtcblx0fVxuXG5cdC8vIElmIGFwcGVuZGluZyB0aGUgc29ydCB0aGVuIHdlIGFyZSBtdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRpZiAoIChzaGlmdCB8fCBhZGRJbmRleCkgJiYgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0TXVsdGkgKSB7XG5cdFx0Ly8gQXJlIHdlIGFscmVhZHkgZG9pbmcgc29tZSBraW5kIG9mIHNvcnQgb24gdGhpcyBjb2x1bW4/XG5cdFx0dmFyIHNvcnRJZHggPSBfcGx1Y2soc29ydGluZywgJzAnKS5pbmRleE9mKGNvbElkeCk7XG5cblx0XHRpZiAoIHNvcnRJZHggIT09IC0xICkge1xuXHRcdFx0Ly8gWWVzLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRcdG5leHRTb3J0SWR4ID0gbmV4dCggc29ydGluZ1tzb3J0SWR4XSwgdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIG5leHRTb3J0SWR4ID09PSBudWxsICYmIHNvcnRpbmcubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRuZXh0U29ydElkeCA9IDA7IC8vIGNhbid0IHJlbW92ZSBzb3J0aW5nIGNvbXBsZXRlbHlcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXh0U29ydElkeCA9PT0gbnVsbCApIHtcblx0XHRcdFx0c29ydGluZy5zcGxpY2UoIHNvcnRJZHgsIDEgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdLl9pZHggPSBuZXh0U29ydElkeDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoc2hpZnQpIHtcblx0XHRcdC8vIE5vIHNvcnQgb24gdGhpcyBjb2x1bW4geWV0LCBiZWluZyBhZGRlZCBieSBzaGlmdCBjbGlja1xuXHRcdFx0Ly8gYWRkIGl0IGFzIGl0c2VsZlxuXHRcdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdLCAwIF0gKTtcblx0XHRcdHNvcnRpbmdbc29ydGluZy5sZW5ndGgtMV0uX2lkeCA9IDA7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTm8gc29ydCBvbiB0aGlzIGNvbHVtbiB5ZXQsIGJlaW5nIGFkZGVkIGZyb20gYSBjb2xzcGFuXG5cdFx0XHQvLyBzbyBhZGQgd2l0aCBzYW1lIGRpcmVjdGlvbiBhcyBmaXJzdCBjb2x1bW5cblx0XHRcdHNvcnRpbmcucHVzaCggWyBjb2xJZHgsIHNvcnRpbmdbMF1bMV0sIDAgXSApO1xuXHRcdFx0c29ydGluZ1tzb3J0aW5nLmxlbmd0aC0xXS5faWR4ID0gMDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHNvcnRpbmcubGVuZ3RoICYmIHNvcnRpbmdbMF1bMF0gPT0gY29sSWR4ICkge1xuXHRcdC8vIFNpbmdsZSBjb2x1bW4gLSBhbHJlYWR5IHNvcnRpbmcgb24gdGhpcyBjb2x1bW4sIG1vZGlmeSB0aGUgc29ydFxuXHRcdG5leHRTb3J0SWR4ID0gbmV4dCggc29ydGluZ1swXSApO1xuXG5cdFx0c29ydGluZy5sZW5ndGggPSAxO1xuXHRcdHNvcnRpbmdbMF1bMV0gPSBhc1NvcnRpbmdbIG5leHRTb3J0SWR4IF07XG5cdFx0c29ydGluZ1swXS5faWR4ID0gbmV4dFNvcnRJZHg7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gU2luZ2xlIGNvbHVtbiAtIHNvcnQgb25seSBvbiB0aGlzIGNvbHVtblxuXHRcdHNvcnRpbmcubGVuZ3RoID0gMDtcblx0XHRzb3J0aW5nLnB1c2goIFsgY29sSWR4LCBhc1NvcnRpbmdbMF0gXSApO1xuXHRcdHNvcnRpbmdbMF0uX2lkeCA9IDA7XG5cdH1cbn1cblxuXG4vKipcbiAqIFNldCB0aGUgc29ydGluZyBjbGFzc2VzIG9uIHRhYmxlJ3MgYm9keSwgTm90ZTogaXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgZnVuY3Rpb25cbiAqIHdoZW4gYlNvcnQgYW5kIGJTb3J0Q2xhc3NlcyBhcmUgZmFsc2VcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApXG57XG5cdHZhciBvbGRTb3J0ID0gc2V0dGluZ3MuYUxhc3RTb3J0O1xuXHR2YXIgc29ydENsYXNzID0gc2V0dGluZ3Mub0NsYXNzZXMub3JkZXIucG9zaXRpb247XG5cdHZhciBzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICk7XG5cdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcblx0dmFyIGksIGllbiwgY29sSWR4O1xuXG5cdGlmICggZmVhdHVyZXMuYlNvcnQgJiYgZmVhdHVyZXMuYlNvcnRDbGFzc2VzICkge1xuXHRcdC8vIFJlbW92ZSBvbGQgc29ydGluZyBjbGFzc2VzXG5cdFx0Zm9yICggaT0wLCBpZW49b2xkU29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbElkeCA9IG9sZFNvcnRbaV0uc3JjO1xuXG5cdFx0XHQvLyBSZW1vdmUgY29sdW1uIHNvcnRpbmdcblx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCApIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBzb3J0Q2xhc3MgKyAoaTwyID8gaSsxIDogMykgKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgbmV3IGNvbHVtbiBzb3J0aW5nXG5cdFx0Zm9yICggaT0wLCBpZW49c29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbElkeCA9IHNvcnRbaV0uc3JjO1xuXG5cdFx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2xJZHggKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggc29ydENsYXNzICsgKGk8MiA/IGkrMSA6IDMpICk7XG5cdFx0fVxuXHR9XG5cblx0c2V0dGluZ3MuYUxhc3RTb3J0ID0gc29ydDtcbn1cblxuXG4vLyBHZXQgdGhlIGRhdGEgdG8gc29ydCBhIGNvbHVtbiwgYmUgaXQgZnJvbSBjYWNoZSwgZnJlc2ggKHBvcHVsYXRpbmcgdGhlXG4vLyBjYWNoZSksIG9yIGZyb20gYSBzb3J0IGZvcm1hdHRlclxuZnVuY3Rpb24gX2ZuU29ydERhdGEoIHNldHRpbmdzLCBjb2xJZHggKVxue1xuXHQvLyBDdXN0b20gc29ydGluZyBmdW5jdGlvbiAtIHByb3ZpZGVkIGJ5IHRoZSBzb3J0IGRhdGEgdHlwZVxuXHR2YXIgY29sdW1uID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xJZHggXTtcblx0dmFyIGN1c3RvbVNvcnQgPSBEYXRhVGFibGUuZXh0Lm9yZGVyWyBjb2x1bW4uc1NvcnREYXRhVHlwZSBdO1xuXHR2YXIgY3VzdG9tRGF0YTtcblxuXHRpZiAoIGN1c3RvbVNvcnQgKSB7XG5cdFx0Y3VzdG9tRGF0YSA9IGN1c3RvbVNvcnQuY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgY29sSWR4LFxuXHRcdFx0X2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIHNldHRpbmdzLCBjb2xJZHggKVxuXHRcdCk7XG5cdH1cblxuXHQvLyBVc2UgLyBwb3B1bGF0ZSBjYWNoZVxuXHR2YXIgcm93LCBjZWxsRGF0YTtcblx0dmFyIGZvcm1hdHRlciA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlclsgY29sdW1uLnNUeXBlK1wiLXByZVwiIF07XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXG5cdGZvciAoIHZhciByb3dJZHg9MCA7IHJvd0lkeDxkYXRhLmxlbmd0aCA7IHJvd0lkeCsrICkge1xuXHRcdC8vIFNwYXJzZSBhcnJheVxuXHRcdGlmICghIGRhdGFbcm93SWR4XSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0cm93ID0gZGF0YVtyb3dJZHhdO1xuXG5cdFx0aWYgKCAhIHJvdy5fYVNvcnREYXRhICkge1xuXHRcdFx0cm93Ll9hU29ydERhdGEgPSBbXTtcblx0XHR9XG5cblx0XHRpZiAoICEgcm93Ll9hU29ydERhdGFbY29sSWR4XSB8fCBjdXN0b21Tb3J0ICkge1xuXHRcdFx0Y2VsbERhdGEgPSBjdXN0b21Tb3J0ID9cblx0XHRcdFx0Y3VzdG9tRGF0YVtyb3dJZHhdIDogLy8gSWYgdGhlcmUgd2FzIGEgY3VzdG9tIHNvcnQgZnVuY3Rpb24sIHVzZSBkYXRhIGZyb20gdGhlcmVcblx0XHRcdFx0X2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgJ3NvcnQnICk7XG5cblx0XHRcdHJvdy5fYVNvcnREYXRhWyBjb2xJZHggXSA9IGZvcm1hdHRlciA/XG5cdFx0XHRcdGZvcm1hdHRlciggY2VsbERhdGEsIHNldHRpbmdzICkgOlxuXHRcdFx0XHRjZWxsRGF0YTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIFN0YXRlIGluZm9ybWF0aW9uIGZvciBhIHRhYmxlXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5nc1xuICogQHJldHVybnMgU3RhdGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9mblNhdmVTdGF0ZSAoIHNldHRpbmdzIClcbntcblx0aWYgKHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU29ydCBzdGF0ZSBzYXZpbmcgdXNlcyBbW2lkeCwgb3JkZXJdXSBzdHJ1Y3R1cmUuXG5cdHZhciBzb3J0aW5nID0gW107XG5cdF9mblNvcnRSZXNvbHZlKHNldHRpbmdzLCBzb3J0aW5nLCBzZXR0aW5ncy5hYVNvcnRpbmcgKTtcblxuXHQvKiBTdG9yZSB0aGUgaW50ZXJlc3RpbmcgdmFyaWFibGVzICovXG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgc3RhdGUgPSB7XG5cdFx0dGltZTogICAgK25ldyBEYXRlKCksXG5cdFx0c3RhcnQ6ICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuZ3RoOiAgc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdG9yZGVyOiAgIHNvcnRpbmcubWFwKGZ1bmN0aW9uIChzb3J0KSB7XG5cdFx0XHQvLyBJZiBhIGNvbHVtbiBuYW1lIGlzIGF2YWlsYWJsZSwgdXNlIGl0XG5cdFx0XHRyZXR1cm4gY29sdW1uc1tzb3J0WzBdXSAmJiBjb2x1bW5zW3NvcnRbMF1dLnNOYW1lXG5cdFx0XHRcdD8gWyBjb2x1bW5zW3NvcnRbMF1dLnNOYW1lLCBzb3J0WzFdIF1cblx0XHRcdFx0OiBzb3J0LnNsaWNlKCk7XG5cdFx0fSApLFxuXHRcdHNlYXJjaDogICQuZXh0ZW5kKHt9LCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gpLFxuXHRcdGNvbHVtbnM6IHNldHRpbmdzLmFvQ29sdW1ucy5tYXAoIGZ1bmN0aW9uICggY29sLCBpICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bmFtZTogY29sLnNOYW1lLFxuXHRcdFx0XHR2aXNpYmxlOiBjb2wuYlZpc2libGUsXG5cdFx0XHRcdHNlYXJjaDogJC5leHRlbmQoe30sIHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSlcblx0XHRcdH07XG5cdFx0fSApXG5cdH07XG5cblx0c2V0dGluZ3Mub1NhdmVkU3RhdGUgPSBzdGF0ZTtcblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiLCAnc3RhdGVTYXZlUGFyYW1zJywgW3NldHRpbmdzLCBzdGF0ZV0gKTtcblx0XG5cdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJTdGF0ZVNhdmUgJiYgIXNldHRpbmdzLmJEZXN0cm95aW5nIClcblx0e1xuXHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgc3RhdGUgKTtcblx0fVx0XG59XG5cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGxvYWQgYSBzYXZlZCB0YWJsZSBzdGF0ZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gb0luaXQgRGF0YVRhYmxlcyBpbml0IG9iamVjdCBzbyB3ZSBjYW4gb3ZlcnJpZGUgc2V0dGluZ3NcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Mb2FkU3RhdGUgKCBzZXR0aW5ncywgaW5pdCwgY2FsbGJhY2sgKVxue1xuXHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTdGF0ZVNhdmUgKSB7XG5cdFx0Y2FsbGJhY2soKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgbG9hZGVkID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRfZm5JbXBsZW1lbnRTdGF0ZShzZXR0aW5ncywgc3RhdGUsIGNhbGxiYWNrKTtcblx0fVxuXG5cdHZhciBzdGF0ZSA9IHNldHRpbmdzLmZuU3RhdGVMb2FkQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgbG9hZGVkICk7XG5cblx0aWYgKCBzdGF0ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdF9mbkltcGxlbWVudFN0YXRlKCBzZXR0aW5ncywgc3RhdGUsIGNhbGxiYWNrICk7XG5cdH1cblx0Ly8gb3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgbG9hZGVkIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG5cblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9mbkltcGxlbWVudFN0YXRlICggc2V0dGluZ3MsIHMsIGNhbGxiYWNrKSB7XG5cdHZhciBpLCBpZW47XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgY3VycmVudE5hbWVzID0gX3BsdWNrKHNldHRpbmdzLmFvQ29sdW1ucywgJ3NOYW1lJyk7XG5cblx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSB0cnVlO1xuXG5cdC8vIFdoZW4gU3RhdGVSZXN0b3JlIHdhcyBpbnRyb2R1Y2VkIHRoZSBzdGF0ZSBjb3VsZCBub3cgYmUgaW1wbGVtZW50ZWQgYXQgYW55IHRpbWVcblx0Ly8gTm90IGp1c3QgaW5pdGlhbGlzYXRpb24uIFRvIGRvIHRoaXMgYW4gYXBpIGluc3RhbmNlIGlzIHJlcXVpcmVkIGluIHNvbWUgcGxhY2VzXG5cdHZhciBhcGkgPSBzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSA/IG5ldyBEYXRhVGFibGUuQXBpKHNldHRpbmdzKSA6IG51bGw7XG5cblx0aWYgKCAhIHMgfHwgISBzLnRpbWUgKSB7XG5cdFx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSBmYWxzZTtcblx0XHRjYWxsYmFjaygpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlamVjdCBvbGQgZGF0YVxuXHR2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbjtcblx0aWYgKCBkdXJhdGlvbiA+IDAgJiYgcy50aW1lIDwgK25ldyBEYXRlKCkgLSAoZHVyYXRpb24qMTAwMCkgKSB7XG5cdFx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSBmYWxzZTtcblx0XHRjYWxsYmFjaygpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEFsbG93IGN1c3RvbSBhbmQgcGx1Zy1pbiBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHRvIGFsdGVyIHRoZSBzYXZlZCBkYXRhIHNldCBhbmRcblx0Ly8gY2FuY2VsbGluZyBvZiBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxuXHR2YXIgYWJTdGF0ZUxvYWQgPSBfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCAnc3RhdGVMb2FkUGFyYW1zJywgW3NldHRpbmdzLCBzXSApO1xuXHRpZiAoIGFiU3RhdGVMb2FkLmluZGV4T2YoZmFsc2UpICE9PSAtMSApIHtcblx0XHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRcdGNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3RvcmUgdGhlIHNhdmVkIHN0YXRlIHNvIGl0IG1pZ2h0IGJlIGFjY2Vzc2VkIGF0IGFueSB0aW1lXG5cdHNldHRpbmdzLm9Mb2FkZWRTdGF0ZSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgcyApO1xuXG5cdC8vIFRoaXMgaXMgbmVlZGVkIGZvciBDb2xSZW9yZGVyLCB3aGljaCBoYXMgdG8gaGFwcGVuIGZpcnN0IHRvIGFsbG93IGFsbFxuXHQvLyB0aGUgc3RvcmVkIGluZGV4ZXMgdG8gYmUgdXNhYmxlLiBJdCBpcyBub3QgcHVibGljbHkgZG9jdW1lbnRlZC5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3N0YXRlTG9hZEluaXQnLCBbc2V0dGluZ3MsIHNdLCB0cnVlICk7XG5cblx0Ly8gUGFnZSBMZW5ndGhcblx0aWYgKCBzLmxlbmd0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIElmIGFscmVhZHkgaW5pdGlhbGlzZWQganVzdCBzZXQgdGhlIHZhbHVlIGRpcmVjdGx5IHNvIHRoYXQgdGhlIHNlbGVjdCBlbGVtZW50IGlzIGFsc28gdXBkYXRlZFxuXHRcdGlmIChhcGkpIHtcblx0XHRcdGFwaS5wYWdlLmxlbihzLmxlbmd0aClcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggICA9IHMubGVuZ3RoO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlc3RvcmUga2V5IGZlYXR1cmVzXG5cdGlmICggcy5zdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGlmKGFwaSA9PT0gbnVsbCkge1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgICAgPSBzLnN0YXJ0O1xuXHRcdFx0c2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBzLnN0YXJ0O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdF9mblBhZ2VDaGFuZ2Uoc2V0dGluZ3MsIHMuc3RhcnQvc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBPcmRlclxuXHRpZiAoIHMub3JkZXIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBbXTtcblx0XHQkLmVhY2goIHMub3JkZXIsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdFx0dmFyIHNldCA9IFsgY29sWzBdLCBjb2xbMV0gXTtcblxuXHRcdFx0Ly8gQSBjb2x1bW4gbmFtZSB3YXMgc3RvcmVkIGFuZCBzaG91bGQgYmUgdXNlZCBmb3IgcmVzdG9yZVxuXHRcdFx0aWYgKHR5cGVvZiBjb2xbMF0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHZhciBpZHggPSBjdXJyZW50TmFtZXMuaW5kZXhPZihjb2xbMF0pO1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5hbWUgZnJvbSB0aGUgY3VycmVudCBsaXN0IG9mIGNvbHVtbiBuYW1lcywgb3IgZmFsbGJhY2sgdG8gaW5kZXggMFxuXHRcdFx0XHRzZXRbMF0gPSBpZHggPj0gMFxuXHRcdFx0XHRcdD8gaWR4XG5cdFx0XHRcdFx0OiAwO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoc2V0WzBdID49IGNvbHVtbnMubGVuZ3RoKSB7XG5cdFx0XHRcdC8vIElmIGEgY29sdW1uIG5hbWUsIGJ1dCBpdCBpcyBvdXQgb2YgYm91bmRzLCBzZXQgdG8gMFxuXHRcdFx0XHRzZXRbMF0gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcucHVzaChzZXQpO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNlYXJjaFxuXHRpZiAoIHMuc2VhcmNoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0JC5leHRlbmQoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgcy5zZWFyY2ggKTtcblx0fVxuXG5cdC8vIENvbHVtbnNcblx0aWYgKCBzLmNvbHVtbnMgKSB7XG5cdFx0dmFyIHNldCA9IHMuY29sdW1ucztcblx0XHR2YXIgaW5jb21pbmcgPSBfcGx1Y2socy5jb2x1bW5zLCAnbmFtZScpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgaXQgaXMgYSAyLjIgc3R5bGUgc3RhdGUgb2JqZWN0IHdpdGggYSBgbmFtZWAgcHJvcGVydHkgZm9yIHRoZSBjb2x1bW5zLCBhbmQgaWZcblx0XHQvLyB0aGUgbmFtZSB3YXMgZGVmaW5lZC4gSWYgc28sIHRoZW4gY3JlYXRlIGEgbmV3IGFycmF5IHRoYXQgd2lsbCBtYXAgdGhlIHN0YXRlIG9iamVjdFxuXHRcdC8vIGdpdmVuLCB0byB0aGUgY3VycmVudCBjb2x1bW5zIChkb24ndCBib3RoZXIgaWYgdGhleSBhcmUgYWxyZWFkeSBtYXRjaGluZyB0aG8pLlxuXHRcdGlmIChpbmNvbWluZy5qb2luKCcnKS5sZW5ndGggJiYgaW5jb21pbmcuam9pbignJykgIT09IGN1cnJlbnROYW1lcy5qb2luKCcnKSkge1xuXHRcdFx0c2V0ID0gW107XG5cblx0XHRcdC8vIEZvciBlYWNoIGNvbHVtbiwgdHJ5IHRvIGZpbmQgdGhlIG5hbWUgaW4gdGhlIGluY29taW5nIGFycmF5XG5cdFx0XHRmb3IgKGk9MCA7IGk8Y3VycmVudE5hbWVzLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0XHRpZiAoY3VycmVudE5hbWVzW2ldICE9ICcnKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IGluY29taW5nLmluZGV4T2YoY3VycmVudE5hbWVzW2ldKTtcblxuXHRcdFx0XHRcdGlmIChpZHggPj0gMCkge1xuXHRcdFx0XHRcdFx0c2V0LnB1c2gocy5jb2x1bW5zW2lkeF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE5vIG1hdGNoaW5nIGNvbHVtbiBuYW1lIGluIHRoZSBzdGF0ZSdzIGNvbHVtbnMsIHNvIHRoaXMgbWlnaHQgYmUgYSBuZXdcblx0XHRcdFx0XHRcdC8vIGNvbHVtbiBhbmQgdGh1cyBjYW4ndCBoYXZlIGEgc3RhdGUgYWxyZWFkeS5cblx0XHRcdFx0XHRcdHNldC5wdXNoKHt9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgbm8gbmFtZSwgYnV0IG90aGVyIGNvbHVtbnMgZGlkIGhhdmUgYSBuYW1lLCB0aGVuIHRoZXJlIGlzIG5vIGtub3dpbmdcblx0XHRcdFx0XHQvLyB3aGVyZSB0aGlzIG9uZSBjYW1lIGZyb20gb3JpZ2luYWxseSBzbyBpdCBjYW4ndCBiZSByZXN0b3JlZC5cblx0XHRcdFx0XHRzZXQucHVzaCh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gcmVzdG9yZSBpcyBkaWZmZXJlbnQgZnJvbSBjdXJyZW50LCB0aGVuIGFsbCBiZXRzIGFyZSBvZmYuXG5cdFx0aWYgKHNldC5sZW5ndGggPT09IGNvbHVtbnMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1zZXQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHZhciBjb2wgPSBzZXRbaV07XG5cblx0XHRcdFx0Ly8gVmlzaWJpbGl0eVxuXHRcdFx0XHRpZiAoIGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGFwaSBpcyBkZWZpbmVkLCB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQgc28gd2UgbmVlZCB0byB1c2UgaXQgcmF0aGVyIHRoYW4gaW50ZXJuYWwgc2V0dGluZ3Ncblx0XHRcdFx0XHRpZiAoYXBpKSB7XG5cdFx0XHRcdFx0XHQvLyBEb24ndCByZWRyYXcgdGhlIGNvbHVtbnMgb24gZXZlcnkgaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCwgd2Ugd2lsbCBkbyB0aGlzIGF0IHRoZSBlbmQgaW5zdGVhZFxuXHRcdFx0XHRcdFx0YXBpLmNvbHVtbihpKS52aXNpYmxlKGNvbC52aXNpYmxlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29sdW1uc1tpXS5iVmlzaWJsZSA9IGNvbC52aXNpYmxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlYXJjaFxuXHRcdFx0XHRpZiAoIGNvbC5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQkLmV4dGVuZCggc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldLCBjb2wuc2VhcmNoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGFwaSBpcyBkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBhZGp1c3QgdGhlIGNvbHVtbnMgb25jZSB0aGUgdmlzaWJpbGl0eSBoYXMgYmVlbiBjaGFuZ2VkXG5cdFx0XHRpZiAoYXBpKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gZmFsc2U7XG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgJ3N0YXRlTG9hZGVkJywgW3NldHRpbmdzLCBzXSApO1xuXHRjYWxsYmFjaygpO1xufVxuXG4vKipcbiAqIExvZyBhbiBlcnJvciBtZXNzYWdlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGxldmVsIGxvZyBlcnJvciBtZXNzYWdlcywgb3IgZGlzcGxheSB0aGVtIHRvIHRoZSB1c2VyXG4gKiAgQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlXG4gKiAgQHBhcmFtIHtpbnR9IHRuIFRlY2huaWNhbCBub3RlIGlkIHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuTG9nKCBzZXR0aW5ncywgbGV2ZWwsIG1zZywgdG4gKVxue1xuXHRtc2cgPSAnRGF0YVRhYmxlcyB3YXJuaW5nOiAnK1xuXHRcdChzZXR0aW5ncyA/ICd0YWJsZSBpZD0nK3NldHRpbmdzLnNUYWJsZUlkKycgLSAnIDogJycpK21zZztcblxuXHRpZiAoIHRuICkge1xuXHRcdG1zZyArPSAnLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlICcrXG5cdFx0J2h0dHBzOi8vZGF0YXRhYmxlcy5uZXQvdG4vJyt0bjtcblx0fVxuXG5cdGlmICggISBsZXZlbCAgKSB7XG5cdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHJlIDEuMTBcblx0XHR2YXIgZXh0ID0gRGF0YVRhYmxlLmV4dDtcblx0XHR2YXIgdHlwZSA9IGV4dC5zRXJyTW9kZSB8fCBleHQuZXJyTW9kZTtcblxuXHRcdGlmICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnZHQtZXJyb3InLCBbIHNldHRpbmdzLCB0biwgbXNnIF0sIHRydWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT0gJ2FsZXJ0JyApIHtcblx0XHRcdGFsZXJ0KCBtc2cgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGUgPT0gJ3Rocm93JyApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHR5cGUoIHNldHRpbmdzLCB0biwgbXNnICk7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKCB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyApIHtcblx0XHRjb25zb2xlLmxvZyggbXNnICk7XG5cdH1cbn1cblxuXG4vKipcbiAqIFNlZSBpZiBhIHByb3BlcnR5IGlzIGRlZmluZWQgb24gb25lIG9iamVjdCwgaWYgc28gYXNzaWduIGl0IHRvIHRoZSBvdGhlciBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gcmV0IHRhcmdldCBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gc3JjIHNvdXJjZSBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ30gbmFtZSBwcm9wZXJ0eVxuICogIEBwYXJhbSB7c3RyaW5nfSBbbWFwcGVkTmFtZV0gbmFtZSB0byBtYXAgdG9vIC0gb3B0aW9uYWwsIG5hbWUgdXNlZCBpZiBub3QgZ2l2ZW5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuTWFwKCByZXQsIHNyYywgbmFtZSwgbWFwcGVkTmFtZSApXG57XG5cdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdCQuZWFjaCggbmFtZSwgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0X2ZuTWFwKCByZXQsIHNyYywgdmFsWzBdLCB2YWxbMV0gKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIG1hcHBlZE5hbWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRtYXBwZWROYW1lID0gbmFtZTtcblx0fVxuXG5cdGlmICggc3JjW25hbWVdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0W21hcHBlZE5hbWVdID0gc3JjW25hbWVdO1xuXHR9XG59XG5cblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0cyAtIHZlcnkgc2ltaWxhciB0byBqUXVlcnkuZXh0ZW5kLCBidXQgZGVlcCBjb3B5IG9iamVjdHMsIGFuZFxuICogc2hhbGxvdyBjb3B5IGFycmF5cy4gVGhlIHJlYXNvbiB3ZSBuZWVkIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0b1xuICogZGVlcCBjb3B5IGFycmF5IGluaXQgdmFsdWVzIChzdWNoIGFzIGFhU29ydGluZykgc2luY2UgdGhlIGRldiB3b3VsZG4ndCBiZVxuICogYWJsZSB0byBvdmVycmlkZSB0aGVtLCBidXQgd2UgZG8gd2FudCB0byBkZWVwIGNvcHkgYXJyYXlzLlxuICogIEBwYXJhbSB7b2JqZWN0fSBvdXQgT2JqZWN0IHRvIGV4dGVuZFxuICogIEBwYXJhbSB7b2JqZWN0fSBleHRlbmRlciBPYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIGFwcGxpZWQgdG9cbiAqICAgICAgb3V0XG4gKiAgQHBhcmFtIHtib29sZWFufSBicmVha1JlZnMgSWYgdHJ1ZSwgdGhlbiBhcnJheXMgd2lsbCBiZSBzbGljZWQgdG8gdGFrZSBhblxuICogICAgICBpbmRlcGVuZGVudCBjb3B5IHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgYGRhdGFgIG9yIGBhYURhdGFgIHBhcmFtZXRlcnNcbiAqICAgICAgaWYgdGhleSBhcmUgcHJlc2VudC4gVGhpcyBpcyBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjb2xsZWN0aW9uIHRvXG4gKiAgICAgIERhdGFUYWJsZXMgYW5kIGhhdmUgdGhhdCB1c2VkIGFzIHlvdXIgZGF0YSBzb3VyY2Ugd2l0aG91dCBicmVha2luZyB0aGVcbiAqICAgICAgcmVmZXJlbmNlc1xuICogIEByZXR1cm5zIHtvYmplY3R9IG91dCBSZWZlcmVuY2UsIGp1c3QgZm9yIGNvbnZlbmllbmNlIC0gb3V0ID09PSB0aGUgcmV0dXJuLlxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICogIEB0b2RvIFRoaXMgZG9lc24ndCB0YWtlIGFjY291bnQgb2YgYXJyYXlzIGluc2lkZSB0aGUgZGVlcCBjb3BpZWQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gX2ZuRXh0ZW5kKCBvdXQsIGV4dGVuZGVyLCBicmVha1JlZnMgKVxue1xuXHR2YXIgdmFsO1xuXG5cdGZvciAoIHZhciBwcm9wIGluIGV4dGVuZGVyICkge1xuXHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4dGVuZGVyLCBwcm9wKSApIHtcblx0XHRcdHZhbCA9IGV4dGVuZGVyW3Byb3BdO1xuXG5cdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsICkgKSB7XG5cdFx0XHRcdGlmICggISAkLmlzUGxhaW5PYmplY3QoIG91dFtwcm9wXSApICkge1xuXHRcdFx0XHRcdG91dFtwcm9wXSA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvdXRbcHJvcF0sIHZhbCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGJyZWFrUmVmcyAmJiBwcm9wICE9PSAnZGF0YScgJiYgcHJvcCAhPT0gJ2FhRGF0YScgJiYgQXJyYXkuaXNBcnJheSh2YWwpICkge1xuXHRcdFx0XHRvdXRbcHJvcF0gPSB2YWwuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRvdXRbcHJvcF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuXG4vKipcbiAqIEJpbmQgYW4gZXZlbnQgaGFuZGVycyB0byBhbGxvdyBhIGNsaWNrIG9yIHJldHVybiBrZXkgdG8gYWN0aXZhdGUgdGhlIGNhbGxiYWNrLlxuICogVGhpcyBpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5IHNpbmNlIGEgcmV0dXJuIG9uIHRoZSBrZXlib2FyZCB3aWxsIGhhdmUgdGhlXG4gKiBzYW1lIGVmZmVjdCBhcyBhIGNsaWNrLCBpZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMuXG4gKiAgQHBhcmFtIHtlbGVtZW50fSBuIEVsZW1lbnQgdG8gYmluZCB0aGUgYWN0aW9uIHRvXG4gKiAgQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciAoZm9yIGRlbGVnYXRlZCBldmVudHMpIG9yIGRhdGEgb2JqZWN0XG4gKiAgIHRvIHBhc3MgdG8gdGhlIHRyaWdnZXJlZCBmdW5jdGlvblxuICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQmluZEFjdGlvbiggbiwgc2VsZWN0b3IsIGZuIClcbntcblx0JChuKVxuXHRcdC5vbiggJ2NsaWNrLkRUJywgc2VsZWN0b3IsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRmbihlKTtcblx0XHR9IClcblx0XHQub24oICdrZXlwcmVzcy5EVCcsIHNlbGVjdG9yLCBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoIGUud2hpY2ggPT09IDEzICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGZuKGUpO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5vbiggJ3NlbGVjdHN0YXJ0LkRUJywgc2VsZWN0b3IsIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIERvbid0IHdhbnQgYSBkb3VibGUgY2xpY2sgcmVzdWx0aW5nIGluIHRleHQgc2VsZWN0aW9uXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSApO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbi4gRWFzaWx5IGFsbG93cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvXG4gKiBhbiBhcnJheSBzdG9yZSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBjYW4gdGhlbiBhbGwgYmUgY2FsbGVkIHRvZ2V0aGVyLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBzdG9yZSBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluIG9TZXR0aW5nc1xuICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBiYWNrXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNhbGxiYWNrUmVnKCBzZXR0aW5ncywgc3RvcmUsIGZuIClcbntcblx0aWYgKCBmbiApIHtcblx0XHRzZXR0aW5nc1tzdG9yZV0ucHVzaChmbik7XG5cdH1cbn1cblxuXG4vKipcbiAqIEZpcmUgY2FsbGJhY2sgZnVuY3Rpb25zIGFuZCB0cmlnZ2VyIGV2ZW50cy4gTm90ZSB0aGF0IHRoZSBsb29wIG92ZXIgdGhlXG4gKiBjYWxsYmFjayBhcnJheSBzdG9yZSBpcyBkb25lIGJhY2t3YXJkcyEgRnVydGhlciBub3RlIHRoYXQgeW91IGRvIG5vdCB3YW50IHRvXG4gKiBmaXJlIG9mZiB0cmlnZ2VycyBpbiB0aW1lIHNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKGZvciBleGFtcGxlIGNlbGwgY3JlYXRpb24pXG4gKiBhcyBpdHMgc2xvdy5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ30gY2FsbGJhY2tBcnIgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpblxuICogICAgICBvU2V0dGluZ3NcbiAqICBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGpRdWVyeSBjdXN0b20gZXZlbnQgdG8gdHJpZ2dlci4gSWZcbiAqICAgICAgbnVsbCBubyB0cmlnZ2VyIGlzIGZpcmVkXG4gKiAgQHBhcmFtIHthcnJheX0gYXJncyBBcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gL1xuICogICAgICB0cmlnZ2VyXG4gKiAgQHBhcmFtIHtib29sZWFufSBbYnViYmxlc10gVHJ1ZSBpZiB0aGUgZXZlbnQgc2hvdWxkIGJ1YmJsZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBjYWxsYmFja0FyciwgZXZlbnROYW1lLCBhcmdzLCBidWJibGVzIClcbntcblx0dmFyIHJldCA9IFtdO1xuXG5cdGlmICggY2FsbGJhY2tBcnIgKSB7XG5cdFx0cmV0ID0gc2V0dGluZ3NbY2FsbGJhY2tBcnJdLnNsaWNlKCkucmV2ZXJzZSgpLm1hcCggZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0cmV0dXJuIHZhbC5hcHBseSggc2V0dGluZ3Mub0luc3RhbmNlLCBhcmdzICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBldmVudE5hbWUgIT09IG51bGwpIHtcblx0XHR2YXIgZSA9ICQuRXZlbnQoIGV2ZW50TmFtZSsnLmR0JyApO1xuXHRcdHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblx0XHRcblx0XHQvLyBFeHBvc2UgdGhlIERhdGFUYWJsZXMgQVBJIG9uIHRoZSBldmVudCBvYmplY3QgZm9yIGVhc3kgYWNjZXNzXG5cdFx0ZS5kdCA9IHNldHRpbmdzLmFwaTtcblxuXHRcdHRhYmxlW2J1YmJsZXMgPyAgJ3RyaWdnZXInIDogJ3RyaWdnZXJIYW5kbGVyJ10oIGUsIGFyZ3MgKTtcblxuXHRcdC8vIElmIG5vdCB5ZXQgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB0cmlnZ2VyIHRoZSBldmVudFxuXHRcdC8vIG9uIHRoZSBib2R5IGRpcmVjdGx5IHRvIHNvcnQgb2Ygc2ltdWxhdGUgdGhlIGJ1YmJsZVxuXHRcdGlmIChidWJibGVzICYmIHRhYmxlLnBhcmVudHMoJ2JvZHknKS5sZW5ndGggPT09IDApIHtcblx0XHRcdCQoJ2JvZHknKS50cmlnZ2VyKCBlLCBhcmdzICk7XG5cdFx0fVxuXG5cdFx0cmV0LnB1c2goIGUucmVzdWx0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIF9mbkxlbmd0aE92ZXJmbG93ICggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aDtcblxuXHQvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXG5cdGlmICggc3RhcnQgPj0gZW5kIClcblx0e1xuXHRcdHN0YXJ0ID0gZW5kIC0gbGVuO1xuXHR9XG5cblx0Ly8gS2VlcCB0aGUgc3RhcnQgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0c3RhcnQgLT0gKHN0YXJ0ICUgbGVuKTtcblxuXHRpZiAoIGxlbiA9PT0gLTEgfHwgc3RhcnQgPCAwIClcblx0e1xuXHRcdHN0YXJ0ID0gMDtcblx0fVxuXG5cdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG59XG5cblxuZnVuY3Rpb24gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCB0eXBlIClcbntcblx0dmFyIHJlbmRlcmVyID0gc2V0dGluZ3MucmVuZGVyZXI7XG5cdHZhciBob3N0ID0gRGF0YVRhYmxlLmV4dC5yZW5kZXJlclt0eXBlXTtcblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcmVuZGVyZXIgKSAmJiByZW5kZXJlclt0eXBlXSApIHtcblx0XHQvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXG5cdFx0Ly8gdGhlIGRlZmF1bHQuXG5cdFx0cmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIHJlbmRlcmVyID09PSAnc3RyaW5nJyApIHtcblx0XHQvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxuXHRcdC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcblx0XHRyZXR1cm4gaG9zdFtyZW5kZXJlcl0gfHwgaG9zdC5fO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBkZWZhdWx0XG5cdHJldHVybiBob3N0Ll87XG59XG5cblxuLyoqXG4gKiBEZXRlY3QgdGhlIGRhdGEgc291cmNlIGJlaW5nIHVzZWQgZm9yIHRoZSB0YWJsZS4gVXNlZCB0byBzaW1wbGlmeSB0aGUgY29kZVxuICogYSBsaXR0bGUgKGFqYXgpIGFuZCB0byBtYWtlIGl0IGNvbXByZXNzIGEgbGl0dGxlIHNtYWxsZXIuXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtzdHJpbmd9IERhdGEgc291cmNlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkRhdGFTb3VyY2UgKCBzZXR0aW5ncyApXG57XG5cdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdHJldHVybiAnc3NwJztcblx0fVxuXHRlbHNlIGlmICggc2V0dGluZ3MuYWpheCApIHtcblx0XHRyZXR1cm4gJ2FqYXgnO1xuXHR9XG5cdHJldHVybiAnZG9tJztcbn1cblxuLyoqXG4gKiBDb21tb24gcmVwbGFjZW1lbnQgZm9yIGxhbmd1YWdlIHN0cmluZ3NcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERUIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBzdHIgU3RyaW5nIHdpdGggdmFsdWVzIHRvIHJlcGxhY2VcbiAqIEBwYXJhbSB7Kn0gZW50cmllcyBQbHVyYWwgbnVtYmVyIGZvciBfRU5UUklFU18gLSBjYW4gYmUgdW5kZWZpbmVkXG4gKiBAcmV0dXJucyBTdHJpbmdcbiAqL1xuZnVuY3Rpb24gX2ZuTWFjcm9zICggc2V0dGluZ3MsIHN0ciwgZW50cmllcyApXG57XG5cdC8vIFdoZW4gaW5maW5pdGUgc2Nyb2xsaW5nLCB3ZSBhcmUgYWx3YXlzIHN0YXJ0aW5nIGF0IDEuIF9pRGlzcGxheVN0YXJ0IGlzXG5cdC8vIHVzZWQgb25seSBpbnRlcm5hbGx5XG5cdHZhclxuXHRcdGZvcm1hdHRlciAgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlcixcblx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdHZpcyAgICAgICAgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0bWF4ICAgICAgICA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG5cdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cblx0cmV0dXJuIHN0ci5cblx0XHRyZXBsYWNlKC9fU1RBUlRfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc3RhcnQgKSApLlxuXHRcdHJlcGxhY2UoL19FTkRfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSApICkuXG5cdFx0cmVwbGFjZSgvX01BWF8vZywgICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIG1heCApICkuXG5cdFx0cmVwbGFjZSgvX1RPVEFMXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHZpcyApICkuXG5cdFx0cmVwbGFjZSgvX1BBR0VfL2csICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICkgKSApLlxuXHRcdHJlcGxhY2UoL19QQUdFU18vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXMgLyBsZW4gKSApICkuXG5cdFx0cmVwbGFjZSgvX0VOVFJJRVNfL2csIHNldHRpbmdzLmFwaS5pMThuKCdlbnRyaWVzJywgJycsIGVudHJpZXMpICkuXG5cdFx0cmVwbGFjZSgvX0VOVFJJRVMtTUFYXy9nLCBzZXR0aW5ncy5hcGkuaTE4bignZW50cmllcycsICcnLCBtYXgpICkuXG5cdFx0cmVwbGFjZSgvX0VOVFJJRVMtVE9UQUxfL2csIHNldHRpbmdzLmFwaS5pMThuKCdlbnRyaWVzJywgJycsIHZpcykgKTtcbn1cblxuLyoqXG4gKiBBZGQgZWxlbWVudHMgdG8gYW4gYXJyYXkgYXMgcXVpY2tseSBhcyBwb3NzaWJsZSwgYnV0IHN0YWNrIHN0YWZlLlxuICpcbiAqIEBwYXJhbSB7Kn0gYXJyIEFycmF5IHRvIGFkZCB0aGUgZGF0YSB0b1xuICogQHBhcmFtIHsqfSBkYXRhIERhdGEgYXJyYXkgdGhhdCBpcyB0byBiZSBhZGRlZFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIF9mbkFycmF5QXBwbHkoYXJyLCBkYXRhKSB7XG5cdGlmICghIGRhdGEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBDaHJvbWUgY2FuIHRocm93IGEgbWF4IHN0YWNrIGVycm9yIGlmIGFwcGx5IGlzIGNhbGxlZCB3aXRoXG5cdC8vIHRvbyBsYXJnZSBhbiBhcnJheSwgYnV0IGFwcGx5IGlzIGZhc3Rlci5cblx0aWYgKGRhdGEubGVuZ3RoIDwgMTAwMDApIHtcblx0XHRhcnIucHVzaC5hcHBseShhcnIsIGRhdGEpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAoaT0wIDsgaTxkYXRhLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0YXJyLnB1c2goZGF0YVtpXSk7XG5cdFx0fVxuXHR9XG59XG5cblxuXG4vKipcbiAqIENvbXB1dGVkIHN0cnVjdHVyZSBvZiB0aGUgRGF0YVRhYmxlcyBBUEksIGRlZmluZWQgYnkgdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG4gKiBgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcigpYCB3aGVuIGJ1aWxkaW5nIHRoZSBBUEkuXG4gKlxuICogVGhlIHN0cnVjdHVyZSBpcyBidWlsdCBpbiBvcmRlciB0byBzcGVlZCBjcmVhdGlvbiBhbmQgZXh0ZW5zaW9uIG9mIHRoZSBBcGlcbiAqIG9iamVjdHMgc2luY2UgdGhlIGV4dGVuc2lvbnMgYXJlIGVmZmVjdGl2ZWx5IHByZS1wYXJzZWQuXG4gKlxuICogVGhlIGFycmF5IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSwgd2hlcmUgdGhpc1xuICogYmFzZSBhcnJheSByZXByZXNlbnRzIHRoZSBBcGkgcHJvdG90eXBlIGJhc2U6XG4gKlxuICogICAgIFtcbiAqICAgICAgIHtcbiAqICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG4gKiAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG4gKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSwgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIG1ldGhvZCByZXN1bHRcbiAqICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcbiAqICAgICAgIH0sXG4gKiAgICAgICB7XG4gKiAgICAgICAgIG5hbWU6ICAgICAncm93J1xuICogICAgICAgICB2YWw6ICAgICAgIHt9LFxuICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG4gKiAgICAgICAgIHByb3BFeHQ6ICAgW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnXG4gKiAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuICogICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuICogICAgICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXVxuICogICAgICAgfVxuICogICAgIF1cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaWdub3JlXG4gKi9cbnZhciBfX2FwaVN0cnVjdCA9IFtdO1xuXG5cbi8qKlxuICogYEFycmF5LnByb3RvdHlwZWAgcmVmZXJlbmNlLlxuICpcbiAqIEB0eXBlIG9iamVjdFxuICogQGlnbm9yZVxuICovXG52YXIgX19hcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gZm9yIGBjb250ZXh0YCBwYXJhbWV0ZXIgb2YgdGhlIGBBcGlgIGNvbnN0cnVjdG9yIHRvIGFsbG93IGl0IHRvXG4gKiB0YWtlIHNldmVyYWwgZGlmZmVyZW50IGZvcm1zIGZvciBlYXNlIG9mIHVzZS5cbiAqXG4gKiBFYWNoIG9mIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdHlwZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhVGFibGVzIHNldHRpbmdzXG4gKiBvYmplY3Qgd2hlcmUgcG9zc2libGUuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfG5vZGV8alF1ZXJ5fG9iamVjdH0gbWl4ZWQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIENhbiBiZSBvbmVcbiAqICAgb2Y6XG4gKlxuICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG4gKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cbiAqICAgKiBgbm9kZWAgLSBgVEFCTEVgIG5vZGUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBmb3JtZWQgaW50byBhIERhdGFUYWJsZS5cbiAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICAgKiBgRGF0YVRhYmxlcy5BcGlgIC0gQVBJIGluc3RhbmNlXG4gKiBAcmV0dXJuIHthcnJheXxudWxsfSBNYXRjaGluZyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuIGBudWxsYCBvclxuICogICBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBpZiBubyBtYXRjaGluZyBEYXRhVGFibGUgaXMgZm91bmQuXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfdG9TZXR0aW5ncyA9IGZ1bmN0aW9uICggbWl4ZWQgKVxue1xuXHR2YXIgaWR4LCBqcTtcblx0dmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHR2YXIgdGFibGVzID0gX3BsdWNrKHNldHRpbmdzLCAnblRhYmxlJyk7XG5cblx0aWYgKCAhIG1peGVkICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRlbHNlIGlmICggbWl4ZWQublRhYmxlICYmIG1peGVkLm9GZWF0dXJlcyApIHtcblx0XHQvLyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdHJldHVybiBbIG1peGVkIF07XG5cdH1cblx0ZWxzZSBpZiAoIG1peGVkLm5vZGVOYW1lICYmIG1peGVkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScgKSB7XG5cdFx0Ly8gVGFibGUgbm9kZVxuXHRcdGlkeCA9IHRhYmxlcy5pbmRleE9mKG1peGVkKTtcblx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/IFsgc2V0dGluZ3NbaWR4XSBdIDogbnVsbDtcblx0fVxuXHRlbHNlIGlmICggbWl4ZWQgJiYgdHlwZW9mIG1peGVkLnNldHRpbmdzID09PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBtaXhlZC5zZXR0aW5ncygpLnRvQXJyYXkoKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIG1peGVkID09PSAnc3RyaW5nJyApIHtcblx0XHQvLyBqUXVlcnkgc2VsZWN0b3Jcblx0XHRqcSA9ICQobWl4ZWQpLmdldCgpO1xuXHR9XG5cdGVsc2UgaWYgKCBtaXhlZCBpbnN0YW5jZW9mICQgKSB7XG5cdFx0Ly8galF1ZXJ5IG9iamVjdCAoYWxzbyBEYXRhVGFibGVzIGluc3RhbmNlKVxuXHRcdGpxID0gbWl4ZWQuZ2V0KCk7XG5cdH1cblxuXHRpZiAoIGpxICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5maWx0ZXIoZnVuY3Rpb24gKHYsIGlkeCkge1xuXHRcdFx0cmV0dXJuIGpxLmluY2x1ZGVzKHRhYmxlc1tpZHhdKTtcblx0XHR9KTtcblx0fVxufTtcblxuXG4vKipcbiAqIERhdGFUYWJsZXMgQVBJIGNsYXNzIC0gdXNlZCB0byBjb250cm9sIGFuZCBpbnRlcmZhY2Ugd2l0aCAgb25lIG9yIG1vcmVcbiAqIERhdGFUYWJsZXMgZW5oYW5jZWQgdGFibGVzLlxuICpcbiAqIFRoZSBBUEkgY2xhc3MgaXMgaGVhdmlseSBiYXNlZCBvbiBqUXVlcnksIHByZXNlbnRpbmcgYSBjaGFpbmFibGUgaW50ZXJmYWNlXG4gKiB0aGF0IHlvdSBjYW4gdXNlIHRvIGludGVyYWN0IHdpdGggdGFibGVzLiBFYWNoIGluc3RhbmNlIG9mIHRoZSBBUEkgY2xhc3MgaGFzXG4gKiBhIFwiY29udGV4dFwiIC0gaS5lLiB0aGUgdGFibGVzIHRoYXQgaXQgd2lsbCBvcGVyYXRlIG9uLiBUaGlzIGNvdWxkIGJlIGEgc2luZ2xlXG4gKiB0YWJsZSwgYWxsIHRhYmxlcyBvbiBhIHBhZ2Ugb3IgYSBzdWItc2V0IHRoZXJlb2YuXG4gKlxuICogQWRkaXRpb25hbGx5IHRoZSBBUEkgaXMgZGVzaWduZWQgdG8gYWxsb3cgeW91IHRvIGVhc2lseSB3b3JrIHdpdGggdGhlIGRhdGEgaW5cbiAqIHRoZSB0YWJsZXMsIHJldHJpZXZpbmcgYW5kIG1hbmlwdWxhdGluZyBpdCBhcyByZXF1aXJlZC4gVGhpcyBpcyBkb25lIGJ5XG4gKiBwcmVzZW50aW5nIHRoZSBBUEkgY2xhc3MgYXMgYW4gYXJyYXkgbGlrZSBpbnRlcmZhY2UuIFRoZSBjb250ZW50cyBvZiB0aGVcbiAqIGFycmF5IGRlcGVuZCB1cG9uIHRoZSBhY3Rpb25zIHJlcXVlc3RlZCBieSBlYWNoIG1ldGhvZCAoZm9yIGV4YW1wbGVcbiAqIGByb3dzKCkubm9kZXMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygbm9kZXMsIHdoaWxlIGByb3dzKCkuZGF0YSgpYCB3aWxsXG4gKiByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhcnJheXMgZGVwZW5kaW5nIHVwb24geW91ciB0YWJsZSdzXG4gKiBjb25maWd1cmF0aW9uKS4gVGhlIEFQSSBvYmplY3QgaGFzIGEgbnVtYmVyIG9mIGFycmF5IGxpa2UgbWV0aG9kcyAoYHB1c2hgLFxuICogYHBvcGAsIGByZXZlcnNlYCBldGMpIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyAoYGVhY2hgLCBgcGx1Y2tgLFxuICogYHVuaXF1ZWAgZXRjKSB0byBhc3Npc3QgeW91ciB3b3JraW5nIHdpdGggdGhlIGRhdGEgaGVsZCBpbiBhIHRhYmxlLlxuICpcbiAqIE1vc3QgbWV0aG9kcyAodGhvc2Ugd2hpY2ggcmV0dXJuIGFuIEFwaSBpbnN0YW5jZSkgYXJlIGNoYWluYWJsZSwgd2hpY2ggbWVhbnNcbiAqIHRoZSByZXR1cm4gZnJvbSBhIG1ldGhvZCBjYWxsIGFsc28gaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdGhhdCB0aGVcbiAqIHRvcCBsZXZlbCBvYmplY3QgaGFkLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvIGNhbGxzIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgICAvLyBOb3QgY2hhaW5lZFxuICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApO1xuICogICAgIGFwaS5kcmF3KCk7XG4gKlxuICogICAgIC8vIENoYWluZWRcbiAqICAgICBhcGkucm93LmFkZCggey4uLn0gKS5kcmF3KCk7XG4gKlxuICogQGNsYXNzIERhdGFUYWJsZS5BcGlcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHN0cmluZ3xqUXVlcnl9IGNvbnRleHQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIFRoaXMgaXNcbiAqICAgdXNlZCB0byBkZWZpbmUgd2hpY2ggRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMgdGhpcyBBUEkgd2lsbCBvcGVyYXRlIG9uLlxuICogICBDYW4gYmUgb25lIG9mOlxuICpcbiAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXG4gKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG4gKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cbiAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0ge2FycmF5fSBbZGF0YV0gRGF0YSB0byBpbml0aWFsaXNlIHRoZSBBcGkgaW5zdGFuY2Ugd2l0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBEaXJlY3QgaW5pdGlhbGlzYXRpb24gZHVyaW5nIERhdGFUYWJsZXMgY29uc3RydWN0aW9uXG4gKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLkRhdGFUYWJsZSgpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEluaXRpYWxpc2F0aW9uIHVzaW5nIGEgRGF0YVRhYmxlcyBqUXVlcnkgb2JqZWN0XG4gKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmFwaSgpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEluaXRpYWxpc2F0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAqICAgdmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKCAndGFibGUuZGF0YVRhYmxlJyApO1xuICovXG5fQXBpID0gZnVuY3Rpb24gKCBjb250ZXh0LCBkYXRhIClcbntcblx0aWYgKCAhICh0aGlzIGluc3RhbmNlb2YgX0FwaSkgKSB7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCBjb250ZXh0LCBkYXRhICk7XG5cdH1cblxuXHR2YXIgaTtcblx0dmFyIHNldHRpbmdzID0gW107XG5cdHZhciBjdHhTZXR0aW5ncyA9IGZ1bmN0aW9uICggbyApIHtcblx0XHR2YXIgYSA9IF90b1NldHRpbmdzKCBvICk7XG5cdFx0aWYgKCBhICkge1xuXHRcdFx0c2V0dGluZ3MucHVzaC5hcHBseSggc2V0dGluZ3MsIGEgKTtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBjb250ZXh0ICkgKSB7XG5cdFx0Zm9yICggaT0wIDsgaTxjb250ZXh0Lmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdGN0eFNldHRpbmdzKCBjb250ZXh0W2ldICk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdGN0eFNldHRpbmdzKCBjb250ZXh0ICk7XG5cdH1cblxuXHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHR0aGlzLmNvbnRleHQgPSBzZXR0aW5ncy5sZW5ndGggPiAxXG5cdFx0PyBfdW5pcXVlKCBzZXR0aW5ncyApXG5cdFx0OiBzZXR0aW5ncztcblxuXHQvLyBJbml0aWFsIGRhdGFcblx0X2ZuQXJyYXlBcHBseSh0aGlzLCBkYXRhKTtcblxuXHQvLyBzZWxlY3RvclxuXHR0aGlzLnNlbGVjdG9yID0ge1xuXHRcdHJvd3M6IG51bGwsXG5cdFx0Y29sczogbnVsbCxcblx0XHRvcHRzOiBudWxsXG5cdH07XG5cblx0X0FwaS5leHRlbmQoIHRoaXMsIHRoaXMsIF9fYXBpU3RydWN0ICk7XG59O1xuXG5EYXRhVGFibGUuQXBpID0gX0FwaTtcblxuLy8gRG9uJ3QgZGVzdHJveSB0aGUgZXhpc3RpbmcgcHJvdG90eXBlLCBqdXN0IGV4dGVuZCBpdC4gUmVxdWlyZWQgZm9yIGpRdWVyeSAyJ3Ncbi8vIGlzUGxhaW5PYmplY3QuXG4kLmV4dGVuZCggX0FwaS5wcm90b3R5cGUsIHtcblx0YW55OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuY291bnQoKSAhPT0gMDtcblx0fSxcblxuXHRjb250ZXh0OiBbXSwgLy8gYXJyYXkgb2YgdGFibGUgc2V0dGluZ3Mgb2JqZWN0c1xuXG5cdGNvdW50OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuZmxhdHRlbigpLmxlbmd0aDtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiAoIGZuIClcblx0e1xuXHRcdGZvciAoIHZhciBpPTAsIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuOyBpKysgKSB7XG5cdFx0XHRmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uICggaWR4IClcblx0e1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XG5cdFx0XHRuZXcgX0FwaSggY3R4W2lkeF0sIHRoaXNbaWR4XSApIDpcblx0XHRcdG51bGw7XG5cdH0sXG5cblx0ZmlsdGVyOiBmdW5jdGlvbiAoIGZuIClcblx0e1xuXHRcdHZhciBhID0gX19hcnJheVByb3RvLmZpbHRlci5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIGEgKTtcblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblxuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhLmNvbmNhdC5hcHBseSggYSwgdGhpcy50b0FycmF5KCkgKSApO1xuXHR9LFxuXG5cdGdldDogZnVuY3Rpb24gKCBpZHggKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXNbIGlkeCBdO1xuXHR9LFxuXG5cdGpvaW46ICAgIF9fYXJyYXlQcm90by5qb2luLFxuXG5cdGluY2x1ZGVzOiBmdW5jdGlvbiAoIGZpbmQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZXhPZiggZmluZCApID09PSAtMSA/IGZhbHNlIDogdHJ1ZTtcblx0fSxcblxuXHRpbmRleE9mOiBfX2FycmF5UHJvdG8uaW5kZXhPZixcblxuXHRpdGVyYXRvcjogZnVuY3Rpb24gKCBmbGF0dGVuLCB0eXBlLCBmbiwgYWx3YXlzTmV3ICkge1xuXHRcdHZhclxuXHRcdFx0YSA9IFtdLCByZXQsXG5cdFx0XHRpLCBpZW4sIGosIGplbixcblx0XHRcdGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG5cdFx0XHRyb3dzLCBpdGVtcywgaXRlbSxcblx0XHRcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcblxuXHRcdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCB0eXBlb2YgZmxhdHRlbiA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRhbHdheXNOZXcgPSBmbjtcblx0XHRcdGZuID0gdHlwZTtcblx0XHRcdHR5cGUgPSBmbGF0dGVuO1xuXHRcdFx0ZmxhdHRlbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGZvciAoIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR2YXIgYXBpSW5zdCA9IG5ldyBfQXBpKCBjb250ZXh0W2ldICk7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gJ3RhYmxlJyApIHtcblx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaSApO1xuXG5cdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW5zJyB8fCB0eXBlID09PSAncm93cycgKSB7XG5cdFx0XHRcdC8vIHRoaXMgaGFzIHNhbWUgbGVuZ3RoIGFzIGNvbnRleHQgLSBvbmUgZW50cnkgZm9yIGVhY2ggdGFibGVcblx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgdGhpc1tpXSwgaSApO1xuXG5cdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdldmVyeScgfHwgdHlwZSA9PT0gJ2NvbHVtbicgfHwgdHlwZSA9PT0gJ2NvbHVtbi1yb3dzJyB8fCB0eXBlID09PSAncm93JyB8fCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdC8vIGNvbHVtbnMgYW5kIHJvd3Mgc2hhcmUgdGhlIHNhbWUgc3RydWN0dXJlLlxuXHRcdFx0XHQvLyAndGhpcycgaXMgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgZm9yIGVhY2ggY29udGV4dFxuXHRcdFx0XHRpdGVtcyA9IHRoaXNbaV07XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSAnY29sdW1uLXJvd3MnICkge1xuXHRcdFx0XHRcdHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIGNvbnRleHRbaV0sIHNlbGVjdG9yLm9wdHMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGo9MCwgamVuPWl0ZW1zLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtc1tqXTtcblxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbS5yb3csIGl0ZW0uY29sdW1uLCBpLCBqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbSwgaSwgaiwgcm93cyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggYS5sZW5ndGggfHwgYWx3YXlzTmV3ICkge1xuXHRcdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBjb250ZXh0LCBmbGF0dGVuID8gYS5jb25jYXQuYXBwbHkoIFtdLCBhICkgOiBhICk7XG5cdFx0XHR2YXIgYXBpU2VsZWN0b3IgPSBhcGkuc2VsZWN0b3I7XG5cdFx0XHRhcGlTZWxlY3Rvci5yb3dzID0gc2VsZWN0b3Iucm93cztcblx0XHRcdGFwaVNlbGVjdG9yLmNvbHMgPSBzZWxlY3Rvci5jb2xzO1xuXHRcdFx0YXBpU2VsZWN0b3Iub3B0cyA9IHNlbGVjdG9yLm9wdHM7XG5cdFx0XHRyZXR1cm4gYXBpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRsYXN0SW5kZXhPZjogX19hcnJheVByb3RvLmxhc3RJbmRleE9mLFxuXG5cdGxlbmd0aDogIDAsXG5cblx0bWFwOiBmdW5jdGlvbiAoIGZuIClcblx0e1xuXHRcdHZhciBhID0gX19hcnJheVByb3RvLm1hcC5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIGEgKTtcblx0fSxcblxuXHRwbHVjazogZnVuY3Rpb24gKCBwcm9wIClcblx0e1xuXHRcdHZhciBmbiA9IERhdGFUYWJsZS51dGlsLmdldChwcm9wKTtcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCBlbCApIHtcblx0XHRcdHJldHVybiBmbihlbCk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHBvcDogICAgIF9fYXJyYXlQcm90by5wb3AsXG5cblx0cHVzaDogICAgX19hcnJheVByb3RvLnB1c2gsXG5cblx0cmVkdWNlOiBfX2FycmF5UHJvdG8ucmVkdWNlLFxuXG5cdHJlZHVjZVJpZ2h0OiBfX2FycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG5cblx0cmV2ZXJzZTogX19hcnJheVByb3RvLnJldmVyc2UsXG5cblx0Ly8gT2JqZWN0IHdpdGggcm93cywgY29sdW1ucyBhbmQgb3B0c1xuXHRzZWxlY3RvcjogbnVsbCxcblxuXHRzaGlmdDogICBfX2FycmF5UHJvdG8uc2hpZnQsXG5cblx0c2xpY2U6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgdGhpcyApO1xuXHR9LFxuXG5cdHNvcnQ6ICAgIF9fYXJyYXlQcm90by5zb3J0LFxuXG5cdHNwbGljZTogIF9fYXJyYXlQcm90by5zcGxpY2UsXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiBfX2FycmF5UHJvdG8uc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdHRvJDogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiAkKCB0aGlzICk7XG5cdH0sXG5cblx0dG9KUXVlcnk6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHR9LFxuXG5cdHVuaXF1ZTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBfdW5pcXVlKHRoaXMudG9BcnJheSgpKSApO1xuXHR9LFxuXG5cdHVuc2hpZnQ6IF9fYXJyYXlQcm90by51bnNoaWZ0XG59ICk7XG5cblxuZnVuY3Rpb24gX2FwaV9zY29wZSggc2NvcGUsIGZuLCBzdHJ1YyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmV0ID0gZm4uYXBwbHkoIHNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0Ly8gTWV0aG9kIGV4dGVuc2lvblxuXHRcdF9BcGkuZXh0ZW5kKCByZXQsIHJldCwgc3RydWMubWV0aG9kRXh0ICk7XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxuZnVuY3Rpb24gX2FwaV9maW5kKCBzcmMsIG5hbWUgKSB7XG5cdGZvciAoIHZhciBpPTAsIGllbj1zcmMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0aWYgKCBzcmNbaV0ubmFtZSA9PT0gbmFtZSApIHtcblx0XHRcdHJldHVybiBzcmNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG53aW5kb3cuX19hcGlTdHJ1Y3QgPSBfX2FwaVN0cnVjdDtcblxuX0FwaS5leHRlbmQgPSBmdW5jdGlvbiAoIHNjb3BlLCBvYmosIGV4dCApXG57XG5cdC8vIE9ubHkgZXh0ZW5kIEFQSSBpbnN0YW5jZXMgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBBUElcblx0aWYgKCAhIGV4dC5sZW5ndGggfHwgISBvYmogfHwgKCAhIChvYmogaW5zdGFuY2VvZiBfQXBpKSAmJiAhIG9iai5fX2R0X3dyYXBwZXIgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHRpLCBpZW4sXG5cdFx0c3RydWN0O1xuXG5cdGZvciAoIGk9MCwgaWVuPWV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRzdHJ1Y3QgPSBleHRbaV07XG5cblx0XHRpZiAoc3RydWN0Lm5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBWYWx1ZVxuXHRcdG9ialsgc3RydWN0Lm5hbWUgXSA9IHN0cnVjdC50eXBlID09PSAnZnVuY3Rpb24nID9cblx0XHRcdF9hcGlfc2NvcGUoIHNjb3BlLCBzdHJ1Y3QudmFsLCBzdHJ1Y3QgKSA6XG5cdFx0XHRzdHJ1Y3QudHlwZSA9PT0gJ29iamVjdCcgP1xuXHRcdFx0XHR7fSA6XG5cdFx0XHRcdHN0cnVjdC52YWw7XG5cblx0XHRvYmpbIHN0cnVjdC5uYW1lIF0uX19kdF93cmFwcGVyID0gdHJ1ZTtcblxuXHRcdC8vIFByb3BlcnR5IGV4dGVuc2lvblxuXHRcdF9BcGkuZXh0ZW5kKCBzY29wZSwgb2JqWyBzdHJ1Y3QubmFtZSBdLCBzdHJ1Y3QucHJvcEV4dCApO1xuXHR9XG59O1xuXG4vLyAgICAgW1xuLy8gICAgICAge1xuLy8gICAgICAgICBuYW1lOiAgICAgICdkYXRhJyAgICAgICAgICAgICAgICAtLSBzdHJpbmcgICAtIFByb3BlcnR5IG5hbWVcbi8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3Rcbi8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuLy8gICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF0gICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0eVxuLy8gICAgICAgfSxcbi8vICAgICAgIHtcbi8vICAgICAgICAgbmFtZTogICAgICdyb3cnXG4vLyAgICAgICAgIHZhbDogICAgICAge30sXG4vLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcbi8vICAgICAgICAgcHJvcEV4dDogICBbXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcbi8vICAgICAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sXG4vLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG4vLyAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cbi8vICAgICAgICAgICB9LFxuLy8gICAgICAgICAgIC4uLlxuLy8gICAgICAgICBdXG4vLyAgICAgICB9XG4vLyAgICAgXVxuXG5cbl9BcGkucmVnaXN0ZXIgPSBfYXBpX3JlZ2lzdGVyID0gZnVuY3Rpb24gKCBuYW1lLCB2YWwgKVxue1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRmb3IgKCB2YXIgaj0wLCBqZW49bmFtZS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdF9BcGkucmVnaXN0ZXIoIG5hbWVbal0sIHZhbCApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHRpLCBpZW4sXG5cdFx0aGVpciA9IG5hbWUuc3BsaXQoJy4nKSxcblx0XHRzdHJ1Y3QgPSBfX2FwaVN0cnVjdCxcblx0XHRrZXksIG1ldGhvZDtcblxuXHRmb3IgKCBpPTAsIGllbj1oZWlyLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdG1ldGhvZCA9IGhlaXJbaV0uaW5kZXhPZignKCknKSAhPT0gLTE7XG5cdFx0a2V5ID0gbWV0aG9kID9cblx0XHRcdGhlaXJbaV0ucmVwbGFjZSgnKCknLCAnJykgOlxuXHRcdFx0aGVpcltpXTtcblxuXHRcdHZhciBzcmMgPSBfYXBpX2ZpbmQoIHN0cnVjdCwga2V5ICk7XG5cdFx0aWYgKCAhIHNyYyApIHtcblx0XHRcdHNyYyA9IHtcblx0XHRcdFx0bmFtZTogICAgICBrZXksXG5cdFx0XHRcdHZhbDogICAgICAge30sXG5cdFx0XHRcdG1ldGhvZEV4dDogW10sXG5cdFx0XHRcdHByb3BFeHQ6ICAgW10sXG5cdFx0XHRcdHR5cGU6ICAgICAgJ29iamVjdCdcblx0XHRcdH07XG5cdFx0XHRzdHJ1Y3QucHVzaCggc3JjICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpID09PSBpZW4tMSApIHtcblx0XHRcdHNyYy52YWwgPSB2YWw7XG5cdFx0XHRzcmMudHlwZSA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQnZnVuY3Rpb24nIDpcblx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCB2YWwgKSA/XG5cdFx0XHRcdFx0J29iamVjdCcgOlxuXHRcdFx0XHRcdCdvdGhlcic7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c3RydWN0ID0gbWV0aG9kID9cblx0XHRcdFx0c3JjLm1ldGhvZEV4dCA6XG5cdFx0XHRcdHNyYy5wcm9wRXh0O1xuXHRcdH1cblx0fVxufTtcblxuX0FwaS5yZWdpc3RlclBsdXJhbCA9IF9hcGlfcmVnaXN0ZXJQbHVyYWwgPSBmdW5jdGlvbiAoIHBsdXJhbE5hbWUsIHNpbmd1bGFyTmFtZSwgdmFsICkge1xuXHRfQXBpLnJlZ2lzdGVyKCBwbHVyYWxOYW1lLCB2YWwgKTtcblxuXHRfQXBpLnJlZ2lzdGVyKCBzaW5ndWxhck5hbWUsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmV0ID0gdmFsLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdGlmICggcmV0ID09PSB0aGlzICkge1xuXHRcdFx0Ly8gUmV0dXJuZWQgaXRlbSBpcyB0aGUgQVBJIGluc3RhbmNlIHRoYXQgd2FzIHBhc3NlZCBpbiwgcmV0dXJuIGl0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHJldCBpbnN0YW5jZW9mIF9BcGkgKSB7XG5cdFx0XHQvLyBOZXcgQVBJIGluc3RhbmNlIHJldHVybmVkLCB3YW50IHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHQvLyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgZm9yIHRoZSBzaW5ndWxhciByZXN1bHQuXG5cdFx0XHRyZXR1cm4gcmV0Lmxlbmd0aCA/XG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoIHJldFswXSApID9cblx0XHRcdFx0XHRuZXcgX0FwaSggcmV0LmNvbnRleHQsIHJldFswXSApIDogLy8gQXJyYXkgcmVzdWx0cyBhcmUgJ2VuaGFuY2VkJ1xuXHRcdFx0XHRcdHJldFswXSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBOb24tQVBJIHJldHVybiAtIGp1c3QgZmlyZSBpdCBiYWNrXG5cdFx0cmV0dXJuIHJldDtcblx0fSApO1xufTtcblxuXG4vKipcbiAqIFNlbGVjdG9yIGZvciBIVE1MIHRhYmxlcy4gQXBwbHkgdGhlIGdpdmVuIHNlbGVjdG9yIHRvIHRoZSBnaXZlIGFycmF5IG9mXG4gKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW3NlbGVjdG9yXSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nIG9yIGludGVnZXJcbiAqIEBwYXJhbSAge2FycmF5fSBBcnJheSBvZiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMgdG8gYmUgZmlsdGVyZWRcbiAqIEByZXR1cm4ge2FycmF5fVxuICogQGlnbm9yZVxuICovXG52YXIgX190YWJsZV9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIGEgKVxue1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpICkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdHNlbGVjdG9yLmZvckVhY2goZnVuY3Rpb24gKHNlbCkge1xuXHRcdFx0dmFyIGlubmVyID0gX190YWJsZV9zZWxlY3RvcihzZWwsIGEpO1xuXG5cdFx0XHRfZm5BcnJheUFwcGx5KHJlc3VsdCwgaW5uZXIpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5maWx0ZXIoIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEludGVnZXIgaXMgdXNlZCB0byBwaWNrIG91dCBhIHRhYmxlIGJ5IGluZGV4XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnbnVtYmVyJyApIHtcblx0XHRyZXR1cm4gWyBhWyBzZWxlY3RvciBdIF07XG5cdH1cblxuXHQvLyBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSB0YWJsZSBub2Rlc1xuXHR2YXIgbm9kZXMgPSBhLm1hcCggZnVuY3Rpb24gKGVsKSB7XG5cdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0fSApO1xuXG5cdHJldHVybiAkKG5vZGVzKVxuXHRcdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBOZWVkIHRvIHRyYW5zbGF0ZSBiYWNrIGZyb20gdGhlIHRhYmxlIG5vZGUgdG8gdGhlIHNldHRpbmdzXG5cdFx0XHR2YXIgaWR4ID0gbm9kZXMuaW5kZXhPZih0aGlzKTtcblx0XHRcdHJldHVybiBhWyBpZHggXTtcblx0XHR9IClcblx0XHQudG9BcnJheSgpO1xufTtcblxuXG5cbi8qKlxuICogQ29udGV4dCBzZWxlY3RvciBmb3IgdGhlIEFQSSdzIGNvbnRleHQgKGkuZS4gdGhlIHRhYmxlcyB0aGUgQVBJIGluc3RhbmNlXG4gKiByZWZlcnMgdG8uXG4gKlxuICogQG5hbWUgICAgRGF0YVRhYmxlLkFwaSN0YWJsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXG4gKiAgIHNob3VsZCBvcGVyYXRlIG9uLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhcmVcbiAqICAgdXNlZC4gVGhpcyBjYW4gYmUgZ2l2ZW4gYXMgYSBqUXVlcnkgc2VsZWN0b3IgKGZvciBleGFtcGxlIGAnOmd0KDApJ2ApIHRvXG4gKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlLkFwaX0gUmV0dXJucyBhIG5ldyBBUEkgaW5zdGFuY2UgaWYgYSBzZWxlY3RvciBpcyBnaXZlbi5cbiAqL1xuX2FwaV9yZWdpc3RlciggJ3RhYmxlcygpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0Ly8gQSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBpZiB0aGVyZSB3YXMgYSBzZWxlY3RvciBzcGVjaWZpZWRcblx0cmV0dXJuIHNlbGVjdG9yICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0b3IgIT09IG51bGwgP1xuXHRcdG5ldyBfQXBpKCBfX3RhYmxlX3NlbGVjdG9yKCBzZWxlY3RvciwgdGhpcy5jb250ZXh0ICkgKSA6XG5cdFx0dGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAndGFibGUoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyggc2VsZWN0b3IgKTtcblx0dmFyIGN0eCA9IHRhYmxlcy5jb250ZXh0O1xuXG5cdC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXG5cdHJldHVybiBjdHgubGVuZ3RoID9cblx0XHRuZXcgX0FwaSggY3R4WzBdICkgOlxuXHRcdHRhYmxlcztcbn0gKTtcblxuLy8gQ29tbW9uIG1ldGhvZHMsIGNvbWJpbmVkIHRvIHJlZHVjZSBzaXplXG5bXG5cdFsnbm9kZXMnLCAnbm9kZScsICduVGFibGUnXSxcblx0Wydib2R5JywgJ2JvZHknLCAnblRCb2R5J10sXG5cdFsnaGVhZGVyJywgJ2hlYWRlcicsICduVEhlYWQnXSxcblx0Wydmb290ZXInLCAnZm9vdGVyJywgJ25URm9vdCddLFxuXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoXG5cdFx0J3RhYmxlcygpLicgKyBpdGVtWzBdICsgJygpJyxcblx0XHQndGFibGUoKS4nICsgaXRlbVsxXSArICcoKScgLFxuXHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdFx0cmV0dXJuIGN0eFtpdGVtWzJdXTtcblx0XHRcdH0sIDEgKTtcblx0XHR9XG5cdCk7XG59KTtcblxuLy8gU3RydWN0dXJlIG1ldGhvZHNcbltcblx0WydoZWFkZXInLCAnYW9IZWFkZXInXSxcblx0Wydmb290ZXInLCAnYW9Gb290ZXInXSxcbl0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRfYXBpX3JlZ2lzdGVyKCAndGFibGUoKS4nICsgaXRlbVswXSArICcuc3RydWN0dXJlKCknICwgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdFx0dmFyIGluZGV4ZXMgPSB0aGlzLmNvbHVtbnMoc2VsZWN0b3IpLmluZGV4ZXMoKS5mbGF0dGVuKCk7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcblx0XHRcblx0XHRyZXR1cm4gX2ZuSGVhZGVyTGF5b3V0KGN0eCwgY3R4W2l0ZW1bMV1dLCBpbmRleGVzKTtcblx0fSApO1xufSlcblxuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuY29udGFpbmVycygpJywgJ3RhYmxlKCkuY29udGFpbmVyKCknICwgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0cmV0dXJuIGN0eC5uVGFibGVXcmFwcGVyO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXIoICd0YWJsZXMoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzLCBpKSB7XG5cdFx0Zm4uY2FsbCh0aGF0LnRhYmxlKGkpLCBpKTtcblx0fSk7XG59KTtcblxuX2FwaV9yZWdpc3RlciggJ2NhcHRpb24oKScsIGZ1bmN0aW9uICggdmFsdWUsIHNpZGUgKSB7XG5cdHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdC8vIEdldHRlciAtIHJldHVybiBleGlzdGluZyBub2RlJ3MgY29udGVudFxuXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dmFyIGNhcHRpb24gPSBjb250ZXh0WzBdLmNhcHRpb25Ob2RlO1xuXG5cdFx0cmV0dXJuIGNhcHRpb24gJiYgY29udGV4dC5sZW5ndGggP1xuXHRcdFx0Y2FwdGlvbi5pbm5lckhUTUwgOiBcblx0XHRcdG51bGw7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0dmFyIHRhYmxlID0gJChjdHgublRhYmxlKTtcblx0XHR2YXIgY2FwdGlvbiA9ICQoY3R4LmNhcHRpb25Ob2RlKTtcblx0XHR2YXIgY29udGFpbmVyID0gJChjdHgublRhYmxlV3JhcHBlcik7XG5cblx0XHQvLyBDcmVhdGUgdGhlIG5vZGUgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXRcblx0XHRpZiAoICEgY2FwdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRjYXB0aW9uID0gJCgnPGNhcHRpb24vPicpLmh0bWwoIHZhbHVlICk7XG5cdFx0XHRjdHguY2FwdGlvbk5vZGUgPSBjYXB0aW9uWzBdO1xuXG5cdFx0XHQvLyBJZiBzaWRlIGlzbid0IHNldCwgd2UgbmVlZCB0byBpbnNlcnQgaW50byB0aGUgZG9jdW1lbnQgdG8gbGV0IHRoZVxuXHRcdFx0Ly8gQ1NTIGRlY2lkZSBzbyB3ZSBjYW4gcmVhZCBpdCBiYWNrLCBvdGhlcndpc2UgdGhlcmUgaXMgbm8gd2F5IHRvXG5cdFx0XHQvLyBrbm93IGlmIHRoZSBDU1Mgd291bGQgcHV0IGl0IHRvcCBvciBib3R0b20gZm9yIHNjcm9sbGluZ1xuXHRcdFx0aWYgKCEgc2lkZSkge1xuXHRcdFx0XHR0YWJsZS5wcmVwZW5kKGNhcHRpb24pO1xuXG5cdFx0XHRcdHNpZGUgPSBjYXB0aW9uLmNzcygnY2FwdGlvbi1zaWRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2FwdGlvbi5odG1sKCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBzaWRlICkge1xuXHRcdFx0Y2FwdGlvbi5jc3MoICdjYXB0aW9uLXNpZGUnLCBzaWRlICk7XG5cdFx0XHRjYXB0aW9uWzBdLl9jYXB0aW9uU2lkZSA9IHNpZGU7XG5cdFx0fVxuXG5cdFx0aWYgKGNvbnRhaW5lci5maW5kKCdkaXYuZGF0YVRhYmxlc19zY3JvbGwnKS5sZW5ndGgpIHtcblx0XHRcdHZhciBzZWxlY3RvciA9IChzaWRlID09PSAndG9wJyA/ICdIZWFkJyA6ICdGb290Jyk7XG5cblx0XHRcdGNvbnRhaW5lci5maW5kKCdkaXYuZGF0YVRhYmxlc19zY3JvbGwnKyBzZWxlY3RvciArJyB0YWJsZScpLnByZXBlbmQoY2FwdGlvbik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGFibGUucHJlcGVuZChjYXB0aW9uKTtcblx0XHR9XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ2NhcHRpb24ubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdHJldHVybiBjdHgubGVuZ3RoID8gY3R4WzBdLmNhcHRpb25Ob2RlIDogbnVsbDtcbn0gKTtcblxuXG4vKipcbiAqIFJlZHJhdyB0aGUgdGFibGVzIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdkcmF3KCknLCBmdW5jdGlvbiAoIHBhZ2luZyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCBwYWdpbmcgPT09ICdwYWdlJyApIHtcblx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFnaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cGFnaW5nID0gcGFnaW5nID09PSAnZnVsbC1ob2xkJyA/XG5cdFx0XHRcdFx0ZmFsc2UgOlxuXHRcdFx0XHRcdHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIHBhZ2luZz09PWZhbHNlICk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBwYWdlIGluZGV4LlxuICpcbiAqIEByZXR1cm4ge2ludGVnZXJ9IEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZClcbiAqLy8qKlxuICogU2V0IHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogTm90ZSB0aGF0IGlmIHlvdSBhdHRlbXB0IHRvIHNob3cgYSBwYWdlIHdoaWNoIGRvZXMgbm90IGV4aXN0LCBEYXRhVGFibGVzIHdpbGxcbiAqIG5vdCB0aHJvdyBhbiBlcnJvciwgYnV0IHJhdGhlciByZXNldCB0aGUgcGFnaW5nLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcnxzdHJpbmd9IGFjdGlvbiBUaGUgcGFnaW5nIGFjdGlvbiB0byB0YWtlLiBUaGlzIGNhbiBiZSBvbmUgb2Y6XG4gKiAgKiBgaW50ZWdlcmAgLSBUaGUgcGFnZSBpbmRleCB0byBqdW1wIHRvXG4gKiAgKiBgc3RyaW5nYCAtIEFuIGFjdGlvbiB0byB0YWtlOlxuICogICAgKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlLlxuICogICAgKiBgbmV4dGAgLSBKdW1wIHRvIHRoZSBuZXh0IHBhZ2VcbiAqICAgICogYHByZXZpb3VzYCAtIEp1bXAgdG8gcHJldmlvdXMgcGFnZVxuICogICAgKiBgbGFzdGAgLSBKdW1wIHRvIHRoZSBsYXN0IHBhZ2UuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ3BhZ2UoKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRpZiAoIGFjdGlvbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLnBhZ2UuaW5mbygpLnBhZ2U7IC8vIG5vdCBhbiBleHBlbnNpdmUgY2FsbFxuXHR9XG5cblx0Ly8gZWxzZSwgaGF2ZSBhbiBhY3Rpb24gdG8gdGFrZSBvbiBhbGwgdGFibGVzXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdF9mblBhZ2VDaGFuZ2UoIHNldHRpbmdzLCBhY3Rpb24gKTtcblx0fSApO1xufSApO1xuXG5cbi8qKlxuICogUGFnaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBJZiB5b3UgcmVxdWlyZSBwYWdpbmcgaW5mb3JtYXRpb24gZm9yIGFub3RoZXIgdGFibGUsIHVzZSB0aGUgYHRhYmxlKClgIG1ldGhvZFxuICogd2l0aCBhIHN1aXRhYmxlIHNlbGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHNldDpcbiAqICAqIGBwYWdlYCAtIEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZCAtIGkuZS4gdGhlIGZpcnN0IHBhZ2UgaXMgYDBgKVxuICogICogYHBhZ2VzYCAtIFRvdGFsIG51bWJlciBvZiBwYWdlc1xuICogICogYHN0YXJ0YCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBmaXJzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuICogICogYGVuZGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgbGFzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuICogICogYGxlbmd0aGAgLSBEaXNwbGF5IGxlbmd0aCAobnVtYmVyIG9mIHJlY29yZHMpLiBOb3RlIHRoYXQgZ2VuZXJhbGx5IGBzdGFydFxuICogICAgKyBsZW5ndGggPSBlbmRgLCBidXQgdGhpcyBpcyBub3QgYWx3YXlzIHRydWUsIGZvciBleGFtcGxlIGlmIHRoZXJlIGFyZVxuICogICAgb25seSAyIHJlY29yZHMgdG8gc2hvdyBvbiB0aGUgZmluYWwgcGFnZSwgd2l0aCBhIGxlbmd0aCBvZiAxMC5cbiAqICAqIGByZWNvcmRzVG90YWxgIC0gRnVsbCBkYXRhIHNldCBsZW5ndGhcbiAqICAqIGByZWNvcmRzRGlzcGxheWAgLSBEYXRhIHNldCBsZW5ndGggb25jZSB0aGUgY3VycmVudCBmaWx0ZXJpbmcgY3JpdGVyaW9uXG4gKiAgICBhcmUgYXBwbGllZC5cbiAqL1xuX2FwaV9yZWdpc3RlciggJ3BhZ2UuaW5mbygpJywgZnVuY3Rpb24gKCkge1xuXHRpZiAoIHRoaXMuY29udGV4dC5sZW5ndGggPT09IDAgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdHZhclxuXHRcdHNldHRpbmdzICAgPSB0aGlzLmNvbnRleHRbMF0sXG5cdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlID8gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDogLTEsXG5cdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMTtcblxuXHRyZXR1cm4ge1xuXHRcdFwicGFnZVwiOiAgICAgICAgICAgYWxsID8gMCA6IE1hdGguZmxvb3IoIHN0YXJ0IC8gbGVuICksXG5cdFx0XCJwYWdlc1wiOiAgICAgICAgICBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0XCJzdGFydFwiOiAgICAgICAgICBzdGFydCxcblx0XHRcImVuZFwiOiAgICAgICAgICAgIHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdFwibGVuZ3RoXCI6ICAgICAgICAgbGVuLFxuXHRcdFwicmVjb3Jkc1RvdGFsXCI6ICAgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcInJlY29yZHNEaXNwbGF5XCI6IHZpc1JlY29yZHMsXG5cdFx0XCJzZXJ2ZXJTaWRlXCI6ICAgICBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09PSAnc3NwJ1xuXHR9O1xufSApO1xuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuICpcbiAqIEByZXR1cm4ge2ludGVnZXJ9IEN1cnJlbnQgcGFnZSBsZW5ndGguIE5vdGUgYC0xYCBpbmRpY2F0ZXMgdGhhdCBhbGwgcmVjb3Jkc1xuICogICBhcmUgdG8gYmUgc2hvd24uXG4gKi8vKipcbiAqIFNldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFBhZ2UgbGVuZ3RoIHRvIHNldC4gVXNlIGAtMWAgdG8gc2hvdyBhbGwgcmVjb3Jkcy5cbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAncGFnZS5sZW4oKScsIGZ1bmN0aW9uICggbGVuICkge1xuXHQvLyBOb3RlIHRoYXQgd2UgY2FuJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uICdsZW5ndGgoKScgYmVjYXVzZSBgbGVuZ3RoYFxuXHQvLyBpcyBhIEphdmFzY3JpcHQgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHdoaWNoIGRlZmluZXMgaG93IG1hbnkgYXJndW1lbnRzXG5cdC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzLlxuXHRpZiAoIGxlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwID9cblx0XHRcdHRoaXMuY29udGV4dFswXS5faURpc3BsYXlMZW5ndGggOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gZWxzZSwgc2V0IHRoZSBwYWdlIGxlbmd0aFxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCBsZW4gKTtcblx0fSApO1xufSApO1xuXG5cblxudmFyIF9fcmVsb2FkID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uLCBjYWxsYmFjayApIHtcblx0Ly8gVXNlIHRoZSBkcmF3IGV2ZW50IHRvIHRyaWdnZXIgYSBjYWxsYmFja1xuXHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblxuXHRcdGFwaS5vbmUoICdkcmF3JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2FsbGJhY2soIGFwaS5hamF4Lmpzb24oKSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PSAnc3NwJyApIHtcblx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0fVxuXHRlbHNlIHtcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblxuXHRcdC8vIENhbmNlbCBhbiBleGlzdGluZyByZXF1ZXN0XG5cdFx0dmFyIHhociA9IHNldHRpbmdzLmpxWEhSO1xuXHRcdGlmICggeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlciB4aHJcblx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCB7fSwgZnVuY3Rpb24oIGpzb24gKSB7XG5cdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXG5cdFx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdF9mbkFkZERhdGEoIHNldHRpbmdzLCBkYXRhW2ldICk7XG5cdFx0XHR9XG5cblx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiApO1xuXHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncyApO1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdH0gKTtcblx0fVxufTtcblxuXG4vKipcbiAqIEdldCB0aGUgSlNPTiByZXNwb25zZSBmcm9tIHRoZSBsYXN0IEFqYXggcmVxdWVzdCB0aGF0IERhdGFUYWJsZXMgbWFkZSB0byB0aGVcbiAqIHNlcnZlci4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgSlNPTiBmcm9tIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudFxuICogY29udGV4dC5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IEpTT04gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRyZXR1cm4gY3R4WzBdLmpzb247XG5cdH1cblxuXHQvLyBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG59ICk7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgc3VibWl0dGVkIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC5wYXJhbXMoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdHJldHVybiBjdHhbMF0ub0FqYXhEYXRhO1xuXHR9XG5cblx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xufSApO1xuXG5cbi8qKlxuICogUmVsb2FkIHRhYmxlcyBmcm9tIHRoZSBBamF4IGRhdGEgc291cmNlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHJlLWRyYXcgdGhlIHRhYmxlIHdoZW4gdGhlIHJlbW90ZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcbiAqICAgcG9zaXRpb24uIEEgZnVsbCByZS1zb3J0IGFuZCByZS1maWx0ZXIgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBtZXRob2QgaXNcbiAqICAgY2FsbGVkLCB3aGljaCBpcyB3aHkgdGhlIHBhZ2luYXRpb24gcmVzZXQgaXMgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdhamF4LnJlbG9hZCgpJywgZnVuY3Rpb24gKCBjYWxsYmFjaywgcmVzZXRQYWdpbmcgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblx0XHRfX3JlbG9hZCggc2V0dGluZ3MsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdH0gKTtcbn0gKTtcblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgVVJMIGZyb20gdGhlIGZpcnN0XG4gKiB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBBamF4IHNvdXJjZSBVUkxcbiAqLy8qKlxuICogU2V0IHRoZSBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzZXQgdGhlIFVSTCBmb3IgYWxsIHRhYmxlcyBpbiB0aGVcbiAqIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byBzZXQuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCknLCBmdW5jdGlvbiAoIHVybCApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIGdldFxuXHRcdGlmICggY3R4Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGN0eCA9IGN0eFswXTtcblxuXHRcdHJldHVybiAkLmlzUGxhaW5PYmplY3QoIGN0eC5hamF4ICkgP1xuXHRcdFx0Y3R4LmFqYXgudXJsIDpcblx0XHRcdGN0eC5hamF4O1xuXHR9XG5cblx0Ly8gc2V0XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzZXR0aW5ncy5hamF4ICkgKSB7XG5cdFx0XHRzZXR0aW5ncy5hamF4LnVybCA9IHVybDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzZXR0aW5ncy5hamF4ID0gdXJsO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5cbi8qKlxuICogTG9hZCBkYXRhIGZyb20gdGhlIG5ld2x5IHNldCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAqIGF2YWlsYWJsZSB3aGVuIGBhamF4LnVybCgpYCBpcyB1c2VkIHRvIHNldCBhIFVSTC4gQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZFxuICogaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBjYWxsaW5nIGBhamF4LnJlbG9hZCgpYCBidXQgaXMgcHJvdmlkZWQgZm9yXG4gKiBjb252ZW5pZW5jZSB3aGVuIHNldHRpbmcgYSBuZXcgVVJMLiBMaWtlIGBhamF4LnJlbG9hZCgpYCBpdCB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyB0aGUgdGFibGUgb25jZSB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuICpcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC51cmwoKS5sb2FkKCknLCBmdW5jdGlvbiAoIGNhbGxiYWNrLCByZXNldFBhZ2luZyApIHtcblx0Ly8gU2FtZSBhcyBhIHJlbG9hZCwgYnV0IG1ha2VzIHNlbnNlIHRvIHByZXNlbnQgaXQgZm9yIGVhc3kgYWNjZXNzIGFmdGVyIGFcblx0Ly8gdXJsIGNoYW5nZVxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0X19yZWxvYWQoIGN0eCwgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0fSApO1xufSApO1xuXG5cblxuXG52YXIgX3NlbGVjdG9yX3J1biA9IGZ1bmN0aW9uICggdHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cyApXG57XG5cdHZhclxuXHRcdG91dCA9IFtdLCByZXMsXG5cdFx0YSwgaSwgaWVuLCBqLCBqZW4sXG5cdFx0c2VsZWN0b3JUeXBlID0gdHlwZW9mIHNlbGVjdG9yO1xuXG5cdC8vIENhbid0IGp1c3QgY2hlY2sgZm9yIGlzQXJyYXkgaGVyZSwgYXMgYW4gQVBJIG9yIGpRdWVyeSBpbnN0YW5jZSBtaWdodCBiZVxuXHQvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xuXHRpZiAoICEgc2VsZWN0b3IgfHwgc2VsZWN0b3JUeXBlID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvclR5cGUgPT09ICdmdW5jdGlvbicgfHwgc2VsZWN0b3IubGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0c2VsZWN0b3IgPSBbIHNlbGVjdG9yIF07XG5cdH1cblxuXHRmb3IgKCBpPTAsIGllbj1zZWxlY3Rvci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHQvLyBPbmx5IHNwbGl0IG9uIHNpbXBsZSBzdHJpbmdzIC0gY29tcGxleCBleHByZXNzaW9ucyB3aWxsIGJlIGpRdWVyeSBzZWxlY3RvcnNcblx0XHRhID0gc2VsZWN0b3JbaV0gJiYgc2VsZWN0b3JbaV0uc3BsaXQgJiYgISBzZWxlY3RvcltpXS5tYXRjaCgvW1soOl0vKSA/XG5cdFx0XHRzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcblx0XHRcdFsgc2VsZWN0b3JbaV0gXTtcblxuXHRcdGZvciAoIGo9MCwgamVuPWEubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRyZXMgPSBzZWxlY3RGbiggdHlwZW9mIGFbal0gPT09ICdzdHJpbmcnID8gKGFbal0pLnRyaW0oKSA6IGFbal0gKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGVtcHR5IGl0ZW1zXG5cdFx0XHRyZXMgPSByZXMuZmlsdGVyKCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCByZXMgJiYgcmVzLmxlbmd0aCApIHtcblx0XHRcdFx0b3V0ID0gb3V0LmNvbmNhdCggcmVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gc2VsZWN0b3IgZXh0ZW5zaW9uc1xuXHR2YXIgZXh0ID0gX2V4dC5zZWxlY3RvclsgdHlwZSBdO1xuXHRpZiAoIGV4dC5sZW5ndGggKSB7XG5cdFx0Zm9yICggaT0wLCBpZW49ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0b3V0ID0gZXh0W2ldKCBzZXR0aW5ncywgb3B0cywgb3V0ICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIF91bmlxdWUoIG91dCApO1xufTtcblxuXG52YXIgX3NlbGVjdG9yX29wdHMgPSBmdW5jdGlvbiAoIG9wdHMgKVxue1xuXHRpZiAoICEgb3B0cyApIHtcblx0XHRvcHRzID0ge307XG5cdH1cblxuXHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXG5cdC8vIHRoYW4gc2VhcmNoXG5cdGlmICggb3B0cy5maWx0ZXIgJiYgb3B0cy5zZWFyY2ggPT09IHVuZGVmaW5lZCApIHtcblx0XHRvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xuXHR9XG5cblx0cmV0dXJuICQuZXh0ZW5kKCB7XG5cdFx0c2VhcmNoOiAnbm9uZScsXG5cdFx0b3JkZXI6ICdjdXJyZW50Jyxcblx0XHRwYWdlOiAnYWxsJ1xuXHR9LCBvcHRzICk7XG59O1xuXG5cbi8vIFJlZHVjZSB0aGUgQVBJIGluc3RhbmNlIHRvIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG52YXIgX3NlbGVjdG9yX2ZpcnN0ID0gZnVuY3Rpb24gKCBvbGQgKVxue1xuXHR2YXIgaW5zdCA9IG5ldyBfQXBpKG9sZC5jb250ZXh0WzBdKTtcblxuXHQvLyBVc2UgYSBwdXNoIHJhdGhlciB0aGFuIHBhc3NpbmcgdG8gdGhlIGNvbnN0cnVjdG9yLCBzaW5jZSBpdCB3aWxsXG5cdC8vIG1lcmdlIGFycmF5cyBkb3duIGF1dG9tYXRpY2FsbHksIHdoaWNoIGlzbid0IHdoYXQgaXMgd2FudGVkIGhlcmVcblx0aWYgKG9sZC5sZW5ndGgpIHtcblx0XHRpbnN0LnB1c2goIG9sZFswXSApO1xuXHR9XG5cblx0aW5zdC5zZWxlY3RvciA9IG9sZC5zZWxlY3RvcjtcblxuXHQvLyBMaW1pdCB0byBhIHNpbmdsZSByb3cgLyBjb2x1bW4gLyBjZWxsXG5cdGlmIChpbnN0Lmxlbmd0aCAmJiBpbnN0WzBdLmxlbmd0aCA+IDEpIHtcblx0XHRpbnN0WzBdLnNwbGljZSgxKTtcblx0fVxuXG5cdHJldHVybiBpbnN0O1xufTtcblxuXG52YXIgX3NlbGVjdG9yX3Jvd19pbmRleGVzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApXG57XG5cdHZhclxuXHRcdGksIGllbiwgdG1wLCBhPVtdLFxuXHRcdGRpc3BsYXlGaWx0ZXJlZCA9IHNldHRpbmdzLmFpRGlzcGxheSxcblx0XHRkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXG5cdHZhclxuXHRcdHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxuXHRcdG9yZGVyICA9IG9wdHMub3JkZXIsICAgLy8gYXBwbGllZCwgY3VycmVudCwgaW5kZXggKG9yaWdpbmFsIC0gY29tcGF0aWJpbGl0eSB3aXRoIDEuOSlcblx0XHRwYWdlICAgPSBvcHRzLnBhZ2U7ICAgIC8vIGFsbCwgY3VycmVudFxuXG5cdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PSAnc3NwJyApIHtcblx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG1vZGUsIG1vc3Qgb3B0aW9ucyBhcmUgaXJyZWxldmFudCBzaW5jZVxuXHRcdC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcblx0XHQvLyBSZW1vdmVkIGlzIGEgc3BlY2lhbCBjYXNlIC0gZm9yIGNvbnNpc3RlbmN5IGp1c3QgcmV0dXJuIGFuIGVtcHR5XG5cdFx0Ly8gYXJyYXlcblx0XHRyZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xuXHRcdFx0W10gOlxuXHRcdFx0X3JhbmdlKCAwLCBkaXNwbGF5TWFzdGVyLmxlbmd0aCApO1xuXHR9XG5cblx0aWYgKCBwYWdlID09ICdjdXJyZW50JyApIHtcblx0XHQvLyBDdXJyZW50IHBhZ2UgaW1wbGllcyB0aGF0IG9yZGVyPWN1cnJlbnQgYW5kIGZpbHRlcj1hcHBsaWVkLCBzaW5jZSBpdCBpc1xuXHRcdC8vIGZhaXJseSBzZW5zZWxlc3Mgb3RoZXJ3aXNlLCByZWdhcmRsZXNzIG9mIHdoYXQgb3JkZXIgYW5kIHNlYXJjaCBhY3R1YWxseVxuXHRcdC8vIGFyZVxuXHRcdGZvciAoIGk9c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsIGllbj1zZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0YS5wdXNoKCBkaXNwbGF5RmlsdGVyZWRbaV0gKTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIG9yZGVyID09ICdjdXJyZW50JyB8fCBvcmRlciA9PSAnYXBwbGllZCcgKSB7XG5cdFx0aWYgKCBzZWFyY2ggPT0gJ25vbmUnKSB7XG5cdFx0XHRhID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2VhcmNoID09ICdhcHBsaWVkJyApIHtcblx0XHRcdGEgPSBkaXNwbGF5RmlsdGVyZWQuc2xpY2UoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNlYXJjaCA9PSAncmVtb3ZlZCcgKSB7XG5cdFx0XHQvLyBPKG4rbSkgc29sdXRpb24gYnkgY3JlYXRpbmcgYSBoYXNoIG1hcFxuXHRcdFx0dmFyIGRpc3BsYXlGaWx0ZXJlZE1hcCA9IHt9O1xuXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1kaXNwbGF5RmlsdGVyZWQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGRpc3BsYXlGaWx0ZXJlZE1hcFtkaXNwbGF5RmlsdGVyZWRbaV1dID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZGlzcGxheU1hc3Rlci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdGlmICghIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaXNwbGF5RmlsdGVyZWRNYXAsIGl0ZW0pKSB7XG5cdFx0XHRcdFx0YS5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIG9yZGVyID09ICdpbmRleCcgfHwgb3JkZXIgPT0gJ29yaWdpbmFsJyApIHtcblx0XHRmb3IgKCBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoISBzZXR0aW5ncy5hb0RhdGFbaV0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2VhcmNoID09ICdub25lJyApIHtcblx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcblx0XHRcdFx0dG1wID0gZGlzcGxheUZpbHRlcmVkLmluZGV4T2YoaSk7XG5cblx0XHRcdFx0aWYgKCh0bXAgPT09IC0xICYmIHNlYXJjaCA9PSAncmVtb3ZlZCcpIHx8XG5cdFx0XHRcdFx0KHRtcCA+PSAwICAgJiYgc2VhcmNoID09ICdhcHBsaWVkJykgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicgKSB7XG5cdFx0Ly8gT3JkZXIgdGhlIHJvd3MgYnkgdGhlIGdpdmVuIGNvbHVtblxuXHRcdHZhciBvcmRlcmVkID0gX2ZuU29ydChzZXR0aW5ncywgb3JkZXIsICdhc2MnKTtcblxuXHRcdGlmIChzZWFyY2ggPT09ICdub25lJykge1xuXHRcdFx0YSA9IG9yZGVyZWQ7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyBhcHBsaWVkIHwgcmVtb3ZlZFxuXHRcdFx0Zm9yIChpPTA7IGk8b3JkZXJlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0bXAgPSBkaXNwbGF5RmlsdGVyZWQuaW5kZXhPZihvcmRlcmVkW2ldKTtcblxuXHRcdFx0XHRpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcblx0XHRcdFx0XHQodG1wID49IDAgICAmJiBzZWFyY2ggPT0gJ2FwcGxpZWQnKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhLnB1c2goIG9yZGVyZWRbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhO1xufTtcblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIFJvd3NcbiAqXG4gKiB7fSAgICAgICAgICAtIG5vIHNlbGVjdG9yIC0gdXNlIGFsbCBhdmFpbGFibGUgcm93c1xuICoge2ludGVnZXJ9ICAgLSByb3cgYW9EYXRhIGluZGV4XG4gKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcbiAqIHtzdHJpbmd9ICAgIC0galF1ZXJ5IHNlbGVjdG9yIHRvIGFwcGx5IHRvIHRoZSBUUiBlbGVtZW50c1xuICoge2FycmF5fSAgICAgLSBqUXVlcnkgYXJyYXkgb2Ygbm9kZXMsIG9yIHNpbXBseSBhbiBhcnJheSBvZiBUUiBub2Rlc1xuICpcbiAqL1xudmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxue1xuXHR2YXIgcm93cztcblx0dmFyIHJ1biA9IGZ1bmN0aW9uICggc2VsICkge1xuXHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzZWwgKTtcblx0XHR2YXIgYW9EYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXG5cdFx0Ly8gU2hvcnQgY3V0IC0gc2VsZWN0b3IgaXMgYSBudW1iZXIgYW5kIG5vIG9wdGlvbnMgcHJvdmlkZWQgKGRlZmF1bHQgaXNcblx0XHQvLyBhbGwgcmVjb3Jkcywgc28gbm8gbmVlZCB0byBjaGVjayBpZiB0aGUgaW5kZXggaXMgaW4gdGhlcmUsIHNpbmNlIGl0XG5cdFx0Ly8gbXVzdCBiZSAtIGRldiBlcnJvciBpZiB0aGUgaW5kZXggZG9lc24ndCBleGlzdCkuXG5cdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgISBvcHRzICkge1xuXHRcdFx0cmV0dXJuIFsgc2VsSW50IF07XG5cdFx0fVxuXG5cdFx0aWYgKCAhIHJvd3MgKSB7XG5cdFx0XHRyb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcdH1cblxuXHRcdGlmICggc2VsSW50ICE9PSBudWxsICYmIHJvd3MuaW5kZXhPZihzZWxJbnQpICE9PSAtMSApIHtcblx0XHRcdC8vIFNlbGVjdG9yIC0gaW50ZWdlclxuXHRcdFx0cmV0dXJuIFsgc2VsSW50IF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzZWwgPT09IG51bGwgfHwgc2VsID09PSB1bmRlZmluZWQgfHwgc2VsID09PSAnJyApIHtcblx0XHRcdC8vIFNlbGVjdG9yIC0gbm9uZVxuXHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgLSBmdW5jdGlvblxuXHRcdGlmICggdHlwZW9mIHNlbCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHJldHVybiByb3dzLm1hcCggZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHR2YXIgcm93ID0gYW9EYXRhWyBpZHggXTtcblx0XHRcdFx0cmV0dXJuIHNlbCggaWR4LCByb3cuX2FEYXRhLCByb3cublRyICkgPyBpZHggOiBudWxsO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFNlbGVjdG9yIC0gbm9kZVxuXHRcdGlmICggc2VsLm5vZGVOYW1lICkge1xuXHRcdFx0dmFyIHJvd0lkeCA9IHNlbC5fRFRfUm93SW5kZXg7ICAvLyBQcm9wZXJ0eSBhZGRlZCBieSBEVCBmb3IgZmFzdCBsb29rdXBcblx0XHRcdHZhciBjZWxsSWR4ID0gc2VsLl9EVF9DZWxsSW5kZXg7XG5cblx0XHRcdGlmICggcm93SWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByb3cgaXMgYWN0dWFsbHkgc3RpbGwgcHJlc2VudCBpbiB0aGUgdGFibGVcblx0XHRcdFx0cmV0dXJuIGFvRGF0YVsgcm93SWR4IF0gJiYgYW9EYXRhWyByb3dJZHggXS5uVHIgPT09IHNlbCA/XG5cdFx0XHRcdFx0WyByb3dJZHggXSA6XG5cdFx0XHRcdFx0W107XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY2VsbElkeCApIHtcblx0XHRcdFx0cmV0dXJuIGFvRGF0YVsgY2VsbElkeC5yb3cgXSAmJiBhb0RhdGFbIGNlbGxJZHgucm93IF0ublRyID09PSBzZWwucGFyZW50Tm9kZSA/XG5cdFx0XHRcdFx0WyBjZWxsSWR4LnJvdyBdIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgaG9zdCA9ICQoc2VsKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuXHRcdFx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0XHRcdFsgaG9zdC5kYXRhKCdkdC1yb3cnKSBdIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRCBzZWxlY3Rvci4gV2FudCB0byBhbHdheXMgYmUgYWJsZSB0byBzZWxlY3Qgcm93cyBieSBpZCwgcmVnYXJkbGVzc1xuXHRcdC8vIG9mIGlmIHRoZSB0ciBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3Igbm90LCBzbyBjYW4ndCByZWx5IHVwb25cblx0XHQvLyBqUXVlcnkgaGVyZSAtIGhlbmNlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLiBUaGlzIGRvZXMgbm90IG1hdGNoXG5cdFx0Ly8gU2l6emxlJ3MgZmFzdCBzZWxlY3RvciBvciBIVE1MNCAtIGluIEhUTUw1IHRoZSBJRCBjYW4gYmUgYW55dGhpbmcsXG5cdFx0Ly8gYnV0IHRvIHNlbGVjdCBpdCB1c2luZyBhIENTUyBzZWxlY3RvciBlbmdpbmUgKGxpa2UgU2l6emxlIG9yXG5cdFx0Ly8gcXVlcnlTZWxlY3QpIGl0IHdvdWxkIG5lZWQgdG8gbmVlZCB0byBiZSBlc2NhcGVkIGZvciBzb21lIGNoYXJhY3RlcnMuXG5cdFx0Ly8gRGF0YVRhYmxlcyBzaW1wbGlmaWVzIHRoaXMgZm9yIHJvdyBzZWxlY3RvcnMgc2luY2UgeW91IGNhbiBzZWxlY3Rcblx0XHQvLyBvbmx5IGEgcm93LiBBICMgaW5kaWNhdGVzIGFuIGlkIGFueSBhbnl0aGluZyB0aGF0IGZvbGxvd3MgaXMgdGhlIGlkIC1cblx0XHQvLyB1bmVzY2FwZWQuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsID09PSAnc3RyaW5nJyAmJiBzZWwuY2hhckF0KDApID09PSAnIycgKSB7XG5cdFx0XHQvLyBnZXQgcm93IGluZGV4IGZyb20gaWRcblx0XHRcdHZhciByb3dPYmogPSBzZXR0aW5ncy5hSWRzWyBzZWwucmVwbGFjZSggL14jLywgJycgKSBdO1xuXHRcdFx0aWYgKCByb3dPYmogIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIFsgcm93T2JqLmlkeCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBuZWVkIHRvIGZhbGwgdGhyb3VnaCB0byBqUXVlcnkgaW4gY2FzZSB0aGVyZSBpcyBET00gaWQgdGhhdFxuXHRcdFx0Ly8gbWF0Y2hlc1xuXHRcdH1cblx0XHRcblx0XHQvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcblx0XHR2YXIgbm9kZXMgPSBfcmVtb3ZlRW1wdHkoXG5cdFx0XHRfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ25UcicgKVxuXHRcdCk7XG5cblx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcsIGFycmF5IG9mIG5vZGVzIG9yIGpRdWVyeSBvYmplY3QvXG5cdFx0Ly8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxuXHRcdC8vIGl0IGFsc28gYWxsb3dzIGFycmF5cywgc28gdGhpcyB3aWxsIGNvcGUgd2l0aCBhbGwgdGhyZWUgb3B0aW9uc1xuXHRcdHJldHVybiAkKG5vZGVzKVxuXHRcdFx0LmZpbHRlciggc2VsIClcblx0XHRcdC5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX0RUX1Jvd0luZGV4O1xuXHRcdFx0fSApXG5cdFx0XHQudG9BcnJheSgpO1xuXHR9O1xuXG5cdHZhciBtYXRjaGVkID0gX3NlbGVjdG9yX3J1biggJ3JvdycsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cblx0aWYgKG9wdHMub3JkZXIgPT09ICdjdXJyZW50JyB8fCBvcHRzLm9yZGVyID09PSAnYXBwbGllZCcpIHtcblx0XHRfZm5Tb3J0RGlzcGxheShzZXR0aW5ncywgbWF0Y2hlZCk7XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxuX2FwaV9yZWdpc3RlciggJ3Jvd3MoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzZWxlY3RvciA9ICcnO1xuXHR9XG5cdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKSB7XG5cdFx0b3B0cyA9IHNlbGVjdG9yO1xuXHRcdHNlbGVjdG9yID0gJyc7XG5cdH1cblxuXHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblxuXHR2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIF9fcm93X3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0fSwgMSApO1xuXG5cdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX19yb3dfc2VsZWN0b3I/XG5cdGluc3Quc2VsZWN0b3Iucm93cyA9IHNlbGVjdG9yO1xuXHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXG5cdHJldHVybiBpbnN0O1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAncm93cygpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdLm5UciB8fCB1bmRlZmluZWQ7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ3Jvd3MoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCB0cnVlLCAncm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvd3MgKSB7XG5cdFx0cmV0dXJuIF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnX2FEYXRhJyApO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuY2FjaGUoKScsICdyb3coKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHR2YXIgciA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFx0cmV0dXJuIHR5cGUgPT09ICdzZWFyY2gnID8gci5fYUZpbHRlckRhdGEgOiByLl9hU29ydERhdGE7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pbnZhbGlkYXRlKCknLCAncm93KCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYyApO1xuXHR9ICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW5kZXhlcygpJywgJ3JvdygpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdHJldHVybiByb3c7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pZHMoKScsICdyb3coKS5pZCgpJywgZnVuY3Rpb24gKCBoYXNoICkge1xuXHR2YXIgYSA9IFtdO1xuXHR2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHQvLyBgaXRlcmF0b3JgIHdpbGwgZHJvcCB1bmRlZmluZWQgdmFsdWVzLCBidXQgaW4gdGhpcyBjYXNlIHdlIHdhbnQgdGhlbVxuXHRmb3IgKCB2YXIgaT0wLCBpZW49Y29udGV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGhpc1tpXS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdHZhciBpZCA9IGNvbnRleHRbaV0ucm93SWRGbiggY29udGV4dFtpXS5hb0RhdGFbIHRoaXNbaV1bal0gXS5fYURhdGEgKTtcblx0XHRcdGEucHVzaCggKGhhc2ggPT09IHRydWUgPyAnIycgOiAnJyApKyBpZCApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgYSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLnJlbW92ZSgpJywgJ3JvdygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xuXHR0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdHZhciByb3dEYXRhID0gZGF0YVsgcm93IF07XG5cblx0XHQvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcblx0XHR2YXIgaWR4ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLmluZGV4T2Yocm93KTtcblx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNwbGljZShpZHgsIDEpO1xuXHRcdH1cblxuXHRcdC8vIEZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcyAtIHN1YnRyYWN0IHRoZSBkZWxldGVkIHJvdyBmcm9tIHRoZSBjb3VudFxuXHRcdGlmICggc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA+IDAgKSB7XG5cdFx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5LS07XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIGFuICdvdmVyZmxvdycgdGhleSBjYXNlIGZvciBkaXNwbGF5aW5nIHRoZSB0YWJsZVxuXHRcdF9mbkxlbmd0aE92ZXJmbG93KCBzZXR0aW5ncyApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSByb3cncyBJRCByZWZlcmVuY2UgaWYgdGhlcmUgaXMgb25lXG5cdFx0dmFyIGlkID0gc2V0dGluZ3Mucm93SWRGbiggcm93RGF0YS5fYURhdGEgKTtcblx0XHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkZWxldGUgc2V0dGluZ3MuYUlkc1sgaWQgXTtcblx0XHR9XG5cblx0XHRkYXRhW3Jvd10gPSBudWxsO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3Jvd3MuYWRkKCknLCBmdW5jdGlvbiAoIHJvd3MgKSB7XG5cdHZhciBuZXdSb3dzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciByb3csIGksIGllbjtcblx0XHRcdHZhciBvdXQgPSBbXTtcblxuXHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0cm93ID0gcm93c1tpXTtcblxuXHRcdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93ICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH0sIDEgKTtcblxuXHQvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgc28gcm93cygpLm5vZGVzKCkgZXRjIGNhbiBiZSB1c2VkXG5cdHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKCAtMSApO1xuXHRtb2RSb3dzLnBvcCgpO1xuXHRfZm5BcnJheUFwcGx5KG1vZFJvd3MsIG5ld1Jvd3MpO1xuXG5cdHJldHVybiBtb2RSb3dzO1xufSApO1xuXG5cblxuXG5cbi8qKlxuICpcbiAqL1xuX2FwaV9yZWdpc3RlciggJ3JvdygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5yb3dzKCBzZWxlY3Rvciwgb3B0cyApICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3JvdygpLmRhdGEoKScsIGZ1bmN0aW9uICggZGF0YSApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBHZXRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCAmJiB0aGlzWzBdLmxlbmd0aCA/XG5cdFx0XHRjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0uX2FEYXRhIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNldFxuXHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdO1xuXHRyb3cuX2FEYXRhID0gZGF0YTtcblxuXHQvLyBJZiB0aGUgRE9NIGhhcyBhbiBpZCwgYW5kIHRoZSBkYXRhIHNvdXJjZSBpcyBhbiBhcnJheVxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSAmJiByb3cublRyICYmIHJvdy5uVHIuaWQgKSB7XG5cdFx0X2ZuU2V0T2JqZWN0RGF0YUZuKCBjdHhbMF0ucm93SWQgKSggZGF0YSwgcm93Lm5Uci5pZCApO1xuXHR9XG5cblx0Ly8gQXV0b21hdGljYWxseSBpbnZhbGlkYXRlXG5cdF9mbkludmFsaWRhdGUoIGN0eFswXSwgdGhpc1swXSwgJ2RhdGEnICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3JvdygpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCAmJiB0aGlzWzBdLmxlbmd0aCkge1xuXHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF07XG5cblx0XHRpZiAocm93ICYmIHJvdy5uVHIpIHtcblx0XHRcdHJldHVybiByb3cublRyO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdyb3cuYWRkKCknLCBmdW5jdGlvbiAoIHJvdyApIHtcblx0Ly8gQWxsb3cgYSBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiAtIG9ubHkgYSBzaW5nbGUgcm93IGlzIGFkZGVkIGZyb21cblx0Ly8gaXQgdGhvdWdoIC0gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuXHRpZiAoIHJvdyBpbnN0YW5jZW9mICQgJiYgcm93Lmxlbmd0aCApIHtcblx0XHRyb3cgPSByb3dbMF07XG5cdH1cblxuXHR2YXIgcm93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCByb3cubm9kZU5hbWUgJiYgcm93Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicgKSB7XG5cdFx0XHRyZXR1cm4gX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKTtcblx0fSApO1xuXG5cdC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCB3aXRoIHRoZSBuZXdseSBhZGRlZCByb3cgc2VsZWN0ZWRcblx0cmV0dXJuIHRoaXMucm93KCByb3dzWzBdICk7XG59ICk7XG5cblxuJChkb2N1bWVudCkub24oJ3BsdWdpbi1pbml0LmR0JywgZnVuY3Rpb24gKGUsIGNvbnRleHQpIHtcblx0dmFyIGFwaSA9IG5ldyBfQXBpKCBjb250ZXh0ICk7XG5cblx0YXBpLm9uKCAnc3RhdGVTYXZlUGFyYW1zLkRUJywgZnVuY3Rpb24gKCBlLCBzZXR0aW5ncywgZCApIHtcblx0XHQvLyBUaGlzIGNvdWxkIGJlIG1vcmUgY29tcGFjdCB3aXRoIHRoZSBBUEksIGJ1dCBpdCBpcyBhIGxvdCBmYXN0ZXIgYXMgYSBzaW1wbGVcblx0XHQvLyBpbnRlcm5hbCBsb29wXG5cdFx0dmFyIGlkRm4gPSBzZXR0aW5ncy5yb3dJZEZuO1xuXHRcdHZhciByb3dzID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXHRcdHZhciBpZHMgPSBbXTtcblxuXHRcdGZvciAodmFyIGk9MCA7IGk8cm93cy5sZW5ndGggOyBpKyspIHtcblx0XHRcdHZhciByb3dJZHggPSByb3dzW2ldO1xuXHRcdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XTtcblxuXHRcdFx0aWYgKGRhdGEuX2RldGFpbHNTaG93KSB7XG5cdFx0XHRcdGlkcy5wdXNoKCAnIycgKyBpZEZuKGRhdGEuX2FEYXRhKSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGQuY2hpbGRSb3dzID0gaWRzO1xuXHR9KTtcblxuXHQvLyBGb3IgZnV0dXJlIHN0YXRlIGxvYWRzIChlLmcuIHdpdGggU3RhdGVSZXN0b3JlKVxuXHRhcGkub24oICdzdGF0ZUxvYWRlZC5EVCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgc3RhdGUpIHtcblx0XHRfX2RldGFpbHNfc3RhdGVfbG9hZCggYXBpLCBzdGF0ZSApO1xuXHR9KTtcblxuXHQvLyBBbmQgdGhlIGluaXRpYWwgbG9hZCBzdGF0ZVxuXHRfX2RldGFpbHNfc3RhdGVfbG9hZCggYXBpLCBhcGkuc3RhdGUubG9hZGVkKCkgKTtcbn0pO1xuXG52YXIgX19kZXRhaWxzX3N0YXRlX2xvYWQgPSBmdW5jdGlvbiAoYXBpLCBzdGF0ZSlcbntcblx0aWYgKCBzdGF0ZSAmJiBzdGF0ZS5jaGlsZFJvd3MgKSB7XG5cdFx0YXBpXG5cdFx0XHQucm93cyggc3RhdGUuY2hpbGRSb3dzLm1hcChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdFx0Ly8gRXNjYXBlIGFueSBgOmAgY2hhcmFjdGVycyBmcm9tIHRoZSByb3cgaWQuIEFjY291bnRzIGZvclxuXHRcdFx0XHQvLyBhbHJlYWR5IGVzY2FwZWQgY2hhcmFjdGVycy5cblx0XHRcdFx0cmV0dXJuIGlkLnJlcGxhY2UoLyhbXjpcXFxcXSooPzpcXFxcLlteOlxcXFxdKikqKTovZywgXCIkMVxcXFw6XCIpO1xuXHRcdFx0fSkgKVxuXHRcdFx0LmV2ZXJ5KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggYXBpLnNldHRpbmdzKClbMF0sIG51bGwsICdyZXF1ZXN0Q2hpbGQnLCBbIHRoaXMgXSApXG5cdFx0XHR9KTtcblx0fVxufVxuXG52YXIgX19kZXRhaWxzX2FkZCA9IGZ1bmN0aW9uICggY3R4LCByb3csIGRhdGEsIGtsYXNzIClcbntcblx0Ly8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xuXHR2YXIgcm93cyA9IFtdO1xuXHR2YXIgYWRkUm93ID0gZnVuY3Rpb24gKCByLCBrICkge1xuXHRcdC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCByICkgfHwgciBpbnN0YW5jZW9mICQgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0YWRkUm93KCByW2ldLCBrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHQvLyB0byBhZGQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMgZXRjXG5cdFx0aWYgKCByLm5vZGVOYW1lICYmIHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyJyApIHtcblx0XHRcdHIuc2V0QXR0cmlidXRlKCAnZGF0YS1kdC1yb3cnLCByb3cuaWR4ICk7XG5cdFx0XHRyb3dzLnB1c2goIHIgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UgY3JlYXRlIGEgcm93IHdpdGggYSB3cmFwcGVyXG5cdFx0XHR2YXIgY3JlYXRlZCA9ICQoJzx0cj48dGQ+PC90ZD48L3RyPicpXG5cdFx0XHRcdC5hdHRyKCAnZGF0YS1kdC1yb3cnLCByb3cuaWR4IClcblx0XHRcdFx0LmFkZENsYXNzKCBrICk7XG5cdFx0XHRcblx0XHRcdCQoJ3RkJywgY3JlYXRlZClcblx0XHRcdFx0LmFkZENsYXNzKCBrIClcblx0XHRcdFx0Lmh0bWwoIHIgKVswXS5jb2xTcGFuID0gX2ZuVmlzYmxlQ29sdW1ucyggY3R4ICk7XG5cblx0XHRcdHJvd3MucHVzaCggY3JlYXRlZFswXSApO1xuXHRcdH1cblx0fTtcblxuXHRhZGRSb3coIGRhdGEsIGtsYXNzICk7XG5cblx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0cm93Ll9kZXRhaWxzLmRldGFjaCgpO1xuXHR9XG5cblx0cm93Ll9kZXRhaWxzID0gJChyb3dzKTtcblxuXHQvLyBJZiB0aGUgY2hpbGRyZW4gd2VyZSBhbHJlYWR5IHNob3duLCB0aGF0IHN0YXRlIHNob3VsZCBiZSByZXRhaW5lZFxuXHRpZiAoIHJvdy5fZGV0YWlsc1Nob3cgKSB7XG5cdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdH1cbn07XG5cblxuLy8gTWFrZSBzdGF0ZSBzYXZpbmcgb2YgY2hpbGQgcm93IGRldGFpbHMgYXN5bmMgdG8gYWxsb3cgdGhlbSB0byBiZSBiYXRjaCBwcm9jZXNzZWRcbnZhciBfX2RldGFpbHNfc3RhdGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZShcblx0ZnVuY3Rpb24gKGN0eCkge1xuXHRcdF9mblNhdmVTdGF0ZSggY3R4WzBdIClcblx0fSxcblx0NTAwXG4pO1xuXG5cbnZhciBfX2RldGFpbHNfcmVtb3ZlID0gZnVuY3Rpb24gKCBhcGksIGlkeCApXG57XG5cdHZhciBjdHggPSBhcGkuY29udGV4dDtcblxuXHRpZiAoIGN0eC5sZW5ndGggKSB7XG5cdFx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIGlkeCAhPT0gdW5kZWZpbmVkID8gaWR4IDogYXBpWzBdIF07XG5cblx0XHRpZiAoIHJvdyAmJiByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRyb3cuX2RldGFpbHMucmVtb3ZlKCk7XG5cblx0XHRcdHJvdy5fZGV0YWlsc1Nob3cgPSB1bmRlZmluZWQ7XG5cdFx0XHRyb3cuX2RldGFpbHMgPSB1bmRlZmluZWQ7XG5cdFx0XHQkKCByb3cublRyICkucmVtb3ZlQ2xhc3MoICdkdC1oYXNDaGlsZCcgKTtcblx0XHRcdF9fZGV0YWlsc19zdGF0ZSggY3R4ICk7XG5cdFx0fVxuXHR9XG59O1xuXG5cbnZhciBfX2RldGFpbHNfZGlzcGxheSA9IGZ1bmN0aW9uICggYXBpLCBzaG93ICkge1xuXHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoICYmIGFwaS5sZW5ndGggKSB7XG5cdFx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIGFwaVswXSBdO1xuXG5cdFx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRyb3cuX2RldGFpbHNTaG93ID0gc2hvdztcblxuXHRcdFx0aWYgKCBzaG93ICkge1xuXHRcdFx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0XHRcdFx0JCggcm93Lm5UciApLmFkZENsYXNzKCAnZHQtaGFzQ2hpbGQnICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzLmRldGFjaCgpO1xuXHRcdFx0XHQkKCByb3cublRyICkucmVtb3ZlQ2xhc3MoICdkdC1oYXNDaGlsZCcgKTtcblx0XHRcdH1cblxuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBjdHhbMF0sIG51bGwsICdjaGlsZFJvdycsIFsgc2hvdywgYXBpLnJvdyggYXBpWzBdICkgXSApXG5cblx0XHRcdF9fZGV0YWlsc19ldmVudHMoIGN0eFswXSApO1xuXHRcdFx0X19kZXRhaWxzX3N0YXRlKCBjdHggKTtcblx0XHR9XG5cdH1cbn07XG5cblxudmFyIF9fZGV0YWlsc19ldmVudHMgPSBmdW5jdGlvbiAoIHNldHRpbmdzIClcbntcblx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXHR2YXIgbmFtZXNwYWNlID0gJy5kdC5EVF9kZXRhaWxzJztcblx0dmFyIGRyYXdFdmVudCA9ICdkcmF3JytuYW1lc3BhY2U7XG5cdHZhciBjb2x2aXNFdmVudCA9ICdjb2x1bW4tc2l6aW5nJytuYW1lc3BhY2U7XG5cdHZhciBkZXN0cm95RXZlbnQgPSAnZGVzdHJveScrbmFtZXNwYWNlO1xuXHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblxuXHRhcGkub2ZmKCBkcmF3RXZlbnQgKycgJysgY29sdmlzRXZlbnQgKycgJysgZGVzdHJveUV2ZW50ICk7XG5cblx0aWYgKCBfcGx1Y2soIGRhdGEsICdfZGV0YWlscycgKS5sZW5ndGggPiAwICkge1xuXHRcdC8vIE9uIGVhY2ggZHJhdywgaW5zZXJ0IHRoZSByZXF1aXJlZCBlbGVtZW50cyBpbnRvIHRoZSBkb2N1bWVudFxuXHRcdGFwaS5vbiggZHJhd0V2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRhcGkucm93cygge3BhZ2U6J2N1cnJlbnQnfSApLmVxKDApLmVhY2goIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0Ly8gSW50ZXJuYWwgZGF0YSBncmFiXG5cdFx0XHRcdHZhciByb3cgPSBkYXRhWyBpZHggXTtcblxuXHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlsc1Nob3cgKSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cblx0XHQvLyBDb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2UgLSB1cGRhdGUgdGhlIGNvbHNwYW5cblx0XHRhcGkub24oIGNvbHZpc0V2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIGNvbHNwYW4gZm9yIHRoZSBkZXRhaWxzIHJvd3MgKG5vdGUsIG9ubHkgaWYgaXQgYWxyZWFkeSBoYXNcblx0XHRcdC8vIGEgY29sc3Bhbilcblx0XHRcdHZhciByb3csIHZpc2libGUgPSBfZm5WaXNibGVDb2x1bW5zKCBjdHggKTtcblxuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHJvdyA9IGRhdGFbaV07XG5cblx0XHRcdFx0aWYgKCByb3cgJiYgcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0XHRcdHJvdy5fZGV0YWlscy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciBlbCA9ICQodGhpcykuY2hpbGRyZW4oJ3RkJyk7XG5cblx0XHRcdFx0XHRcdGlmIChlbC5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRlbC5hdHRyKCdjb2xzcGFuJywgdmlzaWJsZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBUYWJsZSBkZXN0cm95ZWQgLSBudWtlIGFueSBjaGlsZCByb3dzXG5cdFx0YXBpLm9uKCBkZXN0cm95RXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbaV0gJiYgZGF0YVtpXS5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRfX2RldGFpbHNfcmVtb3ZlKCBhcGksIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufTtcblxuLy8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxudmFyIF9lbXAgPSAnJztcbnZhciBfY2hpbGRfb2JqID0gX2VtcCsncm93KCkuY2hpbGQnO1xudmFyIF9jaGlsZF9tdGggPSBfY2hpbGRfb2JqKycoKSc7XG5cbi8vIGRhdGEgY2FuIGJlOlxuLy8gIHRyXG4vLyAgc3RyaW5nXG4vLyAgalF1ZXJ5IG9yIGFycmF5IG9mIGFueSBvZiB0aGUgYWJvdmVcbl9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9tdGgsIGZ1bmN0aW9uICggZGF0YSwga2xhc3MgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gZ2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggJiYgY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdXG5cdFx0XHQ/IGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlsc1xuXHRcdFx0OiB1bmRlZmluZWQ7XG5cdH1cblx0ZWxzZSBpZiAoIGRhdGEgPT09IHRydWUgKSB7XG5cdFx0Ly8gc2hvd1xuXHRcdHRoaXMuY2hpbGQuc2hvdygpO1xuXHR9XG5cdGVsc2UgaWYgKCBkYXRhID09PSBmYWxzZSApIHtcblx0XHQvLyByZW1vdmVcblx0XHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdH1cblx0ZWxzZSBpZiAoIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggKSB7XG5cdFx0Ly8gc2V0XG5cdFx0X19kZXRhaWxzX2FkZCggY3R4WzBdLCBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0sIGRhdGEsIGtsYXNzICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdF9jaGlsZF9vYmorJy5zaG93KCknLFxuXHRfY2hpbGRfbXRoKycuc2hvdygpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5dLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIHRydWUgKTtcblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggW1xuXHRfY2hpbGRfb2JqKycuaGlkZSgpJyxcblx0X2NoaWxkX210aCsnLmhpZGUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXSwgZnVuY3Rpb24gKCkgeyAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdF9fZGV0YWlsc19kaXNwbGF5KCB0aGlzLCBmYWxzZSApO1xuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdF9jaGlsZF9vYmorJy5yZW1vdmUoKScsXG5cdF9jaGlsZF9tdGgrJy5yZW1vdmUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXSwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0X19kZXRhaWxzX3JlbW92ZSggdGhpcyApO1xuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBfY2hpbGRfb2JqKycuaXNTaG93bigpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCAmJiBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0gKSB7XG5cdFx0Ly8gX2RldGFpbHNTaG93biBhcyBmYWxzZSBvciB1bmRlZmluZWQgd2lsbCBmYWxsIHRocm91Z2ggdG8gcmV0dXJuIGZhbHNlXG5cdFx0cmV0dXJuIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlsc1Nob3cgfHwgZmFsc2U7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBDb2x1bW5zXG4gKlxuICoge2ludGVnZXJ9ICAgICAgICAgICAtIGNvbHVtbiBpbmRleCAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcbiAqIFwie2ludGVnZXJ9OnZpc0lkeFwiICAtIHZpc2libGUgY29sdW1uIGluZGV4IChpLmUuIHRyYW5zbGF0ZSB0byBjb2x1bW4gaW5kZXgpICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcbiAqIFwie2ludGVnZXJ9OnZpc2libGVcIiAtIGFsaWFzIGZvciB7aW50ZWdlcn06dmlzSWR4ICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcbiAqIFwie3N0cmluZ306bmFtZVwiICAgICAtIGNvbHVtbiBuYW1lXG4gKiBcIntzdHJpbmd9XCIgICAgICAgICAgLSBqUXVlcnkgc2VsZWN0b3Igb24gY29sdW1uIGhlYWRlciBub2Rlc1xuICpcbiAqL1xuXG4vLyBjYW4gYmUgYW4gYXJyYXkgb2YgdGhlc2UgaXRlbXMsIGNvbW1hIHNlcGFyYXRlZCBsaXN0LCBvciBhbiBhcnJheSBvZiBjb21tYVxuLy8gc2VwYXJhdGVkIGxpc3RzXG5cbnZhciBfX3JlX2NvbHVtbl9zZWxlY3RvciA9IC9eKFteOl0rKT86KG5hbWV8dGl0bGV8dmlzSWR4fHZpc2libGUpJC87XG5cblxuLy8gcjEgYW5kIHIyIGFyZSByZWR1bmRhbnQgLSBidXQgaXQgbWVhbnMgdGhhdCB0aGUgcGFyYW1ldGVycyBtYXRjaCBmb3IgdGhlXG4vLyBpdGVyYXRvciBjYWxsYmFjayBpbiBjb2x1bW5zKCkuZGF0YSgpXG52YXIgX19jb2x1bW5EYXRhID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCByMSwgcjIsIHJvd3MsIHR5cGUgKSB7XG5cdHZhciBhID0gW107XG5cdGZvciAoIHZhciByb3c9MCwgaWVuPXJvd3MubGVuZ3RoIDsgcm93PGllbiA7IHJvdysrICkge1xuXHRcdGEucHVzaCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dzW3Jvd10sIGNvbHVtbiwgdHlwZSApICk7XG5cdH1cblx0cmV0dXJuIGE7XG59O1xuXG5cbnZhciBfX2NvbHVtbl9oZWFkZXIgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHJvdyApIHtcblx0dmFyIGhlYWRlciA9IHNldHRpbmdzLmFvSGVhZGVyO1xuXHR2YXIgdGFyZ2V0ID0gcm93ICE9PSB1bmRlZmluZWRcblx0XHQ/IHJvd1xuXHRcdDogc2V0dGluZ3MuYlNvcnRDZWxsc1RvcCAvLyBsZWdhY3kgc3VwcG9ydFxuXHRcdFx0PyAwXG5cdFx0XHQ6IGhlYWRlci5sZW5ndGggLSAxO1xuXG5cdHJldHVybiBoZWFkZXJbdGFyZ2V0XVtjb2x1bW5dLmNlbGw7XG59O1xuXG52YXIgX19jb2x1bW5fc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG57XG5cdHZhclxuXHRcdGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0bmFtZXMgPSBfcGx1Y2soIGNvbHVtbnMsICdzTmFtZScgKSxcblx0XHR0aXRsZXMgPSBfcGx1Y2soIGNvbHVtbnMsICdzVGl0bGUnICksXG5cdFx0Y2VsbHMgPSBEYXRhVGFibGUudXRpbC5nZXQoJ1tdLltdLmNlbGwnKShzZXR0aW5ncy5hb0hlYWRlciksXG5cdFx0bm9kZXMgPSBfdW5pcXVlKCBfZmxhdHRlbihbXSwgY2VsbHMpICk7XG5cdFxuXHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzICk7XG5cblx0XHQvLyBTZWxlY3RvciAtIGFsbFxuXHRcdGlmICggcyA9PT0gJycgKSB7XG5cdFx0XHRyZXR1cm4gX3JhbmdlKCBjb2x1bW5zLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIFNlbGVjdG9yIC0gaW5kZXhcblx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBbIHNlbEludCA+PSAwID9cblx0XHRcdFx0c2VsSW50IDogLy8gQ291bnQgZnJvbSBsZWZ0XG5cdFx0XHRcdGNvbHVtbnMubGVuZ3RoICsgc2VsSW50IC8vIENvdW50IGZyb20gcmlnaHQgKCsgYmVjYXVzZSBpdHMgYSBuZWdhdGl2ZSB2YWx1ZSlcblx0XHRcdF07XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgPSBmdW5jdGlvblxuXHRcdGlmICggdHlwZW9mIHMgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblxuXHRcdFx0cmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gcyhcblx0XHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRcdF9fY29sdW1uRGF0YSggc2V0dGluZ3MsIGlkeCwgMCwgMCwgcm93cyApLFxuXHRcdFx0XHRcdFx0X19jb2x1bW5faGVhZGVyKCBzZXR0aW5ncywgaWR4IClcblx0XHRcdFx0XHQpID8gaWR4IDogbnVsbDtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIGpRdWVyeSBvciBzdHJpbmcgc2VsZWN0b3Jcblx0XHR2YXIgbWF0Y2ggPSB0eXBlb2YgcyA9PT0gJ3N0cmluZycgP1xuXHRcdFx0cy5tYXRjaCggX19yZV9jb2x1bW5fc2VsZWN0b3IgKSA6XG5cdFx0XHQnJztcblxuXHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRzd2l0Y2goIG1hdGNoWzJdICkge1xuXHRcdFx0XHRjYXNlICd2aXNJZHgnOlxuXHRcdFx0XHRjYXNlICd2aXNpYmxlJzpcblx0XHRcdFx0XHQvLyBTZWxlY3RvciBpcyBhIGNvbHVtbiBpbmRleFxuXHRcdFx0XHRcdGlmIChtYXRjaFsxXSAmJiBtYXRjaFsxXS5tYXRjaCgvXlxcZCskLykpIHtcblx0XHRcdFx0XHRcdHZhciBpZHggPSBwYXJzZUludCggbWF0Y2hbMV0sIDEwICk7XG5cblx0XHRcdFx0XHRcdC8vIFZpc2libGUgaW5kZXggZ2l2ZW4sIGNvbnZlcnQgdG8gY29sdW1uIGluZGV4XG5cdFx0XHRcdFx0XHRpZiAoIGlkeCA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENvdW50aW5nIGZyb20gdGhlIHJpZ2h0XG5cdFx0XHRcdFx0XHRcdHZhciB2aXNDb2x1bW5zID0gY29sdW1ucy5tYXAoIGZ1bmN0aW9uIChjb2wsaSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjb2wuYlZpc2libGUgPyBpIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyB2aXNDb2x1bW5zWyB2aXNDb2x1bW5zLmxlbmd0aCArIGlkeCBdIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBDb3VudGluZyBmcm9tIHRoZSBsZWZ0XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGlkeCApIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBjb2x1bW5zLm1hcCggZnVuY3Rpb24gKGNvbCwgaWR4KSB7XG5cdFx0XHRcdFx0XHQvLyBOb3QgdmlzaWJsZSwgY2FuJ3QgbWF0Y2hcblx0XHRcdFx0XHRcdGlmICghIGNvbC5iVmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3Jcblx0XHRcdFx0XHRcdGlmIChtYXRjaFsxXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJChub2Rlc1tpZHhdKS5maWx0ZXIobWF0Y2hbMV0pLmxlbmd0aCA+IDAgPyBpZHggOiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBgOnZpc2libGVgIG9uIGl0cyBvd25cblx0XHRcdFx0XHRcdHJldHVybiBpZHg7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGNhc2UgJ25hbWUnOlxuXHRcdFx0XHRcdC8vIG1hdGNoIGJ5IG5hbWUuIGBuYW1lc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxuXHRcdFx0XHRcdHJldHVybiBuYW1lcy5tYXAoIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmFtZSA9PT0gbWF0Y2hbMV0gPyBpIDogbnVsbDtcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Y2FzZSAndGl0bGUnOlxuXHRcdFx0XHRcdC8vIG1hdGNoIGJ5IGNvbHVtbiB0aXRsZVxuXHRcdFx0XHRcdHJldHVybiB0aXRsZXMubWFwKCBmdW5jdGlvbiAodGl0bGUsIGkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aXRsZSA9PT0gbWF0Y2hbMV0gPyBpIDogbnVsbDtcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2VsbCBpbiB0aGUgdGFibGUgYm9keVxuXHRcdGlmICggcy5ub2RlTmFtZSAmJiBzLl9EVF9DZWxsSW5kZXggKSB7XG5cdFx0XHRyZXR1cm4gWyBzLl9EVF9DZWxsSW5kZXguY29sdW1uIF07XG5cdFx0fVxuXG5cdFx0Ly8galF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSBUSCBlbGVtZW50cyBmb3IgdGhlIGNvbHVtbnNcblx0XHR2YXIganFSZXN1bHQgPSAkKCBub2RlcyApXG5cdFx0XHQuZmlsdGVyKCBzIClcblx0XHRcdC5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF9mbkNvbHVtbnNGcm9tSGVhZGVyKCB0aGlzICk7IC8vIGBub2Rlc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxuXHRcdFx0fSApXG5cdFx0XHQudG9BcnJheSgpXG5cdFx0XHQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYSAtIGI7XG5cdFx0XHR9KTtcblxuXHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdHJldHVybiBqcVJlc3VsdDtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UgYSBub2RlIHdoaWNoIG1pZ2h0IGhhdmUgYSBgZHQtY29sdW1uYCBkYXRhIGF0dHJpYnV0ZSwgb3IgYmVcblx0XHQvLyBhIGNoaWxkIG9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdHZhciBob3N0ID0gJChzKS5jbG9zZXN0KCcqW2RhdGEtZHQtY29sdW1uXScpO1xuXHRcdHJldHVybiBob3N0Lmxlbmd0aCA/XG5cdFx0XHRbIGhvc3QuZGF0YSgnZHQtY29sdW1uJykgXSA6XG5cdFx0XHRbXTtcblx0fTtcblxuXHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ2NvbHVtbicsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG59O1xuXG5cbnZhciBfX3NldENvbHVtblZpcyA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgdmlzICkge1xuXHR2YXJcblx0XHRjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdGNvbCAgPSBjb2xzWyBjb2x1bW4gXSxcblx0XHRkYXRhID0gc2V0dGluZ3MuYW9EYXRhLFxuXHRcdGNlbGxzLCBpLCBpZW4sIHRyO1xuXG5cdC8vIEdldFxuXHRpZiAoIHZpcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiBjb2wuYlZpc2libGU7XG5cdH1cblxuXHQvLyBTZXRcblx0Ly8gTm8gY2hhbmdlXG5cdGlmICggY29sLmJWaXNpYmxlID09PSB2aXMgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCB2aXMgKSB7XG5cdFx0Ly8gSW5zZXJ0IGNvbHVtblxuXHRcdC8vIE5lZWQgdG8gZGVjaWRlIGlmIHdlIHNob3VsZCB1c2UgYXBwZW5kQ2hpbGQgb3IgaW5zZXJ0QmVmb3JlXG5cdFx0dmFyIGluc2VydEJlZm9yZSA9IF9wbHVjayhjb2xzLCAnYlZpc2libGUnKS5pbmRleE9mKHRydWUsIGNvbHVtbisxKTtcblxuXHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoZGF0YVtpXSkge1xuXHRcdFx0XHR0ciA9IGRhdGFbaV0ublRyO1xuXHRcdFx0XHRjZWxscyA9IGRhdGFbaV0uYW5DZWxscztcblxuXHRcdFx0XHRpZiAoIHRyICkge1xuXHRcdFx0XHRcdC8vIGluc2VydEJlZm9yZSBjYW4gYWN0IGxpa2UgYXBwZW5kQ2hpbGQgaWYgMm5kIGFyZyBpcyBudWxsXG5cdFx0XHRcdFx0dHIuaW5zZXJ0QmVmb3JlKCBjZWxsc1sgY29sdW1uIF0sIGNlbGxzWyBpbnNlcnRCZWZvcmUgXSB8fCBudWxsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gUmVtb3ZlIGNvbHVtblxuXHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbHVtbiApICkuZGV0YWNoKCk7XG5cdH1cblxuXHQvLyBDb21tb24gYWN0aW9uc1xuXHRjb2wuYlZpc2libGUgPSB2aXM7XG5cblx0X2NvbEdyb3VwKHNldHRpbmdzKTtcblx0XG5cdHJldHVybiB0cnVlO1xufTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY29sdW1ucygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0Ly8gYXJndW1lbnQgc2hpZnRpbmdcblx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHNlbGVjdG9yID0gJyc7XG5cdH1cblx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRvcHRzID0gc2VsZWN0b3I7XG5cdFx0c2VsZWN0b3IgPSAnJztcblx0fVxuXG5cdG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyggb3B0cyApO1xuXG5cdHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gX19jb2x1bW5fc2VsZWN0b3IoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApO1xuXHR9LCAxICk7XG5cblx0Ly8gV2FudCBhcmd1bWVudCBzaGlmdGluZyBoZXJlIGFuZCBpbiBfcm93X3NlbGVjdG9yP1xuXHRpbnN0LnNlbGVjdG9yLmNvbHMgPSBzZWxlY3Rvcjtcblx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblxuXHRyZXR1cm4gaW5zdDtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5oZWFkZXIoKScsICdjb2x1bW4oKS5oZWFkZXIoKScsIGZ1bmN0aW9uICggcm93ICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XG5cdFx0cmV0dXJuIF9fY29sdW1uX2hlYWRlcihzZXR0aW5ncywgY29sdW1uLCByb3cpO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZm9vdGVyKCknLCAnY29sdW1uKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoIHJvdyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0dmFyIGZvb3RlciA9IHNldHRpbmdzLmFvRm9vdGVyO1xuXG5cdFx0aWYgKCEgZm9vdGVyLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldHRpbmdzLmFvRm9vdGVyW3JvdyAhPT0gdW5kZWZpbmVkID8gcm93IDogMF1bY29sdW1uXS5jZWxsO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YSgpJywgJ2NvbHVtbigpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIF9fY29sdW1uRGF0YSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnJlbmRlcigpJywgJ2NvbHVtbigpLnJlbmRlcigpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzICkge1xuXHRcdHJldHVybiBfX2NvbHVtbkRhdGEoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MsIHR5cGUgKTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmRhdGFTcmMoKScsICdjb2x1bW4oKS5kYXRhU3JjKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5tRGF0YTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmNhY2hlKCknLCAnY29sdW1uKCkuY2FjaGUoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsXG5cdFx0XHR0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnLCBjb2x1bW5cblx0XHQpO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuaW5pdCgpJywgJ2NvbHVtbigpLmluaXQoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkubm9kZXMoKScsICdjb2x1bW4oKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzICkge1xuXHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4gKSA7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS50aXRsZXMoKScsICdjb2x1bW4oKS50aXRsZSgpJywgZnVuY3Rpb24gKHRpdGxlLCByb3cpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAodHlwZW9mIHRpdGxlID09PSAnbnVtYmVyJykge1xuXHRcdFx0cm93ID0gdGl0bGU7XG5cdFx0XHR0aXRsZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR2YXIgc3BhbiA9ICQoJ3NwYW4uZHQtY29sdW1uLXRpdGxlJywgdGhpcy5jb2x1bW4oY29sdW1uKS5oZWFkZXIocm93KSk7XG5cblx0XHRpZiAodGl0bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3Bhbi5odG1sKHRpdGxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJldHVybiBzcGFuLmh0bWwoKTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnR5cGVzKCknLCAnY29sdW1uKCkudHlwZSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHR2YXIgdHlwZSA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLnNUeXBlO1xuXG5cdFx0Ly8gSWYgdGhlIHR5cGUgd2FzIGludmFsaWRhdGVkLCB0aGVuIHJlc29sdmUgaXQuIFRoaXMgYWN0dWFsbHkgZG9lc1xuXHRcdC8vIGFsbCBjb2x1bW5zIGF0IHRoZSBtb21lbnQuIFdvdWxkIG9ubHkgaGFwcGVuIG9uY2UgaWYgZ2V0dGluZyBhbGxcblx0XHQvLyBjb2x1bW4ncyBkYXRhIHR5cGVzLlxuXHRcdGlmICghIHR5cGUpIHtcblx0XHRcdF9mbkNvbHVtblR5cGVzKHNldHRpbmdzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHlwZTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnZpc2libGUoKScsICdjb2x1bW4oKS52aXNpYmxlKCknLCBmdW5jdGlvbiAoIHZpcywgY2FsYyApIHtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXHR2YXIgY2hhbmdlZCA9IFtdO1xuXHR2YXIgcmV0ID0gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRpZiAoIHZpcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1sgY29sdW1uIF0uYlZpc2libGU7XG5cdFx0fSAvLyBlbHNlXG5cdFx0XG5cdFx0aWYgKF9fc2V0Q29sdW1uVmlzKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKSkge1xuXHRcdFx0Y2hhbmdlZC5wdXNoKGNvbHVtbik7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gR3JvdXAgdGhlIGNvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZXNcblx0aWYgKCB2aXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gUmVkcmF3IHRoZSBoZWFkZXIgYWZ0ZXIgY2hhbmdlc1xuXHRcdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3RlciApO1xuXHRcblx0XHRcdC8vIFVwZGF0ZSBjb2xzcGFuIGZvciBubyByZWNvcmRzIGRpc3BsYXkuIENoaWxkIHJvd3MgYW5kIGV4dGVuc2lvbnMgd2lsbCB1c2UgdGhlaXIgb3duXG5cdFx0XHQvLyBsaXN0ZW5lcnMgdG8gZG8gdGhpcyAtIG9ubHkgbmVlZCB0byB1cGRhdGUgdGhlIGVtcHR5IHRhYmxlIGl0ZW0gaGVyZVxuXHRcdFx0aWYgKCAhIHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggKSB7XG5cdFx0XHRcdCQoc2V0dGluZ3MublRCb2R5KS5maW5kKCd0ZFtjb2xzcGFuXScpLmF0dHIoJ2NvbHNwYW4nLCBfZm5WaXNibGVDb2x1bW5zKHNldHRpbmdzKSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuU2F2ZVN0YXRlKCBzZXR0aW5ncyApO1xuXG5cdFx0XHQvLyBTZWNvbmQgbG9vcCBvbmNlIHRoZSBmaXJzdCBpcyBkb25lIGZvciBldmVudHNcblx0XHRcdHRoYXQuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdGlmIChjaGFuZ2VkLmluY2x1ZGVzKGNvbHVtbikpIHtcblx0XHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXZpc2liaWxpdHknLCBbc2V0dGluZ3MsIGNvbHVtbiwgdmlzLCBjYWxjXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggY2hhbmdlZC5sZW5ndGggJiYgKGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjKSApIHtcblx0XHRcdFx0dGhhdC5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS53aWR0aHMoKScsICdjb2x1bW4oKS53aWR0aCgpJywgZnVuY3Rpb24gKCkge1xuXHQvLyBJbmplY3RzIGEgZmFrZSByb3cgaW50byB0aGUgdGFibGUgZm9yIGp1c3QgYSBtb21lbnQgc28gdGhlIHdpZHRocyBjYW5cblx0Ly8gYmUgcmVhZCwgcmVnYXJkbGVzcyBvZiBjb2xzcGFuIGluIHRoZSBoZWFkZXIgYW5kIHJvd3MgYmVpbmcgcHJlc2VudCBpblxuXHQvLyB0aGUgYm9keVxuXHR2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucygnOnZpc2libGUnKS5jb3VudCgpO1xuXHR2YXIgcm93ID0gJCgnPHRyPicpLmh0bWwoJzx0ZD4nICsgQXJyYXkoY29sdW1ucykuam9pbignPC90ZD48dGQ+JykgKyAnPC90ZD4nKTtcblxuXHQkKHRoaXMudGFibGUoKS5ib2R5KCkpLmFwcGVuZChyb3cpO1xuXG5cdHZhciB3aWR0aHMgPSByb3cuY2hpbGRyZW4oKS5tYXAoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAkKHRoaXMpLm91dGVyV2lkdGgoKTtcblx0fSk7XG5cblx0cm93LnJlbW92ZSgpO1xuXHRcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0dmFyIHZpc0lkeCA9IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uICk7XG5cblx0XHRyZXR1cm4gdmlzSWR4ICE9PSBudWxsID8gd2lkdGhzW3Zpc0lkeF0gOiAwO1xuXHR9LCAxKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5pbmRleGVzKCknLCAnY29sdW1uKCkuaW5kZXgoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHR5cGUgPT09ICd2aXNpYmxlJyA/XG5cdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApIDpcblx0XHRcdGNvbHVtbjtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAnY29sdW1ucy5hZGp1c3QoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0Ly8gRm9yY2UgYSBjb2x1bW4gc2l6aW5nIHRvIGhhcHBlbiB3aXRoIGEgbWFudWFsIGNhbGwgLSBvdGhlcndpc2UgaXQgY2FuIHNraXBcblx0XHQvLyBpZiB0aGUgc2l6ZSBoYXNuJ3QgY2hhbmdlZFxuXHRcdHNldHRpbmdzLmNvbnRhaW5lcldpZHRoID0gLTE7XG5cblx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbi5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlLCBpZHggKSB7XG5cdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdFx0aWYgKCB0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnICkge1xuXHRcdFx0cmV0dXJuIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBjdHgsIGlkeCApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJyApIHtcblx0XHRcdHJldHVybiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggY3R4LCBpZHggKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbigpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jb2x1bW5zKCBzZWxlY3Rvciwgb3B0cyApICk7XG59ICk7XG5cbnZhciBfX2NlbGxfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG57XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0dmFyIGNlbGxzID0gX3JlbW92ZUVtcHR5KCBfcGx1Y2tfb3JkZXIoIGRhdGEsIHJvd3MsICdhbkNlbGxzJyApICk7XG5cdHZhciBhbGxDZWxscyA9ICQoX2ZsYXR0ZW4oIFtdLCBjZWxscyApKTtcblx0dmFyIHJvdztcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHR2YXIgYSwgaSwgaWVuLCBqLCBvLCBob3N0O1xuXG5cdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0dmFyIGZuU2VsZWN0b3IgPSB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJztcblxuXHRcdGlmICggcyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQgfHwgZm5TZWxlY3RvciApIHtcblx0XHRcdC8vIEFsbCBjZWxscyBhbmQgZnVuY3Rpb24gc2VsZWN0b3JzXG5cdFx0XHRhID0gW107XG5cblx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3MubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cblx0XHRcdFx0Zm9yICggaj0wIDsgajxjb2x1bW5zIDsgaisrICkge1xuXHRcdFx0XHRcdG8gPSB7XG5cdFx0XHRcdFx0XHRyb3c6IHJvdyxcblx0XHRcdFx0XHRcdGNvbHVtbjogalxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIGZuU2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRob3N0ID0gZGF0YVsgcm93IF07XG5cblx0XHRcdFx0XHRcdGlmICggcyggbywgX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgaiksIGhvc3QuYW5DZWxscyA/IGhvc3QuYW5DZWxsc1tqXSA6IG51bGwgKSApIHtcblx0XHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzICkgKSB7XG5cdFx0XHQvLyBWYWxpZCBjZWxsIGluZGV4IGFuZCBpdHMgaW4gdGhlIGFycmF5IG9mIHNlbGVjdGFibGUgcm93c1xuXHRcdFx0cmV0dXJuIHMuY29sdW1uICE9PSB1bmRlZmluZWQgJiYgcy5yb3cgIT09IHVuZGVmaW5lZCAmJiByb3dzLmluZGV4T2Yocy5yb3cpICE9PSAtMSA/XG5cdFx0XHRcdFtzXSA6XG5cdFx0XHRcdFtdO1xuXHRcdH1cblxuXHRcdC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXG5cdFx0dmFyIGpxUmVzdWx0ID0gYWxsQ2VsbHNcblx0XHRcdC5maWx0ZXIoIHMgKVxuXHRcdFx0Lm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRcdHJldHVybiB7IC8vIHVzZSBhIG5ldyBvYmplY3QsIGluIGNhc2Ugc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZXNcblx0XHRcdFx0XHRyb3c6ICAgIGVsLl9EVF9DZWxsSW5kZXgucm93LFxuXHRcdFx0XHRcdGNvbHVtbjogZWwuX0RUX0NlbGxJbmRleC5jb2x1bW5cblx0XHRcdFx0fTtcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKTtcblxuXHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdHJldHVybiBqcVJlc3VsdDtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UgdGhlIHNlbGVjdG9yIGlzIGEgbm9kZSwgYW5kIHRoZXJlIGlzIG9uZSBsYXN0IG9wdGlvbiAtIHRoZVxuXHRcdC8vIGVsZW1lbnQgbWlnaHQgYmUgYSBjaGlsZCBvZiBhbiBlbGVtZW50IHdoaWNoIGhhcyBkdC1yb3cgYW5kIGR0LWNvbHVtblxuXHRcdC8vIGRhdGEgYXR0cmlidXRlc1xuXHRcdGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1yb3ddJyk7XG5cdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFsge1xuXHRcdFx0XHRyb3c6IGhvc3QuZGF0YSgnZHQtcm93JyksXG5cdFx0XHRcdGNvbHVtbjogaG9zdC5kYXRhKCdkdC1jb2x1bW4nKVxuXHRcdFx0fSBdIDpcblx0XHRcdFtdO1xuXHR9O1xuXG5cdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY2VsbCcsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG59O1xuXG5cblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKScsIGZ1bmN0aW9uICggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkge1xuXHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcm93U2VsZWN0b3IgKSApIHtcblx0XHQvLyBJbmRleGVzXG5cdFx0aWYgKCByb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIFNlbGVjdG9yIG9wdGlvbnMgaW4gZmlyc3QgcGFyYW1ldGVyXG5cdFx0XHRvcHRzID0gcm93U2VsZWN0b3I7XG5cdFx0XHRyb3dTZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0b3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuXHRcdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHRcdH1cblx0fVxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggY29sdW1uU2VsZWN0b3IgKSApIHtcblx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHR9XG5cblx0Ly8gQ2VsbCBzZWxlY3RvclxuXHRpZiAoIGNvbHVtblNlbGVjdG9yID09PSBudWxsIHx8IGNvbHVtblNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX19jZWxsX3NlbGVjdG9yKCBzZXR0aW5ncywgcm93U2VsZWN0b3IsIF9zZWxlY3Rvcl9vcHRzKCBvcHRzICkgKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBUaGUgZGVmYXVsdCBidWlsdCBpbiBvcHRpb25zIG5lZWQgdG8gYXBwbHkgdG8gcm93IGFuZCBjb2x1bW5zXG5cdHZhciBpbnRlcm5hbE9wdHMgPSBvcHRzID8ge1xuXHRcdHBhZ2U6IG9wdHMucGFnZSxcblx0XHRvcmRlcjogb3B0cy5vcmRlcixcblx0XHRzZWFyY2g6IG9wdHMuc2VhcmNoXG5cdH0gOiB7fTtcblxuXHQvLyBSb3cgKyBjb2x1bW4gc2VsZWN0b3Jcblx0dmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoIGNvbHVtblNlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0dmFyIHJvd3MgPSB0aGlzLnJvd3MoIHJvd1NlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0dmFyIGksIGllbiwgaiwgamVuO1xuXG5cdHZhciBjZWxsc05vT3B0cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGlkeCApIHtcblx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0Zm9yICggaT0wLCBpZW49cm93c1tpZHhdLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1uc1tpZHhdLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRhLnB1c2goIHtcblx0XHRcdFx0XHRyb3c6ICAgIHJvd3NbaWR4XVtpXSxcblx0XHRcdFx0XHRjb2x1bW46IGNvbHVtbnNbaWR4XVtqXVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGE7XG5cdH0sIDEgKTtcblxuXHQvLyBUaGVyZSBpcyBjdXJyZW50bHkgb25seSBvbmUgZXh0ZW5zaW9uIHdoaWNoIHVzZXMgYSBjZWxsIHNlbGVjdG9yIGV4dGVuc2lvblxuXHQvLyBJdCBpcyBhIF9tYWpvcl8gcGVyZm9ybWFuY2UgZHJhZyB0byBydW4gdGhpcyBpZiBpdCBpc24ndCBuZWVkZWQsIHNvIHRoaXMgaXNcblx0Ly8gYW4gZXh0ZW5zaW9uIHNwZWNpZmljIGNoZWNrIGF0IHRoZSBtb21lbnRcblx0dmFyIGNlbGxzID0gb3B0cyAmJiBvcHRzLnNlbGVjdGVkID9cblx0XHR0aGlzLmNlbGxzKCBjZWxsc05vT3B0cywgb3B0cyApIDpcblx0XHRjZWxsc05vT3B0cztcblxuXHQkLmV4dGVuZCggY2VsbHMuc2VsZWN0b3IsIHtcblx0XHRjb2xzOiBjb2x1bW5TZWxlY3Rvcixcblx0XHRyb3dzOiByb3dTZWxlY3Rvcixcblx0XHRvcHRzOiBvcHRzXG5cdH0gKTtcblxuXHRyZXR1cm4gY2VsbHM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkubm9kZXMoKScsICdjZWxsKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cblx0XHRyZXR1cm4gZGF0YSAmJiBkYXRhLmFuQ2VsbHMgP1xuXHRcdFx0ZGF0YS5hbkNlbGxzWyBjb2x1bW4gXSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdHJldHVybiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvdywgY29sdW1uICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jYWNoZSgpJywgJ2NlbGwoKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHR0eXBlID0gdHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJztcblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9EYXRhWyByb3cgXVsgdHlwZSBdWyBjb2x1bW4gXTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4sIHR5cGUgKTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmluZGV4ZXMoKScsICdjZWxsKCkuaW5kZXgoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJvdzogcm93LFxuXHRcdFx0Y29sdW1uOiBjb2x1bW4sXG5cdFx0XHRjb2x1bW5WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApXG5cdFx0fTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYywgY29sdW1uICk7XG5cdH0gKTtcbn0gKTtcblxuXG5cbl9hcGlfcmVnaXN0ZXIoICdjZWxsKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jZWxscyggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbCgpLmRhdGEoKScsIGZ1bmN0aW9uICggZGF0YSApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0dmFyIGNlbGwgPSB0aGlzWzBdO1xuXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIEdldFxuXHRcdHJldHVybiBjdHgubGVuZ3RoICYmIGNlbGwubGVuZ3RoID9cblx0XHRcdF9mbkdldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiApIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNldFxuXHRfZm5TZXRDZWxsRGF0YSggY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4sIGRhdGEgKTtcblx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCBjZWxsWzBdLnJvdywgJ2RhdGEnLCBjZWxsWzBdLmNvbHVtbiApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cblxuLyoqXG4gKiBHZXQgY3VycmVudCBvcmRlcmluZyAoc29ydGluZykgdGhhdCBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSB0YWJsZS5cbiAqXG4gKiBAcmV0dXJucyB7YXJyYXl9IDJEIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNvcnRpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdFxuICogICB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LiBFYWNoIGVsZW1lbnQgaW4gdGhlIHBhcmVudCBhcnJheSByZXByZXNlbnRzXG4gKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXG4gKiAgIDIgaW5uZXIgYXJyYXlzKS4gVGhlIGlubmVyIGFycmF5cyBtYXkgaGF2ZSAyIG9yIDMgZWxlbWVudHMuIFRoZSBmaXJzdCBpc1xuICogICB0aGUgY29sdW1uIGluZGV4IHRoYXQgdGhlIHNvcnRpbmcgY29uZGl0aW9uIGFwcGxpZXMgdG8sIHRoZSBzZWNvbmQgaXMgdGhlXG4gKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcbiAqICAgaW5kZXggb2YgdGhlIHNvcnRpbmcgb3JkZXIgZnJvbSB0aGUgYGNvbHVtbi5zb3J0aW5nYCBpbml0aWFsaXNhdGlvbiBhcnJheS5cbiAqLy8qKlxuICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb3JkZXIgQ29sdW1uIGluZGV4IHRvIHNvcnQgdXBvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBzb3J0IHRvIGJlIGFwcGxpZWQgKGBhc2NgIG9yIGBkZXNjYClcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovLyoqXG4gKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gKlxuICogQHBhcmFtIHthcnJheX0gb3JkZXIgMUQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIHthcnJheX0gWy4uLl0gT3B0aW9uYWwgYWRkaXRpb25hbCBzb3J0aW5nIGNvbmRpdGlvbnNcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovLyoqXG4gKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gKlxuICogQHBhcmFtIHthcnJheX0gb3JkZXIgMkQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdvcmRlcigpJywgZnVuY3Rpb24gKCBvcmRlciwgZGlyICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gZ2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggIT09IDAgP1xuXHRcdFx0Y3R4WzBdLmFhU29ydGluZyA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBzZXRcblx0aWYgKCB0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInICkge1xuXHRcdC8vIFNpbXBsZSBjb2x1bW4gLyBkaXJlY3Rpb24gcGFzc2VkIGluXG5cdFx0b3JkZXIgPSBbIFsgb3JkZXIsIGRpciBdIF07XG5cdH1cblx0ZWxzZSBpZiAoIGFyZ3MubGVuZ3RoID4gMSApIHtcblx0XHQvLyBBcmd1bWVudHMgcGFzc2VkIGluIChsaXN0IG9mIDFEIGFycmF5cylcblx0XHRvcmRlciA9IGFyZ3M7XG5cdH1cblx0Ly8gb3RoZXJ3aXNlIGEgMkQgYXJyYXkgd2FzIHBhc3NlZCBpblxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHNldHRpbmdzLmFhU29ydGluZyA9IEFycmF5LmlzQXJyYXkob3JkZXIpID8gb3JkZXIuc2xpY2UoKSA6IG9yZGVyO1xuXHR9ICk7XG59ICk7XG5cblxuLyoqXG4gKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXG4gKlxuICogQHBhcmFtIHtub2RlfGpRdWVyeXxzdHJpbmd9IG5vZGUgSWRlbnRpZmllciBmb3IgdGhlIGVsZW1lbnQocykgdG8gYXR0YWNoIHRoZVxuICogICBsaXN0ZW5lciB0by4gVGhpcyBjYW4gdGFrZSB0aGUgZm9ybSBvZiBhIHNpbmdsZSBET00gbm9kZSwgYSBqUXVlcnlcbiAqICAgY29sbGVjdGlvbiBvZiBub2RlcyBvciBhIGpRdWVyeSBzZWxlY3RvciB3aGljaCB3aWxsIGlkZW50aWZ5IHRoZSBub2RlKHMpLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBjb2x1bW4gdGhlIGNvbHVtbiB0aGF0IGEgY2xpY2sgb24gdGhpcyBub2RlIHdpbGwgc29ydCBvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ29yZGVyLmxpc3RlbmVyKCknLCBmdW5jdGlvbiAoIG5vZGUsIGNvbHVtbiwgY2FsbGJhY2sgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lcihzZXR0aW5ncywgbm9kZSwge30sIGNvbHVtbiwgY2FsbGJhY2spO1xuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ29yZGVyLmZpeGVkKCknLCBmdW5jdGlvbiAoIHNldCApIHtcblx0aWYgKCAhIHNldCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcdHZhciBmaXhlZCA9IGN0eC5sZW5ndGggP1xuXHRcdFx0Y3R4WzBdLmFhU29ydGluZ0ZpeGVkIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRcdHJldHVybiBBcnJheS5pc0FycmF5KCBmaXhlZCApID9cblx0XHRcdHsgcHJlOiBmaXhlZCB9IDpcblx0XHRcdGZpeGVkO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0c2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHNldCApO1xuXHR9ICk7XG59ICk7XG5cblxuLy8gT3JkZXIgYnkgdGhlIHNlbGVjdGVkIGNvbHVtbihzKVxuX2FwaV9yZWdpc3RlciggW1xuXHQnY29sdW1ucygpLm9yZGVyKCknLFxuXHQnY29sdW1uKCkub3JkZXIoKSdcbl0sIGZ1bmN0aW9uICggZGlyICkge1xuXHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0aWYgKCAhIGRpciApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGlkeCApIHtcblx0XHRcdHZhciBzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICk7XG5cblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNvcnRbaV0uY29sID09PSBpZHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNvcnRbaV0uZGlyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sIDEgKTtcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaSApIHtcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IHRoYXRbaV0ubWFwKCBmdW5jdGlvbiAoY29sKSB7XG5cdFx0XHRcdHJldHVybiBbIGNvbCwgZGlyIF07XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS5vcmRlcmFibGUoKScsICdjb2x1bW4oKS5vcmRlcmFibGUoKScsIGZ1bmN0aW9uICggZGlyZWN0aW9ucyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHggKSB7XG5cdFx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1tpZHhdO1xuXG5cdFx0cmV0dXJuIGRpcmVjdGlvbnMgP1xuXHRcdFx0Y29sLmFzU29ydGluZyA6XG5cdFx0XHRjb2wuYlNvcnRhYmxlO1xuXHR9LCAxICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3Byb2Nlc3NpbmcoKScsIGZ1bmN0aW9uICggc2hvdyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBjdHgsIHNob3cgKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdzZWFyY2goKScsIGZ1bmN0aW9uICggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggaW5wdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBnZXRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRjdHhbMF0ub1ByZXZpb3VzU2VhcmNoLnNlYXJjaCA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBzZXRcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcmVnZXggPT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBOZXcgc3R5bGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzZWFyY2ggYnVpbGRlclxuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCAkLmV4dGVuZCggc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCByZWdleCwge1xuXHRcdFx0XHRzZWFyY2g6IGlucHV0XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBDb21wYXQgZm9yIHRoZSBvbGQgb3B0aW9uc1xuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCAkLmV4dGVuZCggc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCB7XG5cdFx0XHRcdHNlYXJjaDogaW5wdXQsXG5cdFx0XHRcdHJlZ2V4OiAgcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuXHRcdFx0XHRzbWFydDogIHNtYXJ0ID09PSBudWxsID8gdHJ1ZSAgOiBzbWFydCxcblx0XHRcdFx0Y2FzZUluc2Vuc2l0aXZlOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdH0gKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ3NlYXJjaC5maXhlZCgpJywgZnVuY3Rpb24gKCBuYW1lLCBzZWFyY2ggKSB7XG5cdHZhciByZXQgPSB0aGlzLml0ZXJhdG9yKCB0cnVlLCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHZhciBmaXhlZCA9IHNldHRpbmdzLnNlYXJjaEZpeGVkO1xuXG5cdFx0aWYgKCEgbmFtZSkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKGZpeGVkKVxuXHRcdH1cblx0XHRlbHNlIGlmIChzZWFyY2ggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZpeGVkW25hbWVdO1xuXHRcdH1cblx0XHRlbHNlIGlmIChzZWFyY2ggPT09IG51bGwpIHtcblx0XHRcdGRlbGV0ZSBmaXhlZFtuYW1lXTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmaXhlZFtuYW1lXSA9IHNlYXJjaDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXG5cdHJldHVybiBuYW1lICE9PSB1bmRlZmluZWQgJiYgc2VhcmNoID09PSB1bmRlZmluZWRcblx0XHQ/IHJldFswXVxuXHRcdDogcmV0O1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKFxuXHQnY29sdW1ucygpLnNlYXJjaCgpJyxcblx0J2NvbHVtbigpLnNlYXJjaCgpJyxcblx0ZnVuY3Rpb24gKCBpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4gKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgcHJlU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXG5cdFx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gcHJlU2VhcmNoWyBjb2x1bW4gXS5zZWFyY2g7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldFxuXHRcdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgcmVnZXggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdC8vIE5ldyBzdHlsZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNlYXJjaCBidWlsZGVyXG5cdFx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCByZWdleCwge1xuXHRcdFx0XHRcdHNlYXJjaDogaW5wdXRcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE9sZCBzdHlsZSAod2l0aCBub3QgYWxsIG9wdGlvbnMgYXZhaWxhYmxlKVxuXHRcdFx0XHQkLmV4dGVuZCggcHJlU2VhcmNoWyBjb2x1bW4gXSwge1xuXHRcdFx0XHRcdHNlYXJjaDogaW5wdXQsXG5cdFx0XHRcdFx0cmVnZXg6ICByZWdleCA9PT0gbnVsbCA/IGZhbHNlIDogcmVnZXgsXG5cdFx0XHRcdFx0c21hcnQ6ICBzbWFydCA9PT0gbnVsbCA/IHRydWUgIDogc21hcnQsXG5cdFx0XHRcdFx0Y2FzZUluc2Vuc2l0aXZlOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKTtcblx0XHR9ICk7XG5cdH1cbik7XG5cbl9hcGlfcmVnaXN0ZXIoW1xuXHRcdCdjb2x1bW5zKCkuc2VhcmNoLmZpeGVkKCknLFxuXHRcdCdjb2x1bW4oKS5zZWFyY2guZml4ZWQoKSdcblx0XSxcblx0ZnVuY3Rpb24gKCBuYW1lLCBzZWFyY2ggKSB7XG5cdFx0dmFyIHJldCA9IHRoaXMuaXRlcmF0b3IoIHRydWUsICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2xJZHggKSB7XG5cdFx0XHR2YXIgZml4ZWQgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XS5zZWFyY2hGaXhlZDtcblxuXHRcdFx0aWYgKCEgbmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoZml4ZWQpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzZWFyY2ggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZml4ZWRbbmFtZV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzZWFyY2ggPT09IG51bGwpIHtcblx0XHRcdFx0ZGVsZXRlIGZpeGVkW25hbWVdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZpeGVkW25hbWVdID0gc2VhcmNoO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gbmFtZSAhPT0gdW5kZWZpbmVkICYmIHNlYXJjaCA9PT0gdW5kZWZpbmVkXG5cdFx0XHQ/IHJldFswXVxuXHRcdFx0OiByZXQ7XG5cdH1cbik7XG4vKlxuICogU3RhdGUgQVBJIG1ldGhvZHNcbiAqL1xuXG5fYXBpX3JlZ2lzdGVyKCAnc3RhdGUoKScsIGZ1bmN0aW9uICggc2V0LCBpZ25vcmVUaW1lICkge1xuXHQvLyBnZXR0ZXJcblx0aWYgKCAhIHNldCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxuXHRcdFx0bnVsbDtcblx0fVxuXG5cdHZhciBzZXRNdXRhdGUgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHNldCApO1xuXG5cdC8vIHNldHRlclxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRpZiAoIGlnbm9yZVRpbWUgIT09IGZhbHNlICkge1xuXHRcdFx0c2V0TXV0YXRlLnRpbWUgPSArbmV3IERhdGUoKSArIDEwMDtcblx0XHR9XG5cblx0XHRfZm5JbXBsZW1lbnRTdGF0ZSggc2V0dGluZ3MsIHNldE11dGF0ZSwgZnVuY3Rpb24oKXt9ICk7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnc3RhdGUuY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0Ly8gU2F2ZSBhbiBlbXB0eSBvYmplY3Rcblx0XHRzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHt9ICk7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cblx0XHR0aGlzLmNvbnRleHRbMF0ub0xvYWRlZFN0YXRlIDpcblx0XHRudWxsO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5zYXZlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblx0fSApO1xufSApO1xuXG4vLyBDYW4gYmUgYXNzaWduZWQgaW4gRGF0ZVRhYmxlLnVzZSgpIC0gbm90ZSBsdXhvbiBhbmQgbW9tZW50IHZhcnMgYXJlIGluIGhlbHBlcnMuanNcbnZhciBfX2Jvb3RzdHJhcDtcbnZhciBfX2ZvdW5kYXRpb247XG5cbi8qKlxuICogU2V0IHRoZSBsaWJyYXJpZXMgdGhhdCBEYXRhVGFibGVzIHVzZXMsIG9yIHRoZSBnbG9iYWwgb2JqZWN0cy5cbiAqIE5vdGUgdGhhdCB0aGUgYXJndW1lbnRzIGNhbiBiZSBlaXRoZXIgd2F5IGFyb3VuZCAobGVnYWN5IHN1cHBvcnQpXG4gKiBhbmQgdGhlIHNlY29uZCBpcyBvcHRpb25hbC4gU2VlIGRvY3MuXG4gKi9cbkRhdGFUYWJsZS51c2UgPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuXHQvLyBSZXZlcnNlIGFyZ3VtZW50cyBmb3IgbGVnYWN5IHN1cHBvcnRcblx0dmFyIG1vZHVsZSA9IHR5cGVvZiBhcmcxID09PSAnc3RyaW5nJ1xuXHRcdD8gYXJnMlxuXHRcdDogYXJnMTtcblx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMiA9PT0gJ3N0cmluZydcblx0XHQ/IGFyZzJcblx0XHQ6IGFyZzE7XG5cblx0Ly8gR2V0dGVyXG5cdGlmIChtb2R1bGUgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ2xpYic6XG5cdFx0XHRjYXNlICdqcSc6XG5cdFx0XHRcdHJldHVybiAkO1xuXG5cdFx0XHRjYXNlICd3aW4nOlxuXHRcdFx0XHRyZXR1cm4gd2luZG93O1xuXG5cdFx0XHRjYXNlICdkYXRldGltZSc6XG5cdFx0XHRcdHJldHVybiBEYXRhVGFibGUuRGF0ZVRpbWU7XG5cblx0XHRcdGNhc2UgJ2x1eG9uJzpcblx0XHRcdFx0cmV0dXJuIF9fbHV4b247XG5cblx0XHRcdGNhc2UgJ21vbWVudCc6XG5cdFx0XHRcdHJldHVybiBfX21vbWVudDtcblxuXHRcdFx0Y2FzZSAnYm9vdHN0cmFwJzpcblx0XHRcdFx0Ly8gVXNlIGxvY2FsIGlmIHNldCwgb3RoZXJ3aXNlIHRyeSB3aW5kb3csIHdoaWNoIGNvdWxkIGJlIHVuZGVmaW5lZFxuXHRcdFx0XHRyZXR1cm4gX19ib290c3RyYXAgfHwgd2luZG93LmJvb3RzdHJhcDtcblxuXHRcdFx0Y2FzZSAnZm91bmRhdGlvbic6XG5cdFx0XHRcdC8vIERpdHRvXG5cdFx0XHRcdHJldHVybiBfX2ZvdW5kYXRpb24gfHwgd2luZG93LkZvdW5kYXRpb247XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldHRlclxuXHRpZiAodHlwZSA9PT0gJ2xpYicgfHwgdHlwZSA9PT0gJ2pxJyB8fCAobW9kdWxlICYmIG1vZHVsZS5mbiAmJiBtb2R1bGUuZm4uanF1ZXJ5KSkge1xuXHRcdCQgPSBtb2R1bGU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ3dpbicgfHwgKG1vZHVsZSAmJiBtb2R1bGUuZG9jdW1lbnQpKSB7XG5cdFx0d2luZG93ID0gbW9kdWxlO1xuXHRcdGRvY3VtZW50ID0gbW9kdWxlLmRvY3VtZW50O1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdkYXRldGltZScgfHwgKG1vZHVsZSAmJiBtb2R1bGUudHlwZSA9PT0gJ0RhdGVUaW1lJykpIHtcblx0XHREYXRhVGFibGUuRGF0ZVRpbWUgPSBtb2R1bGU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ2x1eG9uJyB8fCAobW9kdWxlICYmIG1vZHVsZS5GaXhlZE9mZnNldFpvbmUpKSB7XG5cdFx0X19sdXhvbiA9IG1vZHVsZTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnbW9tZW50JyB8fCAobW9kdWxlICYmIG1vZHVsZS5pc01vbWVudCkpIHtcblx0XHRfX21vbWVudCA9IG1vZHVsZTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnYm9vdHN0cmFwJyB8fCAobW9kdWxlICYmIG1vZHVsZS5Nb2RhbCAmJiBtb2R1bGUuTW9kYWwuTkFNRSA9PT0gJ21vZGFsJykpXG5cdHtcblx0XHQvLyBUaGlzIGlzIGN1cnJlbnRseSBmb3IgQlM1IG9ubHkuIEJTMy80IGF0dGFjaCB0byBqUXVlcnksIHNvIG5vIG5lZWQgdG8gdXNlIGAudXNlKClgXG5cdFx0X19ib290c3RyYXAgPSBtb2R1bGU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ2ZvdW5kYXRpb24nIHx8IChtb2R1bGUgJiYgbW9kdWxlLlJldmVhbCkpIHtcblx0XHRfX2ZvdW5kYXRpb24gPSBtb2R1bGU7XG5cdH1cbn1cblxuLyoqXG4gKiBDb21tb25KUyBmYWN0b3J5IGZ1bmN0aW9uIHBhc3MgdGhyb3VnaC4gVGhpcyB3aWxsIGNoZWNrIGlmIHRoZSBhcmd1bWVudHNcbiAqIGdpdmVuIGFyZSBhIHdpbmRvdyBvYmplY3Qgb3IgYSBqUXVlcnkgb2JqZWN0LiBJZiBzbyB0aGV5IGFyZSBzZXRcbiAqIGFjY29yZGluZ2x5LlxuICogQHBhcmFtIHsqfSByb290IFdpbmRvd1xuICogQHBhcmFtIHsqfSBqcSBqUVVlcnlcbiAqIEByZXR1cm5zIHtib29sZWFufSBJbmRpY2F0b3JcbiAqL1xuRGF0YVRhYmxlLmZhY3RvcnkgPSBmdW5jdGlvbiAocm9vdCwganEpIHtcblx0dmFyIGlzID0gZmFsc2U7XG5cblx0Ly8gVGVzdCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgd2luZG93IG9iamVjdFxuXHRpZiAocm9vdCAmJiByb290LmRvY3VtZW50KSB7XG5cdFx0d2luZG93ID0gcm9vdDtcblx0XHRkb2N1bWVudCA9IHJvb3QuZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBUZXN0IGlmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIGEgalF1ZXJ5IG9iamVjdFxuXHRpZiAoanEgJiYganEuZm4gJiYganEuZm4uanF1ZXJ5KSB7XG5cdFx0JCA9IGpxO1xuXHRcdGlzID0gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBpcztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgY29tbW9uIG1ldGhvZCBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgdGhlIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBiZWluZ1xuICogdXNlZCwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG4gKlxuICogIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuXG4gKiAgICBOb3RlIHRoYXQgdGhlIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cbiAqICBAcGFyYW0ge3N0cmluZ30gW3ZlcnNpb24yPWN1cnJlbnQgRGF0YVRhYmxlcyB2ZXJzaW9uXSBBcyBhYm92ZSwgYnV0IG9wdGlvbmFsLlxuICogICBJZiBub3QgZ2l2ZW4gdGhlIGN1cnJlbnQgRGF0YVRhYmxlcyB2ZXJzaW9uIHdpbGwgYmUgdXNlZC5cbiAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXG4gKiAgICB0aGUgcmVxdWlyZWQgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3RcbiAqICAgIHN1aXRhYmxlXG4gKiAgQHN0YXRpY1xuICogIEBkdG9wdCBBUEktU3RhdGljXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBhbGVydCggJC5mbi5kYXRhVGFibGUudmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcbiAqL1xuRGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IGZ1bmN0aW9uKCB2ZXJzaW9uLCB2ZXJzaW9uMiApXG57XG5cdHZhciBhVGhpcyA9IHZlcnNpb24yID9cblx0XHR2ZXJzaW9uMi5zcGxpdCgnLicpIDpcblx0XHREYXRhVGFibGUudmVyc2lvbi5zcGxpdCgnLicpO1xuXHR2YXIgYVRoYXQgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdHZhciBpVGhpcywgaVRoYXQ7XG5cblx0Zm9yICggdmFyIGk9MCwgaUxlbj1hVGhhdC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0aVRoaXMgPSBwYXJzZUludCggYVRoaXNbaV0sIDEwICkgfHwgMDtcblx0XHRpVGhhdCA9IHBhcnNlSW50KCBhVGhhdFtpXSwgMTAgKSB8fCAwO1xuXG5cdFx0Ly8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xuXHRcdGlmIChpVGhpcyA9PT0gaVRoYXQpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdC8vIFBhcnRzIGFyZSBkaWZmZXJlbnQsIHJldHVybiBpbW1lZGlhdGVseVxuXHRcdHJldHVybiBpVGhpcyA+IGlUaGF0O1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBgPHRhYmxlPmAgbm9kZSBpcyBhIERhdGFUYWJsZSB0YWJsZSBhbHJlYWR5IG9yIG5vdC5cbiAqXG4gKiAgQHBhcmFtIHtub2RlfGpxdWVyeXxzdHJpbmd9IHRhYmxlIFRhYmxlIG5vZGUsIGpRdWVyeSBvYmplY3Qgb3IgalF1ZXJ5XG4gKiAgICAgIHNlbGVjdG9yIGZvciB0aGUgdGFibGUgdG8gdGVzdC4gTm90ZSB0aGF0IGlmIG1vcmUgdGhhbiBtb3JlIHRoYW4gb25lXG4gKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXG4gKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgdGhlIHRhYmxlIGdpdmVuIGlzIGEgRGF0YVRhYmxlLCBvciBmYWxzZSBvdGhlcndpc2VcbiAqICBAc3RhdGljXG4gKiAgQGR0b3B0IEFQSS1TdGF0aWNcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xuICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICogICAgfVxuICovXG5EYXRhVGFibGUuaXNEYXRhVGFibGUgPSBmdW5jdGlvbiAoIHRhYmxlIClcbntcblx0dmFyIHQgPSAkKHRhYmxlKS5nZXQoMCk7XG5cdHZhciBpcyA9IGZhbHNlO1xuXG5cdGlmICggdGFibGUgaW5zdGFuY2VvZiBEYXRhVGFibGUuQXBpICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0JC5lYWNoKCBEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChpLCBvKSB7XG5cdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0dmFyIGZvb3QgPSBvLm5TY3JvbGxGb290ID8gJCgndGFibGUnLCBvLm5TY3JvbGxGb290KVswXSA6IG51bGw7XG5cblx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdGlzID0gdHJ1ZTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gaXM7XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBEYXRhVGFibGUgdGFibGVzIHRoYXQgaGF2ZSBiZWVuIGluaXRpYWxpc2VkIC0gb3B0aW9uYWxseSB5b3UgY2FuXG4gKiBzZWxlY3QgdG8gZ2V0IG9ubHkgY3VycmVudGx5IHZpc2libGUgdGFibGVzLlxuICpcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFt2aXNpYmxlPWZhbHNlXSBGbGFnIHRvIGluZGljYXRlIGlmIHlvdSB3YW50IGFsbCAoZGVmYXVsdClcbiAqICAgIG9yIHZpc2libGUgdGFibGVzIG9ubHkuXG4gKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG4gKiAgICBEYXRhVGFibGVzXG4gKiAgQHN0YXRpY1xuICogIEBkdG9wdCBBUEktU3RhdGljXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuICogICAgICAkKHRhYmxlKS5EYXRhVGFibGUoKS5jb2x1bW5zLmFkanVzdCgpO1xuICogICAgfSApO1xuICovXG5EYXRhVGFibGUudGFibGVzID0gZnVuY3Rpb24gKCB2aXNpYmxlIClcbntcblx0dmFyIGFwaSA9IGZhbHNlO1xuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCB2aXNpYmxlICkgKSB7XG5cdFx0YXBpID0gdmlzaWJsZS5hcGk7XG5cdFx0dmlzaWJsZSA9IHZpc2libGUudmlzaWJsZTtcblx0fVxuXG5cdHZhciBhID0gRGF0YVRhYmxlLnNldHRpbmdzXG5cdFx0LmZpbHRlciggZnVuY3Rpb24gKG8pIHtcblx0XHRcdHJldHVybiAhdmlzaWJsZSB8fCAodmlzaWJsZSAmJiAkKG8ublRhYmxlKS5pcygnOnZpc2libGUnKSkgXG5cdFx0XHRcdD8gdHJ1ZVxuXHRcdFx0XHQ6IGZhbHNlO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRyZXR1cm4gby5uVGFibGU7XG5cdFx0fSk7XG5cblx0cmV0dXJuIGFwaSA/XG5cdFx0bmV3IF9BcGkoIGEgKSA6XG5cdFx0YTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiBub3RhdGlvbi4gVGhpcyBpcyBtYWRlIHB1YmxpY1xuICogZm9yIHRoZSBleHRlbnNpb25zIHRvIHByb3ZpZGUgdGhlIHNhbWUgYWJpbGl0eSBhcyBEYXRhVGFibGVzIGNvcmUgdG8gYWNjZXB0XG4gKiBlaXRoZXIgdGhlIDEuOSBzdHlsZSBIdW5nYXJpYW4gbm90YXRpb24sIG9yIHRoZSAxLjEwKyBzdHlsZSBjYW1lbENhc2VcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxuICogICAgbWFwcGVkLlxuICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXG4gKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcbiAqICAgIHdvbid0IGJlLlxuICovXG5EYXRhVGFibGUuY2FtZWxUb0h1bmdhcmlhbiA9IF9mbkNhbWVsVG9IdW5nYXJpYW47XG5cblxuXG4vKipcbiAqXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICckKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHR2YXJcblx0XHRyb3dzICAgPSB0aGlzLnJvd3MoIG9wdHMgKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3Ncblx0XHRqcVJvd3MgPSAkKHJvd3MpO1xuXG5cdHJldHVybiAkKCBbXS5jb25jYXQoXG5cdFx0anFSb3dzLmZpbHRlciggc2VsZWN0b3IgKS50b0FycmF5KCksXG5cdFx0anFSb3dzLmZpbmQoIHNlbGVjdG9yICkudG9BcnJheSgpXG5cdCkgKTtcbn0gKTtcblxuXG4vLyBqUXVlcnkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gdGhlIHRhYmxlc1xuJC5lYWNoKCBbICdvbicsICdvbmUnLCAnb2ZmJyBdLCBmdW5jdGlvbiAoaSwga2V5KSB7XG5cdF9hcGlfcmVnaXN0ZXIoIGtleSsnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovICkge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHRcdC8vIEFkZCB0aGUgYGR0YCBuYW1lc3BhY2UgYXV0b21hdGljYWxseSBpZiBpdCBpc24ndCBhbHJlYWR5IHByZXNlbnRcblx0XHRhcmdzWzBdID0gYXJnc1swXS5zcGxpdCggL1xccy8gKS5tYXAoIGZ1bmN0aW9uICggZSApIHtcblx0XHRcdHJldHVybiAhIGUubWF0Y2goL1xcLmR0XFxiLykgP1xuXHRcdFx0XHRlKycuZHQnIDpcblx0XHRcdFx0ZTtcblx0XHRcdH0gKS5qb2luKCAnICcgKTtcblxuXHRcdHZhciBpbnN0ID0gJCggdGhpcy50YWJsZXMoKS5ub2RlcygpICk7XG5cdFx0aW5zdFtrZXldLmFwcGx5KCBpbnN0LCBhcmdzICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0X2ZuQ2xlYXJUYWJsZSggc2V0dGluZ3MgKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdlcnJvcigpJywgZnVuY3Rpb24gKG1zZykge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBtc2cgKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdzZXR0aW5ncygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgdGhpcy5jb250ZXh0ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ2luaXQoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0cmV0dXJuIGN0eC5sZW5ndGggPyBjdHhbMF0ub0luaXQgOiBudWxsO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdkYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScgKTtcblx0fSApLmZsYXR0ZW4oKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAndHJpZ2dlcigpJywgZnVuY3Rpb24gKCBuYW1lLCBhcmdzLCBidWJibGVzICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgbmFtZSwgYXJncywgYnViYmxlcyApO1xuXHR9ICkuZmxhdHRlbigpO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdyZWFkeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHQvLyBHZXQgc3RhdHVzIG9mIGZpcnN0IHRhYmxlXG5cdGlmICghIGZuKSB7XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGhcblx0XHRcdD8gKGN0eFswXS5fYkluaXRDb21wbGV0ZSB8fCBmYWxzZSlcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdC8vIEZ1bmN0aW9uIHRvIHJ1biBlaXRoZXIgb25jZSB0aGUgdGFibGUgYmVjb21lcyByZWFkeSBvclxuXHQvLyBpbW1lZGlhdGVseSBpZiBpdCBpcyBhbHJlYWR5IHJlYWR5LlxuXHRyZXR1cm4gdGhpcy50YWJsZXMoKS5ldmVyeShmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGFwaSA9IHRoaXM7XG5cblx0XHRpZiAodGhpcy5jb250ZXh0WzBdLl9iSW5pdENvbXBsZXRlKSB7XG5cdFx0XHRmbi5jYWxsKGFwaSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5vbignaW5pdC5kdC5EVCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Zm4uY2FsbChhcGkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ2Rlc3Ryb3koKScsIGZ1bmN0aW9uICggcmVtb3ZlICkge1xuXHRyZW1vdmUgPSByZW1vdmUgfHwgZmFsc2U7XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0dmFyIGNsYXNzZXMgICA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciB0YWJsZSAgICAgPSBzZXR0aW5ncy5uVGFibGU7XG5cdFx0dmFyIHRib2R5ICAgICA9IHNldHRpbmdzLm5UQm9keTtcblx0XHR2YXIgdGhlYWQgICAgID0gc2V0dGluZ3MublRIZWFkO1xuXHRcdHZhciB0Zm9vdCAgICAgPSBzZXR0aW5ncy5uVEZvb3Q7XG5cdFx0dmFyIGpxVGFibGUgICA9ICQodGFibGUpO1xuXHRcdHZhciBqcVRib2R5ICAgPSAkKHRib2R5KTtcblx0XHR2YXIganFXcmFwcGVyID0gJChzZXR0aW5ncy5uVGFibGVXcmFwcGVyKTtcblx0XHR2YXIgcm93cyAgICAgID0gc2V0dGluZ3MuYW9EYXRhLm1hcCggZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIgPyByLm5UciA6IG51bGw7IH0gKTtcblx0XHR2YXIgb3JkZXJDbGFzc2VzID0gY2xhc3Nlcy5vcmRlcjtcblxuXHRcdC8vIEZsYWcgdG8gbm90ZSB0aGF0IHRoZSB0YWJsZSBpcyBjdXJyZW50bHkgYmVpbmcgZGVzdHJveWVkIC0gbm8gYWN0aW9uXG5cdFx0Ly8gc2hvdWxkIGJlIHRha2VuXG5cdFx0c2V0dGluZ3MuYkRlc3Ryb3lpbmcgPSB0cnVlO1xuXG5cdFx0Ly8gRmlyZSBvZmYgdGhlIGRlc3Ryb3kgY2FsbGJhY2tzIGZvciBwbHVnLWlucyBldGNcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBcImFvRGVzdHJveUNhbGxiYWNrXCIsIFwiZGVzdHJveVwiLCBbc2V0dGluZ3NdLCB0cnVlICk7XG5cblx0XHQvLyBJZiBub3QgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudCwgbWFrZSBhbGwgY29sdW1ucyB2aXNpYmxlXG5cdFx0aWYgKCAhIHJlbW92ZSApIHtcblx0XHRcdG5ldyBfQXBpKCBzZXR0aW5ncyApLmNvbHVtbnMoKS52aXNpYmxlKCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udGFpbmVyIHdpZHRoIGNoYW5nZSBsaXN0ZW5lclxuXHRcdGlmIChzZXR0aW5ncy5yZXNpemVPYnNlcnZlcikge1xuXHRcdFx0c2V0dGluZ3MucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHRcdH1cblxuXHRcdC8vIEJsaXR6IGFsbCBgRFRgIG5hbWVzcGFjZWQgZXZlbnRzICh0aGVzZSBhcmUgaW50ZXJuYWwgZXZlbnRzLCB0aGVcblx0XHQvLyBsb3dlcmNhc2UsIGBkdGAgZXZlbnRzIGFyZSB1c2VyIHN1YnNjcmliZWQgYW5kIHRoZXkgYXJlIHJlc3BvbnNpYmxlXG5cdFx0Ly8gZm9yIHJlbW92aW5nIHRoZW1cblx0XHRqcVdyYXBwZXIub2ZmKCcuRFQnKS5maW5kKCc6bm90KHRib2R5ICopJykub2ZmKCcuRFQnKTtcblx0XHQkKHdpbmRvdykub2ZmKCcuRFQtJytzZXR0aW5ncy5zSW5zdGFuY2UpO1xuXG5cdFx0Ly8gV2hlbiBzY3JvbGxpbmcgd2UgaGFkIHRvIGJyZWFrIHRoZSB0YWJsZSB1cCAtIHJlc3RvcmUgaXRcblx0XHRpZiAoIHRhYmxlICE9IHRoZWFkLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmRldGFjaCgpO1xuXHRcdFx0anFUYWJsZS5hcHBlbmQoIHRoZWFkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0Zm9vdCAmJiB0YWJsZSAhPSB0Zm9vdC5wYXJlbnROb2RlICkge1xuXHRcdFx0anFUYWJsZS5jaGlsZHJlbigndGZvb3QnKS5kZXRhY2goKTtcblx0XHRcdGpxVGFibGUuYXBwZW5kKCB0Zm9vdCApO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIHRoZSBoZWFkZXJcblx0XHQkKHRoZWFkKS5maW5kKCdzcGFuLmR0LWNvbHVtbi1vcmRlcicpLnJlbW92ZSgpO1xuXHRcdCQodGhlYWQpLmZpbmQoJ3NwYW4uZHQtY29sdW1uLXRpdGxlJykuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdGl0bGUgPSAkKHRoaXMpLmh0bWwoKTtcblx0XHRcdCQodGhpcykucGFyZW50KCkuYXBwZW5kKHRpdGxlKTtcblx0XHRcdCQodGhpcykucmVtb3ZlKCk7XG5cdFx0fSk7XG5cblx0XHRzZXR0aW5ncy5jb2xncm91cC5yZW1vdmUoKTtcblxuXHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gW107XG5cdFx0X2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzICk7XG5cblx0XHQkKGpxVGFibGUpLmZpbmQoJ3RoLCB0ZCcpLnJlbW92ZUNsYXNzKFxuXHRcdFx0JC5tYXAoRGF0YVRhYmxlLmV4dC50eXBlLmNsYXNzTmFtZSwgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9KS5qb2luKCcgJylcblx0XHQpO1xuXG5cdFx0JCgndGgsIHRkJywgdGhlYWQpXG5cdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdG9yZGVyQ2xhc3Nlcy5ub25lICsgJyAnICtcblx0XHRcdFx0b3JkZXJDbGFzc2VzLmNhbkFzYyArICcgJyArXG5cdFx0XHRcdG9yZGVyQ2xhc3Nlcy5jYW5EZXNjICsgJyAnICtcblx0XHRcdFx0b3JkZXJDbGFzc2VzLmlzQXNjICsgJyAnICtcblx0XHRcdFx0b3JkZXJDbGFzc2VzLmlzRGVzY1xuXHRcdFx0KVxuXHRcdFx0LmNzcygnd2lkdGgnLCAnJylcblx0XHRcdC5yZW1vdmVBdHRyKCdkYXRhLWR0LWNvbHVtbicpXG5cdFx0XHQucmVtb3ZlQXR0cignYXJpYS1zb3J0Jyk7XG5cblx0XHQvLyBBZGQgdGhlIFRSIGVsZW1lbnRzIGJhY2sgaW50byB0aGUgdGFibGUgaW4gdGhlaXIgb3JpZ2luYWwgb3JkZXJcblx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0anFUYm9keS5hcHBlbmQoIHJvd3MgKTtcblxuXHRcdHZhciBvcmlnID0gc2V0dGluZ3MublRhYmxlV3JhcHBlci5wYXJlbnROb2RlO1xuXHRcdHZhciBpbnNlcnRCZWZvcmUgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLm5leHRTaWJsaW5nO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBEYXRhVGFibGVzIGdlbmVyYXRlZCBub2RlcywgZXZlbnRzIGFuZCBjbGFzc2VzXG5cdFx0dmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xuXHRcdGpxVGFibGVbIHJlbW92ZWRNZXRob2QgXSgpO1xuXHRcdGpxV3JhcHBlclsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cblx0XHQvLyBJZiB3ZSBuZWVkIHRvIHJlYXR0YWNoIHRoZSB0YWJsZSB0byB0aGUgZG9jdW1lbnRcblx0XHRpZiAoICEgcmVtb3ZlICYmIG9yaWcgKSB7XG5cdFx0XHQvLyBpbnNlcnRCZWZvcmUgYWN0cyBsaWtlIGFwcGVuZENoaWxkIGlmICFhcmdbMV1cblx0XHRcdG9yaWcuaW5zZXJ0QmVmb3JlKCB0YWJsZSwgaW5zZXJ0QmVmb3JlICk7XG5cblx0XHRcdC8vIFJlc3RvcmUgdGhlIHdpZHRoIG9mIHRoZSBvcmlnaW5hbCB0YWJsZSAtIHdhcyByZWFkIGZyb20gdGhlIHN0eWxlIHByb3BlcnR5LFxuXHRcdFx0Ly8gc28gd2UgY2FuIHJlc3RvcmUgZGlyZWN0bHkgdG8gdGhhdFxuXHRcdFx0anFUYWJsZVxuXHRcdFx0XHQuY3NzKCAnd2lkdGgnLCBzZXR0aW5ncy5zRGVzdHJveVdpZHRoIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjbGFzc2VzLnRhYmxlICk7XG5cdFx0fVxuXG5cdFx0LyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cblx0XHR2YXIgaWR4ID0gRGF0YVRhYmxlLnNldHRpbmdzLmluZGV4T2Yoc2V0dGluZ3MpO1xuXHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdERhdGFUYWJsZS5zZXR0aW5ncy5zcGxpY2UoIGlkeCwgMSApO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5cbi8vIEFkZCB0aGUgYGV2ZXJ5KClgIG1ldGhvZCBmb3Igcm93cywgY29sdW1ucyBhbmQgY2VsbHMgaW4gYSBjb21wYWN0IGZvcm1cbiQuZWFjaCggWyAnY29sdW1uJywgJ3JvdycsICdjZWxsJyBdLCBmdW5jdGlvbiAoIGksIHR5cGUgKSB7XG5cdF9hcGlfcmVnaXN0ZXIoIHR5cGUrJ3MoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0XHR2YXIgb3B0cyA9IHRoaXMuc2VsZWN0b3Iub3B0cztcblx0XHR2YXIgYXBpID0gdGhpcztcblx0XHR2YXIgaW5zdDtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2V2ZXJ5JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0ZWRJZHgsIHRhYmxlSWR4ICkge1xuXHRcdFx0aW5zdCA9IGFwaVsgdHlwZSBdKHNlbGVjdGVkSWR4LCBvcHRzKTtcblxuXHRcdFx0aWYgKHR5cGUgPT09ICdjZWxsJykge1xuXHRcdFx0XHRmbi5jYWxsKGluc3QsIGluc3RbMF1bMF0ucm93LCBpbnN0WzBdWzBdLmNvbHVtbiwgdGFibGVJZHgsIGNvdW50ZXIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZuLmNhbGwoaW5zdCwgc2VsZWN0ZWRJZHgsIHRhYmxlSWR4LCBjb3VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Y291bnRlcisrO1xuXHRcdH0gKTtcblx0fSApO1xufSApO1xuXG5cbi8vIGkxOG4gbWV0aG9kIGZvciBleHRlbnNpb25zIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBsYW5ndWFnZSBvYmplY3QgZnJvbSB0aGVcbi8vIERhdGFUYWJsZVxuX2FwaV9yZWdpc3RlciggJ2kxOG4oKScsIGZ1bmN0aW9uICggdG9rZW4sIGRlZiwgcGx1cmFsICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHR2YXIgcmVzb2x2ZWQgPSBfZm5HZXRPYmplY3REYXRhRm4oIHRva2VuICkoIGN0eC5vTGFuZ3VhZ2UgKTtcblxuXHRpZiAoIHJlc29sdmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmVzb2x2ZWQgPSBkZWY7XG5cdH1cblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcmVzb2x2ZWQgKSApIHtcblx0XHRyZXNvbHZlZCA9IHBsdXJhbCAhPT0gdW5kZWZpbmVkICYmIHJlc29sdmVkWyBwbHVyYWwgXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHJlc29sdmVkWyBwbHVyYWwgXSA6XG5cdFx0XHRyZXNvbHZlZC5fO1xuXHR9XG5cblx0cmV0dXJuIHR5cGVvZiByZXNvbHZlZCA9PT0gJ3N0cmluZydcblx0XHQ/IHJlc29sdmVkLnJlcGxhY2UoICclZCcsIHBsdXJhbCApIC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxuXHRcdDogcmVzb2x2ZWQ7XG59ICk7XG5cbi8qKlxuICogVmVyc2lvbiBzdHJpbmcgZm9yIHBsdWctaW5zIHRvIGNoZWNrIGNvbXBhdGliaWxpdHkuIEFsbG93ZWQgZm9ybWF0IGlzXG4gKiBgYS5iLmMtZGAgd2hlcmU6IGE6aW50LCBiOmludCwgYzppbnQsIGQ6c3RyaW5nKGRldnxiZXRhfGFscGhhKS4gYGRgIGlzIHVzZWRcbiAqIG9ubHkgZm9yIG5vbi1yZWxlYXNlIGJ1aWxkcy4gU2VlIGh0dHBzOi8vc2VtdmVyLm9yZy8gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAgQG1lbWJlclxuICogIEB0eXBlIHN0cmluZ1xuICogIEBkZWZhdWx0IFZlcnNpb24gbnVtYmVyXG4gKi9cbkRhdGFUYWJsZS52ZXJzaW9uID0gXCIyLjIuMlwiO1xuXG4vKipcbiAqIFByaXZhdGUgZGF0YSBzdG9yZSwgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzIG9iamVjdHMgdGhhdCBhcmVcbiAqIGNyZWF0ZWQgZm9yIHRoZSB0YWJsZXMgb24gYSBnaXZlbiBwYWdlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5zZXR0aW5nc2Agb2JqZWN0IGlzIGFsaWFzZWQgdG9cbiAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCB0aHJvdWdoIHdoaWNoIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmRcbiAqIG1hbmlwdWxhdGVkLCBvciBgalF1ZXJ5LmZuLmRhdGFUYWJsZS5zZXR0aW5nc2AuXG4gKiAgQG1lbWJlclxuICogIEB0eXBlIGFycmF5XG4gKiAgQGRlZmF1bHQgW11cbiAqICBAcHJpdmF0ZVxuICovXG5EYXRhVGFibGUuc2V0dGluZ3MgPSBbXTtcblxuLyoqXG4gKiBPYmplY3QgbW9kZWxzIGNvbnRhaW5lciwgZm9yIHRoZSB2YXJpb3VzIG1vZGVscyB0aGF0IERhdGFUYWJsZXMgaGFzXG4gKiBhdmFpbGFibGUgdG8gaXQuIFRoZXNlIG1vZGVscyBkZWZpbmUgdGhlIG9iamVjdHMgdGhhdCBhcmUgdXNlZCB0byBob2xkXG4gKiB0aGUgYWN0aXZlIHN0YXRlIGFuZCBjb25maWd1cmF0aW9uIG9mIHRoZSB0YWJsZS5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMgPSB7fTtcblxuXG5cbi8qKlxuICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHNlYXJjaCBpbmZvcm1hdGlvbiBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlcnMuXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggPSB7XG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBmaWx0ZXJpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUgb3Igbm90XG5cdCAqL1xuXHRcImNhc2VJbnNlbnNpdGl2ZVwiOiB0cnVlLFxuXG5cdC8qKlxuXHQgKiBBcHBsaWVkIHNlYXJjaCB0ZXJtXG5cdCAqL1xuXHRcInNlYXJjaFwiOiBcIlwiLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuXHQgKiByZWd1bGFyIGV4cHJlc3Npb24gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFuZCB0aGVyZWZvcmUgYW5kIHNwZWNpYWxcblx0ICogcmVnZXggY2hhcmFjdGVycyBlc2NhcGVkLlxuXHQgKi9cblx0XCJyZWdleFwiOiBmYWxzZSxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIGlzIHRvIHVzZSBpdHMgc21hcnQgZmlsdGVyaW5nIG9yIG5vdC5cblx0ICovXG5cdFwic21hcnRcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZWFyY2ggd2hlblxuXHQgKiB0aGUgcmV0dXJuIGtleSBpcyBwcmVzc2VkLlxuXHQgKi9cblx0XCJyZXR1cm5cIjogZmFsc2Vcbn07XG5cblxuXG5cbi8qKlxuICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIGVhY2ggaW5kaXZpZHVhbCByb3cuIFRoaXMgaXMgdGhlIG9iamVjdCBmb3JtYXQgdXNlZCBmb3IgdGhlIHNldHRpbmdzXG4gKiBhb0RhdGEgYXJyYXkuXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUubW9kZWxzLm9Sb3cgPSB7XG5cdC8qKlxuXHQgKiBUUiBlbGVtZW50IGZvciB0aGUgcm93XG5cdCAqL1xuXHRcIm5UclwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBURCBlbGVtZW50cyBmb3IgZWFjaCByb3cuIFRoaXMgaXMgbnVsbCB1bnRpbCB0aGUgcm93IGhhcyBiZWVuXG5cdCAqIGNyZWF0ZWQuXG5cdCAqL1xuXHRcImFuQ2VsbHNcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGF0YSBvYmplY3QgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cuIFRoaXMgaXMgZWl0aGVyXG5cdCAqIGFuIGFycmF5IGlmIHVzaW5nIHRoZSB0cmFkaXRpb25hbCBmb3JtIG9mIERhdGFUYWJsZXMsIG9yIGFuIG9iamVjdCBpZlxuXHQgKiB1c2luZyBtRGF0YSBvcHRpb25zLiBUaGUgZXhhY3QgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgcGFzc2VkIGluXG5cdCAqIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2UsIG9yIHdpbGwgYmUgYW4gYXJyYXkgaWYgdXNpbmcgRE9NIGEgZGF0YVxuXHQgKiBzb3VyY2UuXG5cdCAqL1xuXHRcIl9hRGF0YVwiOiBbXSxcblxuXHQvKipcblx0ICogU29ydGluZyBkYXRhIGNhY2hlIC0gdGhpcyBhcnJheSBpcyBvc3RlbnNpYmx5IHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcblx0ICogbnVtYmVyIG9mIGNvbHVtbnMgKGFsdGhvdWdoIGVhY2ggaW5kZXggaXMgZ2VuZXJhdGVkIG9ubHkgYXMgaXQgaXNcblx0ICogbmVlZGVkKSwgYW5kIGhvbGRzIHRoZSBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29ydGluZyBlYWNoIGNvbHVtbiBpbiB0aGVcblx0ICogcm93LiBXZSBkbyB0aGlzIGNhY2hlIGdlbmVyYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3J0IGluIG9yZGVyIHRoYXRcblx0ICogdGhlIGZvcm1hdHRpbmcgb2YgdGhlIHNvcnQgZGF0YSBuZWVkIGJlIGRvbmUgb25seSBvbmNlIGZvciBlYWNoIGNlbGxcblx0ICogcGVyIHNvcnQuIFRoaXMgYXJyYXkgc2hvdWxkIG5vdCBiZSByZWFkIGZyb20gb3Igd3JpdHRlbiB0byBieSBhbnl0aGluZ1xuXHQgKiBvdGhlciB0aGFuIHRoZSBtYXN0ZXIgc29ydGluZyBtZXRob2RzLlxuXHQgKi9cblx0XCJfYVNvcnREYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFBlciBjZWxsIGZpbHRlcmluZyBkYXRhIGNhY2hlLiBBcyBwZXIgdGhlIHNvcnQgZGF0YSBjYWNoZSwgdXNlZCB0b1xuXHQgKiBpbmNyZWFzZSB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzXG5cdCAqL1xuXHRcIl9hRmlsdGVyRGF0YVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGaWx0ZXJpbmcgZGF0YSBjYWNoZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgY2VsbCBmaWx0ZXJpbmcgY2FjaGUsIGJ1dFxuXHQgKiBpbiB0aGlzIGNhc2UgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gYXJyYXkuIFRoaXMgaXMgZWFzaWx5IGNvbXB1dGVkIHdpdGhcblx0ICogYSBqb2luIG9uIGBfYUZpbHRlckRhdGFgLCBidXQgaXMgcHJvdmlkZWQgYXMgYSBjYWNoZSBzbyB0aGUgam9pbiBpc24ndFxuXHQgKiBuZWVkZWQgb24gZXZlcnkgc2VhcmNoIChtZW1vcnkgdHJhZGVkIGZvciBwZXJmb3JtYW5jZSlcblx0ICovXG5cdFwiX3NGaWx0ZXJSb3dcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2Vcblx0ICogb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yIGludmFsaWRhdGluZyBkYXRhLCBzbyBEYXRhVGFibGVzIGNhblxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlYWQgZGF0YSBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHVubGVzcyB1bmluc3RydWN0ZWRcblx0ICogb3RoZXJ3aXNlLlxuXHQgKi9cblx0XCJzcmNcIjogbnVsbCxcblxuXHQvKipcblx0ICogSW5kZXggaW4gdGhlIGFvRGF0YSBhcnJheS4gVGhpcyBzYXZlcyBhbiBpbmRleE9mIGxvb2t1cCB3aGVuIHdlIGhhdmUgdGhlXG5cdCAqIG9iamVjdCwgYnV0IHdhbnQgdG8ga25vdyB0aGUgaW5kZXhcblx0ICovXG5cdFwiaWR4XCI6IC0xLFxuXG5cdC8qKlxuXHQgKiBDYWNoZWQgZGlzcGxheSB2YWx1ZVxuXHQgKi9cblx0ZGlzcGxheURhdGE6IG51bGxcbn07XG5cblxuLyoqXG4gKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gb2JqZWN0IGluIERhdGFUYWJsZXMuIFRoaXMgb2JqZWN0XG4gKiBpcyBoZWxkIGluIHRoZSBzZXR0aW5ncyBhb0NvbHVtbnMgYXJyYXkgYW5kIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdGhhdFxuICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufVxuICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cbiAqIEl0IHNob3VsZCBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGRcbiAqIGJlIGRvbmUgdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMub0NvbHVtbiA9IHtcblx0LyoqXG5cdCAqIENvbHVtbiBpbmRleC5cblx0ICovXG5cdFwiaWR4XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cblx0ICogaXMgc29ydGVkLiBUaGF0IHRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXkgYWxsb3dzIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdCAqIHRvIGJlIGRlZmluZWQgZm9yIGEgY29sdW1uIChmb3IgZXhhbXBsZSBmaXJzdCBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnNcblx0ICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcblx0ICogY29sdW1ucyB0byBiZSBzb3J0ZWQgb24gKHR5cGljYWxseSBpdCB3aWxsIGJlIGEgc2luZ2xlIGludGVnZXIgcG9pbnRpbmdcblx0ICogYXQgaXRzZWxmLCBidXQgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIGNhc2UpLlxuXHQgKi9cblx0XCJhRGF0YVNvcnRcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGVmaW5lIHRoZSBzb3J0aW5nIGRpcmVjdGlvbnMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgY29sdW1uLCBpbiBzZXF1ZW5jZVxuXHQgKiBhcyB0aGUgY29sdW1uIGlzIHJlcGVhdGVkbHkgc29ydGVkIHVwb24gLSBpLmUuIHRoZSBmaXJzdCB2YWx1ZSBpcyB1c2VkXG5cdCAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cblx0ICogU29ydCBpdCBhZ2FpbiAoY2xpY2sgYWdhaW4pIGFuZCBpdCB3aWxsIG1vdmUgb24gdG8gdGhlIG5leHQgaW5kZXguXG5cdCAqIFJlcGVhdCB1bnRpbCBsb29wLlxuXHQgKi9cblx0XCJhc1NvcnRpbmdcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNlYXJjaGFibGUsIGFuZCB0aHVzIHNob3VsZCBiZSBpbmNsdWRlZFxuXHQgKiBpbiB0aGUgZmlsdGVyaW5nIG9yIG5vdC5cblx0ICovXG5cdFwiYlNlYXJjaGFibGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNvcnRhYmxlIG9yIG5vdC5cblx0ICovXG5cdFwiYlNvcnRhYmxlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdGFibGUgb3Igbm90XG5cdCAqL1xuXHRcImJWaXNpYmxlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFN0b3JlIGZvciBtYW51YWwgdHlwZSBhc3NpZ25tZW50IHVzaW5nIHRoZSBgY29sdW1uLnR5cGVgIG9wdGlvbi4gVGhpc1xuXHQgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxuXHQgKi9cblx0XCJfc01hbnVhbFR5cGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBIVE1MNSBkYXRhIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGRhdGFcblx0ICogc291cmNlIGZvciBmaWx0ZXJpbmcgb3Igc29ydGluZy4gVHJ1ZSBpcyBlaXRoZXIgYXJlLlxuXHQgKi9cblx0XCJfYkF0dHJTcmNcIjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHQgKiBldGMpIG9yIHByb2Nlc3NlZCBmb3IgaW5wdXQgKERPTSBzb3VyY2UpLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgY29tcGxpbWVudCB0byBtUmVuZGVyXG5cdCAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXG5cdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHQgKi9cblx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHQgKiBhY2Nlc3MgZGF0YSBkaXJlY3RseSB0aHJvdWdoIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG5cdCAqIHRoZSBtZXRob2QgYXR0YWNoZWQgdG8gdGhpcyBwcm9wZXJ0eS4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzXG5cdCAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxuXHQgKiBpbml0aWFsaXNhdGlvbiBtZXRob2Rcblx0ICovXG5cdFwiZm5HZXREYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0ICogc2V0IHRoZSBkYXRhIGRpcmVjdGx5IHRvIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG5cdCAqIHRoaXMgbWV0aG9kLiBJdCBhbGxvd3MgbURhdGEgdG8gZnVuY3Rpb24gYXMgcmVxdWlyZWQuIFRoaXMgZnVuY3Rpb25cblx0ICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHQgKi9cblx0XCJmblNldERhdGFcIjogbnVsbCxcblxuXHQvKipcblx0ICogUHJvcGVydHkgdG8gcmVhZCB0aGUgdmFsdWUgZm9yIHRoZSBjZWxscyBpbiB0aGUgY29sdW1uIGZyb20gdGhlIGRhdGFcblx0ICogc291cmNlIGFycmF5IC8gb2JqZWN0LiBJZiBudWxsLCB0aGVuIHRoZSBkZWZhdWx0IGNvbnRlbnQgaXMgdXNlZCwgaWYgYVxuXHQgKiBmdW5jdGlvbiBpcyBnaXZlbiB0aGVuIHRoZSByZXR1cm4gZnJvbSB0aGUgZnVuY3Rpb24gaXMgdXNlZC5cblx0ICovXG5cdFwibURhdGFcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGFydG5lciBwcm9wZXJ0eSB0byBtRGF0YSB3aGljaCBpcyB1c2VkIChvbmx5IHdoZW4gZGVmaW5lZCkgdG8gZ2V0XG5cdCAqIHRoZSBkYXRhIC0gaS5lLiBpdCBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgbURhdGEsIGJ1dCB3aXRob3V0IHRoZVxuXHQgKiAnc2V0JyBvcHRpb24sIGFuZCBhbHNvIHRoZSBkYXRhIGZlZCB0byBpdCBpcyB0aGUgcmVzdWx0IGZyb20gbURhdGEuXG5cdCAqIFRoaXMgaXMgdGhlIHJlbmRlcmluZyBtZXRob2QgdG8gbWF0Y2ggdGhlIGRhdGEgbWV0aG9kIG9mIG1EYXRhLlxuXHQgKi9cblx0XCJtUmVuZGVyXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cblx0ICovXG5cdFwic0NsYXNzXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcblx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHQgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcblx0ICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcblx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHQgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXG5cdCAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcblx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0ICovXG5cdFwic0NvbnRlbnRQYWRkaW5nXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHQgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgbURhdGFcblx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0ICovXG5cdFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIE5hbWUgZm9yIHRoZSBjb2x1bW4sIGFsbG93aW5nIHJlZmVyZW5jZSB0byB0aGUgY29sdW1uIGJ5IG5hbWUgYXMgd2VsbCBhc1xuXHQgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cblx0ICovXG5cdFwic05hbWVcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ3VzdG9tIHNvcnRpbmcgZGF0YSB0eXBlIC0gZGVmaW5lcyB3aGljaCBvZiB0aGUgYXZhaWxhYmxlIHBsdWctaW5zIGluXG5cdCAqIGFmblNvcnREYXRhIHRoZSBjdXN0b20gc29ydGluZyB3aWxsIHVzZSAtIGlmIGFueSBpcyBkZWZpbmVkLlxuXHQgKi9cblx0XCJzU29ydERhdGFUeXBlXCI6ICdzdGQnLFxuXG5cdC8qKlxuXHQgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgZWxlbWVudCB3aGVuIHNvcnRpbmcgb24gdGhpcyBjb2x1bW5cblx0ICovXG5cdFwic1NvcnRpbmdDbGFzc1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxuXHQgKi9cblx0XCJzVGl0bGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ29sdW1uIHNvcnRpbmcgYW5kIGZpbHRlcmluZyB0eXBlXG5cdCAqL1xuXHRcInNUeXBlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cblx0ICovXG5cdFwic1dpZHRoXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW4gd2hlbiBpdCB3YXMgZmlyc3QgXCJlbmNvdW50ZXJlZFwiXG5cdCAqL1xuXHRcInNXaWR0aE9yaWdcIjogbnVsbCxcblxuXHQvKiogQ2FjaGVkIHN0cmluZyB3aGljaCBpcyB0aGUgbG9uZ2VzdCBpbiB0aGUgY29sdW1uICovXG5cdG1heExlblN0cmluZzogbnVsbCxcblxuXHQvKipcblx0ICogU3RvcmUgZm9yIG5hbWVkIHNlYXJjaGVzXG5cdCAqL1xuXHRzZWFyY2hGaXhlZDogbnVsbFxufTtcblxuXG4vKlxuICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxuICogbm90YXRpb24sIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGludGVyZmFjZSBmb3IgRGF0YVRhYmxlcyBwcmlvciB0byB2MS4xMCwgaG93ZXZlclxuICogZnJvbSB2MS4xMCBvbndhcmRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBpcyBjYW1lbCBjYXNlLiBJbiBvcmRlciB0byBhdm9pZFxuICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXG4gKiB2ZXJzaW9uIGlzIHN0aWxsLCBpbnRlcm5hbGx5IHRoZSBwcmltYXJ5IGludGVyZmFjZSwgYnV0IGlzIGlzIG5vdCBkb2N1bWVudGVkXG4gKiAtIGhlbmNlIHRoZSBAbmFtZSB0YWdzIGluIGVhY2ggZG9jIGNvbW1lbnQuIFRoaXMgYWxsb3dzIGEgSmF2YXNjcmlwdCBmdW5jdGlvblxuICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cbiAqIHdvdWxkIHJlcXVpcmUgZWFjaCBwcm9wZXJ0eSB0byBiZSBsaXN0ZWQsIHdoaWNoIHdvdWxkIGFkZCBhcm91bmQgM0sgdG8gdGhlIHNpemVcbiAqIG9mIERhdGFUYWJsZXMsIHdoaWxlIHRoaXMgbWV0aG9kIGlzIGFib3V0IGEgMC41SyBoaXQpLlxuICpcbiAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcbiAqIGNvbXBsZXRlbHksIGJ1dCB0aGF0IGlzIGEgbWFzc2l2ZSBhbW91bnQgb2Ygd29yayBhbmQgd2lsbCBicmVhayBjdXJyZW50XG4gKiBpbnN0YWxscyAodGhlcmVmb3JlIGlzIG9uLWhvbGQgdW50aWwgdjIpLlxuICovXG5cbi8qKlxuICogSW5pdGlhbGlzYXRpb24gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uXG4gKiB0aW1lLlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLmRlZmF1bHRzID0ge1xuXHQvKipcblx0ICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXG5cdCAqIHdpbGwgYmUgdXNlZCBpbiBwcmVmZXJlbmNlIHRvIGFueSBkYXRhIHdoaWNoIGlzIGFscmVhZHkgaW4gdGhlIERPTS4gVGhpcyBpc1xuXHQgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb25zdHJ1Y3RpbmcgdGFibGVzIHB1cmVseSBpbiBKYXZhc2NyaXB0LCBmb3Jcblx0ICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cblx0ICovXG5cdFwiYWFEYXRhXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogSWYgb3JkZXJpbmcgaXMgZW5hYmxlZCwgdGhlbiBEYXRhVGFibGVzIHdpbGwgcGVyZm9ybSBhIGZpcnN0IHBhc3Mgc29ydCBvblxuXHQgKiBpbml0aWFsaXNhdGlvbi4gWW91IGNhbiBkZWZpbmUgd2hpY2ggY29sdW1uKHMpIHRoZSBzb3J0IGlzIHBlcmZvcm1lZFxuXHQgKiB1cG9uLCBhbmQgdGhlIHNvcnRpbmcgZGlyZWN0aW9uLCB3aXRoIHRoaXMgdmFyaWFibGUuIFRoZSBgc29ydGluZ2AgYXJyYXlcblx0ICogc2hvdWxkIGNvbnRhaW4gYW4gYXJyYXkgZm9yIGVhY2ggY29sdW1uIHRvIGJlIHNvcnRlZCBpbml0aWFsbHkgY29udGFpbmluZ1xuXHQgKiB0aGUgY29sdW1uJ3MgaW5kZXggYW5kIGEgZGlyZWN0aW9uIHN0cmluZyAoJ2FzYycgb3IgJ2Rlc2MnKS5cblx0ICovXG5cdFwiYWFTb3J0aW5nXCI6IFtbMCwnYXNjJ11dLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGlzIGJhc2ljYWxseSBpZGVudGljYWwgdG8gdGhlIGBzb3J0aW5nYCBwYXJhbWV0ZXIsIGJ1dFxuXHQgKiBjYW5ub3QgYmUgb3ZlcnJpZGRlbiBieSB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIHRhYmxlLiBXaGF0IHRoaXMgbWVhbnNcblx0ICogaXMgdGhhdCB5b3UgY291bGQgaGF2ZSBhIGNvbHVtbiAodmlzaWJsZSBvciBoaWRkZW4pIHdoaWNoIHRoZSBzb3J0aW5nXG5cdCAqIHdpbGwgYWx3YXlzIGJlIGZvcmNlZCBvbiBmaXJzdCAtIGFueSBzb3J0aW5nIGFmdGVyIHRoYXQgKGZyb20gdGhlIHVzZXIpXG5cdCAqIHdpbGwgdGhlbiBiZSBwZXJmb3JtZWQgYXMgcmVxdWlyZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZ3JvdXBpbmcgcm93c1xuXHQgKiB0b2dldGhlci5cblx0ICovXG5cdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBjYW4gYmUgaW5zdHJ1Y3RlZCB0byBsb2FkIGRhdGEgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUgZnJvbSBhXG5cdCAqIEFqYXggc291cmNlLiBUaGlzIG9wdGlvbiBkZWZpbmVzIGhvdyB0aGF0IEFqYXggY2FsbCBpcyBtYWRlIGFuZCB3aGVyZSB0by5cblx0ICpcblx0ICogVGhlIGBhamF4YCBwcm9wZXJ0eSBoYXMgdGhyZWUgZGlmZmVyZW50IG1vZGVzIG9mIG9wZXJhdGlvbiwgZGVwZW5kaW5nIG9uXG5cdCAqIGhvdyBpdCBpcyBkZWZpbmVkLiBUaGVzZSBhcmU6XG5cdCAqXG5cdCAqICogYHN0cmluZ2AgLSBTZXQgdGhlIFVSTCBmcm9tIHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbS5cblx0ICogKiBgb2JqZWN0YCAtIERlZmluZSBwcm9wZXJ0aWVzIGZvciBgalF1ZXJ5LmFqYXhgLlxuXHQgKiAqIGBmdW5jdGlvbmAgLSBDdXN0b20gZGF0YSBnZXQgZnVuY3Rpb25cblx0ICpcblx0ICogYHN0cmluZ2Bcblx0ICogLS0tLS0tLS1cblx0ICpcblx0ICogQXMgYSBzdHJpbmcsIHRoZSBgYWpheGAgcHJvcGVydHkgc2ltcGx5IGRlZmluZXMgdGhlIFVSTCBmcm9tIHdoaWNoXG5cdCAqIERhdGFUYWJsZXMgd2lsbCBsb2FkIGRhdGEuXG5cdCAqXG5cdCAqIGBvYmplY3RgXG5cdCAqIC0tLS0tLS0tXG5cdCAqXG5cdCAqIEFzIGFuIG9iamVjdCwgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIG9iamVjdCBhcmUgcGFzc2VkIHRvXG5cdCAqIFtqUXVlcnkuYWpheF0oaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC8pIGFsbG93aW5nIGZpbmUgY29udHJvbFxuXHQgKiBvZiB0aGUgQWpheCByZXF1ZXN0LiBEYXRhVGFibGVzIGhhcyBhIG51bWJlciBvZiBkZWZhdWx0IHBhcmFtZXRlcnMgd2hpY2hcblx0ICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcblx0ICogZG9jdW1lbnRhdGlvbiBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSwgYWx0aG91Z2hcblx0ICogdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIHByb3ZpZGUgYWRkaXRpb25hbCBvcHRpb25zIGluIERhdGFUYWJsZXMgb3Jcblx0ICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XG5cdCAqXG5cdCAqICogYGRhdGFgIC0gQXMgd2l0aCBqUXVlcnksIGBkYXRhYCBjYW4gYmUgcHJvdmlkZWQgYXMgYW4gb2JqZWN0LCBidXQgaXRcblx0ICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXG5cdCAqICAgdG8gdGhlIHNlcnZlci4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW4gb2JqZWN0IG9mXG5cdCAqICAgcGFyYW1ldGVycyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCBEYXRhVGFibGVzIGhhcyByZWFkaWVkIGZvciBzZW5kaW5nLiBBblxuXHQgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xuXHQgKiAgIGRlZmF1bHRzLCBvciB5b3UgY2FuIGFkZCB0aGUgaXRlbXMgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4gYW5kXG5cdCAqICAgbm90IHJldHVybiBhbnl0aGluZyBmcm9tIHRoZSBmdW5jdGlvbi4gVGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlclBhcmFtc2Bcblx0ICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cblx0ICpcblx0ICogKiBgZGF0YVNyY2AgLSBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvclxuXHQgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXG5cdCAqICAgZnJvbSBhbiBBamF4IHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyXG5cdCAqICAgYWxsb3dzIHRoYXQgcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWRcblx0ICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxuXHQgKiAgIGl0IG15IGJlIHVzZWQgYXMgYSBmdW5jdGlvbi4gQXMgYSBmdW5jdGlvbiBpdCB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsXG5cdCAqICAgdGhlIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYXNcblx0ICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXG5cdCAqICAgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS5cblx0ICpcblx0ICogKiBgc3VjY2Vzc2AgLSBTaG91bGQgbm90IGJlIG92ZXJyaWRkZW4gaXQgaXMgdXNlZCBpbnRlcm5hbGx5IGluXG5cdCAqICAgRGF0YVRhYmxlcy4gVG8gbWFuaXB1bGF0ZSAvIHRyYW5zZm9ybSB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG5cdCAqICAgdXNlIGBhamF4LmRhdGFTcmNgLCBvciB1c2UgYGFqYXhgIGFzIGEgZnVuY3Rpb24gKHNlZSBiZWxvdykuXG5cdCAqXG5cdCAqIGBmdW5jdGlvbmBcblx0ICogLS0tLS0tLS0tLVxuXHQgKlxuXHQgKiBBcyBhIGZ1bmN0aW9uLCBtYWtpbmcgdGhlIEFqYXggY2FsbCBpcyBsZWZ0IHVwIHRvIHlvdXJzZWxmIGFsbG93aW5nXG5cdCAqIGNvbXBsZXRlIGNvbnRyb2wgb2YgdGhlIEFqYXggcmVxdWVzdC4gSW5kZWVkLCBpZiBkZXNpcmVkLCBhIG1ldGhvZCBvdGhlclxuXHQgKiB0aGFuIEFqYXggY291bGQgYmUgdXNlZCB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEsIHN1Y2ggYXMgV2ViIHN0b3JhZ2Vcblx0ICogb3IgYW4gQUlSIGRhdGFiYXNlLlxuXHQgKlxuXHQgKiBUaGUgZnVuY3Rpb24gaXMgZ2l2ZW4gZm91ciBwYXJhbWV0ZXJzIGFuZCBubyByZXR1cm4gaXMgcmVxdWlyZWQuIFRoZVxuXHQgKiBwYXJhbWV0ZXJzIGFyZTpcblx0ICpcblx0ICogMS4gX29iamVjdF8gLSBEYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlclxuXHQgKiAyLiBfZnVuY3Rpb25fIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBtdXN0IGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHJlcXVpcmVkXG5cdCAqICAgIGRhdGEgaGFzIGJlZW4gb2J0YWluZWQuIFRoYXQgZGF0YSBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrXG5cdCAqICAgIGFzIHRoZSBvbmx5IHBhcmFtZXRlclxuXHQgKiAzLiBfb2JqZWN0XyAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgdGFibGVcblx0ICovXG5cdFwiYWpheFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gcmVhZGlseSBzcGVjaWZ5IHRoZSBlbnRyaWVzIGluIHRoZSBsZW5ndGggZHJvcFxuXHQgKiBkb3duIG1lbnUgdGhhdCBEYXRhVGFibGVzIHNob3dzIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLiBJdCBjYW4gYmVcblx0ICogZWl0aGVyIGEgMUQgYXJyYXkgb2Ygb3B0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGJvdGggdGhlIGRpc3BsYXllZFxuXHQgKiBvcHRpb24gYW5kIHRoZSB2YWx1ZSwgb3IgYSAyRCBhcnJheSB3aGljaCB3aWxsIHVzZSB0aGUgYXJyYXkgaW4gdGhlIGZpcnN0XG5cdCAqIHBvc2l0aW9uIGFzIHRoZSB2YWx1ZSwgYW5kIHRoZSBhcnJheSBpbiB0aGUgc2Vjb25kIHBvc2l0aW9uIGFzIHRoZVxuXHQgKiBkaXNwbGF5ZWQgb3B0aW9ucyAodXNlZnVsIGZvciBsYW5ndWFnZSBzdHJpbmdzIHN1Y2ggYXMgJ0FsbCcpLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBwYWdlTGVuZ3RoYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZVxuXHQgKiBmaXJzdCB2YWx1ZSBnaXZlbiBpbiB0aGlzIGFycmF5LCB1bmxlc3MgYHBhZ2VMZW5ndGhgIGlzIGFsc28gcHJvdmlkZWQuXG5cdCAqL1xuXHRcImFMZW5ndGhNZW51XCI6IFsgMTAsIDI1LCA1MCwgMTAwIF0sXG5cblxuXHQvKipcblx0ICogVGhlIGBjb2x1bW5zYCBvcHRpb24gaW4gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGRlZmluZVxuXHQgKiBkZXRhaWxzIGFib3V0IHRoZSB3YXkgaW5kaXZpZHVhbCBjb2x1bW5zIGJlaGF2ZS4gRm9yIGEgZnVsbCBsaXN0IG9mXG5cdCAqIGNvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCwgcGxlYXNlIHNlZVxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0uIE5vdGUgdGhhdCBpZiB5b3UgdXNlIGBjb2x1bW5zYCB0b1xuXHQgKiBkZWZpbmUgeW91ciBjb2x1bW5zLCB5b3UgbXVzdCBoYXZlIGFuIGVudHJ5IGluIHRoZSBhcnJheSBmb3IgZXZlcnkgc2luZ2xlXG5cdCAqIGNvbHVtbiB0aGF0IHlvdSBoYXZlIGluIHlvdXIgdGFibGUgKHRoZXNlIGNhbiBiZSBudWxsIGlmIHlvdSBkb24ndCB3aGljaFxuXHQgKiB0byBzcGVjaWZ5IGFueSBvcHRpb25zKS5cblx0ICovXG5cdFwiYW9Db2x1bW5zXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFZlcnkgc2ltaWxhciB0byBgY29sdW1uc2AsIGBjb2x1bW5EZWZzYCBhbGxvd3MgeW91IHRvIHRhcmdldCBhIHNwZWNpZmljXG5cdCAqIGNvbHVtbiwgbXVsdGlwbGUgY29sdW1ucywgb3IgYWxsIGNvbHVtbnMsIHVzaW5nIHRoZSBgdGFyZ2V0c2AgcHJvcGVydHkgb2Zcblx0ICogZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBUaGlzIGFsbG93cyBncmVhdCBmbGV4aWJpbGl0eSB3aGVuIGNyZWF0aW5nXG5cdCAqIHRhYmxlcywgYXMgdGhlIGBjb2x1bW5EZWZzYCBhcnJheXMgY2FuIGJlIG9mIGFueSBsZW5ndGgsIHRhcmdldGluZyB0aGVcblx0ICogY29sdW1ucyB5b3Ugc3BlY2lmaWNhbGx5IHdhbnQuIGBjb2x1bW5EZWZzYCBtYXkgdXNlIGFueSBvZiB0aGUgY29sdW1uXG5cdCAqIG9wdGlvbnMgYXZhaWxhYmxlOiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0sIGJ1dCBpdCBfbXVzdF9cblx0ICogaGF2ZSBgdGFyZ2V0c2AgZGVmaW5lZCBpbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFZhbHVlcyBpbiB0aGUgYHRhcmdldHNgXG5cdCAqIGFycmF5IG1heSBiZTpcblx0ICogICA8dWw+XG5cdCAqICAgICA8bGk+YSBzdHJpbmcgLSBjbGFzcyBuYW1lIHdpbGwgYmUgbWF0Y2hlZCBvbiB0aGUgVEggZm9yIHRoZSBjb2x1bW48L2xpPlxuXHQgKiAgICAgPGxpPjAgb3IgYSBwb3NpdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIGxlZnQ8L2xpPlxuXHQgKiAgICAgPGxpPmEgbmVnYXRpdmUgaW50ZWdlciAtIGNvbHVtbiBpbmRleCBjb3VudGluZyBmcm9tIHRoZSByaWdodDwvbGk+XG5cdCAqICAgICA8bGk+dGhlIHN0cmluZyBcIl9hbGxcIiAtIGFsbCBjb2x1bW5zIChpLmUuIGFzc2lnbiBhIGRlZmF1bHQpPC9saT5cblx0ICogICA8L3VsPlxuXHQgKi9cblx0XCJhb0NvbHVtbkRlZnNcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgYHNlYXJjaGAsIHRoaXMgcGFyYW1ldGVyIGRlZmluZXMgdGhlIGluZGl2aWR1YWwgY29sdW1uXG5cdCAqIGZpbHRlcmluZyBzdGF0ZSBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLiBUaGUgYXJyYXkgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplXG5cdCAqIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucywgYW5kIGVhY2ggZWxlbWVudCBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyYW1ldGVyc1xuXHQgKiBgc2VhcmNoYCBhbmQgYGVzY2FwZVJlZ2V4YCAodGhlIGxhdHRlciBpcyBvcHRpb25hbCkuICdudWxsJyBpcyBhbHNvXG5cdCAqIGFjY2VwdGVkIGFuZCB0aGUgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG5cdCAqL1xuXHRcImFvU2VhcmNoQ29sc1wiOiBbXSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uLiBUaGlzIGNhbiBiZSBkaXNhYmxlZFxuXHQgKiBhcyBhbiBvcHRpbWlzYXRpb24gKGl0IHRha2VzIHNvbWUgdGltZSB0byBjYWxjdWxhdGUgdGhlIHdpZHRocykgaWYgdGhlXG5cdCAqIHRhYmxlcyB3aWR0aHMgYXJlIHBhc3NlZCBpbiB1c2luZyBgY29sdW1uc2AuXG5cdCAqL1xuXHRcImJBdXRvV2lkdGhcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBEZWZlcnJlZCByZW5kZXJpbmcgY2FuIHByb3ZpZGUgRGF0YVRhYmxlcyB3aXRoIGEgaHVnZSBzcGVlZCBib29zdCB3aGVuIHlvdVxuXHQgKiBhcmUgdXNpbmcgYW4gQWpheCBvciBKUyBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIG9wdGlvbiwgd2hlbiBzZXQgdG9cblx0ICogdHJ1ZSwgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGRlZmVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgdGFibGUgZWxlbWVudHMgZm9yXG5cdCAqIGVhY2ggcm93IHVudGlsIHRoZXkgYXJlIG5lZWRlZCBmb3IgYSBkcmF3IC0gc2F2aW5nIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mXG5cdCAqIHRpbWUuXG5cdCAqL1xuXHRcImJEZWZlclJlbmRlclwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIFJlcGxhY2UgYSBEYXRhVGFibGUgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gc2VsZWN0b3IgYW5kIHJlcGxhY2UgaXQgd2l0aFxuXHQgKiBvbmUgd2hpY2ggaGFzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuZXcgaW5pdGlhbGlzYXRpb24gb2JqZWN0IHBhc3NlZC4gSWYgbm9cblx0ICogdGFibGUgbWF0Y2hlcyB0aGUgc2VsZWN0b3IsIHRoZW4gdGhlIG5ldyBEYXRhVGFibGUgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhc1xuXHQgKiBwZXIgbm9ybWFsLlxuXHQgKi9cblx0XCJiRGVzdHJveVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb2YgZGF0YS4gRmlsdGVyaW5nIGluIERhdGFUYWJsZXMgaXMgXCJzbWFydFwiIGluXG5cdCAqIHRoYXQgaXQgYWxsb3dzIHRoZSBlbmQgdXNlciB0byBpbnB1dCBtdWx0aXBsZSB3b3JkcyAoc3BhY2Ugc2VwYXJhdGVkKSBhbmRcblx0ICogd2lsbCBtYXRjaCBhIHJvdyBjb250YWluaW5nIHRob3NlIHdvcmRzLCBldmVuIGlmIG5vdCBpbiB0aGUgb3JkZXIgdGhhdCB3YXNcblx0ICogc3BlY2lmaWVkICh0aGlzIGFsbG93IG1hdGNoaW5nIGFjcm9zcyBtdWx0aXBsZSBjb2x1bW5zKS4gTm90ZSB0aGF0IGlmIHlvdVxuXHQgKiB3aXNoIHRvIHVzZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyB0aGlzIG11c3QgcmVtYWluICd0cnVlJyAtIHRvIHJlbW92ZSB0aGVcblx0ICogZGVmYXVsdCBmaWx0ZXJpbmcgaW5wdXQgYm94IGFuZCByZXRhaW4gZmlsdGVyaW5nIGFiaWxpdGllcywgcGxlYXNlIHVzZVxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbX0uXG5cdCAqL1xuXHRcImJGaWx0ZXJcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogVXNlZCBvbmx5IGZvciBjb21wYXRpYmxpdHkgd2l0aCBEVDFcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdFwiYkluZm9cIjogdHJ1ZSxcblxuXHQvKipcblx0ICogVXNlZCBvbmx5IGZvciBjb21wYXRpYmxpdHkgd2l0aCBEVDFcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdFwiYkxlbmd0aENoYW5nZVwiOiB0cnVlLFxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBwYWdpbmF0aW9uLlxuXHQgKi9cblx0XCJiUGFnaW5hdGVcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiBhICdwcm9jZXNzaW5nJyBpbmRpY2F0b3Igd2hlbiB0aGUgdGFibGUgaXNcblx0ICogYmVpbmcgcHJvY2Vzc2VkIChlLmcuIGEgc29ydCkuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgdGFibGVzIHdpdGhcblx0ICogbGFyZ2UgYW1vdW50cyBvZiBkYXRhIHdoZXJlIGl0IGNhbiB0YWtlIGEgbm90aWNlYWJsZSBhbW91bnQgb2YgdGltZSB0byBzb3J0XG5cdCAqIHRoZSBlbnRyaWVzLlxuXHQgKi9cblx0XCJiUHJvY2Vzc2luZ1wiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSB0aGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoZSBnaXZlbiBzZWxlY3Rvci4gTm90ZSB0aGF0IGlmIHRoZVxuXHQgKiB0YWJsZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkLCB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlIERhdGFUYWJsZXNcblx0ICogdG8gc2ltcGx5IHJldHVybiB0aGUgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzZXQgdXAgLSBpdCB3aWxsIG5vdCB0YWtlXG5cdCAqIGFjY291bnQgb2YgYW55IGNoYW5nZXMgeW91IG1pZ2h0IGhhdmUgbWFkZSB0byB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0XG5cdCAqIHBhc3NlZCB0byBEYXRhVGFibGVzIChzZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaXMgYW4gYWNrbm93bGVkZ2VtZW50XG5cdCAqIHRoYXQgeW91IHVuZGVyc3RhbmQgdGhpcykuIGBkZXN0cm95YCBjYW4gYmUgdXNlZCB0byByZWluaXRpYWxpc2UgYSB0YWJsZSBpZlxuXHQgKiB5b3UgbmVlZC5cblx0ICovXG5cdFwiYlJldHJpZXZlXCI6IGZhbHNlLFxuXG5cblx0LyoqXG5cdCAqIFdoZW4gdmVydGljYWwgKHkpIHNjcm9sbGluZyBpcyBlbmFibGVkLCBEYXRhVGFibGVzIHdpbGwgZm9yY2UgdGhlIGhlaWdodCBvZlxuXHQgKiB0aGUgdGFibGUncyB2aWV3cG9ydCB0byB0aGUgZ2l2ZW4gaGVpZ2h0IGF0IGFsbCB0aW1lcyAodXNlZnVsIGZvciBsYXlvdXQpLlxuXHQgKiBIb3dldmVyLCB0aGlzIGNhbiBsb29rIG9kZCB3aGVuIGZpbHRlcmluZyBkYXRhIGRvd24gdG8gYSBzbWFsbCBkYXRhIHNldCxcblx0ICogYW5kIHRoZSBmb290ZXIgaXMgbGVmdCBcImZsb2F0aW5nXCIgZnVydGhlciBkb3duLiBUaGlzIHBhcmFtZXRlciAod2hlblxuXHQgKiBlbmFibGVkKSB3aWxsIGNhdXNlIERhdGFUYWJsZXMgdG8gY29sbGFwc2UgdGhlIHRhYmxlJ3Mgdmlld3BvcnQgZG93biB3aGVuXG5cdCAqIHRoZSByZXN1bHQgc2V0IHdpbGwgZml0IHdpdGhpbiB0aGUgZ2l2ZW4gWSBoZWlnaHQuXG5cdCAqL1xuXHRcImJTY3JvbGxDb2xsYXBzZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxuXHQgKiBgYWpheGAgcGFyYW1ldGVyIG11c3QgYWxzbyBiZSBnaXZlbiBpbiBvcmRlciB0byBnaXZlIERhdGFUYWJsZXMgYVxuXHQgKiBzb3VyY2UgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhIGZvciBlYWNoIGRyYXcuXG5cdCAqL1xuXHRcImJTZXJ2ZXJTaWRlXCI6IGZhbHNlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHNvcnRpbmcgb2YgY29sdW1ucy4gU29ydGluZyBvZiBpbmRpdmlkdWFsIGNvbHVtbnMgY2FuIGJlXG5cdCAqIGRpc2FibGVkIGJ5IHRoZSBgc29ydGFibGVgIG9wdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdCAqL1xuXHRcImJTb3J0XCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc3BsYXkgRGF0YVRhYmxlcycgYWJpbGl0eSB0byBzb3J0IG11bHRpcGxlIGNvbHVtbnMgYXQgdGhlXG5cdCAqIHNhbWUgdGltZSAoYWN0aXZhdGVkIGJ5IHNoaWZ0LWNsaWNrIGJ5IHRoZSB1c2VyKS5cblx0ICovXG5cdFwiYlNvcnRNdWx0aVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEFsbG93cyBjb250cm9sIG92ZXIgd2hldGhlciBEYXRhVGFibGVzIHNob3VsZCB1c2UgdGhlIHRvcCAodHJ1ZSkgdW5pcXVlXG5cdCAqIGNlbGwgdGhhdCBpcyBmb3VuZCBmb3IgYSBzaW5nbGUgY29sdW1uLCBvciB0aGUgYm90dG9tIChmYWxzZSAtIGRlZmF1bHQpLlxuXHQgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGNvbXBsZXggaGVhZGVycy5cblx0ICovXG5cdFwiYlNvcnRDZWxsc1RvcFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiB0aGUgY2xhc3NlcyBgc29ydGluZ1xcXzFgLCBgc29ydGluZ1xcXzJgIGFuZFxuXHQgKiBgc29ydGluZ1xcXzNgIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgYmVpbmcgc29ydGVkIG9uLiBUaGlzIGlzXG5cdCAqIHByZXNlbnRlZCBhcyBhIGZlYXR1cmUgc3dpdGNoIGFzIGl0IGNhbiBpbmNyZWFzZSBwcm9jZXNzaW5nIHRpbWUgKHdoaWxlXG5cdCAqIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIGFkZGVkKSBzbyBmb3IgbGFyZ2UgZGF0YSBzZXRzIHlvdSBtaWdodCB3YW50IHRvXG5cdCAqIHR1cm4gdGhpcyBvZmYuXG5cdCAqL1xuXHRcImJTb3J0Q2xhc3Nlc1wiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHN0YXRlIHNhdmluZy4gV2hlbiBlbmFibGVkIEhUTUw1IGBsb2NhbFN0b3JhZ2VgIHdpbGwgYmVcblx0ICogdXNlZCB0byBzYXZlIHRhYmxlIGRpc3BsYXkgaW5mb3JtYXRpb24gc3VjaCBhcyBwYWdpbmF0aW9uIGluZm9ybWF0aW9uLFxuXHQgKiBkaXNwbGF5IGxlbmd0aCwgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLiBBcyBzdWNoIHdoZW4gdGhlIGVuZCB1c2VyIHJlbG9hZHNcblx0ICogdGhlIHBhZ2UgdGhlIGRpc3BsYXkgZGlzcGxheSB3aWxsIG1hdGNoIHdoYXQgdGh5IGhhZCBwcmV2aW91c2x5IHNldCB1cC5cblx0ICovXG5cdFwiYlN0YXRlU2F2ZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgVFIgZWxlbWVudCBpcyBjcmVhdGVkIChhbmQgYWxsIFREIGNoaWxkXG5cdCAqIGVsZW1lbnRzIGhhdmUgYmVlbiBpbnNlcnRlZCksIG9yIHJlZ2lzdGVyZWQgaWYgdXNpbmcgYSBET00gc291cmNlLCBhbGxvd2luZ1xuXHQgKiBtYW5pcHVsYXRpb24gb2YgdGhlIFRSIGVsZW1lbnQgKGFkZGluZyBjbGFzc2VzIGV0YykuXG5cdCAqL1xuXHRcImZuQ3JlYXRlZFJvd1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0ICogZHluYW1pY2FsbHkgbW9kaWZ5IGFueSBhc3BlY3QgeW91IHdhbnQgYWJvdXQgdGhlIGNyZWF0ZWQgRE9NLlxuXHQgKi9cblx0XCJmbkRyYXdDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIElkZW50aWNhbCB0byBmbkhlYWRlckNhbGxiYWNrKCkgYnV0IGZvciB0aGUgdGFibGUgZm9vdGVyIHRoaXMgZnVuY3Rpb25cblx0ICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXG5cdCAqL1xuXHRcImZuRm9vdGVyQ2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBXaGVuIHJlbmRlcmluZyBsYXJnZSBudW1iZXJzIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGZvciB0aGUgdGFibGVcblx0ICogKGkuZS4gXCJTaG93aW5nIDEgdG8gMTAgb2YgNTcgZW50cmllc1wiKSBEYXRhVGFibGVzIHdpbGwgcmVuZGVyIGxhcmdlIG51bWJlcnNcblx0ICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xuXHQgKiByZW5kZXJlZCBhcyBcIjEsMDAwLDAwMFwiKSB0byBoZWxwIHJlYWRhYmlsaXR5IGZvciB0aGUgZW5kIHVzZXIuIFRoaXNcblx0ICogZnVuY3Rpb24gd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2QgRGF0YVRhYmxlcyB1c2VzLlxuXHQgKi9cblx0XCJmbkZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xuXHRcdHJldHVybiB0b0Zvcm1hdC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcblx0XHRcdHRoaXMub0xhbmd1YWdlLnNUaG91c2FuZHNcblx0XHQpO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0ICogZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSBoZWFkZXIgcm93LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBhbmRcblx0ICogZGlzcGxheSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlLlxuXHQgKi9cblx0XCJmbkhlYWRlckNhbGxiYWNrXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG5cdCAqIHN0YXRlIG9mIHRoZSB0YWJsZS4gQWx0aG91Z2ggdGhlIGludGVybmF0aW9uYWxpc2F0aW9uIG9wdGlvbnMgcHJlc2VudGVkIGJ5XG5cdCAqIERhdGFUYWJsZXMgYXJlIHF1aXRlIGNhcGFibGUgb2YgZGVhbGluZyB3aXRoIG1vc3QgY3VzdG9taXNhdGlvbnMsIHRoZXJlIG1heVxuXHQgKiBiZSB0aW1lcyB3aGVyZSB5b3Ugd2lzaCB0byBjdXN0b21pc2UgdGhlIHN0cmluZyBmdXJ0aGVyLiBUaGlzIGNhbGxiYWNrXG5cdCAqIGFsbG93cyB5b3UgdG8gZG8gZXhhY3RseSB0aGF0LlxuXHQgKi9cblx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC4gTm9ybWFsbHkgRGF0YVRhYmxlcyB3aWxsXG5cdCAqIGluaXRpYWxpc2Ugc2VxdWVudGlhbGx5IGFuZCB0aGVyZSB3aWxsIGJlIG5vIG5lZWQgZm9yIHRoaXMgZnVuY3Rpb24sXG5cdCAqIGhvd2V2ZXIsIHRoaXMgZG9lcyBub3QgaG9sZCB0cnVlIHdoZW4gdXNpbmcgZXh0ZXJuYWwgbGFuZ3VhZ2UgaW5mb3JtYXRpb25cblx0ICogc2luY2UgdGhhdCBpcyBvYnRhaW5lZCB1c2luZyBhbiBhc3luYyBYSFIgY2FsbC5cblx0ICovXG5cdFwiZm5Jbml0Q29tcGxldGVcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYXQgdGhlIHZlcnkgc3RhcnQgb2YgZWFjaCB0YWJsZSBkcmF3IGFuZCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlXG5cdCAqIGRyYXcgYnkgcmV0dXJuaW5nIGZhbHNlLCBhbnkgb3RoZXIgcmV0dXJuIChpbmNsdWRpbmcgdW5kZWZpbmVkKSByZXN1bHRzIGluXG5cdCAqIHRoZSBmdWxsIGRyYXcgb2NjdXJyaW5nKS5cblx0ICovXG5cdFwiZm5QcmVEcmF3Q2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gJ3Bvc3QgcHJvY2VzcycgZWFjaCByb3cgYWZ0ZXIgaXQgaGF2ZSBiZWVuXG5cdCAqIGdlbmVyYXRlZCBmb3IgZWFjaCB0YWJsZSBkcmF3LCBidXQgYmVmb3JlIGl0IGlzIHJlbmRlcmVkIG9uIHNjcmVlbi4gVGhpc1xuXHQgKiBmdW5jdGlvbiBtaWdodCBiZSB1c2VkIGZvciBzZXR0aW5nIHRoZSByb3cgY2xhc3MgbmFtZSBldGMuXG5cdCAqL1xuXHRcImZuUm93Q2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBMb2FkIHRoZSB0YWJsZSBzdGF0ZS4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gZGVmaW5lIGZyb20gd2hlcmUsIGFuZCBob3csIHRoZVxuXHQgKiBzdGF0ZSBvZiBhIHRhYmxlIGlzIGxvYWRlZC4gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9hZCBmcm9tIGBsb2NhbFN0b3JhZ2VgXG5cdCAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxuXHQgKi9cblx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKFxuXHRcdFx0XHQoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLmdldEl0ZW0oXG5cdFx0XHRcdFx0J0RhdGFUYWJsZXNfJytzZXR0aW5ncy5zSW5zdGFuY2UrJ18nK2xvY2F0aW9uLnBhdGhuYW1lXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzYXZlZCBzdGF0ZSBwcmlvciB0byBsb2FkaW5nIHRoYXQgc3RhdGUuXG5cdCAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRhYmxlIGlzIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGUgc3RvcmVkIGRhdGEsIGJ1dFxuXHQgKiBwcmlvciB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzYXZlZCBzdGF0ZS4gTm90ZSB0aGF0IGZvclxuXHQgKiBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGQgdXNlIHRoZSBgc3RhdGVMb2FkUGFyYW1zYCBldmVudCB0byBsb2FkIHBhcmFtZXRlcnMgZm9yXG5cdCAqIGEgcGx1Zy1pbi5cblx0ICovXG5cdFwiZm5TdGF0ZUxvYWRQYXJhbXNcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSB0aGUgc3RhdGUgc2F2aW5nIG1ldGhvZFxuXHQgKiBhbmQgdGhlIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIG1vZGlmaWVkIGFzIGEgcmVzdWx0IG9mIHRoZSBsb2FkZWQgc3RhdGUuXG5cdCAqL1xuXHRcImZuU3RhdGVMb2FkZWRcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBTYXZlIHRoZSB0YWJsZSBzdGF0ZS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIGRlZmluZSB3aGVyZSBhbmQgaG93IHRoZSBzdGF0ZVxuXHQgKiBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlIGlzIHN0b3JlZCBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCB1c2UgYGxvY2FsU3RvcmFnZWBcblx0ICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG5cdCAqL1xuXHRcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIjogZnVuY3Rpb24gKCBzZXR0aW5ncywgZGF0YSApIHtcblx0XHR0cnkge1xuXHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5zZXRJdGVtKFxuXHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWUsXG5cdFx0XHRcdEpTT04uc3RyaW5naWZ5KCBkYXRhIClcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gbm9vcFxuXHRcdH1cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSB0byBiZSBzYXZlZC4gQ2FsbGVkIHdoZW4gdGhlIHRhYmxlXG5cdCAqIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmUgaXMgcmVxdWlyZWQuIFRoaXMgbWV0aG9kIGFsbG93cyBtb2RpZmljYXRpb24gb2Zcblx0ICogdGhlIHN0YXRlIHNhdmluZyBvYmplY3QgcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvclxuXHQgKiBvdGhlciBzdGF0ZSBwcm9wZXJ0aWVzIG9yIG1vZGlmaWNhdGlvbi4gTm90ZSB0aGF0IGZvciBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGRcblx0ICogdXNlIHRoZSBgc3RhdGVTYXZlUGFyYW1zYCBldmVudCB0byBzYXZlIHBhcmFtZXRlcnMgZm9yIGEgcGx1Zy1pbi5cblx0ICovXG5cdFwiZm5TdGF0ZVNhdmVQYXJhbXNcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBEdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uIGlzIGNvbnNpZGVyZWQgdmFsaWQuIEFmdGVyIHRoaXMgcGVyaW9kXG5cdCAqIGhhcyBlbGFwc2VkIHRoZSBzdGF0ZSB3aWxsIGJlIHJldHVybmVkIHRvIHRoZSBkZWZhdWx0LlxuXHQgKiBWYWx1ZSBpcyBnaXZlbiBpbiBzZWNvbmRzLlxuXHQgKi9cblx0XCJpU3RhdGVEdXJhdGlvblwiOiA3MjAwLFxuXG5cblx0LyoqXG5cdCAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgb24gYSBzaW5nbGUgcGFnZSB3aGVuIHVzaW5nIHBhZ2luYXRpb24uIElmXG5cdCAqIGZlYXR1cmUgZW5hYmxlZCAoYGxlbmd0aENoYW5nZWApIHRoZW4gdGhlIGVuZCB1c2VyIHdpbGwgYmUgYWJsZSB0byBvdmVycmlkZVxuXHQgKiB0aGlzIHRvIGEgY3VzdG9tIHNldHRpbmcgdXNpbmcgYSBwb3AtdXAgbWVudS5cblx0ICovXG5cdFwiaURpc3BsYXlMZW5ndGhcIjogMTAsXG5cblxuXHQvKipcblx0ICogRGVmaW5lIHRoZSBzdGFydGluZyBwb2ludCBmb3IgZGF0YSBkaXNwbGF5IHdoZW4gdXNpbmcgRGF0YVRhYmxlcyB3aXRoXG5cdCAqIHBhZ2luYXRpb24uIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJhdGhlciB0aGFuXG5cdCAqIHRoZSBwYWdlIG51bWJlciwgc28gaWYgeW91IGhhdmUgMTAgcmVjb3JkcyBwZXIgcGFnZSBhbmQgd2FudCB0byBzdGFydCBvblxuXHQgKiB0aGUgdGhpcmQgcGFnZSwgaXQgc2hvdWxkIGJlIFwiMjBcIi5cblx0ICovXG5cdFwiaURpc3BsYXlTdGFydFwiOiAwLFxuXG5cblx0LyoqXG5cdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcblx0ICogYW5kIGZpbHRlcmluZykgYnkgYWRkaW5nIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUgdG8gdGhlIHJlcXVpcmVkIGVsZW1lbnRzLiBUaGlzXG5cdCAqIGFsbG93cyB5b3UgdG8gdGFiIHRocm91Z2ggdGhlIGNvbnRyb2xzIGFuZCBwcmVzcyB0aGUgZW50ZXIga2V5IHRvIGFjdGl2YXRlIHRoZW0uXG5cdCAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxuXHQgKiBZb3UgY2FuIG92ZXJydWxlIHRoaXMgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgaWYgeW91IHdpc2guIFVzZSBhIHZhbHVlIG9mIC0xIHRvXG5cdCAqIGRpc2FibGUgYnVpbHQtaW4ga2V5Ym9hcmQgbmF2aWdhdGlvbi5cblx0ICovXG5cdFwiaVRhYkluZGV4XCI6IDAsXG5cblxuXHQvKipcblx0ICogQ2xhc3NlcyB0aGF0IERhdGFUYWJsZXMgYXNzaWducyB0byB0aGUgdmFyaW91cyBjb21wb25lbnRzIGFuZCBmZWF0dXJlc1xuXHQgKiB0aGF0IGl0IGFkZHMgdG8gdGhlIEhUTUwgdGFibGUuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gYmUgY29uZmlndXJlZFxuXHQgKiBkdXJpbmcgaW5pdGlhbGlzYXRpb24gaW4gYWRkaXRpb24gdG8gdGhyb3VnaCB0aGUgc3RhdGljXG5cdCAqIHtAbGluayBEYXRhVGFibGUuZXh0Lm9TdGRDbGFzc2VzfSBvYmplY3QpLlxuXHQgKi9cblx0XCJvQ2xhc3Nlc1wiOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBBbGwgc3RyaW5ncyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbiB0aGUgdXNlciBpbnRlcmZhY2UgdGhhdCBpdCBjcmVhdGVzXG5cdCAqIGFyZSBkZWZpbmVkIGluIHRoaXMgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gbW9kaWZpZWQgdGhlbSBpbmRpdmlkdWFsbHkgb3Jcblx0ICogY29tcGxldGVseSByZXBsYWNlIHRoZW0gYWxsIGFzIHJlcXVpcmVkLlxuXHQgKi9cblx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdC8qKlxuXHRcdCAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XG5cdFx0ICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xuXHRcdCAqIG11c3QgYmUgaW50ZXJuYXRpb25hbGlzZWQgYXMgd2VsbCkuXG5cdFx0ICovXG5cdFx0XCJvQXJpYVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlIHNvcnRlZFxuXHRcdFx0ICovXG5cdFx0XHRcIm9yZGVyYWJsZVwiOiBcIjogQWN0aXZhdGUgdG8gc29ydFwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IGJlaW5nIHNvcnRlZFxuXHRcdFx0ICovXG5cdFx0XHRcIm9yZGVyYWJsZVJldmVyc2VcIjogXCI6IEFjdGl2YXRlIHRvIGludmVydCBzb3J0aW5nXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgYmVpbmcgXG5cdFx0XHQgKiBzb3J0ZWQgYW5kIG5leHQgc3RlcCBpcyB0byByZW1vdmUgc29ydGluZ1xuXHRcdFx0ICovXG5cdFx0XHRcIm9yZGVyYWJsZVJlbW92ZVwiOiBcIjogQWN0aXZhdGUgdG8gcmVtb3ZlIHNvcnRpbmdcIixcblxuXHRcdFx0cGFnaW5hdGU6IHtcblx0XHRcdFx0Zmlyc3Q6ICdGaXJzdCcsXG5cdFx0XHRcdGxhc3Q6ICdMYXN0Jyxcblx0XHRcdFx0bmV4dDogJ05leHQnLFxuXHRcdFx0XHRwcmV2aW91czogJ1ByZXZpb3VzJyxcblx0XHRcdFx0bnVtYmVyOiAnJ1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQYWdpbmF0aW9uIHN0cmluZyB1c2VkIGJ5IERhdGFUYWJsZXMgZm9yIHRoZSBidWlsdC1pbiBwYWdpbmF0aW9uXG5cdFx0ICogY29udHJvbCB0eXBlcy5cblx0XHQgKi9cblx0XHRcIm9QYWdpbmF0ZVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIExhYmVsIGFuZCBjaGFyYWN0ZXIgZm9yIGZpcnN0IHBhZ2UgYnV0dG9uICjCqylcblx0XHRcdCAqL1xuXHRcdFx0XCJzRmlyc3RcIjogXCJcXHUwMEFCXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTGFzdCBwYWdlIGJ1dHRvbiAowrspXG5cdFx0XHQgKi9cblx0XHRcdFwic0xhc3RcIjogXCJcXHUwMEJCXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTmV4dCBwYWdlIGJ1dHRvbiAo4oC6KVxuXHRcdFx0ICovXG5cdFx0XHRcInNOZXh0XCI6IFwiXFx1MjAzQVwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFByZXZpb3VzIHBhZ2UgYnV0dG9uICjigLkpXG5cdFx0XHQgKi9cblx0XHRcdFwic1ByZXZpb3VzXCI6IFwiXFx1MjAzOVwiLFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQbHVyYWwgb2JqZWN0IGZvciB0aGUgZGF0YSB0eXBlIHRoZSB0YWJsZSBpcyBzaG93aW5nXG5cdFx0ICovXG5cdFx0ZW50cmllczoge1xuXHRcdFx0XzogXCJlbnRyaWVzXCIsXG5cdFx0XHQxOiBcImVudHJ5XCJcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzdHJpbmcgaXMgc2hvd24gaW4gcHJlZmVyZW5jZSB0byBgemVyb1JlY29yZHNgIHdoZW4gdGhlIHRhYmxlIGlzXG5cdFx0ICogZW1wdHkgb2YgZGF0YSAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLiBOb3RlIHRoYXQgdGhpcyBpcyBhbiBvcHRpb25hbFxuXHRcdCAqIHBhcmFtZXRlciAtIGlmIGl0IGlzIG5vdCBnaXZlbiwgdGhlIHZhbHVlIG9mIGB6ZXJvUmVjb3Jkc2Agd2lsbCBiZSB1c2VkXG5cdFx0ICogaW5zdGVhZCAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGdpdmVuIHZhbHVlKS5cblx0XHQgKi9cblx0XHRcInNFbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzdHJpbmcgZ2l2ZXMgaW5mb3JtYXRpb24gdG8gdGhlIGVuZCB1c2VyIGFib3V0IHRoZSBpbmZvcm1hdGlvblxuXHRcdCAqIHRoYXQgaXMgY3VycmVudCBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLiBUaGUgZm9sbG93aW5nIHRva2VucyBjYW4gYmVcblx0XHQgKiB1c2VkIGluIHRoZSBzdHJpbmcgYW5kIHdpbGwgYmUgZHluYW1pY2FsbHkgcmVwbGFjZWQgYXMgdGhlIHRhYmxlXG5cdFx0ICogZGlzcGxheSB1cGRhdGVzLiBUaGlzIHRva2VucyBjYW4gYmUgcGxhY2VkIGFueXdoZXJlIGluIHRoZSBzdHJpbmcsIG9yXG5cdFx0ICogcmVtb3ZlZCBhcyBuZWVkZWQgYnkgdGhlIGxhbmd1YWdlIHJlcXVpcmVzOlxuXHRcdCAqXG5cdFx0ICogKiBgXFxfU1RBUlRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgZmlyc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHQgKiAqIGBcXF9FTkRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgbGFzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdCAqICogYFxcX1RPVEFMXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSBhZnRlciBmaWx0ZXJpbmdcblx0XHQgKiAqIGBcXF9NQVhcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIHdpdGhvdXQgZmlsdGVyaW5nXG5cdFx0ICogKiBgXFxfUEFHRVxcX2AgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXG5cdFx0ICogKiBgXFxfUEFHRVNcXF9gIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIG9mIGRhdGEgaW4gdGhlIHRhYmxlXG5cdFx0ICovXG5cdFx0XCJzSW5mb1wiOiBcIlNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIF9FTlRSSUVTLVRPVEFMX1wiLFxuXG5cblx0XHQvKipcblx0XHQgKiBEaXNwbGF5IGluZm9ybWF0aW9uIHN0cmluZyBmb3Igd2hlbiB0aGUgdGFibGUgaXMgZW1wdHkuIFR5cGljYWxseSB0aGVcblx0XHQgKiBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIG1hdGNoIGBpbmZvYC5cblx0XHQgKi9cblx0XHRcInNJbmZvRW1wdHlcIjogXCJTaG93aW5nIDAgdG8gMCBvZiAwIF9FTlRSSUVTLVRPVEFMX1wiLFxuXG5cblx0XHQvKipcblx0XHQgKiBXaGVuIGEgdXNlciBmaWx0ZXJzIHRoZSBpbmZvcm1hdGlvbiBpbiBhIHRhYmxlLCB0aGlzIHN0cmluZyBpcyBhcHBlbmRlZFxuXHRcdCAqIHRvIHRoZSBpbmZvcm1hdGlvbiAoYGluZm9gKSB0byBnaXZlIGFuIGlkZWEgb2YgaG93IHN0cm9uZyB0aGUgZmlsdGVyaW5nXG5cdFx0ICogaXMuIFRoZSB2YXJpYWJsZSBfTUFYXyBpcyBkeW5hbWljYWxseSB1cGRhdGVkLlxuXHRcdCAqL1xuXHRcdFwic0luZm9GaWx0ZXJlZFwiOiBcIihmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIF9FTlRSSUVTLU1BWF8pXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIElmIGNhbiBiZSB1c2VmdWwgdG8gYXBwZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBpbmZvIHN0cmluZyBhdCB0aW1lcyxcblx0XHQgKiBhbmQgdGhpcyB2YXJpYWJsZSBkb2VzIGV4YWN0bHkgdGhhdC4gVGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIGFwcGVuZGVkIHRvXG5cdFx0ICogdGhlIGBpbmZvYCAoYGluZm9FbXB0eWAgYW5kIGBpbmZvRmlsdGVyZWRgIGluIHdoYXRldmVyIGNvbWJpbmF0aW9uIHRoZXkgYXJlXG5cdFx0ICogYmVpbmcgdXNlZCkgYXQgYWxsIHRpbWVzLlxuXHRcdCAqL1xuXHRcdFwic0luZm9Qb3N0Rml4XCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZGVjaW1hbCBwbGFjZSBvcGVyYXRvciBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3RoZXJcblx0XHQgKiBsYW5ndWFnZSBvcHRpb25zIHNpbmNlIERhdGFUYWJsZXMgZG9lc24ndCBvdXRwdXQgZmxvYXRpbmcgcG9pbnRcblx0XHQgKiBudW1iZXJzLCBzbyBpdCB3b24ndCBldmVyIHVzZSB0aGlzIGZvciBkaXNwbGF5IG9mIGEgbnVtYmVyLiBSYXRoZXIsXG5cdFx0ICogd2hhdCB0aGlzIHBhcmFtZXRlciBkb2VzIGlzIG1vZGlmeSB0aGUgc29ydCBtZXRob2RzIG9mIHRoZSB0YWJsZSBzb1xuXHRcdCAqIHRoYXQgbnVtYmVycyB3aGljaCBhcmUgaW4gYSBmb3JtYXQgd2hpY2ggaGFzIGEgY2hhcmFjdGVyIG90aGVyIHRoYW5cblx0XHQgKiBhIHBlcmlvZCAoYC5gKSBhcyBhIGRlY2ltYWwgcGxhY2Ugd2lsbCBiZSBzb3J0ZWQgbnVtZXJpY2FsbHkuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgbnVtYmVycyB3aXRoIGRpZmZlcmVudCBkZWNpbWFsIHBsYWNlcyBjYW5ub3QgYmUgc2hvd24gaW5cblx0XHQgKiB0aGUgc2FtZSB0YWJsZSBhbmQgc3RpbGwgYmUgc29ydGFibGUsIHRoZSB0YWJsZSBtdXN0IGJlIGNvbnNpc3RlbnQuXG5cdFx0ICogSG93ZXZlciwgbXVsdGlwbGUgZGlmZmVyZW50IHRhYmxlcyBvbiB0aGUgcGFnZSBjYW4gdXNlIGRpZmZlcmVudFxuXHRcdCAqIGRlY2ltYWwgcGxhY2UgY2hhcmFjdGVycy5cblx0XHQgKi9cblx0XHRcInNEZWNpbWFsXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgaGFzIGEgYnVpbGQgaW4gbnVtYmVyIGZvcm1hdHRlciAoYGZvcm1hdE51bWJlcmApIHdoaWNoIGlzXG5cdFx0ICogdXNlZCB0byBmb3JtYXQgbGFyZ2UgbnVtYmVycyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0YWJsZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBCeSBkZWZhdWx0IGEgY29tbWEgaXMgdXNlZCwgYnV0IHRoaXMgY2FuIGJlIHRyaXZpYWxseSBjaGFuZ2VkIHRvIGFueVxuXHRcdCAqIGNoYXJhY3RlciB5b3Ugd2lzaCB3aXRoIHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqL1xuXHRcdFwic1Rob3VzYW5kc1wiOiBcIixcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogRGV0YWlsIHRoZSBhY3Rpb24gdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIGRyb3AgZG93biBtZW51IGZvciB0aGVcblx0XHQgKiBwYWdpbmF0aW9uIGxlbmd0aCBvcHRpb24gaXMgY2hhbmdlZC4gVGhlICdfTUVOVV8nIHZhcmlhYmxlIGlzIHJlcGxhY2VkXG5cdFx0ICogd2l0aCBhIGRlZmF1bHQgc2VsZWN0IGxpc3Qgb2YgMTAsIDI1LCA1MCBhbmQgMTAwLCBhbmQgY2FuIGJlIHJlcGxhY2VkXG5cdFx0ICogd2l0aCBhIGN1c3RvbSBzZWxlY3QgYm94IGlmIHJlcXVpcmVkLlxuXHRcdCAqL1xuXHRcdFwic0xlbmd0aE1lbnVcIjogXCJfTUVOVV8gX0VOVFJJRVNfIHBlciBwYWdlXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdXNpbmcgQWpheCBzb3VyY2VkIGRhdGEgYW5kIGR1cmluZyB0aGUgZmlyc3QgZHJhdyB3aGVuIERhdGFUYWJsZXMgaXNcblx0XHQgKiBnYXRoZXJpbmcgdGhlIGRhdGEsIHRoaXMgbWVzc2FnZSBpcyBzaG93biBpbiBhbiBlbXB0eSByb3cgaW4gdGhlIHRhYmxlIHRvXG5cdFx0ICogaW5kaWNhdGUgdG8gdGhlIGVuZCB1c2VyIHRoZSB0aGUgZGF0YSBpcyBiZWluZyBsb2FkZWQuIE5vdGUgdGhhdCB0aGlzXG5cdFx0ICogcGFyYW1ldGVyIGlzIG5vdCB1c2VkIHdoZW4gbG9hZGluZyBkYXRhIGJ5IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIGp1c3Rcblx0XHQgKiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcuXG5cdFx0ICovXG5cdFx0XCJzTG9hZGluZ1JlY29yZHNcIjogXCJMb2FkaW5nLi4uXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFRleHQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYmxlIGlzIHByb2Nlc3NpbmcgYSB1c2VyIGFjdGlvblxuXHRcdCAqICh1c3VhbGx5IGEgc29ydCBjb21tYW5kIG9yIHNpbWlsYXIpLlxuXHRcdCAqL1xuXHRcdFwic1Byb2Nlc3NpbmdcIjogXCJcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogRGV0YWlscyB0aGUgYWN0aW9ucyB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgdXNlciB0eXBlcyBpbnRvIHRoZVxuXHRcdCAqIGZpbHRlcmluZyBpbnB1dCB0ZXh0IGJveC4gVGhlIHZhcmlhYmxlIFwiX0lOUFVUX1wiLCBpZiB1c2VkIGluIHRoZSBzdHJpbmcsXG5cdFx0ICogaXMgcmVwbGFjZWQgd2l0aCB0aGUgSFRNTCB0ZXh0IGJveCBmb3IgdGhlIGZpbHRlcmluZyBpbnB1dCBhbGxvd2luZ1xuXHRcdCAqIGNvbnRyb2wgb3ZlciB3aGVyZSBpdCBhcHBlYXJzIGluIHRoZSBzdHJpbmcuIElmIFwiX0lOUFVUX1wiIGlzIG5vdCBnaXZlblxuXHRcdCAqIHRoZW4gdGhlIGlucHV0IGJveCBpcyBhcHBlbmRlZCB0byB0aGUgc3RyaW5nIGF1dG9tYXRpY2FsbHkuXG5cdFx0ICovXG5cdFx0XCJzU2VhcmNoXCI6IFwiU2VhcmNoOlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hQbGFjZWhvbGRlclxuXHRcdCAqL1xuXHRcdFwic1NlYXJjaFBsYWNlaG9sZGVyXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBvZiB0aGUgbGFuZ3VhZ2UgaW5mb3JtYXRpb24gY2FuIGJlIHN0b3JlZCBpbiBhIGZpbGUgb24gdGhlXG5cdFx0ICogc2VydmVyLXNpZGUsIHdoaWNoIERhdGFUYWJsZXMgd2lsbCBsb29rIHVwIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHBhc3NlZC5cblx0XHQgKiBJdCBtdXN0IHN0b3JlIHRoZSBVUkwgb2YgdGhlIGxhbmd1YWdlIGZpbGUsIHdoaWNoIGlzIGluIGEgSlNPTiBmb3JtYXQsXG5cdFx0ICogYW5kIHRoZSBvYmplY3QgaGFzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIG9MYW5ndWFnZSBvYmplY3QgaW4gdGhlXG5cdFx0ICogaW5pdGlhbGlzZXIgb2JqZWN0IChpLmUuIHRoZSBhYm92ZSBwYXJhbWV0ZXJzKS4gUGxlYXNlIHJlZmVyIHRvIG9uZSBvZlxuXHRcdCAqIHRoZSBleGFtcGxlIGxhbmd1YWdlIGZpbGVzIHRvIHNlZSBob3cgdGhpcyB3b3JrcyBpbiBhY3Rpb24uXG5cdFx0ICovXG5cdFx0XCJzVXJsXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFRleHQgc2hvd24gaW5zaWRlIHRoZSB0YWJsZSByZWNvcmRzIHdoZW4gdGhlIGlzIG5vIGluZm9ybWF0aW9uIHRvIGJlXG5cdFx0ICogZGlzcGxheWVkIGFmdGVyIGZpbHRlcmluZy4gYGVtcHR5VGFibGVgIGlzIHNob3duIHdoZW4gdGhlcmUgaXMgc2ltcGx5IG5vXG5cdFx0ICogaW5mb3JtYXRpb24gaW4gdGhlIHRhYmxlIGF0IGFsbCAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLlxuXHRcdCAqL1xuXHRcdFwic1plcm9SZWNvcmRzXCI6IFwiTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFwiXG5cdH0sXG5cblxuXHQvKiogVGhlIGluaXRpYWwgZGF0YSBvcmRlciBpcyByZXZlcnNlZCB3aGVuIGBkZXNjYCBvcmRlcmluZyAqL1xuXHRvcmRlckRlc2NSZXZlcnNlOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gaGF2ZSBkZWZpbmUgdGhlIGdsb2JhbCBmaWx0ZXJpbmcgc3RhdGUgYXRcblx0ICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxuXHQgKiBkZWZpbmVkLCBidXQgYWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBXaGVuIGByZWdleGAgaXMgdHJ1ZSxcblx0ICogdGhlIHNlYXJjaCBzdHJpbmcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCB3aGVuIGZhbHNlXG5cdCAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxuXHQgKiBEYXRhVGFibGVzIHdpbGwgdXNlIGl0J3Mgc21hcnQgZmlsdGVyaW5nIG1ldGhvZHMgKHRvIHdvcmQgbWF0Y2ggYXRcblx0ICogYW55IHBvaW50IGluIHRoZSBkYXRhKSwgd2hlbiBmYWxzZSB0aGlzIHdpbGwgbm90IGJlIGRvbmUuXG5cdCAqL1xuXHRcIm9TZWFyY2hcIjogJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggKSxcblxuXG5cdC8qKlxuXHQgKiBUYWJsZSBhbmQgY29udHJvbCBsYXlvdXQuIFRoaXMgcmVwbGFjZXMgdGhlIGxlZ2FjeSBgZG9tYCBvcHRpb24uXG5cdCAqL1xuXHRsYXlvdXQ6IHtcblx0XHR0b3BTdGFydDogJ3BhZ2VMZW5ndGgnLFxuXHRcdHRvcEVuZDogJ3NlYXJjaCcsXG5cdFx0Ym90dG9tU3RhcnQ6ICdpbmZvJyxcblx0XHRib3R0b21FbmQ6ICdwYWdpbmcnXG5cdH0sXG5cblxuXHQvKipcblx0ICogTGVnYWN5IERPTSBsYXlvdXQgb3B0aW9uXG5cdCAqL1xuXHRcInNEb21cIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZGVsYXkgb3B0aW9uLiBUaGlzIHdpbGwgdGhyb3R0bGUgZnVsbCB0YWJsZSBzZWFyY2hlcyB0aGF0IHVzZSB0aGVcblx0ICogRGF0YVRhYmxlcyBwcm92aWRlZCBzZWFyY2ggaW5wdXQgZWxlbWVudCAoaXQgZG9lcyBub3QgZWZmZWN0IGNhbGxzIHRvXG5cdCAqIGBkdC1hcGkgc2VhcmNoKClgLCBwcm92aWRpbmcgYSBkZWxheSBiZWZvcmUgdGhlIHNlYXJjaCBpcyBtYWRlLlxuXHQgKi9cblx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgZmVhdHVyZXMgc2l4IGRpZmZlcmVudCBidWlsdC1pbiBvcHRpb25zIGZvciB0aGUgYnV0dG9ucyB0b1xuXHQgKiBkaXNwbGF5IGZvciBwYWdpbmF0aW9uIGNvbnRyb2w6XG5cdCAqXG5cdCAqICogYG51bWJlcnNgIC0gUGFnZSBudW1iZXIgYnV0dG9ucyBvbmx5XG5cdCAqICogYHNpbXBsZWAgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucyBvbmx5XG5cdCAqICogJ3NpbXBsZV9udW1iZXJzYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHQgKiAqIGBmdWxsYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnNcblx0ICogKiBgZnVsbF9udW1iZXJzYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXG5cdCAqICogYGZpcnN0X2xhc3RfbnVtYmVyc2AgLSAnRmlyc3QnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0ICovXG5cdFwic1BhZ2luYXRpb25UeXBlXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIGhvcml6b250YWwgc2Nyb2xsaW5nLiBXaGVuIGEgdGFibGUgaXMgdG9vIHdpZGUgdG8gZml0IGludG8gYVxuXHQgKiBjZXJ0YWluIGxheW91dCwgb3IgeW91IGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUsIHlvdVxuXHQgKiBjYW4gZW5hYmxlIHgtc2Nyb2xsaW5nIHRvIHNob3cgdGhlIHRhYmxlIGluIGEgdmlld3BvcnQsIHdoaWNoIGNhbiBiZVxuXHQgKiBzY3JvbGxlZC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYHRydWVgIHdoaWNoIHdpbGwgYWxsb3cgdGhlIHRhYmxlIHRvXG5cdCAqIHNjcm9sbCBob3Jpem9udGFsbHkgd2hlbiBuZWVkZWQsIG9yIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoXG5cdCAqIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLiBTZXR0aW5nIGFzIHNpbXBseSBgdHJ1ZWBcblx0ICogaXMgcmVjb21tZW5kZWQuXG5cdCAqL1xuXHRcInNTY3JvbGxYXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBmb3JjZSBhIERhdGFUYWJsZSB0byB1c2UgbW9yZSB3aWR0aCB0aGFuIGl0XG5cdCAqIG1pZ2h0IG90aGVyd2lzZSBkbyB3aGVuIHgtc2Nyb2xsaW5nIGlzIGVuYWJsZWQuIEZvciBleGFtcGxlIGlmIHlvdSBoYXZlIGFcblx0ICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3Jcblx0ICogXCJvdmVyLXNpemluZ1wiIHRoZSB0YWJsZSwgYW5kIHRodXMgZm9yY2luZyBzY3JvbGxpbmcuIFRoaXMgcHJvcGVydHkgY2FuIGJ5XG5cdCAqIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWxcblx0ICogbWVhc3VyZW1lbnQpLlxuXHQgKi9cblx0XCJzU2Nyb2xsWElubmVyXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIHdpbGwgY29uc3RyYWluIHRoZSBEYXRhVGFibGVcblx0ICogdG8gdGhlIGdpdmVuIGhlaWdodCwgYW5kIGVuYWJsZSBzY3JvbGxpbmcgZm9yIGFueSBkYXRhIHdoaWNoIG92ZXJmbG93cyB0aGVcblx0ICogY3VycmVudCB2aWV3cG9ydC4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBwYWdpbmcgdG8gZGlzcGxheVxuXHQgKiBhIGxvdCBvZiBkYXRhIGluIGEgc21hbGwgYXJlYSAoYWx0aG91Z2ggcGFnaW5nIGFuZCBzY3JvbGxpbmcgY2FuIGJvdGggYmVcblx0ICogZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lKS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYW55IENTUyB1bml0LCBvciBhIG51bWJlclxuXHQgKiAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuXG5cdCAqL1xuXHRcInNTY3JvbGxZXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0ICpcblx0ICogU2V0IHRoZSBIVFRQIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gbWFrZSB0aGUgQWpheCBjYWxsIGZvciBzZXJ2ZXItc2lkZVxuXHQgKiBwcm9jZXNzaW5nIG9yIEFqYXggc291cmNlZCBkYXRhLlxuXHQgKi9cblx0XCJzU2VydmVyTWV0aG9kXCI6IFwiR0VUXCIsXG5cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBtYWtlcyB1c2Ugb2YgcmVuZGVyZXJzIHdoZW4gZGlzcGxheWluZyBIVE1MIGVsZW1lbnRzIGZvclxuXHQgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXG5cdCAqIGdlbmVyYXRlIHN1aXRhYmxlIG1hcmstdXAgZm9yIGEgc2l0ZS4gRm9yIGV4YW1wbGUgdGhlIEJvb3RzdHJhcFxuXHQgKiBpbnRlZ3JhdGlvbiBwbHVnLWluIGZvciBEYXRhVGFibGVzIHVzZXMgYSBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyIHRvXG5cdCAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cblx0ICpcblx0ICogRm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVycyBhdmFpbGFibGUgc2VlXG5cdCAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcblx0ICovXG5cdFwicmVuZGVyZXJcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRhdGEgcHJvcGVydHkgbmFtZSB0aGF0IERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0byBnZXQgYSByb3cncyBpZFxuXHQgKiB0byBzZXQgYXMgdGhlIGBpZGAgcHJvcGVydHkgaW4gdGhlIG5vZGUuXG5cdCAqL1xuXHRcInJvd0lkXCI6IFwiRFRfUm93SWRcIixcblxuXG5cdC8qKlxuXHQgKiBDYXB0aW9uIHZhbHVlXG5cdCAqL1xuXHRcImNhcHRpb25cIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBGb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHVzZSB0aGUgZGF0YSBmcm9tIHRoZSBET00gZm9yIHRoZSBmaXJzdCBkcmF3XG5cdCAqL1xuXHRpRGVmZXJMb2FkaW5nOiBudWxsXG59O1xuXG5fZm5IdW5nYXJpYW5NYXAoIERhdGFUYWJsZS5kZWZhdWx0cyApO1xuXG5cblxuLypcbiAqIERldmVsb3BlciBub3RlIC0gU2VlIG5vdGUgaW4gbW9kZWwuZGVmYXVsdHMuanMgYWJvdXQgdGhlIHVzZSBvZiBIdW5nYXJpYW5cbiAqIG5vdGF0aW9uIGFuZCBjYW1lbCBjYXNlLlxuICovXG5cbi8qKlxuICogQ29sdW1uIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gRGF0YVRhYmxlcyBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiA9IHtcblx0LyoqXG5cdCAqIERlZmluZSB3aGljaCBjb2x1bW4ocykgYW4gb3JkZXIgd2lsbCBvY2N1ciBvbiBmb3IgdGhpcyBjb2x1bW4uIFRoaXNcblx0ICogYWxsb3dzIGEgY29sdW1uJ3Mgb3JkZXJpbmcgdG8gdGFrZSBtdWx0aXBsZSBjb2x1bW5zIGludG8gYWNjb3VudCB3aGVuXG5cdCAqIGRvaW5nIGEgc29ydCBvciB1c2UgdGhlIGRhdGEgZnJvbSBhIGRpZmZlcmVudCBjb2x1bW4uIEZvciBleGFtcGxlIGZpcnN0XG5cdCAqIG5hbWUgLyBsYXN0IG5hbWUgY29sdW1ucyBtYWtlIHNlbnNlIHRvIGRvIGEgbXVsdGktY29sdW1uIHNvcnQgb3ZlciB0aGVcblx0ICogdHdvIGNvbHVtbnMuXG5cdCAqL1xuXHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcImlEYXRhU29ydFwiOiAtMSxcblxuXHRhcmlhVGl0bGU6ICcnLFxuXG5cblx0LyoqXG5cdCAqIFlvdSBjYW4gY29udHJvbCB0aGUgZGVmYXVsdCBvcmRlcmluZyBkaXJlY3Rpb24sIGFuZCBldmVuIGFsdGVyIHRoZVxuXHQgKiBiZWhhdmlvdXIgb2YgdGhlIHNvcnQgaGFuZGxlciAoaS5lLiBvbmx5IGFsbG93IGFzY2VuZGluZyBvcmRlcmluZyBldGMpXG5cdCAqIHVzaW5nIHRoaXMgcGFyYW1ldGVyLlxuXHQgKi9cblx0XCJhc1NvcnRpbmdcIjogWyAnYXNjJywgJ2Rlc2MnLCAnJyBdLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbHRlcmluZyBvbiB0aGUgZGF0YSBpbiB0aGlzIGNvbHVtbi5cblx0ICovXG5cdFwiYlNlYXJjaGFibGVcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBvcmRlcmluZyBvbiB0aGlzIGNvbHVtbi5cblx0ICovXG5cdFwiYlNvcnRhYmxlXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgdGhpcyBjb2x1bW4uXG5cdCAqL1xuXHRcImJWaXNpYmxlXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXG5cdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0ICogYWxsb3dpbmcgeW91IHRvIG1vZGlmeSB0aGUgRE9NIGVsZW1lbnQgKGFkZCBiYWNrZ3JvdW5kIGNvbG91ciBmb3IgZXhhbXBsZSkgd2hlbiB0aGVcblx0ICogZWxlbWVudCBpcyBhdmFpbGFibGUuXG5cdCAqL1xuXHRcImZuQ3JlYXRlZENlbGxcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIHJlYWQgZGF0YSBmcm9tIGFueSBkYXRhIHNvdXJjZSBwcm9wZXJ0eSxcblx0ICogaW5jbHVkaW5nIGRlZXBseSBuZXN0ZWQgb2JqZWN0cyAvIHByb3BlcnRpZXMuIGBkYXRhYCBjYW4gYmUgZ2l2ZW4gaW4gYVxuXHQgKiBudW1iZXIgb2YgZGlmZmVyZW50IHdheXMgd2hpY2ggZWZmZWN0IGl0cyBiZWhhdmlvdXI6XG5cdCAqXG5cdCAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxuXHQgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXG5cdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdCAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xuXHQgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcblx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdCAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xuXHQgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxuXHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdCAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cblx0ICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXG5cdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0ICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxuXHQgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xuXHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHQgKiAgICAgIHJldHVybmVkLlxuXHQgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXG5cdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0ICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXG5cdCAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxuXHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LiBOb3RlIHRoYXRcblx0ICogICAgICBmdW5jdGlvbiBub3RhdGlvbiBpcyByZWNvbW1lbmRlZCBmb3IgdXNlIGluIGByZW5kZXJgIHJhdGhlciB0aGFuXG5cdCAqICAgICAgYGRhdGFgIGFzIGl0IGlzIG11Y2ggc2ltcGxlciB0byB1c2UgYXMgYSByZW5kZXJlci5cblx0ICogKiBgbnVsbGAgLSB1c2UgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IHJhdGhlciB0aGFuIHBsdWNraW5nXG5cdCAqICAgZGF0YSBkaXJlY3RseSBmcm9tIGl0LiBUaGlzIGFjdGlvbiBoYXMgZWZmZWN0cyBvbiB0d28gb3RoZXJcblx0ICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zOlxuXHQgKiAgICAqIGBkZWZhdWx0Q29udGVudGAgLSBXaGVuIG51bGwgaXMgZ2l2ZW4gYXMgdGhlIGBkYXRhYCBvcHRpb24gYW5kXG5cdCAqICAgICAgYGRlZmF1bHRDb250ZW50YCBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB2YWx1ZSBkZWZpbmVkIGJ5XG5cdCAqICAgICAgYGRlZmF1bHRDb250ZW50YCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBjZWxsLlxuXHQgKiAgICAqIGByZW5kZXJgIC0gV2hlbiBudWxsIGlzIHVzZWQgZm9yIHRoZSBgZGF0YWAgb3B0aW9uIGFuZCB0aGUgYHJlbmRlcmBcblx0ICogICAgICBvcHRpb24gaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgd2hvbGUgZGF0YSBzb3VyY2UgZm9yIHRoZVxuXHQgKiAgICAgIHJvdyBpcyB1c2VkIGZvciB0aGUgcmVuZGVyZXIuXG5cdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdCAqICAgdGFrZXMgdGhyZWUgcGFyYW1ldGVyczpcblx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHQgKiAgICAgICogYHthcnJheXxvYmplY3R9YCBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3dcblx0ICogICAgICAqIGB7c3RyaW5nfWAgVGhlIHR5cGUgY2FsbCBkYXRhIHJlcXVlc3RlZCAtIHRoaXMgd2lsbCBiZSAnc2V0JyB3aGVuXG5cdCAqICAgICAgICBzZXR0aW5nIGRhdGEgb3IgJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnLCAnc29ydCcgb3IgdW5kZWZpbmVkXG5cdCAqICAgICAgICB3aGVuIGdhdGhlcmluZyBkYXRhLiBOb3RlIHRoYXQgd2hlbiBgdW5kZWZpbmVkYCBpcyBnaXZlbiBmb3IgdGhlXG5cdCAqICAgICAgICB0eXBlIERhdGFUYWJsZXMgZXhwZWN0cyB0byBnZXQgdGhlIHJhdyBkYXRhIGZvciB0aGUgb2JqZWN0IGJhY2s8XG5cdCAqICAgICAgKiBgeyp9YCBEYXRhIHRvIHNldCB3aGVuIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzICdzZXQnLlxuXHQgKiAgICAqIFJldHVybjpcblx0ICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgbm90IHJlcXVpcmVkIHdoZW4gJ3NldCcgaXNcblx0ICogICAgICAgIHRoZSB0eXBlIG9mIGNhbGwsIGJ1dCBvdGhlcndpc2UgdGhlIHJldHVybiBpcyB3aGF0IHdpbGwgYmUgdXNlZFxuXHQgKiAgICAgICAgZm9yIHRoZSBkYXRhIHJlcXVlc3RlZC5cblx0ICpcblx0ICogTm90ZSB0aGF0IGBkYXRhYCBpcyBhIGdldHRlciBhbmQgc2V0dGVyIG9wdGlvbi4gSWYgeW91IGp1c3QgcmVxdWlyZVxuXHQgKiBmb3JtYXR0aW5nIG9mIGRhdGEgZm9yIG91dHB1dCwgeW91IHdpbGwgbGlrZWx5IHdhbnQgdG8gdXNlIGByZW5kZXJgIHdoaWNoXG5cdCAqIGlzIHNpbXBseSBhIGdldHRlciBhbmQgdGh1cyBzaW1wbGVyIHRvIHVzZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHByaW9yIHRvIERhdGFUYWJsZXMgMS45LjIgYGRhdGFgIHdhcyBjYWxsZWQgYG1EYXRhUHJvcGAuIFRoZVxuXHQgKiBuYW1lIGNoYW5nZSByZWZsZWN0cyB0aGUgZmxleGliaWxpdHkgb2YgdGhpcyBwcm9wZXJ0eSBhbmQgaXMgY29uc2lzdGVudFxuXHQgKiB3aXRoIHRoZSBuYW1pbmcgb2YgbVJlbmRlci4gSWYgJ21EYXRhUHJvcCcgaXMgZ2l2ZW4sIHRoZW4gaXQgd2lsbCBzdGlsbFxuXHQgKiBiZSB1c2VkIGJ5IERhdGFUYWJsZXMsIGFzIGl0IGF1dG9tYXRpY2FsbHkgbWFwcyB0aGUgb2xkIG5hbWUgdG8gdGhlIG5ld1xuXHQgKiBpZiByZXF1aXJlZC5cblx0ICovXG5cdFwibURhdGFcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIHByb3BlcnR5IGlzIHRoZSByZW5kZXJpbmcgcGFydG5lciB0byBgZGF0YWAgYW5kIGl0IGlzIHN1Z2dlc3RlZCB0aGF0XG5cdCAqIHdoZW4geW91IHdhbnQgdG8gbWFuaXB1bGF0ZSBkYXRhIGZvciBkaXNwbGF5IChpbmNsdWRpbmcgZmlsdGVyaW5nLFxuXHQgKiBzb3J0aW5nIGV0Yykgd2l0aG91dCBhbHRlcmluZyB0aGUgdW5kZXJseWluZyBkYXRhIGZvciB0aGUgdGFibGUsIHVzZSB0aGlzXG5cdCAqIHByb3BlcnR5LiBgcmVuZGVyYCBjYW4gYmUgY29uc2lkZXJlZCB0byBiZSB0aGUgdGhlIHJlYWQgb25seSBjb21wYW5pb24gdG9cblx0ICogYGRhdGFgIHdoaWNoIGlzIHJlYWQgLyB3cml0ZSAodGhlbiBhcyBzdWNoIG1vcmUgY29tcGxleCkuIExpa2UgYGRhdGFgXG5cdCAqIHRoaXMgb3B0aW9uIGNhbiBiZSBnaXZlbiBpbiBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0byBlZmZlY3QgaXRzXG5cdCAqIGJlaGF2aW91cjpcblx0ICpcblx0ICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG5cdCAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cblx0ICogKiBgc3RyaW5nYCAtIHJlYWQgYW4gb2JqZWN0IHByb3BlcnR5IGZyb20gdGhlIGRhdGEgc291cmNlLiBUaGVyZSBhcmVcblx0ICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG5cdCAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxuXHQgKiAgICAqIGAuYCAtIERvdHRlZCBKYXZhc2NyaXB0IG5vdGF0aW9uLiBKdXN0IGFzIHlvdSB1c2UgYSBgLmAgaW5cblx0ICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG5cdCAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXG5cdCAqICAgICAgYGJyb3dzZXIubmFtZWAuIElmIHlvdXIgb2JqZWN0IHBhcmFtZXRlciBuYW1lIGNvbnRhaW5zIGEgcGVyaW9kLCB1c2Vcblx0ICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuXHQgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcblx0ICogICAgICBmcm9tIGFuZCBhcnJheSBzb3VyY2UsIGpvaW5pbmcgdGhlIGRhdGEgd2l0aCB0aGUgY2hhcmFjdGVycyBwcm92aWRlZFxuXHQgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG5cdCAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXG5cdCAqICAgICAgYXJlIHByb3ZpZGVkIGJldHdlZW4gdGhlIGJyYWNrZXRzLCB0aGUgb3JpZ2luYWwgYXJyYXkgc291cmNlIGlzXG5cdCAqICAgICAgcmV0dXJuZWQuXG5cdCAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcblx0ICogICAgICBleGVjdXRlIGEgZnVuY3Rpb24gb2YgdGhlIG5hbWUgZ2l2ZW4uIEZvciBleGFtcGxlOiBgYnJvd3NlcigpYCBmb3IgYVxuXHQgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcblx0ICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXG5cdCAqICAgICAgb2JqZWN0IHByb3BlcnR5IGlmIHRoZSBmdW5jdGlvbiBjYWxsZWQgcmV0dXJucyBhbiBvYmplY3QuXG5cdCAqICogYG9iamVjdGAgLSB1c2UgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgZGF0YSB0eXBlcyByZXF1ZXN0ZWQgYnlcblx0ICogICBEYXRhVGFibGVzICgnZmlsdGVyJywgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnKS4gVGhlIHByb3BlcnR5IG5hbWVzXG5cdCAqICAgb2YgdGhlIG9iamVjdCBpcyB0aGUgZGF0YSB0eXBlIHRoZSBwcm9wZXJ0eSByZWZlcnMgdG8gYW5kIHRoZSB2YWx1ZSBjYW5cblx0ICogICBkZWZpbmVkIHVzaW5nIGFuIGludGVnZXIsIHN0cmluZyBvciBmdW5jdGlvbiB1c2luZyB0aGUgc2FtZSBydWxlcyBhc1xuXHQgKiAgIGByZW5kZXJgIG5vcm1hbGx5IGRvZXMuIE5vdGUgdGhhdCBhbiBgX2Agb3B0aW9uIF9tdXN0XyBiZSBzcGVjaWZpZWQuXG5cdCAqICAgVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgeW91IGhhdmVuJ3Qgc3BlY2lmaWVkIGEgdmFsdWUgZm9yXG5cdCAqICAgdGhlIGRhdGEgdHlwZSByZXF1ZXN0ZWQgYnkgRGF0YVRhYmxlcy5cblx0ICogKiBgZnVuY3Rpb25gIC0gdGhlIGZ1bmN0aW9uIGdpdmVuIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbmV2ZXIgRGF0YVRhYmxlc1xuXHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0ICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuXHQgKiAgICAqIFBhcmFtZXRlcnM6XG5cdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKGJhc2VkIG9uIGBkYXRhYClcblx0ICogICAgICAqIHtzdHJpbmd9IFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ2ZpbHRlcicsXG5cdCAqICAgICAgICAnZGlzcGxheScsICd0eXBlJyBvciAnc29ydCcuXG5cdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZnVsbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAobm90IGJhc2VkIG9uXG5cdCAqICAgICAgICBgZGF0YWApXG5cdCAqICAgICogUmV0dXJuOlxuXHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyB3aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlXG5cdCAqICAgICAgICBkYXRhIHJlcXVlc3RlZC5cblx0ICovXG5cdFwibVJlbmRlclwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgY2VsbCB0eXBlIGNyZWF0ZWQgZm9yIHRoZSBjb2x1bW4gLSBlaXRoZXIgVEQgY2VsbHMgb3IgVEggY2VsbHMuIFRoaXNcblx0ICogY2FuIGJlIHVzZWZ1bCBhcyBUSCBjZWxscyBoYXZlIHNlbWFudGljIG1lYW5pbmcgaW4gdGhlIHRhYmxlIGJvZHksIGFsbG93aW5nIHRoZW1cblx0ICogdG8gYWN0IGFzIGEgaGVhZGVyIGZvciBhIHJvdyAoeW91IG1heSB3aXNoIHRvIGFkZCBzY29wZT0ncm93JyB0byB0aGUgVEggZWxlbWVudHMpLlxuXHQgKi9cblx0XCJzQ2VsbFR5cGVcIjogXCJ0ZFwiLFxuXG5cblx0LyoqXG5cdCAqIENsYXNzIHRvIGdpdmUgdG8gZWFjaCBjZWxsIGluIHRoaXMgY29sdW1uLlxuXHQgKi9cblx0XCJzQ2xhc3NcIjogXCJcIixcblxuXHQvKipcblx0ICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxuXHQgKiBpdCBmaW5kcyB0aGUgbG9uZ2VzdCBzdHJpbmcgaW4gZWFjaCBjb2x1bW4gYW5kIHRoZW4gY29uc3RydWN0cyBhXG5cdCAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuXHQgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxuXHQgKiBzdHJpbmcgLSB0aHVzIHRoZSBjYWxjdWxhdGlvbiBjYW4gZ28gd3JvbmcgKGRvaW5nIGl0IHByb3Blcmx5IGFuZCBwdXR0aW5nXG5cdCAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcblx0ICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxuXHQgKiB0ZXh0IHRoYXQgaXMgZm91bmQgdG8gYmUgdGhlIGxvbmdlc3Qgc3RyaW5nIGZvciB0aGUgY29sdW1uIC0gaS5lLiBwYWRkaW5nLlxuXHQgKiBHZW5lcmFsbHkgeW91IHNob3VsZG4ndCBuZWVkIHRoaXMhXG5cdCAqL1xuXHRcInNDb250ZW50UGFkZGluZ1wiOiBcIlwiLFxuXG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHQgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgYGRhdGFgXG5cdCAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXG5cdCAqL1xuXHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpbiBEYXRhVGFibGVzJyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLiBJdCBjYW5cblx0ICogYmUgZXhjZXB0aW9uYWxseSB1c2VmdWwgdG8ga25vdyB3aGF0IGNvbHVtbnMgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcblx0ICogY2xpZW50IHNpZGUsIGFuZCB0byBtYXAgdGhlc2UgdG8gZGF0YWJhc2UgZmllbGRzLiBXaGVuIGRlZmluZWQsIHRoZSBuYW1lc1xuXHQgKiBhbHNvIGFsbG93IERhdGFUYWJsZXMgdG8gcmVvcmRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgaWYgaXQgY29tZXNcblx0ICogYmFjayBpbiBhbiB1bmV4cGVjdGVkIG9yZGVyIChpLmUuIGlmIHlvdSBzd2l0Y2ggeW91ciBjb2x1bW5zIGFyb3VuZCBvbiB0aGVcblx0ICogY2xpZW50LXNpZGUsIHlvdXIgc2VydmVyLXNpZGUgY29kZSBkb2VzIG5vdCBhbHNvIG5lZWQgdXBkYXRpbmcpLlxuXHQgKi9cblx0XCJzTmFtZVwiOiBcIlwiLFxuXG5cblx0LyoqXG5cdCAqIERlZmluZXMgYSBkYXRhIHNvdXJjZSB0eXBlIGZvciB0aGUgb3JkZXJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVhZFxuXHQgKiByZWFsLXRpbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgdGFibGUgKHVwZGF0aW5nIHRoZSBpbnRlcm5hbGx5IGNhY2hlZFxuXHQgKiB2ZXJzaW9uKSBwcmlvciB0byBvcmRlcmluZy4gVGhpcyBhbGxvd3Mgb3JkZXJpbmcgdG8gb2NjdXIgb24gdXNlclxuXHQgKiBlZGl0YWJsZSBlbGVtZW50cyBzdWNoIGFzIGZvcm0gaW5wdXRzLlxuXHQgKi9cblx0XCJzU29ydERhdGFUeXBlXCI6IFwic3RkXCIsXG5cblxuXHQvKipcblx0ICogVGhlIHRpdGxlIG9mIHRoaXMgY29sdW1uLlxuXHQgKi9cblx0XCJzVGl0bGVcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGUgdHlwZSBhbGxvd3MgeW91IHRvIHNwZWNpZnkgaG93IHRoZSBkYXRhIGZvciB0aGlzIGNvbHVtbiB3aWxsIGJlXG5cdCAqIG9yZGVyZWQuIEZvdXIgdHlwZXMgKHN0cmluZywgbnVtZXJpYywgZGF0ZSBhbmQgaHRtbCAod2hpY2ggd2lsbCBzdHJpcFxuXHQgKiBIVE1MIHRhZ3MgYmVmb3JlIG9yZGVyaW5nKSkgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUuIE5vdGUgdGhhdCBvbmx5IGRhdGVcblx0ICogZm9ybWF0cyB1bmRlcnN0b29kIGJ5IEphdmFzY3JpcHQncyBEYXRlKCkgb2JqZWN0IHdpbGwgYmUgYWNjZXB0ZWQgYXMgdHlwZVxuXHQgKiBkYXRlLiBGb3IgZXhhbXBsZTogXCJNYXIgMjYsIDIwMDggNTowMyBQTVwiLiBNYXkgdGFrZSB0aGUgdmFsdWVzOiAnc3RyaW5nJyxcblx0ICogJ251bWVyaWMnLCAnZGF0ZScgb3IgJ2h0bWwnIChieSBkZWZhdWx0KS4gRnVydGhlciB0eXBlcyBjYW4gYmUgYWRkaW5nXG5cdCAqIHRocm91Z2ggcGx1Zy1pbnMuXG5cdCAqL1xuXHRcInNUeXBlXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogRGVmaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4sIHRoaXMgcGFyYW1ldGVyIG1heSB0YWtlIGFueSBDU1MgdmFsdWVcblx0ICogKDNlbSwgMjBweCBldGMpLiBEYXRhVGFibGVzIGFwcGxpZXMgJ3NtYXJ0JyB3aWR0aHMgdG8gY29sdW1ucyB3aGljaCBoYXZlIG5vdFxuXHQgKiBiZWVuIGdpdmVuIGEgc3BlY2lmaWMgd2lkdGggdGhyb3VnaCB0aGlzIGludGVyZmFjZSBlbnN1cmluZyB0aGF0IHRoZSB0YWJsZVxuXHQgKiByZW1haW5zIHJlYWRhYmxlLlxuXHQgKi9cblx0XCJzV2lkdGhcIjogbnVsbFxufTtcblxuX2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uICk7XG5cblxuXG4vKipcbiAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IC0gdGhpcyBob2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYVxuICogZ2l2ZW4gdGFibGUsIGluY2x1ZGluZyBjb25maWd1cmF0aW9uLCBkYXRhIGFuZCBjdXJyZW50IGFwcGxpY2F0aW9uIG9mIHRoZVxuICogdGFibGUgb3B0aW9ucy4gRGF0YVRhYmxlcyBkb2VzIG5vdCBoYXZlIGEgc2luZ2xlIGluc3RhbmNlIGZvciBlYWNoIERhdGFUYWJsZVxuICogd2l0aCB0aGUgc2V0dGluZ3MgYXR0YWNoZWQgdG8gdGhhdCBpbnN0YW5jZSwgYnV0IHJhdGhlciBpbnN0YW5jZXMgb2YgdGhlXG4gKiBEYXRhVGFibGUgXCJjbGFzc1wiIGFyZSBjcmVhdGVkIG9uLXRoZS1mbHkgYXMgbmVlZGVkICh0eXBpY2FsbHkgYnkgYVxuICogJCgpLmRhdGFUYWJsZSgpIGNhbGwpIGFuZCB0aGUgc2V0dGluZ3Mgb2JqZWN0IGlzIHRoZW4gYXBwbGllZCB0byB0aGF0XG4gKiBpbnN0YW5jZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfSBidXQgdGhpc1xuICogb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy4gSXQgc2hvdWxkXG4gKiBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGQgYmUgZG9uZVxuICogdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cbiAqL1xuRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MgPSB7XG5cdC8qKlxuXHQgKiBQcmltYXJ5IGZlYXR1cmVzIG9mIERhdGFUYWJsZXMgYW5kIHRoZWlyIGVuYWJsZW1lbnQgc3RhdGUuXG5cdCAqL1xuXHRcIm9GZWF0dXJlc1wiOiB7XG5cblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIHNheSBpZiBEYXRhVGFibGVzIHNob3VsZCBhdXRvbWF0aWNhbGx5IHRyeSB0byBjYWxjdWxhdGUgdGhlXG5cdFx0ICogb3B0aW11bSB0YWJsZSBhbmQgY29sdW1ucyB3aWR0aHMgKHRydWUpIG9yIG5vdCAoZmFsc2UpLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJBdXRvV2lkdGhcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIERlbGF5IHRoZSBjcmVhdGlvbiBvZiBUUiBhbmQgVEQgZWxlbWVudHMgdW50aWwgdGhleSBhcmUgYWN0dWFsbHlcblx0XHQgKiBuZWVkZWQgYnkgYSBkcml2ZW4gcGFnZSBkcmF3LiBUaGlzIGNhbiBnaXZlIGEgc2lnbmlmaWNhbnQgc3BlZWRcblx0XHQgKiBpbmNyZWFzZSBmb3IgQWpheCBzb3VyY2UgYW5kIEphdmFzY3JpcHQgc291cmNlIGRhdGEsIGJ1dCBtYWtlcyBub1xuXHRcdCAqIGRpZmZlcmVuY2UgYXQgYWxsIGZvciBET00gYW5kIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJEZWZlclJlbmRlclwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIGZpbHRlcmluZyBvbiB0aGUgdGFibGUgb3Igbm90LiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBkaXNhYmxlZFxuXHRcdCAqIHRoZW4gdGhlcmUgaXMgbm8gZmlsdGVyaW5nIGF0IGFsbCBvbiB0aGUgdGFibGUsIGluY2x1ZGluZyBmbkZpbHRlci5cblx0XHQgKiBUbyBqdXN0IHJlbW92ZSB0aGUgZmlsdGVyaW5nIGlucHV0IHVzZSBzRG9tIGFuZCByZW1vdmUgdGhlICdmJyBvcHRpb24uXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYkZpbHRlclwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogVXNlZCBvbmx5IGZvciBjb21wYXRpYmxpdHkgd2l0aCBEVDFcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFwiYkluZm9cIjogdHJ1ZSxcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgb25seSBmb3IgY29tcGF0aWJsaXR5IHdpdGggRFQxXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJMZW5ndGhDaGFuZ2VcIjogdHJ1ZSxcblxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luYXRpb24gZW5hYmxlZCBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkIHRoZW4gbGVuZ3RoXG5cdFx0ICogY2hhbmdpbmcgbXVzdCBhbHNvIGJlIGRpc2FibGVkLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJQYWdpbmF0ZVwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogUHJvY2Vzc2luZyBpbmRpY2F0b3IgZW5hYmxlIGZsYWcgd2hlbmV2ZXIgRGF0YVRhYmxlcyBpcyBlbmFjdGluZyBhXG5cdFx0ICogdXNlciByZXF1ZXN0IC0gdHlwaWNhbGx5IGFuIEFqYXggcmVxdWVzdCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiUHJvY2Vzc2luZ1wiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBlbmFibGVkIGZsYWcgLSB3aGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsXG5cdFx0ICogZ2V0IGFsbCBkYXRhIGZyb20gdGhlIHNlcnZlciBmb3IgZXZlcnkgZHJhdyAtIHRoZXJlIGlzIG5vIGZpbHRlcmluZyxcblx0XHQgKiBzb3J0aW5nIG9yIHBhZ2luZyBkb25lIG9uIHRoZSBjbGllbnQtc2lkZS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiU2VydmVyU2lkZVwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogU29ydGluZyBlbmFibGVtZW50IGZsYWcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYlNvcnRcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIE11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYlNvcnRNdWx0aVwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgYSBjbGFzcyB0byB0aGUgY29sdW1ucyB3aGljaCBhcmUgYmVpbmcgc29ydGVkIHRvIHByb3ZpZGUgYVxuXHRcdCAqIHZpc3VhbCBoaWdobGlnaHQgb3Igbm90LiBUaGlzIGNhbiBzbG93IHRoaW5ncyBkb3duIHdoZW4gZW5hYmxlZCBzaW5jZVxuXHRcdCAqIHRoZXJlIGlzIGEgbG90IG9mIERPTSBpbnRlcmFjdGlvbi5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiU29ydENsYXNzZXNcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFN0YXRlIHNhdmluZyBlbmFibGVtZW50IGZsYWcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYlN0YXRlU2F2ZVwiOiBudWxsXG5cdH0sXG5cblxuXHQvKipcblx0ICogU2Nyb2xsaW5nIHNldHRpbmdzIGZvciBhIHRhYmxlLlxuXHQgKi9cblx0XCJvU2Nyb2xsXCI6IHtcblx0XHQvKipcblx0XHQgKiBXaGVuIHRoZSB0YWJsZSBpcyBzaG9ydGVyIGluIGhlaWdodCB0aGFuIHNTY3JvbGxZLCBjb2xsYXBzZSB0aGVcblx0XHQgKiB0YWJsZSBjb250YWluZXIgZG93biB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSAod2hlbiB0cnVlKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiQ29sbGFwc2VcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIG9mIHRoZSBzY3JvbGxiYXIgZm9yIHRoZSB3ZWItYnJvd3NlcidzIHBsYXRmb3JtLiBDYWxjdWxhdGVkXG5cdFx0ICogZHVyaW5nIHRhYmxlIGluaXRpYWxpc2F0aW9uLlxuXHRcdCAqL1xuXHRcdFwiaUJhcldpZHRoXCI6IDAsXG5cblx0XHQvKipcblx0XHQgKiBWaWV3cG9ydCB3aWR0aCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIEhvcml6b250YWwgc2Nyb2xsaW5nIGlzXG5cdFx0ICogZGlzYWJsZWQgaWYgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcInNYXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBXaWR0aCB0byBleHBhbmQgdGhlIHRhYmxlIHRvIHdoZW4gdXNpbmcgeC1zY3JvbGxpbmcuIFR5cGljYWxseSB5b3Vcblx0XHQgKiBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoaXMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFwic1hJbm5lclwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogVmlld3BvcnQgaGVpZ2h0IGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyBpcyBkaXNhYmxlZFxuXHRcdCAqIGlmIGFuIGVtcHR5IHN0cmluZy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJzWVwiOiBudWxsXG5cdH0sXG5cblx0LyoqXG5cdCAqIExhbmd1YWdlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUuXG5cdCAqL1xuXHRcIm9MYW5ndWFnZVwiOiB7XG5cdFx0LyoqXG5cdFx0ICogSW5mb3JtYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24uIFNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuZm5JbmZvQ2FsbGJhY2t9XG5cdFx0ICovXG5cdFx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsXG5cdH0sXG5cblx0LyoqXG5cdCAqIEJyb3dzZXIgc3VwcG9ydCBwYXJhbWV0ZXJzXG5cdCAqL1xuXHRcIm9Ccm93c2VyXCI6IHtcblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyBvbiB0aGUgcmlnaHQgb3IgbGVmdCBvZiB0aGVcblx0XHQgKiBzY3JvbGxpbmcgY29udGFpbmVyIC0gbmVlZGVkIGZvciBydGwgbGFuZ3VhZ2UgbGF5b3V0LCBhbHRob3VnaCBub3Rcblx0XHQgKiBhbGwgYnJvd3NlcnMgbW92ZSB0aGUgc2Nyb2xsYmFyIChTYWZhcmkpLlxuXHRcdCAqL1xuXHRcdFwiYlNjcm9sbGJhckxlZnRcIjogZmFsc2UsXG5cblx0XHQvKipcblx0XHQgKiBCcm93c2VyIHNjcm9sbGJhciB3aWR0aFxuXHRcdCAqL1xuXHRcdFwiYmFyV2lkdGhcIjogMFxuXHR9LFxuXG5cblx0XCJhamF4XCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogQXJyYXkgcmVmZXJlbmNpbmcgdGhlIG5vZGVzIHdoaWNoIGFyZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMuIFRoZVxuXHQgKiBwYXJhbWV0ZXJzIG9mIHRoaXMgb2JqZWN0IG1hdGNoIHdoYXQgaXMgYWxsb3dlZCBieSBzRG9tIC0gaS5lLlxuXHQgKiAgIDx1bD5cblx0ICogICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxuXHQgKiAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XG5cdCAqICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XG5cdCAqICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxuXHQgKiAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxuXHQgKiAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxuXHQgKiAgIDwvdWw+XG5cdCAqL1xuXHRcImFhbkZlYXR1cmVzXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZSBkYXRhIGluZm9ybWF0aW9uIC0gc2VlIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9Sb3d9IGZvciBkZXRhaWxlZFxuXHQgKiBpbmZvcm1hdGlvbi5cblx0ICovXG5cdFwiYW9EYXRhXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBpbmRleGVzIHdoaWNoIGFyZSBpbiB0aGUgY3VycmVudCBkaXNwbGF5IChhZnRlciBmaWx0ZXJpbmcgZXRjKVxuXHQgKi9cblx0XCJhaURpc3BsYXlcIjogW10sXG5cblx0LyoqXG5cdCAqIEFycmF5IG9mIGluZGV4ZXMgZm9yIGRpc3BsYXkgLSBubyBmaWx0ZXJpbmdcblx0ICovXG5cdFwiYWlEaXNwbGF5TWFzdGVyXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBNYXAgb2Ygcm93IGlkcyB0byBkYXRhIGluZGV4ZXNcblx0ICovXG5cdFwiYUlkc1wiOiB7fSxcblxuXHQvKipcblx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBjb2x1bW4gdGhhdCBpcyBpbiB1c2Vcblx0ICovXG5cdFwiYW9Db2x1bW5zXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBoZWFkZXJcblx0ICovXG5cdFwiYW9IZWFkZXJcIjogW10sXG5cblx0LyoqXG5cdCAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSdzIGZvb3RlclxuXHQgKi9cblx0XCJhb0Zvb3RlclwiOiBbXSxcblxuXHQvKipcblx0ICogU3RvcmUgdGhlIGFwcGxpZWQgZ2xvYmFsIHNlYXJjaCBpbmZvcm1hdGlvbiBpbiBjYXNlIHdlIHdhbnQgdG8gZm9yY2UgYVxuXHQgKiByZXNlYXJjaCBvciBjb21wYXJlIHRoZSBvbGQgc2VhcmNoIHRvIGEgbmV3IG9uZS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwib1ByZXZpb3VzU2VhcmNoXCI6IHt9LFxuXG5cdC8qKlxuXHQgKiBTdG9yZSBmb3IgbmFtZWQgc2VhcmNoZXNcblx0ICovXG5cdHNlYXJjaEZpeGVkOiB7fSxcblxuXHQvKipcblx0ICogU3RvcmUgdGhlIGFwcGxpZWQgc2VhcmNoIGZvciBlYWNoIGNvbHVtbiAtIHNlZVxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNofSBmb3IgdGhlIGZvcm1hdCB0aGF0IGlzIHVzZWQgZm9yIHRoZVxuXHQgKiBmaWx0ZXJpbmcgaW5mb3JtYXRpb24gZm9yIGVhY2ggY29sdW1uLlxuXHQgKi9cblx0XCJhb1ByZVNlYXJjaENvbHNcIjogW10sXG5cblx0LyoqXG5cdCAqIFNvcnRpbmcgdGhhdCBpcyBhcHBsaWVkIHRvIHRoZSB0YWJsZS4gTm90ZSB0aGF0IHRoZSBpbm5lciBhcnJheXMgYXJlXG5cdCAqIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBtYW5uZXI6XG5cdCAqIDx1bD5cblx0ICogICA8bGk+SW5kZXggMCAtIGNvbHVtbiBudW1iZXI8L2xpPlxuXHQgKiAgIDxsaT5JbmRleCAxIC0gY3VycmVudCBzb3J0aW5nIGRpcmVjdGlvbjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcImFhU29ydGluZ1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBTb3J0aW5nIHRoYXQgaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIChpLmUuIHByZWZpeGVkIGluIGZyb250IG9mXG5cdCAqIGFhU29ydGluZykuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyB3aWR0aFxuXHQgKi9cblx0XCJzRGVzdHJveVdpZHRoXCI6IDAsXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBhcnJheSBmb3IgZXZlcnkgdGltZSBhIHJvdyBpcyBpbnNlcnRlZCAoaS5lLiBvbiBhIGRyYXcpLlxuXHQgKi9cblx0XCJhb1Jvd0NhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBoZWFkZXIgb24gZWFjaCBkcmF3LlxuXHQgKi9cblx0XCJhb0hlYWRlckNhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGZvb3RlciBvbiBlYWNoIGRyYXcuXG5cdCAqL1xuXHRcImFvRm9vdGVyQ2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZHJhdyBjYWxsYmFjayBmdW5jdGlvbnNcblx0ICovXG5cdFwiYW9EcmF3Q2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igcm93IGNyZWF0ZWQgZnVuY3Rpb25cblx0ICovXG5cdFwiYW9Sb3dDcmVhdGVkQ2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IganVzdCBiZWZvcmUgdGhlIHRhYmxlIGlzIHJlZHJhd24uIEEgcmV0dXJuIG9mXG5cdCAqIGZhbHNlIHdpbGwgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcuXG5cdCAqL1xuXHRcImFvUHJlRHJhd0NhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLlxuXHQgKi9cblx0XCJhb0luaXRDb21wbGV0ZVwiOiBbXSxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdG8gYmUgc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmcsIHByaW9yIHRvXG5cdCAqIHNhdmluZyBzdGF0ZS5cblx0ICovXG5cdFwiYW9TdGF0ZVNhdmVQYXJhbXNcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0aGF0IGhhdmUgYmVlbiBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZ1xuXHQgKiBwcmlvciB0byB1c2luZyB0aGUgc3RvcmVkIHZhbHVlcyB0byByZXN0b3JlIHRoZSBzdGF0ZS5cblx0ICovXG5cdFwiYW9TdGF0ZUxvYWRQYXJhbXNcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrcyBmb3Igb3BlcmF0aW5nIG9uIHRoZSBzZXR0aW5ncyBvYmplY3Qgb25jZSB0aGUgc2F2ZWQgc3RhdGUgaGFzIGJlZW5cblx0ICogbG9hZGVkXG5cdCAqL1xuXHRcImFvU3RhdGVMb2FkZWRcIjogW10sXG5cblx0LyoqXG5cdCAqIENhY2hlIHRoZSB0YWJsZSBJRCBmb3IgcXVpY2sgYWNjZXNzXG5cdCAqL1xuXHRcInNUYWJsZUlkXCI6IFwiXCIsXG5cblx0LyoqXG5cdCAqIFRoZSBUQUJMRSBub2RlIGZvciB0aGUgbWFpbiB0YWJsZVxuXHQgKi9cblx0XCJuVGFibGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGhlYWQgZWxlbWVudFxuXHQgKi9cblx0XCJuVEhlYWRcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGZvb3QgZWxlbWVudCAtIGlmIGl0IGV4aXN0c1xuXHQgKi9cblx0XCJuVEZvb3RcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGJvZHkgZWxlbWVudFxuXHQgKi9cblx0XCJuVEJvZHlcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ2FjaGUgdGhlIHdyYXBwZXIgbm9kZSAoY29udGFpbnMgYWxsIERhdGFUYWJsZXMgY29udHJvbGxlZCBlbGVtZW50cylcblx0ICovXG5cdFwiblRhYmxlV3JhcHBlclwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZSBpZiBhbGwgcmVxdWlyZWQgaW5mb3JtYXRpb24gaGFzIGJlZW4gcmVhZCBpblxuXHQgKi9cblx0XCJiSW5pdGlhbGlzZWRcIjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIEluZm9ybWF0aW9uIGFib3V0IG9wZW4gcm93cy4gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5IGhhcyB0aGUgcGFyYW1ldGVyc1xuXHQgKiAnblRyJyBhbmQgJ25QYXJlbnQnXG5cdCAqL1xuXHRcImFvT3BlblJvd3NcIjogW10sXG5cblx0LyoqXG5cdCAqIERpY3RhdGUgdGhlIHBvc2l0aW9uaW5nIG9mIERhdGFUYWJsZXMnIGNvbnRyb2wgZWxlbWVudHMgLSBzZWVcblx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbC5vSW5pdC5zRG9tfS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwic0RvbVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZGVsYXkgKGluIG1TKVxuXHQgKi9cblx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBXaGljaCB0eXBlIG9mIHBhZ2luYXRpb24gc2hvdWxkIGJlIHVzZWQuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcInNQYWdpbmF0aW9uVHlwZVwiOiBcInR3b19idXR0b25cIixcblxuXHQvKipcblx0ICogTnVtYmVyIG9mIHBhZ2luZyBjb250cm9scyBvbiB0aGUgcGFnZS4gT25seSB1c2VkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHQgKi9cblx0cGFnaW5nQ29udHJvbHM6IDAsXG5cblx0LyoqXG5cdCAqIFRoZSBzdGF0ZSBkdXJhdGlvbiAoZm9yIGBzdGF0ZVNhdmVgKSBpbiBzZWNvbmRzLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJpU3RhdGVEdXJhdGlvblwiOiAwLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIHNhdmluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG5cdCAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0ICogICA8dWw+XG5cdCAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG5cdCAqICAgICAgIGFuZCB0aGUgSlNPTiBzdHJpbmcgdG8gc2F2ZSB0aGF0IGhhcyBiZWVuIHRodXMgZmFyIGNyZWF0ZWQuIFJldHVybnNcblx0ICogICAgICAgYSBKU09OIHN0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIGEganNvbiBvYmplY3Rcblx0ICogICAgICAgKGkuZS4gJ1wicGFyYW1cIjogWyAwLCAxLCAyXScpPC9saT5cblx0ICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cblx0ICogICA8L3VsPlxuXHQgKi9cblx0XCJhb1N0YXRlU2F2ZVwiOiBbXSxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBsb2FkaW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cblx0ICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuXHQgKiAgIDx1bD5cblx0ICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3Ncblx0ICogICAgICAgYW5kIHRoZSBvYmplY3Qgc3RvcmVkLiBNYXkgcmV0dXJuIGZhbHNlIHRvIGNhbmNlbCBzdGF0ZSBsb2FkaW5nPC9saT5cblx0ICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cblx0ICogICA8L3VsPlxuXHQgKi9cblx0XCJhb1N0YXRlTG9hZFwiOiBbXSxcblxuXHQvKipcblx0ICogU3RhdGUgdGhhdCB3YXMgc2F2ZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2Vcblx0ICovXG5cdFwib1NhdmVkU3RhdGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogU3RhdGUgdGhhdCB3YXMgbG9hZGVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdCAqL1xuXHRcIm9Mb2FkZWRTdGF0ZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBOb3RlIGlmIGRyYXcgc2hvdWxkIGJlIGJsb2NrZWQgd2hpbGUgZ2V0dGluZyBkYXRhXG5cdCAqL1xuXHRcImJBamF4RGF0YUdldFwiOiB0cnVlLFxuXG5cdC8qKlxuXHQgKiBUaGUgbGFzdCBqUXVlcnkgWEhSIG9iamVjdCB0aGF0IHdhcyB1c2VkIGZvciBzZXJ2ZXItc2lkZSBkYXRhIGdhdGhlcmluZy5cblx0ICogVGhpcyBjYW4gYmUgdXNlZCBmb3Igd29ya2luZyB3aXRoIHRoZSBYSFIgaW5mb3JtYXRpb24gaW4gb25lIG9mIHRoZVxuXHQgKiBjYWxsYmFja3Ncblx0ICovXG5cdFwianFYSFJcIjogbnVsbCxcblxuXHQvKipcblx0ICogSlNPTiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgaW4gdGhlIGxhc3QgQWpheCByZXF1ZXN0XG5cdCAqL1xuXHRcImpzb25cIjogdW5kZWZpbmVkLFxuXG5cdC8qKlxuXHQgKiBEYXRhIHN1Ym1pdHRlZCBhcyBwYXJ0IG9mIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHQgKi9cblx0XCJvQWpheERhdGFcIjogdW5kZWZpbmVkLFxuXG5cdC8qKlxuXHQgKiBTZW5kIHRoZSBYSFIgSFRUUCBtZXRob2QgLSBHRVQgb3IgUE9TVCAoY291bGQgYmUgUFVUIG9yIERFTEVURSBpZlxuXHQgKiByZXF1aXJlZCkuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcInNTZXJ2ZXJNZXRob2RcIjogbnVsbCxcblxuXHQvKipcblx0ICogRm9ybWF0IG51bWJlcnMgZm9yIGRpc3BsYXkuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcImZuRm9ybWF0TnVtYmVyXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIExpc3Qgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGZvciB0aGUgdXNlciBzZWxlY3RhYmxlIGxlbmd0aCBtZW51LlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJhTGVuZ3RoTWVudVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBDb3VudGVyIGZvciB0aGUgZHJhd3MgdGhhdCB0aGUgdGFibGUgZG9lcy4gQWxzbyB1c2VkIGFzIGEgdHJhY2tlciBmb3Jcblx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHQgKi9cblx0XCJpRHJhd1wiOiAwLFxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZSBpZiBhIHJlZHJhdyBpcyBiZWluZyBkb25lIC0gdXNlZnVsIGZvciBBamF4XG5cdCAqL1xuXHRcImJEcmF3aW5nXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBEcmF3IGluZGV4IChpRHJhdykgb2YgdGhlIGxhc3QgZXJyb3Igd2hlbiBwYXJzaW5nIHRoZSByZXR1cm5lZCBkYXRhXG5cdCAqL1xuXHRcImlEcmF3RXJyb3JcIjogLTEsXG5cblx0LyoqXG5cdCAqIFBhZ2luZyBkaXNwbGF5IGxlbmd0aFxuXHQgKi9cblx0XCJfaURpc3BsYXlMZW5ndGhcIjogMTAsXG5cblx0LyoqXG5cdCAqIFBhZ2luZyBzdGFydCBwb2ludCAtIGFpRGlzcGxheSBpbmRleFxuXHQgKi9cblx0XCJfaURpc3BsYXlTdGFydFwiOiAwLFxuXG5cdC8qKlxuXHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHJlc3VsdCBzZXRcblx0ICogKGkuZS4gYmVmb3JlIGZpbHRlcmluZyksIFVzZSBmblJlY29yZHNUb3RhbCByYXRoZXIgdGhhblxuXHQgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXG5cdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdCAqL1xuXHRcIl9pUmVjb3Jkc1RvdGFsXCI6IDAsXG5cblx0LyoqXG5cdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCBkaXNwbGF5IHNldFxuXHQgKiAoaS5lLiBhZnRlciBmaWx0ZXJpbmcpLiBVc2UgZm5SZWNvcmRzRGlzcGxheSByYXRoZXIgdGhhblxuXHQgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXG5cdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdCAqL1xuXHRcIl9pUmVjb3Jkc0Rpc3BsYXlcIjogMCxcblxuXHQvKipcblx0ICogVGhlIGNsYXNzZXMgdG8gdXNlIGZvciB0aGUgdGFibGVcblx0ICovXG5cdFwib0NsYXNzZXNcIjoge30sXG5cblx0LyoqXG5cdCAqIEZsYWcgYXR0YWNoZWQgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBzbyB5b3UgY2FuIGNoZWNrIGluIHRoZSBkcmF3XG5cdCAqIGNhbGxiYWNrIGlmIGZpbHRlcmluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxuXHQgKiBldmVudHMuXG5cdCAqICBAZGVwcmVjYXRlZFxuXHQgKi9cblx0XCJiRmlsdGVyZWRcIjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIEZsYWcgYXR0YWNoZWQgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBzbyB5b3UgY2FuIGNoZWNrIGluIHRoZSBkcmF3XG5cdCAqIGNhbGxiYWNrIGlmIHNvcnRpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0ICogZXZlbnRzLlxuXHQgKiAgQGRlcHJlY2F0ZWRcblx0ICovXG5cdFwiYlNvcnRlZFwiOiBmYWxzZSxcblxuXHQvKipcblx0ICogSW5kaWNhdGUgdGhhdCBpZiBtdWx0aXBsZSByb3dzIGFyZSBpbiB0aGUgaGVhZGVyIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW5cblx0ICogb25lIHVuaXF1ZSBjZWxsIHBlciBjb2x1bW4sIGlmIHRoZSB0b3Agb25lICh0cnVlKSBvciBib3R0b20gb25lIChmYWxzZSlcblx0ICogc2hvdWxkIGJlIHVzZWQgZm9yIHNvcnRpbmcgLyB0aXRsZSBieSBEYXRhVGFibGVzLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJiU29ydENlbGxzVG9wXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpc2F0aW9uIG9iamVjdCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZVxuXHQgKi9cblx0XCJvSW5pdFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGNhbGxiYWNrIGZ1bmN0aW9ucyAtIGZvciBwbHVnLWlucyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0byB0aGVcblx0ICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cblx0ICovXG5cdFwiYW9EZXN0cm95Q2FsbGJhY2tcIjogW10sXG5cblxuXHQvKipcblx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXG5cdCAqL1xuXHRcImZuUmVjb3Jkc1RvdGFsXCI6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gX2ZuRGF0YVNvdXJjZSggdGhpcyApID09ICdzc3AnID9cblx0XHRcdHRoaXMuX2lSZWNvcmRzVG90YWwgKiAxIDpcblx0XHRcdHRoaXMuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0ICovXG5cdFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIF9mbkRhdGFTb3VyY2UoIHRoaXMgKSA9PSAnc3NwJyA/XG5cdFx0XHR0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcblx0XHRcdHRoaXMuYWlEaXNwbGF5Lmxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBkaXNwbGF5IGVuZCBwb2ludCAtIGFpRGlzcGxheSBpbmRleFxuXHQgKi9cblx0XCJmbkRpc3BsYXlFbmRcIjogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhclxuXHRcdFx0bGVuICAgICAgPSB0aGlzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdHN0YXJ0ICAgID0gdGhpcy5faURpc3BsYXlTdGFydCxcblx0XHRcdGNhbGMgICAgID0gc3RhcnQgKyBsZW4sXG5cdFx0XHRyZWNvcmRzICA9IHRoaXMuYWlEaXNwbGF5Lmxlbmd0aCxcblx0XHRcdGZlYXR1cmVzID0gdGhpcy5vRmVhdHVyZXMsXG5cdFx0XHRwYWdpbmF0ZSA9IGZlYXR1cmVzLmJQYWdpbmF0ZTtcblxuXHRcdGlmICggZmVhdHVyZXMuYlNlcnZlclNpZGUgKSB7XG5cdFx0XHRyZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xuXHRcdFx0XHRzdGFydCArIHJlY29yZHMgOlxuXHRcdFx0XHRNYXRoLm1pbiggc3RhcnQrbGVuLCB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gISBwYWdpbmF0ZSB8fCBjYWxjPnJlY29yZHMgfHwgbGVuPT09LTEgP1xuXHRcdFx0XHRyZWNvcmRzIDpcblx0XHRcdFx0Y2FsYztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxuXHQgKi9cblx0XCJvSW5zdGFuY2VcIjogbnVsbCxcblxuXHQvKipcblx0ICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggaW5zdGFuY2Ugb2YgdGhlIERhdGFUYWJsZXMgb2JqZWN0LiBJZiB0aGVyZVxuXHQgKiBpcyBhbiBJRCBvbiB0aGUgdGFibGUgbm9kZSwgdGhlbiBpdCB0YWtlcyB0aGF0IHZhbHVlLCBvdGhlcndpc2UgYW5cblx0ICogaW5jcmVtZW50aW5nIGludGVybmFsIGNvdW50ZXIgaXMgdXNlZC5cblx0ICovXG5cdFwic0luc3RhbmNlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIHRhYmluZGV4IGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIERhdGFUYWJsZXMgY29udHJvbCBlbGVtZW50cywgYWxsb3dpbmdcblx0ICoga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgYW5kIGl0cyBjb250cm9scy5cblx0ICovXG5cdFwiaVRhYkluZGV4XCI6IDAsXG5cblx0LyoqXG5cdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHQgKi9cblx0XCJuU2Nyb2xsSGVhZFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcblx0ICovXG5cdFwiblNjcm9sbEZvb3RcIjogbnVsbCxcblxuXHQvKipcblx0ICogTGFzdCBhcHBsaWVkIHNvcnRcblx0ICovXG5cdFwiYUxhc3RTb3J0XCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcblx0ICovXG5cdFwib1BsdWdpbnNcIjoge30sXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHVzZWQgdG8gZ2V0IGEgcm93J3MgaWQgZnJvbSB0aGUgcm93J3MgZGF0YVxuXHQgKi9cblx0XCJyb3dJZEZuXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIERhdGEgbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgYSByb3cncyBpZFxuXHQgKi9cblx0XCJyb3dJZFwiOiBudWxsLFxuXG5cdGNhcHRpb246ICcnLFxuXG5cdGNhcHRpb25Ob2RlOiBudWxsLFxuXG5cdGNvbGdyb3VwOiBudWxsLFxuXG5cdC8qKiBEZWxheSBsb2FkaW5nIG9mIGRhdGEgKi9cblx0ZGVmZXJMb2FkaW5nOiBudWxsLFxuXG5cdC8qKiBBbGxvdyBhdXRvIHR5cGUgZGV0ZWN0aW9uICovXG5cdHR5cGVEZXRlY3Q6IHRydWUsXG5cblx0LyoqIFJlc2l6ZU9ic2VydmVyIGZvciB0aGUgY29udGFpbmVyIGRpdiAqL1xuXHRyZXNpemVPYnNlcnZlcjogbnVsbCxcblxuXHQvKiogS2VlcCBhIHJlY29yZCBvZiB0aGUgbGFzdCBzaXplIG9mIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiBza2lwIGR1cGxpY2F0ZXMgKi9cblx0Y29udGFpbmVyV2lkdGg6IC0xXG59O1xuXG4vKipcbiAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuICogb3B0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcbiAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlLmV4dGAgd2hlcmUgaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZC4gSXQgaXNcbiAqIGFsc28gYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGhpc3RvcmljIHJlYXNvbnMuXG4gKiAgQG5hbWVzcGFjZVxuICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMuZXh0XG4gKi9cblxuXG52YXIgZXh0UGFnaW5hdGlvbiA9IERhdGFUYWJsZS5leHQucGFnZXI7XG5cbi8vIFBhZ2luZyBidXR0b25zIGNvbmZpZ3VyYXRpb25cbiQuZXh0ZW5kKCBleHRQYWdpbmF0aW9uLCB7XG5cdHNpbXBsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBbICdwcmV2aW91cycsICduZXh0JyBdO1xuXHR9LFxuXG5cdGZ1bGw6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWyAnZmlyc3QnLCAncHJldmlvdXMnLCAnbmV4dCcsICdsYXN0JyBdO1xuXHR9LFxuXG5cdG51bWJlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWyAnbnVtYmVycycgXTtcblx0fSxcblxuXHRzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBbICdwcmV2aW91cycsICdudW1iZXJzJywgJ25leHQnIF07XG5cdH0sXG5cblx0ZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ251bWJlcnMnLCAnbmV4dCcsICdsYXN0JyBdO1xuXHR9LFxuXG5cdGZpcnN0X2xhc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWydmaXJzdCcsICdsYXN0J107XG5cdH0sXG5cblx0Zmlyc3RfbGFzdF9udW1iZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsnZmlyc3QnLCAnbnVtYmVycycsICdsYXN0J107XG5cdH0sXG5cblx0Ly8gRm9yIHRlc3RpbmcgYW5kIHBsdWctaW5zIHRvIHVzZVxuXHRfbnVtYmVyczogX3BhZ2luZ051bWJlcnMsXG5cblx0Ly8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIC0gbGVnYWN5LCB1c2UgYG51bWJlcnNgIG9wdGlvbiBmb3IgcGFnaW5nIGZlYXR1cmVcblx0bnVtYmVyc19sZW5ndGg6IDdcbn0gKTtcblxuXG4kLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRwYWdpbmdCdXR0b246IHtcblx0XHRfOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGJ1dHRvblR5cGUsIGNvbnRlbnQsIGFjdGl2ZSwgZGlzYWJsZWQpIHtcblx0XHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMucGFnaW5nO1xuXHRcdFx0dmFyIGJ0bkNsYXNzZXMgPSBbY2xhc3Nlcy5idXR0b25dO1xuXHRcdFx0dmFyIGJ0bjtcblxuXHRcdFx0aWYgKGFjdGl2ZSkge1xuXHRcdFx0XHRidG5DbGFzc2VzLnB1c2goY2xhc3Nlcy5hY3RpdmUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0YnRuQ2xhc3Nlcy5wdXNoKGNsYXNzZXMuZGlzYWJsZWQpXG5cdFx0XHR9XG5cblx0XHRcdGlmIChidXR0b25UeXBlID09PSAnZWxsaXBzaXMnKSB7XG5cdFx0XHRcdGJ0biA9ICQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj48L3NwYW4+JykuaHRtbChjb250ZW50KVswXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRidG4gPSAkKCc8YnV0dG9uPicsIHtcblx0XHRcdFx0XHRjbGFzczogYnRuQ2xhc3Nlcy5qb2luKCcgJyksXG5cdFx0XHRcdFx0cm9sZTogJ2xpbmsnLFxuXHRcdFx0XHRcdHR5cGU6ICdidXR0b24nXG5cdFx0XHRcdH0pLmh0bWwoY29udGVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpc3BsYXk6IGJ0bixcblx0XHRcdFx0Y2xpY2tlcjogYnRuXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHBhZ2luZ0NvbnRhaW5lcjoge1xuXHRcdF86IGZ1bmN0aW9uIChzZXR0aW5ncywgYnV0dG9ucykge1xuXHRcdFx0Ly8gTm8gd3JhcHBpbmcgZWxlbWVudCAtIGp1c3QgYXBwZW5kIGRpcmVjdGx5IHRvIHRoZSBob3N0XG5cdFx0XHRyZXR1cm4gYnV0dG9ucztcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gQ29tbW9uIGZ1bmN0aW9uIHRvIHJlbW92ZSBuZXcgbGluZXMsIHN0cmlwIEhUTUwgYW5kIGRpYWNyaXRpYyBjb250cm9sXG52YXIgX2ZpbHRlclN0cmluZyA9IGZ1bmN0aW9uIChzdHJpcEh0bWwsIG5vcm1hbGl6ZSkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuXHRcdGlmIChfZW1wdHkoc3RyKSB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9XG5cblx0XHRzdHIgPSBzdHIucmVwbGFjZSggX3JlX25ld19saW5lcywgXCIgXCIgKTtcblxuXHRcdGlmIChzdHJpcEh0bWwpIHtcblx0XHRcdHN0ciA9IF9zdHJpcEh0bWwoc3RyKTtcblx0XHR9XG5cblx0XHRpZiAobm9ybWFsaXplKSB7XG5cdFx0XHRzdHIgPSBfbm9ybWFsaXplKHN0ciwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHI7XG5cdH07XG59XG5cbi8qXG4gKiBQdWJsaWMgaGVscGVyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlbid0IHVzZWQgaW50ZXJuYWxseSBieSBEYXRhVGFibGVzLCBvclxuICogY2FsbGVkIGJ5IGFueSBvZiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byBEYXRhVGFibGVzLCBidXQgdGhleSBjYW4gYmUgdXNlZFxuICogZXh0ZXJuYWxseSBieSBkZXZlbG9wZXJzIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzLiBUaGV5IGFyZSBoZWxwZXIgZnVuY3Rpb25zXG4gKiB0byBtYWtlIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzIGEgbGl0dGxlIGJpdCBlYXNpZXIuXG4gKi9cblxuLyoqXG4gKiBDb21tb24gbG9naWMgZm9yIG1vbWVudCwgbHV4b24gb3IgYSBkYXRlIGFjdGlvbi5cbiAqXG4gKiBIYXBwZW5zIGFmdGVyIF9fbWxkT2JqLCBzbyBkb24ndCBuZWVkIHRvIGNhbGwgYHJlc29sdmVXaW5kb3dzTGlic2AgYWdhaW5cbiAqL1xuZnVuY3Rpb24gX19tbGQoIGR0TGliLCBtb21lbnRGbiwgbHV4b25GbiwgZGF0ZUZuLCBhcmcxICkge1xuXHRpZiAoX19tb21lbnQpIHtcblx0XHRyZXR1cm4gZHRMaWJbbW9tZW50Rm5dKCBhcmcxICk7XG5cdH1cblx0ZWxzZSBpZiAoX19sdXhvbikge1xuXHRcdHJldHVybiBkdExpYltsdXhvbkZuXSggYXJnMSApO1xuXHR9XG5cdFxuXHRyZXR1cm4gZGF0ZUZuID8gZHRMaWJbZGF0ZUZuXSggYXJnMSApIDogZHRMaWI7XG59XG5cblxudmFyIF9fbWxXYXJuaW5nID0gZmFsc2U7XG52YXIgX19sdXhvbjsgLy8gQ2FuIGJlIGFzc2lnbmVkIGluIERhdGVUYWJsZS51c2UoKVxudmFyIF9fbW9tZW50OyAvLyBDYW4gYmUgYXNzaWduZWQgaW4gRGF0ZVRhYmxlLnVzZSgpXG5cbi8qKlxuICogXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVXaW5kb3dMaWJzKCkge1xuXHRpZiAod2luZG93Lmx1eG9uICYmICEgX19sdXhvbikge1xuXHRcdF9fbHV4b24gPSB3aW5kb3cubHV4b247XG5cdH1cblx0XG5cdGlmICh3aW5kb3cubW9tZW50ICYmICEgX19tb21lbnQpIHtcblx0XHRfX21vbWVudCA9IHdpbmRvdy5tb21lbnQ7XG5cdH1cbn1cblxuZnVuY3Rpb24gX19tbGRPYmogKGQsIGZvcm1hdCwgbG9jYWxlKSB7XG5cdHZhciBkdDtcblxuXHRyZXNvbHZlV2luZG93TGlicygpO1xuXG5cdGlmIChfX21vbWVudCkge1xuXHRcdGR0ID0gX19tb21lbnQudXRjKCBkLCBmb3JtYXQsIGxvY2FsZSwgdHJ1ZSApO1xuXG5cdFx0aWYgKCEgZHQuaXNWYWxpZCgpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoX19sdXhvbikge1xuXHRcdGR0ID0gZm9ybWF0ICYmIHR5cGVvZiBkID09PSAnc3RyaW5nJ1xuXHRcdFx0PyBfX2x1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQoIGQsIGZvcm1hdCApXG5cdFx0XHQ6IF9fbHV4b24uRGF0ZVRpbWUuZnJvbUlTTyggZCApO1xuXG5cdFx0aWYgKCEgZHQuaXNWYWxpZCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0ZHQgPSBkdC5zZXRMb2NhbGUobG9jYWxlKTtcblx0fVxuXHRlbHNlIGlmICghIGZvcm1hdCkge1xuXHRcdC8vIE5vIGZvcm1hdCBnaXZlbiwgbXVzdCBiZSBJU09cblx0XHRkdCA9IG5ldyBEYXRlKGQpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGlmICghIF9fbWxXYXJuaW5nKSB7XG5cdFx0XHRhbGVydCgnRGF0YVRhYmxlcyB3YXJuaW5nOiBGb3JtYXR0ZWQgZGF0ZSB3aXRob3V0IE1vbWVudC5qcyBvciBMdXhvbiAtIGh0dHBzOi8vZGF0YXRhYmxlcy5uZXQvdG4vMTcnKTtcblx0XHR9XG5cblx0XHRfX21sV2FybmluZyA9IHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZHQ7XG59XG5cbi8vIFdyYXBwZXIgZm9yIGRhdGUsIGRhdGV0aW1lIGFuZCB0aW1lIHdoaWNoIGFsbCBvcGVyYXRlIHRoZSBzYW1lIHdheSB3aXRoIHRoZSBleGNlcHRpb24gb2Zcbi8vIHRoZSBvdXRwdXQgc3RyaW5nIGZvciBhdXRvIGxvY2FsZSBzdXBwb3J0XG5mdW5jdGlvbiBfX21sSGVscGVyIChsb2NhbGVTdHJpbmcpIHtcblx0cmV0dXJuIGZ1bmN0aW9uICggZnJvbSwgdG8sIGxvY2FsZSwgZGVmICkge1xuXHRcdC8vIEx1eG9uIGFuZCBNb21lbnQgc3VwcG9ydFxuXHRcdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0bG9jYWxlID0gJ2VuJztcblx0XHRcdHRvID0gbnVsbDsgLy8gbWVhbnMgdG9Mb2NhbGVTdHJpbmdcblx0XHRcdGZyb20gPSBudWxsOyAvLyBtZWFucyBpc284NjAxXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0bG9jYWxlID0gJ2VuJztcblx0XHRcdHRvID0gZnJvbTtcblx0XHRcdGZyb20gPSBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMiApIHtcblx0XHRcdGxvY2FsZSA9IHRvO1xuXHRcdFx0dG8gPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHR5cGVOYW1lID0gJ2RhdGV0aW1lJyArICh0byA/ICctJyArIHRvIDogJycpO1xuXG5cdFx0Ly8gQWRkIHR5cGUgZGV0ZWN0aW9uIGFuZCBzb3J0aW5nIHNwZWNpZmljIHRvIHRoaXMgZGF0ZSBmb3JtYXQgLSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gaWRlbnRpZnlcblx0XHQvLyBkYXRlIHR5cGUgY29sdW1ucyBhcyBzdWNoLCByYXRoZXIgdGhhbiBhcyBudW1iZXJzIGluIGV4dGVuc2lvbnMuIEhlbmNlIHRoZSBuZWVkIGZvciB0aGlzLlxuXHRcdGlmICghIERhdGFUYWJsZS5leHQudHlwZS5vcmRlclt0eXBlTmFtZSArICctcHJlJ10pIHtcblx0XHRcdERhdGFUYWJsZS50eXBlKHR5cGVOYW1lLCB7XG5cdFx0XHRcdGRldGVjdDogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHQvLyBUaGUgcmVuZGVyZXIgd2lsbCBnaXZlIHRoZSB2YWx1ZSB0byB0eXBlIGRldGVjdCBhcyB0aGUgdHlwZSFcblx0XHRcdFx0XHRyZXR1cm4gZCA9PT0gdHlwZU5hbWUgPyB0eXBlTmFtZSA6IGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvcmRlcjoge1xuXHRcdFx0XHRcdHByZTogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdC8vIFRoZSByZW5kZXJlciBnaXZlcyB1cyBNb21lbnQsIEx1eG9uIG9yIERhdGUgb2JlY3RzIGZvciB0aGUgc29ydGluZywgYWxsIG9mIHdoaWNoIGhhdmUgYVxuXHRcdFx0XHRcdFx0Ly8gYHZhbHVlT2ZgIHdoaWNoIGdpdmVzIG1pbGxpc2Vjb25kcyBlcG9jaFxuXHRcdFx0XHRcdFx0cmV0dXJuIGQudmFsdWVPZigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xhc3NOYW1lOiAnZHQtcmlnaHQnXG5cdFx0XHR9KTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGQsIHR5cGUgKSB7XG5cdFx0XHQvLyBBbGxvdyBmb3IgYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRpZiAoZCA9PT0gbnVsbCB8fCBkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKGRlZiA9PT0gJy0tbm93Jykge1xuXHRcdFx0XHRcdC8vIFdlIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgVVRDIGZ1cnRoZXIgZG93biwgc28gbm8gY2hhbmdlcyBhcmVcblx0XHRcdFx0XHQvLyBtYWRlLCBhcyBzdWNoIG5lZWQgdG8gZ2V0IHRoZSBsb2NhbCBkYXRlIC8gdGltZSBhcyBpZiBpdCB3ZXJlXG5cdFx0XHRcdFx0Ly8gVVRDXG5cdFx0XHRcdFx0dmFyIGxvY2FsID0gbmV3IERhdGUoKTtcblx0XHRcdFx0XHRkID0gbmV3IERhdGUoIERhdGUuVVRDKFxuXHRcdFx0XHRcdFx0bG9jYWwuZ2V0RnVsbFllYXIoKSwgbG9jYWwuZ2V0TW9udGgoKSwgbG9jYWwuZ2V0RGF0ZSgpLFxuXHRcdFx0XHRcdFx0bG9jYWwuZ2V0SG91cnMoKSwgbG9jYWwuZ2V0TWludXRlcygpLCBsb2NhbC5nZXRTZWNvbmRzKClcblx0XHRcdFx0XHQpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZCA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlID09PSAndHlwZScpIHtcblx0XHRcdFx0Ly8gVHlwaW5nIHVzZXMgdGhlIHR5cGUgbmFtZSBmb3IgZmFzdCBtYXRjaGluZ1xuXHRcdFx0XHRyZXR1cm4gdHlwZU5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkID09PSAnJykge1xuXHRcdFx0XHRyZXR1cm4gdHlwZSAhPT0gJ3NvcnQnXG5cdFx0XHRcdFx0PyAnJ1xuXHRcdFx0XHRcdDogX19tbGRPYmooJzAwMDAtMDEtMDEgMDA6MDA6MDAnLCBudWxsLCBsb2NhbGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG9ydGN1dC4gSWYgYGZyb21gIGFuZCBgdG9gIGFyZSB0aGUgc2FtZSwgd2UgYXJlIHVzaW5nIHRoZSByZW5kZXJlciB0b1xuXHRcdFx0Ly8gZm9ybWF0IGZvciBvcmRlcmluZywgbm90IGRpc3BsYXkgLSBpdHMgYWxyZWFkeSBpbiB0aGUgZGlzcGxheSBmb3JtYXQuXG5cdFx0XHRpZiAoIHRvICE9PSBudWxsICYmIGZyb20gPT09IHRvICYmIHR5cGUgIT09ICdzb3J0JyAmJiB0eXBlICE9PSAndHlwZScgJiYgISAoZCBpbnN0YW5jZW9mIERhdGUpICkge1xuXHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGR0ID0gX19tbGRPYmooZCwgZnJvbSwgbG9jYWxlKTtcblxuXHRcdFx0aWYgKGR0ID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZSA9PT0gJ3NvcnQnKSB7XG5cdFx0XHRcdHJldHVybiBkdDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRvID09PSBudWxsXG5cdFx0XHRcdD8gX19tbGQoZHQsICd0b0RhdGUnLCAndG9KU0RhdGUnLCAnJylbbG9jYWxlU3RyaW5nXSgpXG5cdFx0XHRcdDogX19tbGQoZHQsICdmb3JtYXQnLCAndG9Gb3JtYXQnLCAndG9JU09TdHJpbmcnLCB0byk7XG5cblx0XHRcdC8vIFhTUyBwcm90ZWN0aW9uXG5cdFx0XHRyZXR1cm4gdHlwZSA9PT0gJ2Rpc3BsYXknID9cblx0XHRcdFx0X2VzY2FwZUh0bWwoIGZvcm1hdHRlZCApIDpcblx0XHRcdFx0Zm9ybWF0dGVkO1xuXHRcdH07XG5cdH1cbn1cblxuLy8gQmFzZWQgb24gbG9jYWxlLCBkZXRlcm1pbmUgc3RhbmRhcmQgbnVtYmVyIGZvcm1hdHRpbmdcbi8vIEZhbGxiYWNrIGZvciBsZWdhY3kgYnJvd3NlcnMgaXMgVVMgRW5nbGlzaFxudmFyIF9fdGhvdXNhbmRzID0gJywnO1xudmFyIF9fZGVjaW1hbCA9ICcuJztcblxuaWYgKHdpbmRvdy5JbnRsICE9PSB1bmRlZmluZWQpIHtcblx0dHJ5IHtcblx0XHR2YXIgbnVtID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KCkuZm9ybWF0VG9QYXJ0cygxMDAwMDAuMSk7XG5cdFxuXHRcdGZvciAodmFyIGk9MCA7IGk8bnVtLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0aWYgKG51bVtpXS50eXBlID09PSAnZ3JvdXAnKSB7XG5cdFx0XHRcdF9fdGhvdXNhbmRzID0gbnVtW2ldLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobnVtW2ldLnR5cGUgPT09ICdkZWNpbWFsJykge1xuXHRcdFx0XHRfX2RlY2ltYWwgPSBudW1baV0udmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGNhdGNoIChlKSB7XG5cdFx0Ly8gbm9vcFxuXHR9XG59XG5cbi8vIEZvcm1hdHRlZCBkYXRlIHRpbWUgZGV0ZWN0aW9uIC0gdXNlIGJ5IGRlY2xhcmluZyB0aGUgZm9ybWF0cyB5b3UgYXJlIGdvaW5nIHRvIHVzZVxuRGF0YVRhYmxlLmRhdGV0aW1lID0gZnVuY3Rpb24gKCBmb3JtYXQsIGxvY2FsZSApIHtcblx0dmFyIHR5cGVOYW1lID0gJ2RhdGV0aW1lLScgKyBmb3JtYXQ7XG5cblx0aWYgKCEgbG9jYWxlKSB7XG5cdFx0bG9jYWxlID0gJ2VuJztcblx0fVxuXG5cdGlmICghIERhdGFUYWJsZS5leHQudHlwZS5vcmRlclt0eXBlTmFtZV0pIHtcblx0XHREYXRhVGFibGUudHlwZSh0eXBlTmFtZSwge1xuXHRcdFx0ZGV0ZWN0OiBmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHR2YXIgZHQgPSBfX21sZE9iaihkLCBmb3JtYXQsIGxvY2FsZSk7XG5cdFx0XHRcdHJldHVybiBkID09PSAnJyB8fCBkdCA/IHR5cGVOYW1lIDogZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0b3JkZXI6IHtcblx0XHRcdFx0cHJlOiBmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdHJldHVybiBfX21sZE9iaihkLCBmb3JtYXQsIGxvY2FsZSkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNsYXNzTmFtZTogJ2R0LXJpZ2h0J1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogSGVscGVycyBmb3IgYGNvbHVtbnMucmVuZGVyYC5cbiAqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIGhlcmUgY2FuIGJlIHVzZWQgd2l0aCB0aGUgYGNvbHVtbnMucmVuZGVyYCBpbml0aWFsaXNhdGlvblxuICogb3B0aW9uIHRvIHByb3ZpZGUgYSBkaXNwbGF5IHJlbmRlcmVyLiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZDpcbiAqXG4gKiAqIGBtb21lbnRgIC0gVXNlcyB0aGUgTW9tZW50SlMgbGlicmFyeSB0byBjb252ZXJ0IGZyb20gYSBnaXZlbiBmb3JtYXQgaW50byBhbm90aGVyLlxuICogVGhpcyByZW5kZXJlciBoYXMgdGhyZWUgb3ZlcmxvYWRzOlxuICogICAqIDEgcGFyYW1ldGVyOlxuICogICAgICogYHN0cmluZ2AgLSBGb3JtYXQgdG8gY29udmVydCB0byAoYXNzdW1lcyBpbnB1dCBpcyBJU084NjAxIGFuZCBsb2NhbGUgaXMgYGVuYClcbiAqICAgKiAyIHBhcmFtZXRlcnM6XG4gKiAgICAgKiBgc3RyaW5nYCAtIEZvcm1hdCB0byBjb252ZXJ0IGZyb21cbiAqICAgICAqIGBzdHJpbmdgIC0gRm9ybWF0IHRvIGNvbnZlcnQgdG8uIEFzc3VtZXMgYGVuYCBsb2NhbGVcbiAqICAgKiAzIHBhcmFtZXRlcnM6XG4gKiAgICAgKiBgc3RyaW5nYCAtIEZvcm1hdCB0byBjb252ZXJ0IGZyb21cbiAqICAgICAqIGBzdHJpbmdgIC0gRm9ybWF0IHRvIGNvbnZlcnQgdG9cbiAqICAgICAqIGBzdHJpbmdgIC0gTG9jYWxlXG4gKiAqIGBudW1iZXJgIC0gV2lsbCBmb3JtYXQgbnVtZXJpYyBkYXRhIChkZWZpbmVkIGJ5IGBjb2x1bW5zLmRhdGFgKSBmb3JcbiAqICAgZGlzcGxheSwgcmV0YWluaW5nIHRoZSBvcmlnaW5hbCB1bmZvcm1hdHRlZCBkYXRhIGZvciBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcuXG4gKiAgIEl0IHRha2VzIDUgcGFyYW1ldGVyczpcbiAqICAgKiBgc3RyaW5nYCAtIFRob3VzYW5kcyBncm91cGluZyBzZXBhcmF0b3JcbiAqICAgKiBgc3RyaW5nYCAtIERlY2ltYWwgcG9pbnQgaW5kaWNhdG9yXG4gKiAgICogYGludGVnZXJgIC0gTnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIHNob3dcbiAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUHJlZml4LlxuICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQb3N0Zml4ICgvc3VmZml4KS5cbiAqICogYHRleHRgIC0gRXNjYXBlIEhUTUwgdG8gaGVscCBwcmV2ZW50IFhTUyBhdHRhY2tzLiBJdCBoYXMgbm8gb3B0aW9uYWxcbiAqICAgcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBDb2x1bW4gZGVmaW5pdGlvbiB1c2luZyB0aGUgbnVtYmVyIHJlbmRlcmVyXG4gKiAgIHtcbiAqICAgICBkYXRhOiBcInNhbGFyeVwiLFxuICogICAgIHJlbmRlcjogJC5mbi5kYXRhVGFibGUucmVuZGVyLm51bWJlciggJ1xcJycsICcuJywgMCwgJyQnIClcbiAqICAgfVxuICpcbiAqIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLnJlbmRlciA9IHtcblx0ZGF0ZTogX19tbEhlbHBlcigndG9Mb2NhbGVEYXRlU3RyaW5nJyksXG5cdGRhdGV0aW1lOiBfX21sSGVscGVyKCd0b0xvY2FsZVN0cmluZycpLFxuXHR0aW1lOiBfX21sSGVscGVyKCd0b0xvY2FsZVRpbWVTdHJpbmcnKSxcblx0bnVtYmVyOiBmdW5jdGlvbiAoIHRob3VzYW5kcywgZGVjaW1hbCwgcHJlY2lzaW9uLCBwcmVmaXgsIHBvc3RmaXggKSB7XG5cdFx0Ly8gQXV0byBsb2NhbGUgZGV0ZWN0aW9uXG5cdFx0aWYgKHRob3VzYW5kcyA9PT0gbnVsbCB8fCB0aG91c2FuZHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhvdXNhbmRzID0gX190aG91c2FuZHM7XG5cdFx0fVxuXG5cdFx0aWYgKGRlY2ltYWwgPT09IG51bGwgfHwgZGVjaW1hbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkZWNpbWFsID0gX19kZWNpbWFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRkaXNwbGF5OiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGQgIT09ICdudW1iZXInICYmIHR5cGVvZiBkICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkID09PSAnJyB8fCBkID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbmVnYXRpdmUgPSBkIDwgMCA/ICctJyA6ICcnO1xuXHRcdFx0XHR2YXIgZmxvID0gcGFyc2VGbG9hdCggZCApO1xuXHRcdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMoZmxvKTtcblxuXHRcdFx0XHQvLyBTY2llbnRpZmljIG5vdGF0aW9uIGZvciBsYXJnZSBhbmQgc21hbGwgbnVtYmVyc1xuXHRcdFx0XHRpZiAoYWJzID49IDEwMDAwMDAwMDAwMCB8fCAoYWJzIDwgMC4wMDAxICYmIGFicyAhPT0gMCkgKSB7XG5cdFx0XHRcdFx0dmFyIGV4cCA9IGZsby50b0V4cG9uZW50aWFsKHByZWNpc2lvbikuc3BsaXQoL2VcXCs/Lyk7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cFswXSArICcgeCAxMDxzdXA+JyArIGV4cFsxXSArICc8L3N1cD4nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgTmFOIHRoZW4gdGhlcmUgaXNuJ3QgbXVjaCBmb3JtYXR0aW5nIHRoYXQgd2UgY2FuIGRvIC0ganVzdFxuXHRcdFx0XHQvLyByZXR1cm4gaW1tZWRpYXRlbHksIGVzY2FwaW5nIGFueSBIVE1MICh0aGlzIHdhcyBzdXBwb3NlZCB0b1xuXHRcdFx0XHQvLyBiZSBhIG51bWJlciBhZnRlciBhbGwpXG5cdFx0XHRcdGlmICggaXNOYU4oIGZsbyApICkge1xuXHRcdFx0XHRcdHJldHVybiBfZXNjYXBlSHRtbCggZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmxvID0gZmxvLnRvRml4ZWQoIHByZWNpc2lvbiApO1xuXHRcdFx0XHRkID0gTWF0aC5hYnMoIGZsbyApO1xuXG5cdFx0XHRcdHZhciBpbnRQYXJ0ID0gcGFyc2VJbnQoIGQsIDEwICk7XG5cdFx0XHRcdHZhciBmbG9hdFBhcnQgPSBwcmVjaXNpb24gP1xuXHRcdFx0XHRcdGRlY2ltYWwrKGQgLSBpbnRQYXJ0KS50b0ZpeGVkKCBwcmVjaXNpb24gKS5zdWJzdHJpbmcoIDIgKTpcblx0XHRcdFx0XHQnJztcblxuXHRcdFx0XHQvLyBJZiB6ZXJvLCB0aGVuIGNhbid0IGhhdmUgYSBuZWdhdGl2ZSBwcmVmaXhcblx0XHRcdFx0aWYgKGludFBhcnQgPT09IDAgJiYgcGFyc2VGbG9hdChmbG9hdFBhcnQpID09PSAwKSB7XG5cdFx0XHRcdFx0bmVnYXRpdmUgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZWdhdGl2ZSArIChwcmVmaXh8fCcnKSArXG5cdFx0XHRcdFx0aW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgdGhvdXNhbmRzXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0ZmxvYXRQYXJ0ICtcblx0XHRcdFx0XHQocG9zdGZpeHx8JycpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkaXNwbGF5OiBfZXNjYXBlSHRtbCxcblx0XHRcdGZpbHRlcjogX2VzY2FwZUh0bWxcblx0XHR9O1xuXHR9XG59O1xuXG5cbnZhciBfZXh0VHlwZXMgPSBEYXRhVGFibGUuZXh0LnR5cGU7XG5cbi8vIEdldCAvIHNldCB0eXBlXG5EYXRhVGFibGUudHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBwcm9wLCB2YWwpIHtcblx0aWYgKCEgcHJvcCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjbGFzc05hbWU6IF9leHRUeXBlcy5jbGFzc05hbWVbbmFtZV0sXG5cdFx0XHRkZXRlY3Q6IF9leHRUeXBlcy5kZXRlY3QuZmluZChmdW5jdGlvbiAoZm4pIHtcblx0XHRcdFx0cmV0dXJuIGZuLl9uYW1lID09PSBuYW1lO1xuXHRcdFx0fSksXG5cdFx0XHRvcmRlcjoge1xuXHRcdFx0XHRwcmU6IF9leHRUeXBlcy5vcmRlcltuYW1lICsgJy1wcmUnXSxcblx0XHRcdFx0YXNjOiBfZXh0VHlwZXMub3JkZXJbbmFtZSArICctYXNjJ10sXG5cdFx0XHRcdGRlc2M6IF9leHRUeXBlcy5vcmRlcltuYW1lICsgJy1kZXNjJ11cblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IF9leHRUeXBlcy5yZW5kZXJbbmFtZV0sXG5cdFx0XHRzZWFyY2g6IF9leHRUeXBlcy5zZWFyY2hbbmFtZV1cblx0XHR9O1xuXHR9XG5cblx0dmFyIHNldFByb3AgPSBmdW5jdGlvbihwcm9wLCBwcm9wVmFsKSB7XG5cdFx0X2V4dFR5cGVzW3Byb3BdW25hbWVdID0gcHJvcFZhbDtcblx0fTtcblx0dmFyIHNldERldGVjdCA9IGZ1bmN0aW9uIChkZXRlY3QpIHtcblx0XHQvLyBgZGV0ZWN0YCBjYW4gYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QgLSB3ZSBzZXQgYSBuYW1lXG5cdFx0Ly8gcHJvcGVydHkgZm9yIGVpdGhlciAtIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGRldGVjdGlvblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXRlY3QsIFwiX25hbWVcIiwge3ZhbHVlOiBuYW1lfSk7XG5cblx0XHR2YXIgaWR4ID0gX2V4dFR5cGVzLmRldGVjdC5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLl9uYW1lID09PSBuYW1lO1xuXHRcdH0pO1xuXG5cdFx0aWYgKGlkeCA9PT0gLTEpIHtcblx0XHRcdF9leHRUeXBlcy5kZXRlY3QudW5zaGlmdChkZXRlY3QpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdF9leHRUeXBlcy5kZXRlY3Quc3BsaWNlKGlkeCwgMSwgZGV0ZWN0KTtcblx0XHR9XG5cdH07XG5cdHZhciBzZXRPcmRlciA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHRfZXh0VHlwZXMub3JkZXJbbmFtZSArICctcHJlJ10gPSBvYmoucHJlOyAvLyBjYW4gYmUgdW5kZWZpbmVkXG5cdFx0X2V4dFR5cGVzLm9yZGVyW25hbWUgKyAnLWFzYyddID0gb2JqLmFzYzsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuXHRcdF9leHRUeXBlcy5vcmRlcltuYW1lICsgJy1kZXNjJ10gPSBvYmouZGVzYzsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuXHR9O1xuXG5cdC8vIHByb3AgaXMgb3B0aW9uYWxcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFsID0gcHJvcDtcblx0XHRwcm9wID0gbnVsbDtcblx0fVxuXG5cdGlmIChwcm9wID09PSAnY2xhc3NOYW1lJykge1xuXHRcdHNldFByb3AoJ2NsYXNzTmFtZScsIHZhbCk7XG5cdH1cblx0ZWxzZSBpZiAocHJvcCA9PT0gJ2RldGVjdCcpIHtcblx0XHRzZXREZXRlY3QodmFsKTtcblx0fVxuXHRlbHNlIGlmIChwcm9wID09PSAnb3JkZXInKSB7XG5cdFx0c2V0T3JkZXIodmFsKTtcblx0fVxuXHRlbHNlIGlmIChwcm9wID09PSAncmVuZGVyJykge1xuXHRcdHNldFByb3AoJ3JlbmRlcicsIHZhbCk7XG5cdH1cblx0ZWxzZSBpZiAocHJvcCA9PT0gJ3NlYXJjaCcpIHtcblx0XHRzZXRQcm9wKCdzZWFyY2gnLCB2YWwpO1xuXHR9XG5cdGVsc2UgaWYgKCEgcHJvcCkge1xuXHRcdGlmICh2YWwuY2xhc3NOYW1lKSB7XG5cdFx0XHRzZXRQcm9wKCdjbGFzc05hbWUnLCB2YWwuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAodmFsLmRldGVjdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzZXREZXRlY3QodmFsLmRldGVjdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbC5vcmRlcikge1xuXHRcdFx0c2V0T3JkZXIodmFsLm9yZGVyKTtcblx0XHR9XG5cblx0XHRpZiAodmFsLnJlbmRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzZXRQcm9wKCdyZW5kZXInLCB2YWwucmVuZGVyKTtcblx0XHR9XG5cblx0XHRpZiAodmFsLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzZXRQcm9wKCdzZWFyY2gnLCB2YWwuc2VhcmNoKTtcblx0XHR9XG5cdH1cbn1cblxuLy8gR2V0IGEgbGlzdCBvZiB0eXBlc1xuRGF0YVRhYmxlLnR5cGVzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gX2V4dFR5cGVzLmRldGVjdC5tYXAoZnVuY3Rpb24gKGZuKSB7XG5cdFx0cmV0dXJuIGZuLl9uYW1lO1xuXHR9KTtcbn07XG5cbnZhciBfX2RpYWNyaXRpY1NvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRhID0gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQgPyBhLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuXHRiID0gYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgPyBiLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuXG5cdC8vIENoZWNrZWQgZm9yIGBuYXZpZ2F0b3IubGFuZ3VhZ2VzYCBzdXBwb3J0IGluIGBvbmVPZmAgc28gdGhpcyBjb2RlIGNhbid0IGV4ZWN1dGUgaW4gb2xkXG5cdC8vIFNhZmFyaSBhbmQgdGh1cyBjYW4gZGlzYWJsZSB0aGlzIGNoZWNrXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG5cdHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYiwgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UsIHtcblx0XHRudW1lcmljOiB0cnVlLFxuXHRcdGlnbm9yZVB1bmN0dWF0aW9uOiB0cnVlLFxuXHR9KTtcbn1cblxudmFyIF9fZGlhY3JpdGljSHRtbFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRhID0gX3N0cmlwSHRtbChhKTtcblx0YiA9IF9zdHJpcEh0bWwoYik7XG5cblx0cmV0dXJuIF9fZGlhY3JpdGljU29ydChhLCBiKTtcbn1cblxuLy9cbi8vIEJ1aWx0IGluIGRhdGEgdHlwZXNcbi8vXG5cbkRhdGFUYWJsZS50eXBlKCdzdHJpbmcnLCB7XG5cdGRldGVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAnc3RyaW5nJztcblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdC8vIFRoaXMgaXMgYSBsaXR0bGUgY29tcGxleCwgYnV0IGZhc3RlciB0aGFuIGFsd2F5cyBjYWxsaW5nIHRvU3RyaW5nLFxuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdG9zdHJpbmctdi1jaGVja1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSAmJiB0eXBlb2YgYSAhPT0gJ2Jvb2xlYW4nID9cblx0XHRcdFx0JycgOlxuXHRcdFx0XHR0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGEudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0ISBhLnRvU3RyaW5nID9cblx0XHRcdFx0XHRcdCcnIDpcblx0XHRcdFx0XHRcdGEudG9TdHJpbmcoKTtcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyhmYWxzZSwgdHJ1ZSlcbn0pO1xuXG5EYXRhVGFibGUudHlwZSgnc3RyaW5nLXV0ZjgnLCB7XG5cdGRldGVjdDoge1xuXHRcdGFsbE9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBub24tQVNDSUkgY2hhcmFjdGVyXG5cdFx0XHQvLyBUaGlzIGxpbmUgd2lsbCBhbHNvIGNoZWNrIGlmIG5hdmlnYXRvci5sYW5ndWFnZXMgaXMgc3VwcG9ydGVkIG9yIG5vdC4gSWYgbm90IChTYWZhcmkgMTAuMC0pXG5cdFx0XHQvLyB0aGlzIGRhdGEgdHlwZSB3b24ndCBiZSBzdXBwb3J0ZWQuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXHRcdFx0cmV0dXJuICEgX2VtcHR5KCBkICkgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5tYXRjaCgvW15cXHgwMC1cXHg3Rl0vKTtcblx0XHR9XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0YXNjOiBfX2RpYWNyaXRpY1NvcnQsXG5cdFx0ZGVzYzogZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBfX2RpYWNyaXRpY1NvcnQoYSwgYikgKiAtMTtcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyhmYWxzZSwgdHJ1ZSlcbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdodG1sJywge1xuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8ICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5pbmRleE9mKCc8JykgIT09IC0xKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBgPGBcblx0XHRcdHJldHVybiAhIF9lbXB0eSggZCApICYmIHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTE7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0YS5yZXBsYWNlID9cblx0XHRcdFx0XHRfc3RyaXBIdG1sKGEpLnRyaW0oKS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRhKycnO1xuXHRcdH1cblx0fSxcblx0c2VhcmNoOiBfZmlsdGVyU3RyaW5nKHRydWUsIHRydWUpXG59KTtcblxuXG5EYXRhVGFibGUudHlwZSgnaHRtbC11dGY4Jywge1xuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8ICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5pbmRleE9mKCc8JykgIT09IC0xKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBgPGAgYW5kIGEgbm9uLUFTQ0lJIGNoYXJhY3RlclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblx0XHRcdHJldHVybiBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmXG5cdFx0XHRcdCEgX2VtcHR5KCBkICkgJiZcblx0XHRcdFx0dHlwZW9mIGQgPT09ICdzdHJpbmcnICYmXG5cdFx0XHRcdGQuaW5kZXhPZignPCcpICE9PSAtMSAmJlxuXHRcdFx0XHR0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5tYXRjaCgvW15cXHgwMC1cXHg3Rl0vKTtcblx0XHR9XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0YXNjOiBfX2RpYWNyaXRpY0h0bWxTb3J0LFxuXHRcdGRlc2M6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gX19kaWFjcml0aWNIdG1sU29ydChhLCBiKSAqIC0xO1xuXHRcdH1cblx0fSxcblx0c2VhcmNoOiBfZmlsdGVyU3RyaW5nKHRydWUsIHRydWUpXG59KTtcblxuXG5EYXRhVGFibGUudHlwZSgnZGF0ZScsIHtcblx0Y2xhc3NOYW1lOiAnZHQtdHlwZS1kYXRlJyxcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdC8vIFY4IHRyaWVzIF92ZXJ5XyBoYXJkIHRvIG1ha2UgYSBzdHJpbmcgcGFzc2VkIGludG8gYERhdGUucGFyc2UoKWBcblx0XHRcdC8vIHZhbGlkLCBzbyB3ZSBuZWVkIHRvIHVzZSBhIHJlZ2V4IHRvIHJlc3RyaWN0IGRhdGUgZm9ybWF0cy4gVXNlIGFcblx0XHRcdC8vIHBsdWctaW4gZm9yIGFueXRoaW5nIG90aGVyIHRoYW4gSVNPODYwMSBzdHlsZSBzdHJpbmdzXG5cdFx0XHRpZiAoIGQgJiYgIShkIGluc3RhbmNlb2YgRGF0ZSkgJiYgISBfcmVfZGF0ZS50ZXN0KGQpICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJzZWQgPSBEYXRlLnBhcnNlKGQpO1xuXHRcdFx0cmV0dXJuIChwYXJzZWQgIT09IG51bGwgJiYgIWlzTmFOKHBhcnNlZCkpIHx8IF9lbXB0eShkKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZW50cnkgbXVzdCBiZSBhIGRhdGUgb3IgYSBzdHJpbmcgd2l0aCBhIGRhdGVcblx0XHRcdHJldHVybiAoZCBpbnN0YW5jZW9mIERhdGUpIHx8ICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgX3JlX2RhdGUudGVzdChkKSk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0dmFyIHRzID0gRGF0ZS5wYXJzZSggZCApO1xuXHRcdFx0cmV0dXJuIGlzTmFOKHRzKSA/IC1JbmZpbml0eSA6IHRzO1xuXHRcdH1cblx0fVxufSk7XG5cblxuRGF0YVRhYmxlLnR5cGUoJ2h0bWwtbnVtLWZtdCcsIHtcblx0Y2xhc3NOYW1lOiAnZHQtdHlwZS1udW1lcmljJyxcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKSB7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIHRydWUsIGZhbHNlICk7XG5cdFx0fSxcblx0XHRvbmVPZjogZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBudW1lcmljIHZhbHVlXG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIHRydWUsIGZhbHNlICk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBkLCBzICkge1xuXHRcdFx0dmFyIGRwID0gcy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZHAsIF9yZV9odG1sLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyh0cnVlLCB0cnVlKVxufSk7XG5cblxuRGF0YVRhYmxlLnR5cGUoJ2h0bWwtbnVtJywge1xuXHRjbGFzc05hbWU6ICdkdC10eXBlLW51bWVyaWMnLFxuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9odG1sTnVtZXJpYyggZCwgZGVjaW1hbCwgZmFsc2UsIHRydWUgKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcblx0XHRcdC8vIEF0IGxlYXN0IG9uZSBkYXRhIHBvaW50IG11c3QgY29udGFpbiBhIG51bWVyaWMgdmFsdWVcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9odG1sTnVtZXJpYyggZCwgZGVjaW1hbCwgZmFsc2UsIGZhbHNlICk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBkLCBzICkge1xuXHRcdFx0dmFyIGRwID0gcy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZHAsIF9yZV9odG1sICk7XG5cdFx0fVxuXHR9LFxuXHRzZWFyY2g6IF9maWx0ZXJTdHJpbmcodHJ1ZSwgdHJ1ZSlcbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdudW0tZm10Jywge1xuXHRjbGFzc05hbWU6ICdkdC10eXBlLW51bWVyaWMnLFxuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCwgdHJ1ZSwgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0b25lT2Y6IGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCB0cnVlLCBmYWxzZSApO1xuXHRcdH1cblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggZCwgcyApIHtcblx0XHRcdHZhciBkcCA9IHMub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRwLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdudW0nLCB7XG5cdGNsYXNzTmFtZTogJ2R0LXR5cGUtbnVtZXJpYycsXG5cdGRldGVjdDoge1xuXHRcdGFsbE9mOiBmdW5jdGlvbiAoIGQsIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCBmYWxzZSwgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0b25lT2Y6IGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCBmYWxzZSwgZmFsc2UgKTtcblx0XHR9XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0cHJlOiBmdW5jdGlvbiAoZCwgcykge1xuXHRcdFx0dmFyIGRwID0gcy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZHAgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMiApIHtcblx0aWYgKCBkICE9PSAwICYmICghZCB8fCBkID09PSAnLScpICkge1xuXHRcdHJldHVybiAtSW5maW5pdHk7XG5cdH1cblx0XG5cdHZhciB0eXBlID0gdHlwZW9mIGQ7XG5cblx0aWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdiaWdpbnQnKSB7XG5cdFx0cmV0dXJuIGQ7XG5cdH1cblxuXHQvLyBJZiBhIGRlY2ltYWwgcGxhY2Ugb3RoZXIgdGhhbiBgLmAgaXMgdXNlZCwgaXQgbmVlZHMgdG8gYmUgZ2l2ZW4gdG8gdGhlXG5cdC8vIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZXRlY3QgaXQgYW5kIHJlcGxhY2Ugd2l0aCBhIGAuYCB3aGljaCBpcyB0aGUgb25seVxuXHQvLyBkZWNpbWFsIHBsYWNlIEphdmFzY3JpcHQgcmVjb2duaXNlcyAtIGl0IGlzIG5vdCBsb2NhbGUgYXdhcmUuXG5cdGlmICggZGVjaW1hbFBsYWNlICkge1xuXHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0fVxuXG5cdGlmICggZC5yZXBsYWNlICkge1xuXHRcdGlmICggcmUxICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggcmUxLCAnJyApO1xuXHRcdH1cblxuXHRcdGlmICggcmUyICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggcmUyLCAnJyApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkICogMTtcbn07XG5cblxuJC5leHRlbmQoIHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcblx0Zm9vdGVyOiB7XG5cdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY2xhc3NlcyApIHtcblx0XHRcdGNlbGwuYWRkQ2xhc3MoY2xhc3Nlcy50Zm9vdC5jZWxsKTtcblx0XHR9XG5cdH0sXG5cblx0aGVhZGVyOiB7XG5cdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY2xhc3NlcyApIHtcblx0XHRcdGNlbGwuYWRkQ2xhc3MoY2xhc3Nlcy50aGVhZC5jZWxsKTtcblxuXHRcdFx0aWYgKCEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0KSB7XG5cdFx0XHRcdGNlbGwuYWRkQ2xhc3MoY2xhc3Nlcy5vcmRlci5ub25lKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxlZ2FjeVRvcCA9IHNldHRpbmdzLmJTb3J0Q2VsbHNUb3A7XG5cdFx0XHR2YXIgaGVhZGVyUm93cyA9IGNlbGwuY2xvc2VzdCgndGhlYWQnKS5maW5kKCd0cicpO1xuXHRcdFx0dmFyIHJvd0lkeCA9IGNlbGwucGFyZW50KCkuaW5kZXgoKTtcblxuXHRcdFx0Ly8gQ29uZGl0aW9ucyB0byBub3QgYXBwbHkgdGhlIG9yZGVyaW5nIGljb25zXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIENlbGxzIGFuZCByb3dzIHdoaWNoIGhhdmUgdGhlIGF0dHJpYnV0ZSB0byBkaXNhYmxlIHRoZSBpY29uc1xuXHRcdFx0XHRjZWxsLmF0dHIoJ2RhdGEtZHQtb3JkZXInKSA9PT0gJ2Rpc2FibGUnIHx8XG5cdFx0XHRcdGNlbGwucGFyZW50KCkuYXR0cignZGF0YS1kdC1vcmRlcicpID09PSAnZGlzYWJsZScgfHxcblxuXHRcdFx0XHQvLyBMZWdhY3kgc3VwcG9ydCBmb3IgYG9yZGVyQ2VsbHNUb3BgLiBJZiBpdCBpcyBzZXQsIHRoZW4gY2VsbHNcblx0XHRcdFx0Ly8gd2hpY2ggYXJlIG5vdCBpbiB0aGUgdG9wIG9yIGJvdHRvbSByb3cgb2YgdGhlIGhlYWRlciAoZGVwZW5kaW5nXG5cdFx0XHRcdC8vIG9uIHRoZSB2YWx1ZSkgZG8gbm90IGdldCB0aGUgc29ydGluZyBjbGFzc2VzIGFwcGxpZWQgdG8gdGhlbVxuXHRcdFx0XHQobGVnYWN5VG9wID09PSB0cnVlICYmIHJvd0lkeCAhPT0gMCkgfHxcblx0XHRcdFx0KGxlZ2FjeVRvcCA9PT0gZmFsc2UgJiYgcm93SWR4ICE9PSBoZWFkZXJSb3dzLmxlbmd0aCAtIDEpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcblx0XHRcdC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnQgLSBub3RlIHRoYXQgdXNpbmcgdGhlXG5cdFx0XHQvLyBgRFRgIG5hbWVzcGFjZSB3aWxsIGFsbG93IHRoZSBldmVudCB0byBiZSByZW1vdmVkIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcblx0XHRcdC8vIGxpc3RlbmluZyBmb3Jcblx0XHRcdCQoc2V0dGluZ3MublRhYmxlKS5vbiggJ29yZGVyLmR0LkRUIGNvbHVtbi12aXNpYmlsaXR5LmR0LkRUJywgZnVuY3Rpb24gKCBlLCBjdHggKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3Rcblx0XHRcdFx0XHRyZXR1cm47ICAgICAgICAgICAgICAgLy8gdGFibGUsIG5vdCBhIG5lc3RlZCBvbmVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzb3J0aW5nID0gY3R4LnNvcnREZXRhaWxzO1xuXG5cdFx0XHRcdGlmICghIHNvcnRpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0dmFyIG9yZGVyQ2xhc3NlcyA9IGNsYXNzZXMub3JkZXI7XG5cdFx0XHRcdHZhciBjb2x1bW5zID0gY3R4LmFwaS5jb2x1bW5zKCBjZWxsICk7XG5cdFx0XHRcdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1ucy5mbGF0dGVuKClbMF1dO1xuXHRcdFx0XHR2YXIgb3JkZXJhYmxlID0gY29sdW1ucy5vcmRlcmFibGUoKS5pbmNsdWRlcyh0cnVlKTtcblx0XHRcdFx0dmFyIGFyaWFUeXBlID0gJyc7XG5cdFx0XHRcdHZhciBpbmRleGVzID0gY29sdW1ucy5pbmRleGVzKCk7XG5cdFx0XHRcdHZhciBzb3J0RGlycyA9IGNvbHVtbnMub3JkZXJhYmxlKHRydWUpLmZsYXR0ZW4oKTtcblx0XHRcdFx0dmFyIG9yZGVyZWRDb2x1bW5zID0gX3BsdWNrKHNvcnRpbmcsICdjb2wnKTtcblx0XHRcdFx0dmFyIHRhYkluZGV4ID0gc2V0dGluZ3MuaVRhYkluZGV4O1xuXG5cdFx0XHRcdGNlbGxcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRvcmRlckNsYXNzZXMuaXNBc2MgKycgJytcblx0XHRcdFx0XHRcdG9yZGVyQ2xhc3Nlcy5pc0Rlc2Ncblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCBvcmRlckNsYXNzZXMubm9uZSwgISBvcmRlcmFibGUgKVxuXHRcdFx0XHRcdC50b2dnbGVDbGFzcyggb3JkZXJDbGFzc2VzLmNhbkFzYywgb3JkZXJhYmxlICYmIHNvcnREaXJzLmluY2x1ZGVzKCdhc2MnKSApXG5cdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCBvcmRlckNsYXNzZXMuY2FuRGVzYywgb3JkZXJhYmxlICYmIHNvcnREaXJzLmluY2x1ZGVzKCdkZXNjJykgKTtcblxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgaWYgYWxsIG9mIHRoZSBjb2x1bW5zIHRoYXQgdGhpcyBjZWxsIGNvdmVycyBhcmUgaW5jbHVkZWQgaW4gdGhlXG5cdFx0XHRcdC8vIGN1cnJlbnQgb3JkZXJpbmdcblx0XHRcdFx0dmFyIGlzT3JkZXJpbmcgPSB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChpPTA7IGk8aW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICghIG9yZGVyZWRDb2x1bW5zLmluY2x1ZGVzKGluZGV4ZXNbaV0pKSB7XG5cdFx0XHRcdFx0XHRpc09yZGVyaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc09yZGVyaW5nICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgb3JkZXJpbmcgZGlyZWN0aW9uIGZvciB0aGUgY29sdW1ucyB1bmRlciB0aGlzIGNlbGxcblx0XHRcdFx0XHQvLyBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgZm9yIGEgY2VsbCB0byBiZSBhc2MgYW5kIGRlc2Mgc29ydGluZ1xuXHRcdFx0XHRcdC8vIChjb2x1bW4gc3Bhbm5pbmcgY2VsbHMpXG5cdFx0XHRcdFx0dmFyIG9yZGVyRGlycyA9IGNvbHVtbnMub3JkZXIoKTtcblxuXHRcdFx0XHRcdGNlbGwuYWRkQ2xhc3MoXG5cdFx0XHRcdFx0XHRvcmRlckRpcnMuaW5jbHVkZXMoJ2FzYycpID8gb3JkZXJDbGFzc2VzLmlzQXNjIDogJycgK1xuXHRcdFx0XHRcdFx0b3JkZXJEaXJzLmluY2x1ZGVzKCdkZXNjJykgPyBvcmRlckNsYXNzZXMuaXNEZXNjIDogJydcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgZmlyc3QgdmlzaWJsZSBjb2x1bW4gdGhhdCBoYXMgb3JkZXJpbmcgYXBwbGllZCB0byBpdCAtIGl0IGdldCdzXG5cdFx0XHRcdC8vIHRoZSBhcmlhIGluZm9ybWF0aW9uLCBhcyB0aGUgQVJJQSBzcGVjIHNheXMgdGhhdCBvbmx5IG9uZSBjb2x1bW4gc2hvdWxkXG5cdFx0XHRcdC8vIGJlIG1hcmtlZCB3aXRoIGFyaWEtc29ydFxuXHRcdFx0XHR2YXIgZmlyc3RWaXMgPSAtMTsgLy8gY29sdW1uIGluZGV4XG5cblx0XHRcdFx0Zm9yIChpPTA7IGk8b3JkZXJlZENvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoc2V0dGluZ3MuYW9Db2x1bW5zW29yZGVyZWRDb2x1bW5zW2ldXS5iVmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0Zmlyc3RWaXMgPSBvcmRlcmVkQ29sdW1uc1tpXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpbmRleGVzWzBdID09IGZpcnN0VmlzKSB7XG5cdFx0XHRcdFx0dmFyIGZpcnN0U29ydCA9IHNvcnRpbmdbMF07XG5cdFx0XHRcdFx0dmFyIHNvcnRPcmRlciA9IGNvbC5hc1NvcnRpbmc7XG5cblx0XHRcdFx0XHRjZWxsLmF0dHIoJ2FyaWEtc29ydCcsIGZpcnN0U29ydC5kaXIgPT09ICdhc2MnID8gJ2FzY2VuZGluZycgOiAnZGVzY2VuZGluZycpO1xuXG5cdFx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHRoZSBuZXh0IGNsaWNrIHdpbGwgcmVtb3ZlIHNvcnRpbmcgb3IgY2hhbmdlIHRoZSBzb3J0XG5cdFx0XHRcdFx0YXJpYVR5cGUgPSAhIHNvcnRPcmRlcltmaXJzdFNvcnQuaW5kZXggKyAxXSA/ICdSZW1vdmUnIDogJ1JldmVyc2UnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNlbGwucmVtb3ZlQXR0cignYXJpYS1zb3J0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIHRoZSBoZWFkZXJzIHRhYi1hYmxlIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXG5cdFx0XHRcdGlmIChvcmRlcmFibGUpIHtcblx0XHRcdFx0XHR2YXIgb3JkZXJTcGFuID0gY2VsbC5maW5kKCcuZHQtY29sdW1uLW9yZGVyJyk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3JkZXJTcGFuXG5cdFx0XHRcdFx0XHQuYXR0cigncm9sZScsICdidXR0b24nKVxuXHRcdFx0XHRcdFx0LmF0dHIoJ2FyaWEtbGFiZWwnLCBvcmRlcmFibGVcblx0XHRcdFx0XHRcdFx0PyBjb2wuYXJpYVRpdGxlICsgY3R4LmFwaS5pMThuKCdvQXJpYS5vcmRlcmFibGUnICsgYXJpYVR5cGUpXG5cdFx0XHRcdFx0XHRcdDogY29sLmFyaWFUaXRsZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmICh0YWJJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdG9yZGVyU3Bhbi5hdHRyKCd0YWJpbmRleCcsIHRhYkluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0bGF5b3V0OiB7XG5cdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY29udGFpbmVyLCBpdGVtcyApIHtcblx0XHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMubGF5b3V0O1xuXHRcdFx0dmFyIHJvdyA9ICQoJzxkaXYvPicpXG5cdFx0XHRcdC5hdHRyKCdpZCcsIGl0ZW1zLmlkIHx8IG51bGwpXG5cdFx0XHRcdC5hZGRDbGFzcyhpdGVtcy5jbGFzc05hbWUgfHwgY2xhc3Nlcy5yb3cpXG5cdFx0XHRcdC5hcHBlbmRUbyggY29udGFpbmVyICk7XG5cblx0XHRcdERhdGFUYWJsZS5leHQucmVuZGVyZXIubGF5b3V0Ll9mb3JMYXlvdXRSb3coaXRlbXMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0XHRpZiAoa2V5ID09PSAnaWQnIHx8IGtleSA9PT0gJ2NsYXNzTmFtZScpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIga2xhc3MgPSAnJztcblxuXHRcdFx0XHRpZiAodmFsLnRhYmxlKSB7XG5cdFx0XHRcdFx0cm93LmFkZENsYXNzKGNsYXNzZXMudGFibGVSb3cpO1xuXHRcdFx0XHRcdGtsYXNzICs9IGNsYXNzZXMudGFibGVDZWxsICsgJyAnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGtleSA9PT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRcdGtsYXNzICs9IGNsYXNzZXMuc3RhcnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuXHRcdFx0XHRcdGtsYXNzICs9IGNsYXNzZXMuZW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGtsYXNzICs9IGNsYXNzZXMuZnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0aWQ6IHZhbC5pZCB8fCBudWxsLFxuXHRcdFx0XHRcdFx0XCJjbGFzc1wiOiB2YWwuY2xhc3NOYW1lXG5cdFx0XHRcdFx0XHRcdD8gdmFsLmNsYXNzTmFtZVxuXHRcdFx0XHRcdFx0XHQ6IGNsYXNzZXMuY2VsbCArICcgJyArIGtsYXNzXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYXBwZW5kKCB2YWwuY29udGVudHMgKVxuXHRcdFx0XHRcdC5hcHBlbmRUbyggcm93ICk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly8gU2hhcmVkIGZvciB1c2UgYnkgdGhlIHN0eWxpbmcgZnJhbWV3b3Jrc1xuXHRcdF9mb3JMYXlvdXRSb3c6IGZ1bmN0aW9uIChpdGVtcywgZm4pIHtcblx0XHRcdC8vIEFzIHdlIGFyZSBpbnNlcnRpbmcgZG9tIGVsZW1lbnRzLCB3ZSBuZWVkIHN0YXJ0IC8gZW5kIGluIGFcblx0XHRcdC8vIHNwZWNpZmljIG9yZGVyLCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheW91dFxuXHRcdFx0Ly8ga2V5cy5cblx0XHRcdHZhciBsYXlvdXRFbnVtID0gZnVuY3Rpb24gKHgpIHtcblx0XHRcdFx0c3dpdGNoICh4KSB7XG5cdFx0XHRcdFx0Y2FzZSAnJzogcmV0dXJuIDA7XG5cdFx0XHRcdFx0Y2FzZSAnc3RhcnQnOiByZXR1cm4gMTtcblx0XHRcdFx0XHRjYXNlICdlbmQnOiByZXR1cm4gMjtcblx0XHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gMztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0T2JqZWN0XG5cdFx0XHRcdC5rZXlzKGl0ZW1zKVxuXHRcdFx0XHQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBsYXlvdXRFbnVtKGEpIC0gbGF5b3V0RW51bShiKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdGZuKGtleSwgaXRlbXNba2V5XSk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbkRhdGFUYWJsZS5mZWF0dXJlID0ge307XG5cbi8vIFRoaXJkIHBhcmFtZXRlciBpcyBpbnRlcm5hbCBvbmx5IVxuRGF0YVRhYmxlLmZlYXR1cmUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoIG5hbWUsIGNiLCBsZWdhY3kgKSB7XG5cdERhdGFUYWJsZS5leHQuZmVhdHVyZXNbIG5hbWUgXSA9IGNiO1xuXG5cdGlmIChsZWdhY3kpIHtcblx0XHRfZXh0LmZlYXR1cmUucHVzaCh7XG5cdFx0XHRjRmVhdHVyZTogbGVnYWN5LFxuXHRcdFx0Zm5Jbml0OiBjYlxuXHRcdH0pO1xuXHR9XG59O1xuXG5mdW5jdGlvbiBfZGl2UHJvcChlbCwgcHJvcCwgdmFsKSB7XG5cdGlmICh2YWwpIHtcblx0XHRlbFtwcm9wXSA9IHZhbDtcblx0fVxufVxuXG5EYXRhVGFibGUuZmVhdHVyZS5yZWdpc3RlciggJ2RpdicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKSB7XG5cdHZhciBuID0gJCgnPGRpdj4nKVswXTtcblxuXHRpZiAob3B0cykge1xuXHRcdF9kaXZQcm9wKG4sICdjbGFzc05hbWUnLCBvcHRzLmNsYXNzTmFtZSk7XG5cdFx0X2RpdlByb3AobiwgJ2lkJywgb3B0cy5pZCk7XG5cdFx0X2RpdlByb3AobiwgJ2lubmVySFRNTCcsIG9wdHMuaHRtbCk7XG5cdFx0X2RpdlByb3AobiwgJ3RleHRDb250ZW50Jywgb3B0cy50ZXh0KTtcblx0fVxuXG5cdHJldHVybiBuO1xufSApO1xuXG5EYXRhVGFibGUuZmVhdHVyZS5yZWdpc3RlciggJ2luZm8nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzICkge1xuXHQvLyBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBsZWdhY3kgYGluZm9gIHRvcCBsZXZlbCBvcHRpb25cblx0aWYgKCEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJJbmZvKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXJcblx0XHRsYW5nICA9IHNldHRpbmdzLm9MYW5ndWFnZSxcblx0XHR0aWQgPSBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRuID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0J2NsYXNzJzogc2V0dGluZ3Mub0NsYXNzZXMuaW5mby5jb250YWluZXIsXG5cdFx0fSApO1xuXG5cdG9wdHMgPSAkLmV4dGVuZCh7XG5cdFx0Y2FsbGJhY2s6IGxhbmcuZm5JbmZvQ2FsbGJhY2ssXG5cdFx0ZW1wdHk6IGxhbmcuc0luZm9FbXB0eSxcblx0XHRwb3N0Zml4OiBsYW5nLnNJbmZvUG9zdEZpeCxcblx0XHRzZWFyY2g6IGxhbmcuc0luZm9GaWx0ZXJlZCxcblx0XHR0ZXh0OiBsYW5nLnNJbmZvLFxuXHR9LCBvcHRzKTtcblxuXG5cdC8vIFVwZGF0ZSBkaXNwbGF5IG9uIGVhY2ggZHJhd1xuXHRzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKGZ1bmN0aW9uIChzKSB7XG5cdFx0X2ZuVXBkYXRlSW5mbyhzLCBvcHRzLCBuKTtcblx0fSk7XG5cblx0Ly8gRm9yIHRoZSBmaXJzdCBpbmZvIGRpc3BsYXkgaW4gdGhlIHRhYmxlLCB3ZSBhZGQgYSBjYWxsYmFjayBhbmQgYXJpYSBpbmZvcm1hdGlvbi5cblx0aWYgKCEgc2V0dGluZ3MuX2luZm9FbCkge1xuXHRcdG4uYXR0cih7XG5cdFx0XHQnYXJpYS1saXZlJzogJ3BvbGl0ZScsXG5cdFx0XHRpZDogdGlkKydfaW5mbycsXG5cdFx0XHRyb2xlOiAnc3RhdHVzJ1xuXHRcdH0pO1xuXG5cdFx0Ly8gVGFibGUgaXMgZGVzY3JpYmVkIGJ5IG91ciBpbmZvIGRpdlxuXHRcdCQoc2V0dGluZ3MublRhYmxlKS5hdHRyKCAnYXJpYS1kZXNjcmliZWRieScsIHRpZCsnX2luZm8nICk7XG5cblx0XHRzZXR0aW5ncy5faW5mb0VsID0gbjtcblx0fVxuXG5cdHJldHVybiBuO1xufSwgJ2knICk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50cyBpbiB0aGUgZGlzcGxheVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5VcGRhdGVJbmZvICggc2V0dGluZ3MsIG9wdHMsIG5vZGUgKVxue1xuXHR2YXJcblx0XHRzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0KzEsXG5cdFx0ZW5kICAgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRtYXggICA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG5cdFx0dG90YWwgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0b3V0ICAgPSB0b3RhbFxuXHRcdFx0PyBvcHRzLnRleHRcblx0XHRcdDogb3B0cy5lbXB0eTtcblxuXHRpZiAoIHRvdGFsICE9PSBtYXggKSB7XG5cdFx0Ly8gUmVjb3JkIHNldCBhZnRlciBmaWx0ZXJpbmdcblx0XHRvdXQgKz0gJyAnICsgb3B0cy5zZWFyY2g7XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRoZSBtYWNyb3Ncblx0b3V0ICs9IG9wdHMucG9zdGZpeDtcblx0b3V0ID0gX2ZuTWFjcm9zKCBzZXR0aW5ncywgb3V0ICk7XG5cblx0aWYgKCBvcHRzLmNhbGxiYWNrICkge1xuXHRcdG91dCA9IG9wdHMuY2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLFxuXHRcdFx0c2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIG91dFxuXHRcdCk7XG5cdH1cblxuXHRub2RlLmh0bWwoIG91dCApO1xuXG5cdF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ2luZm8nLCBbc2V0dGluZ3MsIG5vZGVbMF0sIG91dF0pO1xufVxuXG52YXIgX19zZWFyY2hDb3VudGVyID0gMDtcblxuLy8gb3B0c1xuLy8gLSB0ZXh0XG4vLyAtIHBsYWNlaG9sZGVyXG5EYXRhVGFibGUuZmVhdHVyZS5yZWdpc3RlciggJ3NlYXJjaCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKSB7XG5cdC8vIERvbid0IHNob3cgdGhlIGlucHV0IGlmIGZpbHRlcmluZyBpc24ndCBhdmFpbGFibGUgb24gdGhlIHRhYmxlXG5cdGlmICghIHNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzLnNlYXJjaDtcblx0dmFyIHRhYmxlSWQgPSBzZXR0aW5ncy5zVGFibGVJZDtcblx0dmFyIGxhbmd1YWdlID0gc2V0dGluZ3Mub0xhbmd1YWdlO1xuXHR2YXIgcHJldmlvdXNTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG5cdHZhciBpbnB1dCA9ICc8aW5wdXQgdHlwZT1cInNlYXJjaFwiIGNsYXNzPVwiJytjbGFzc2VzLmlucHV0KydcIi8+JztcblxuXHRvcHRzID0gJC5leHRlbmQoe1xuXHRcdHBsYWNlaG9sZGVyOiBsYW5ndWFnZS5zU2VhcmNoUGxhY2Vob2xkZXIsXG5cdFx0cHJvY2Vzc2luZzogZmFsc2UsXG5cdFx0dGV4dDogbGFuZ3VhZ2Uuc1NlYXJjaFxuXHR9LCBvcHRzKTtcblxuXHQvLyBUaGUgX0lOUFVUXyBpcyBvcHRpb25hbCAtIGlzIGFwcGVuZGVkIGlmIG5vdCBwcmVzZW50XG5cdGlmIChvcHRzLnRleHQuaW5kZXhPZignX0lOUFVUXycpID09PSAtMSkge1xuXHRcdG9wdHMudGV4dCArPSAnX0lOUFVUXyc7XG5cdH1cblxuXHRvcHRzLnRleHQgPSBfZm5NYWNyb3Moc2V0dGluZ3MsIG9wdHMudGV4dCk7XG5cblx0Ly8gV2UgY2FuIHB1dCB0aGUgPGlucHV0PiBvdXRzaWRlIG9mIHRoZSBsYWJlbCBpZiBpdCBpcyBhdCB0aGUgc3RhcnQgb3IgZW5kXG5cdC8vIHdoaWNoIGhlbHBzIGltcHJvdmUgYWNjZXNzYWJpbGl0eSAobm90IGFsbCBzY3JlZW4gcmVhZGVycyBsaWtlIGltcGxpY2l0XG5cdC8vIGZvciBlbGVtZW50cykuXG5cdHZhciBlbmQgPSBvcHRzLnRleHQubWF0Y2goL19JTlBVVF8kLyk7XG5cdHZhciBzdGFydCA9IG9wdHMudGV4dC5tYXRjaCgvXl9JTlBVVF8vKTtcblx0dmFyIHJlbW92ZWQgPSBvcHRzLnRleHQucmVwbGFjZSgvX0lOUFVUXy8sICcnKTtcblx0dmFyIHN0ciA9ICc8bGFiZWw+JyArIG9wdHMudGV4dCArICc8L2xhYmVsPic7XG5cblx0aWYgKHN0YXJ0KSB7XG5cdFx0c3RyID0gJ19JTlBVVF88bGFiZWw+JyArIHJlbW92ZWQgKyAnPC9sYWJlbD4nO1xuXHR9XG5cdGVsc2UgaWYgKGVuZCkge1xuXHRcdHN0ciA9ICc8bGFiZWw+JyArIHJlbW92ZWQgKyAnPC9sYWJlbD5fSU5QVVRfJztcblx0fVxuXG5cdHZhciBmaWx0ZXIgPSAkKCc8ZGl2PicpXG5cdFx0LmFkZENsYXNzKGNsYXNzZXMuY29udGFpbmVyKVxuXHRcdC5hcHBlbmQoc3RyLnJlcGxhY2UoL19JTlBVVF8vLCBpbnB1dCkpO1xuXG5cdC8vIGFkZCBmb3IgYW5kIGlkIHRvIGxhYmVsIGFuZCBpbnB1dFxuXHRmaWx0ZXIuZmluZCgnbGFiZWwnKS5hdHRyKCdmb3InLCAnZHQtc2VhcmNoLScgKyBfX3NlYXJjaENvdW50ZXIpO1xuXHRmaWx0ZXIuZmluZCgnaW5wdXQnKS5hdHRyKCdpZCcsICdkdC1zZWFyY2gtJyArIF9fc2VhcmNoQ291bnRlcik7XG5cdF9fc2VhcmNoQ291bnRlcisrO1xuXG5cdHZhciBzZWFyY2hGbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZhbCA9IHRoaXMudmFsdWU7XG5cblx0XHRpZihwcmV2aW91c1NlYXJjaC5yZXR1cm4gJiYgZXZlbnQua2V5ICE9PSBcIkVudGVyXCIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBOb3cgZG8gdGhlIGZpbHRlciAqL1xuXHRcdGlmICggdmFsICE9IHByZXZpb3VzU2VhcmNoLnNlYXJjaCApIHtcblx0XHRcdF9mblByb2Nlc3NpbmdSdW4oc2V0dGluZ3MsIG9wdHMucHJvY2Vzc2luZywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwcmV2aW91c1NlYXJjaC5zZWFyY2ggPSB2YWw7XG5cdFx0XG5cdFx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgcHJldmlvdXNTZWFyY2ggKTtcblx0XHRcblx0XHRcdFx0Ly8gTmVlZCB0byByZWRyYXcsIHdpdGhvdXQgcmVzb3J0aW5nXG5cdFx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgc2VhcmNoRGVsYXkgPSBzZXR0aW5ncy5zZWFyY2hEZWxheSAhPT0gbnVsbCA/XG5cdFx0c2V0dGluZ3Muc2VhcmNoRGVsYXkgOlxuXHRcdDA7XG5cblx0dmFyIGpxRmlsdGVyID0gJCgnaW5wdXQnLCBmaWx0ZXIpXG5cdFx0LnZhbCggcHJldmlvdXNTZWFyY2guc2VhcmNoIClcblx0XHQuYXR0ciggJ3BsYWNlaG9sZGVyJywgb3B0cy5wbGFjZWhvbGRlciApXG5cdFx0Lm9uKFxuXHRcdFx0J2tleXVwLkRUIHNlYXJjaC5EVCBpbnB1dC5EVCBwYXN0ZS5EVCBjdXQuRFQnLFxuXHRcdFx0c2VhcmNoRGVsYXkgP1xuXHRcdFx0XHREYXRhVGFibGUudXRpbC5kZWJvdW5jZSggc2VhcmNoRm4sIHNlYXJjaERlbGF5ICkgOlxuXHRcdFx0XHRzZWFyY2hGblxuXHRcdClcblx0XHQub24oICdtb3VzZXVwLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8gRWRnZSBmaXghIEVkZ2UgMTcgZG9lcyBub3QgdHJpZ2dlciBhbnl0aGluZyBvdGhlciB0aGFuIG1vdXNlIGV2ZW50cyB3aGVuIGNsaWNraW5nXG5cdFx0XHQvLyBvbiB0aGUgY2xlYXIgaWNvbiAoRWRnZSBidWcgMTc1ODQ1MTUpLiBUaGlzIGlzIHNhZmUgaW4gb3RoZXIgYnJvd3NlcnMgYXMgYHNlYXJjaEZuYFxuXHRcdFx0Ly8gY2hlY2tzIHRoZSB2YWx1ZSB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQuIEluIG90aGVyIGJyb3dzZXJzIGl0IHdvbid0IGhhdmUuXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlYXJjaEZuLmNhbGwoanFGaWx0ZXJbMF0sIGUpO1xuXHRcdFx0fSwgMTApO1xuXHRcdH0gKVxuXHRcdC5vbiggJ2tleXByZXNzLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0LyogUHJldmVudCBmb3JtIHN1Ym1pc3Npb24gKi9cblx0XHRcdGlmICggZS5rZXlDb2RlID09IDEzICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSApXG5cdFx0LmF0dHIoJ2FyaWEtY29udHJvbHMnLCB0YWJsZUlkKTtcblxuXHQvLyBVcGRhdGUgdGhlIGlucHV0IGVsZW1lbnRzIHdoZW5ldmVyIHRoZSB0YWJsZSBpcyBmaWx0ZXJlZFxuXHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdzZWFyY2guZHQuRFQnLCBmdW5jdGlvbiAoIGV2LCBzICkge1xuXHRcdGlmICggc2V0dGluZ3MgPT09IHMgJiYganFGaWx0ZXJbMF0gIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgKSB7XG5cdFx0XHRqcUZpbHRlci52YWwoIHR5cGVvZiBwcmV2aW91c1NlYXJjaC5zZWFyY2ggIT09ICdmdW5jdGlvbidcblx0XHRcdFx0PyBwcmV2aW91c1NlYXJjaC5zZWFyY2hcblx0XHRcdFx0OiAnJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gZmlsdGVyO1xufSwgJ2YnICk7XG5cbi8vIG9wdHNcbi8vIC0gdHlwZSAtIGJ1dHRvbiBjb25maWd1cmF0aW9uXG4vLyAtIGJ1dHRvbnMgLSBudW1iZXIgb2YgYnV0dG9ucyB0byBzaG93IC0gbXVzdCBiZSBvZGRcbkRhdGFUYWJsZS5mZWF0dXJlLnJlZ2lzdGVyKCAncGFnaW5nJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApIHtcblx0Ly8gRG9uJ3Qgc2hvdyB0aGUgcGFnaW5nIGlucHV0IGlmIHRoZSB0YWJsZSBkb2Vzbid0IGhhdmUgcGFnaW5nIGVuYWJsZWRcblx0aWYgKCEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJQYWdpbmF0ZSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0b3B0cyA9ICQuZXh0ZW5kKHtcblx0XHRidXR0b25zOiBEYXRhVGFibGUuZXh0LnBhZ2VyLm51bWJlcnNfbGVuZ3RoLFxuXHRcdHR5cGU6IHNldHRpbmdzLnNQYWdpbmF0aW9uVHlwZSxcblx0XHRib3VuZGFyeU51bWJlcnM6IHRydWUsXG5cdFx0Zmlyc3RMYXN0OiB0cnVlLFxuXHRcdHByZXZpb3VzTmV4dDogdHJ1ZSxcblx0XHRudW1iZXJzOiB0cnVlXG5cdH0sIG9wdHMpO1xuXG5cdHZhciBob3N0ID0gJCgnPGRpdi8+Jylcblx0XHQuYWRkQ2xhc3Moc2V0dGluZ3Mub0NsYXNzZXMucGFnaW5nLmNvbnRhaW5lciArIChvcHRzLnR5cGUgPyAnIHBhZ2luZ18nICsgb3B0cy50eXBlIDogJycpKVxuXHRcdC5hcHBlbmQoXG5cdFx0XHQkKCc8bmF2PicpXG5cdFx0XHRcdC5hdHRyKCdhcmlhLWxhYmVsJywgJ3BhZ2luYXRpb24nKVxuXHRcdFx0XHQuYWRkQ2xhc3Moc2V0dGluZ3Mub0NsYXNzZXMucGFnaW5nLm5hdilcblx0XHQpO1xuXHR2YXIgZHJhdyA9IGZ1bmN0aW9uICgpIHtcblx0XHRfcGFnaW5nRHJhdyhzZXR0aW5ncywgaG9zdC5jaGlsZHJlbigpLCBvcHRzKTtcblx0fTtcblxuXHRzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKGRyYXcpO1xuXG5cdC8vIFJlc3BvbnNpdmUgcmVkcmF3IG9mIHBhZ2luZyBjb250cm9sXG5cdCQoc2V0dGluZ3MublRhYmxlKS5vbignY29sdW1uLXNpemluZy5kdC5EVCcsIGRyYXcpO1xuXG5cdHJldHVybiBob3N0O1xufSwgJ3AnICk7XG5cbi8qKlxuICogRHluYW1pY2FsbHkgY3JlYXRlIHRoZSBidXR0b24gdHlwZSBhcnJheSBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogVGhpcyB3aWxsIG9ubHkgaGFwcGVuIGlmIHRoZSBwYWdpbmcgdHlwZSBpcyBub3QgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gX3BhZ2luZ0R5bmFtaWMob3B0cykge1xuXHR2YXIgb3V0ID0gW107XG5cblx0aWYgKG9wdHMubnVtYmVycykge1xuXHRcdG91dC5wdXNoKCdudW1iZXJzJyk7XG5cdH1cblxuXHRpZiAob3B0cy5wcmV2aW91c05leHQpIHtcblx0XHRvdXQudW5zaGlmdCgncHJldmlvdXMnKTtcblx0XHRvdXQucHVzaCgnbmV4dCcpO1xuXHR9XG5cblx0aWYgKG9wdHMuZmlyc3RMYXN0KSB7XG5cdFx0b3V0LnVuc2hpZnQoJ2ZpcnN0Jyk7XG5cdFx0b3V0LnB1c2goJ2xhc3QnKTtcblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIF9wYWdpbmdEcmF3KHNldHRpbmdzLCBob3N0LCBvcHRzKSB7XG5cdGlmICghIHNldHRpbmdzLl9iSW5pdENvbXBsZXRlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyXG5cdFx0cGx1Z2luID0gb3B0cy50eXBlXG5cdFx0XHQ/IERhdGFUYWJsZS5leHQucGFnZXJbIG9wdHMudHlwZSBdXG5cdFx0XHQ6IF9wYWdpbmdEeW5hbWljLFxuXHRcdGFyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWEucGFnaW5hdGUgfHwge30sXG5cdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMSxcblx0XHRwYWdlID0gYWxsID8gMCA6IE1hdGguY2VpbCggc3RhcnQgLyBsZW4gKSxcblx0XHRwYWdlcyA9IGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpc1JlY29yZHMgLyBsZW4gKSxcblx0XHRidXR0b25zID0gW10sXG5cdFx0YnV0dG9uRWxzID0gW10sXG5cdFx0YnV0dG9uc05lc3RlZCA9IHBsdWdpbihvcHRzKVxuXHRcdFx0Lm1hcChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHJldHVybiB2YWwgPT09ICdudW1iZXJzJ1xuXHRcdFx0XHRcdD8gX3BhZ2luZ051bWJlcnMocGFnZSwgcGFnZXMsIG9wdHMuYnV0dG9ucywgb3B0cy5ib3VuZGFyeU51bWJlcnMpXG5cdFx0XHRcdFx0OiB2YWw7XG5cdFx0XHR9KTtcblxuXHQvLyAuZmxhdCgpIHdvdWxkIGJlIGJldHRlciwgYnV0IG5vdCBzdXBwb3J0ZWQgaW4gb2xkIFNhZmFyaVxuXHRidXR0b25zID0gYnV0dG9ucy5jb25jYXQuYXBwbHkoYnV0dG9ucywgYnV0dG9uc05lc3RlZCk7XG5cblx0Zm9yICh2YXIgaT0wIDsgaTxidXR0b25zLmxlbmd0aCA7IGkrKykge1xuXHRcdHZhciBidXR0b24gPSBidXR0b25zW2ldO1xuXG5cdFx0dmFyIGJ0bkluZm8gPSBfcGFnaW5nQnV0dG9uSW5mbyhzZXR0aW5ncywgYnV0dG9uLCBwYWdlLCBwYWdlcyk7XG5cdFx0dmFyIGJ0biA9IF9mblJlbmRlcmVyKCBzZXR0aW5ncywgJ3BhZ2luZ0J1dHRvbicgKShcblx0XHRcdHNldHRpbmdzLFxuXHRcdFx0YnV0dG9uLFxuXHRcdFx0YnRuSW5mby5kaXNwbGF5LFxuXHRcdFx0YnRuSW5mby5hY3RpdmUsXG5cdFx0XHRidG5JbmZvLmRpc2FibGVkXG5cdFx0KTtcblxuXHRcdHZhciBhcmlhTGFiZWwgPSB0eXBlb2YgYnV0dG9uID09PSAnc3RyaW5nJ1xuXHRcdFx0PyBhcmlhWyBidXR0b24gXVxuXHRcdFx0OiBhcmlhLm51bWJlclxuXHRcdFx0XHQ/IGFyaWEubnVtYmVyICsgKGJ1dHRvbisxKVxuXHRcdFx0XHQ6IG51bGw7XG5cblx0XHQvLyBDb21tb24gYXR0cmlidXRlc1xuXHRcdCQoYnRuLmNsaWNrZXIpLmF0dHIoe1xuXHRcdFx0J2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdCdhcmlhLWRpc2FibGVkJzogYnRuSW5mby5kaXNhYmxlZCA/ICd0cnVlJyA6IG51bGwsXG5cdFx0XHQnYXJpYS1jdXJyZW50JzogYnRuSW5mby5hY3RpdmUgPyAncGFnZScgOiBudWxsLFxuXHRcdFx0J2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG5cdFx0XHQnZGF0YS1kdC1pZHgnOiBidXR0b24sXG5cdFx0XHQndGFiSW5kZXgnOiBidG5JbmZvLmRpc2FibGVkXG5cdFx0XHRcdD8gLTFcblx0XHRcdFx0OiBzZXR0aW5ncy5pVGFiSW5kZXggJiYgYnRuLmNsaWNrZXJbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3NwYW4nXG5cdFx0XHRcdFx0PyBzZXR0aW5ncy5pVGFiSW5kZXhcblx0XHRcdFx0XHQ6IG51bGwsIC8vIGAwYCBkb2Vzbid0IG5lZWQgYSB0YWJJbmRleCBzaW5jZSBpdCBpcyB0aGUgZGVmYXVsdFxuXHRcdH0pO1xuXG5cdFx0aWYgKHR5cGVvZiBidXR0b24gIT09ICdudW1iZXInKSB7XG5cdFx0XHQkKGJ0bi5jbGlja2VyKS5hZGRDbGFzcyhidXR0b24pO1xuXHRcdH1cblxuXHRcdF9mbkJpbmRBY3Rpb24oXG5cdFx0XHRidG4uY2xpY2tlciwge2FjdGlvbjogYnV0dG9ufSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0X2ZuUGFnZUNoYW5nZSggc2V0dGluZ3MsIGUuZGF0YS5hY3Rpb24sIHRydWUgKTtcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0YnV0dG9uRWxzLnB1c2goYnRuLmRpc3BsYXkpO1xuXHR9XG5cblx0dmFyIHdyYXBwZWQgPSBfZm5SZW5kZXJlcihzZXR0aW5ncywgJ3BhZ2luZ0NvbnRhaW5lcicpKFxuXHRcdHNldHRpbmdzLCBidXR0b25FbHNcblx0KTtcblxuXHR2YXIgYWN0aXZlRWwgPSBob3N0LmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG5cblx0aG9zdC5lbXB0eSgpLmFwcGVuZCh3cmFwcGVkKTtcblxuXHRpZiAoIGFjdGl2ZUVsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0aG9zdC5maW5kKCAnW2RhdGEtZHQtaWR4PScrYWN0aXZlRWwrJ10nICkudHJpZ2dlcignZm9jdXMnKTtcblx0fVxuXG5cdC8vIFJlc3BvbnNpdmUgLSBjaGVjayBpZiB0aGUgYnV0dG9ucyBhcmUgb3ZlciB0d28gbGluZXMgYmFzZWQgb24gdGhlXG5cdC8vIGhlaWdodCBvZiB0aGUgYnV0dG9ucyBhbmQgdGhlIGNvbnRhaW5lci5cblx0aWYgKGJ1dHRvbkVscy5sZW5ndGgpIHtcblx0XHR2YXIgb3V0ZXJIZWlnaHQgPSAkKGJ1dHRvbkVsc1swXSkub3V0ZXJIZWlnaHQoKTtcblx0XG5cdFx0aWYgKFxuXHRcdFx0b3B0cy5idXR0b25zID4gMSAmJiAvLyBwcmV2ZW50IGluZmluaXRlXG5cdFx0XHRvdXRlckhlaWdodCA+IDAgJiYgLy8gd2lsbCBiZSAwIGlmIGhpZGRlblxuXHRcdFx0JChob3N0KS5oZWlnaHQoKSA+PSAob3V0ZXJIZWlnaHQgKiAyKSAtIDEwXG5cdFx0KSB7XG5cdFx0XHRfcGFnaW5nRHJhdyhzZXR0aW5ncywgaG9zdCwgJC5leHRlbmQoe30sIG9wdHMsIHsgYnV0dG9uczogb3B0cy5idXR0b25zIC0gMiB9KSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogR2V0IHByb3BlcnRpZXMgZm9yIGEgYnV0dG9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IHBhZ2luZyBzdGF0ZSBvZiB0aGUgdGFibGVcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERUIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBidXR0b24gVGhlIGJ1dHRvbiB0eXBlIGluIHF1ZXN0aW9uXG4gKiBAcGFyYW0geyp9IHBhZ2UgVGFibGUncyBjdXJyZW50IHBhZ2VcbiAqIEBwYXJhbSB7Kn0gcGFnZXMgTnVtYmVyIG9mIHBhZ2VzXG4gKiBAcmV0dXJucyBJbmZvIG9iamVjdFxuICovXG5mdW5jdGlvbiBfcGFnaW5nQnV0dG9uSW5mbyhzZXR0aW5ncywgYnV0dG9uLCBwYWdlLCBwYWdlcykge1xuXHR2YXIgbGFuZyA9IHNldHRpbmdzLm9MYW5ndWFnZS5vUGFnaW5hdGU7XG5cdHZhciBvID0ge1xuXHRcdGRpc3BsYXk6ICcnLFxuXHRcdGFjdGl2ZTogZmFsc2UsXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlXG5cdH07XG5cblx0c3dpdGNoICggYnV0dG9uICkge1xuXHRcdGNhc2UgJ2VsbGlwc2lzJzpcblx0XHRcdG8uZGlzcGxheSA9ICcmI3gyMDI2Oyc7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2ZpcnN0Jzpcblx0XHRcdG8uZGlzcGxheSA9IGxhbmcuc0ZpcnN0O1xuXG5cdFx0XHRpZiAocGFnZSA9PT0gMCkge1xuXHRcdFx0XHRvLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAncHJldmlvdXMnOlxuXHRcdFx0by5kaXNwbGF5ID0gbGFuZy5zUHJldmlvdXM7XG5cblx0XHRcdGlmICggcGFnZSA9PT0gMCApIHtcblx0XHRcdFx0by5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0by5kaXNwbGF5ID0gbGFuZy5zTmV4dDtcblxuXHRcdFx0aWYgKCBwYWdlcyA9PT0gMCB8fCBwYWdlID09PSBwYWdlcy0xICkge1xuXHRcdFx0XHRvLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRvLmRpc3BsYXkgPSBsYW5nLnNMYXN0O1xuXG5cdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdG8uZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0aWYgKCB0eXBlb2YgYnV0dG9uID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0by5kaXNwbGF5ID0gc2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIoIGJ1dHRvbiArIDEgKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYWdlID09PSBidXR0b24pIHtcblx0XHRcdFx0XHRvLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0cmV0dXJuIG87XG59XG5cbi8qKlxuICogQ29tcHV0ZSB3aGF0IG51bWJlciBidXR0b25zIHRvIHNob3cgaW4gdGhlIHBhZ2luZyBjb250cm9sXG4gKlxuICogQHBhcmFtIHsqfSBwYWdlIEN1cnJlbnQgcGFnZVxuICogQHBhcmFtIHsqfSBwYWdlcyBUb3RhbCBudW1iZXIgb2YgcGFnZXNcbiAqIEBwYXJhbSB7Kn0gYnV0dG9ucyBUYXJnZXQgbnVtYmVyIG9mIG51bWJlciBidXR0b25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFkZEZpcnN0TGFzdCBJbmRpY2F0ZSBpZiBwYWdlIDEgYW5kIGVuZCBzaG91bGQgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIEJ1dHRvbnMgdG8gc2hvd1xuICovXG5mdW5jdGlvbiBfcGFnaW5nTnVtYmVycyAoIHBhZ2UsIHBhZ2VzLCBidXR0b25zLCBhZGRGaXJzdExhc3QgKSB7XG5cdHZhclxuXHRcdG51bWJlcnMgPSBbXSxcblx0XHRoYWxmID0gTWF0aC5mbG9vcihidXR0b25zIC8gMiksXG5cdFx0YmVmb3JlID0gYWRkRmlyc3RMYXN0ID8gMiA6IDEsXG5cdFx0YWZ0ZXIgPSBhZGRGaXJzdExhc3QgPyAxIDogMDtcblxuXHRpZiAoIHBhZ2VzIDw9IGJ1dHRvbnMgKSB7XG5cdFx0bnVtYmVycyA9IF9yYW5nZSgwLCBwYWdlcyk7XG5cdH1cblx0ZWxzZSBpZiAoYnV0dG9ucyA9PT0gMSkge1xuXHRcdC8vIFNpbmdsZSBidXR0b24gLSBjdXJyZW50IHBhZ2Ugb25seVxuXHRcdG51bWJlcnMgPSBbcGFnZV07XG5cdH1cblx0ZWxzZSBpZiAoYnV0dG9ucyA9PT0gMykge1xuXHRcdC8vIFNwZWNpYWwgbG9naWMgZm9yIGp1c3QgdGhyZWUgYnV0dG9uc1xuXHRcdGlmIChwYWdlIDw9IDEpIHtcblx0XHRcdG51bWJlcnMgPSBbMCwgMSwgJ2VsbGlwc2lzJ107XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBhZ2UgPj0gcGFnZXMgLSAyKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKHBhZ2VzLTIsIHBhZ2VzKTtcblx0XHRcdG51bWJlcnMudW5zaGlmdCgnZWxsaXBzaXMnKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRudW1iZXJzID0gWydlbGxpcHNpcycsIHBhZ2UsICdlbGxpcHNpcyddO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggcGFnZSA8PSBoYWxmICkge1xuXHRcdG51bWJlcnMgPSBfcmFuZ2UoMCwgYnV0dG9ucy1iZWZvcmUpO1xuXHRcdG51bWJlcnMucHVzaCgnZWxsaXBzaXMnKTtcblxuXHRcdGlmIChhZGRGaXJzdExhc3QpIHtcblx0XHRcdG51bWJlcnMucHVzaChwYWdlcy0xKTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHBhZ2UgPj0gcGFnZXMgLSAxIC0gaGFsZiApIHtcblx0XHRudW1iZXJzID0gX3JhbmdlKHBhZ2VzLShidXR0b25zLWJlZm9yZSksIHBhZ2VzKTtcblx0XHRudW1iZXJzLnVuc2hpZnQoJ2VsbGlwc2lzJyk7XG5cblx0XHRpZiAoYWRkRmlyc3RMYXN0KSB7XG5cdFx0XHRudW1iZXJzLnVuc2hpZnQoMCk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdG51bWJlcnMgPSBfcmFuZ2UocGFnZS1oYWxmK2JlZm9yZSwgcGFnZStoYWxmLWFmdGVyKTtcblx0XHRudW1iZXJzLnB1c2goJ2VsbGlwc2lzJyk7XG5cdFx0bnVtYmVycy51bnNoaWZ0KCdlbGxpcHNpcycpO1xuXG5cdFx0aWYgKGFkZEZpcnN0TGFzdCkge1xuXHRcdFx0bnVtYmVycy5wdXNoKHBhZ2VzLTEpO1xuXHRcdFx0bnVtYmVycy51bnNoaWZ0KDApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudW1iZXJzO1xufVxuXG52YXIgX19sZW5ndGhDb3VudGVyID0gMDtcblxuLy8gb3B0c1xuLy8gLSBtZW51XG4vLyAtIHRleHRcbkRhdGFUYWJsZS5mZWF0dXJlLnJlZ2lzdGVyKCAncGFnZUxlbmd0aCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKSB7XG5cdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcblxuXHQvLyBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBsZWdhY3kgYHBhZ2VMZW5ndGhgIHRvcCBsZXZlbCBvcHRpb25cblx0aWYgKCEgZmVhdHVyZXMuYlBhZ2luYXRlIHx8ICEgZmVhdHVyZXMuYkxlbmd0aENoYW5nZSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0b3B0cyA9ICQuZXh0ZW5kKHtcblx0XHRtZW51OiBzZXR0aW5ncy5hTGVuZ3RoTWVudSxcblx0XHR0ZXh0OiBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0xlbmd0aE1lbnVcblx0fSwgb3B0cyk7XG5cblx0dmFyXG5cdFx0Y2xhc3NlcyAgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5sZW5ndGgsXG5cdFx0dGFibGVJZCAgPSBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRtZW51ICAgICA9IG9wdHMubWVudSxcblx0XHRsZW5ndGhzICA9IFtdLFxuXHRcdGxhbmd1YWdlID0gW10sXG5cdFx0aTtcblxuXHQvLyBPcHRpb25zIGNhbiBiZSBnaXZlbiBpbiBhIG51bWJlciBvZiB3YXlzXG5cdGlmIChBcnJheS5pc0FycmF5KCBtZW51WzBdICkpIHtcblx0XHQvLyBPbGQgMS54IHN0eWxlIC0gMkQgYXJyYXlcblx0XHRsZW5ndGhzID0gbWVudVswXTtcblx0XHRsYW5ndWFnZSA9IG1lbnVbMV07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Zm9yICggaT0wIDsgaTxtZW51Lmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdC8vIEFuIG9iamVjdCB3aXRoIGRpZmZlcmVudCBsYWJlbCBhbmQgdmFsdWVcblx0XHRcdGlmICgkLmlzUGxhaW5PYmplY3QobWVudVtpXSkpIHtcblx0XHRcdFx0bGVuZ3Rocy5wdXNoKG1lbnVbaV0udmFsdWUpO1xuXHRcdFx0XHRsYW5ndWFnZS5wdXNoKG1lbnVbaV0ubGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE9yIGp1c3QgYSBudW1iZXIgdG8gZGlzcGxheSBhbmQgdXNlXG5cdFx0XHRcdGxlbmd0aHMucHVzaChtZW51W2ldKTtcblx0XHRcdFx0bGFuZ3VhZ2UucHVzaChtZW51W2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBXZSBjYW4gcHV0IHRoZSA8c2VsZWN0PiBvdXRzaWRlIG9mIHRoZSBsYWJlbCBpZiBpdCBpcyBhdCB0aGUgc3RhcnQgb3Jcblx0Ly8gZW5kIHdoaWNoIGhlbHBzIGltcHJvdmUgYWNjZXNzYWJpbGl0eSAobm90IGFsbCBzY3JlZW4gcmVhZGVycyBsaWtlXG5cdC8vIGltcGxpY2l0IGZvciBlbGVtZW50cykuXG5cdHZhciBlbmQgPSBvcHRzLnRleHQubWF0Y2goL19NRU5VXyQvKTtcblx0dmFyIHN0YXJ0ID0gb3B0cy50ZXh0Lm1hdGNoKC9eX01FTlVfLyk7XG5cdHZhciByZW1vdmVkID0gb3B0cy50ZXh0LnJlcGxhY2UoL19NRU5VXy8sICcnKTtcblx0dmFyIHN0ciA9ICc8bGFiZWw+JyArIG9wdHMudGV4dCArICc8L2xhYmVsPic7XG5cblx0aWYgKHN0YXJ0KSB7XG5cdFx0c3RyID0gJ19NRU5VXzxsYWJlbD4nICsgcmVtb3ZlZCArICc8L2xhYmVsPic7XG5cdH1cblx0ZWxzZSBpZiAoZW5kKSB7XG5cdFx0c3RyID0gJzxsYWJlbD4nICsgcmVtb3ZlZCArICc8L2xhYmVsPl9NRU5VXyc7XG5cdH1cblxuXHQvLyBXcmFwcGVyIGVsZW1lbnQgLSB1c2UgYSBzcGFuIGFzIGEgaG9sZGVyIGZvciB3aGVyZSB0aGUgc2VsZWN0IHdpbGwgZ29cblx0dmFyIHRtcElkID0gJ3RtcC0nICsgKCtuZXcgRGF0ZSgpKVxuXHR2YXIgZGl2ID0gJCgnPGRpdi8+Jylcblx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuY29udGFpbmVyIClcblx0XHQuYXBwZW5kKFxuXHRcdFx0c3RyLnJlcGxhY2UoICdfTUVOVV8nLCAnPHNwYW4gaWQ9XCInK3RtcElkKydcIj48L3NwYW4+JyApXG5cdFx0KTtcblxuXHQvLyBTYXZlIHRleHQgbm9kZSBjb250ZW50IGZvciBtYWNybyB1cGRhdGluZ1xuXHR2YXIgdGV4dE5vZGVzID0gW107XG5cdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRpdi5maW5kKCdsYWJlbCcpWzBdLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdFx0aWYgKGVsLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0dGV4dE5vZGVzLnB1c2goe1xuXHRcdFx0XHRlbDogZWwsXG5cdFx0XHRcdHRleHQ6IGVsLnRleHRDb250ZW50XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFVwZGF0ZSB0aGUgbGFiZWwgdGV4dCBpbiBjYXNlIGl0IGhhcyBhbiBlbnRyaWVzIHZhbHVlXG5cdHZhciB1cGRhdGVFbnRyaWVzID0gZnVuY3Rpb24gKGxlbikge1xuXHRcdHRleHROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRub2RlLmVsLnRleHRDb250ZW50ID0gX2ZuTWFjcm9zKHNldHRpbmdzLCBub2RlLnRleHQsIGxlbik7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBOZXh0LCB0aGUgc2VsZWN0IGl0c2VsZiwgYWxvbmcgd2l0aCB0aGUgb3B0aW9uc1xuXHR2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xuXHRcdCdhcmlhLWNvbnRyb2xzJzogdGFibGVJZCxcblx0XHQnY2xhc3MnOiAgICAgICAgIGNsYXNzZXMuc2VsZWN0XG5cdH0gKTtcblxuXHRmb3IgKCBpPTAgOyBpPGxlbmd0aHMubGVuZ3RoIDsgaSsrICkge1xuXHRcdHNlbGVjdFswXVsgaSBdID0gbmV3IE9wdGlvbihcblx0XHRcdHR5cGVvZiBsYW5ndWFnZVtpXSA9PT0gJ251bWJlcicgP1xuXHRcdFx0XHRzZXR0aW5ncy5mbkZvcm1hdE51bWJlciggbGFuZ3VhZ2VbaV0gKSA6XG5cdFx0XHRcdGxhbmd1YWdlW2ldLFxuXHRcdFx0bGVuZ3Roc1tpXVxuXHRcdCk7XG5cdH1cblxuXHQvLyBhZGQgZm9yIGFuZCBpZCB0byBsYWJlbCBhbmQgaW5wdXRcblx0ZGl2LmZpbmQoJ2xhYmVsJykuYXR0cignZm9yJywgJ2R0LWxlbmd0aC0nICsgX19sZW5ndGhDb3VudGVyKTtcblx0c2VsZWN0LmF0dHIoJ2lkJywgJ2R0LWxlbmd0aC0nICsgX19sZW5ndGhDb3VudGVyKTtcblx0X19sZW5ndGhDb3VudGVyKys7XG5cblx0Ly8gU3dhcCBpbiB0aGUgc2VsZWN0IGxpc3Rcblx0ZGl2LmZpbmQoJyMnICsgdG1wSWQpLnJlcGxhY2VXaXRoKHNlbGVjdCk7XG5cblx0Ly8gQ2FuJ3QgdXNlIGBzZWxlY3RgIHZhcmlhYmxlIGFzIHVzZXIgbWlnaHQgcHJvdmlkZSB0aGVpciBvd24gYW5kIHRoZVxuXHQvLyByZWZlcmVuY2UgaXMgYnJva2VuIGJ5IHRoZSB1c2Ugb2Ygb3V0ZXJIVE1MXG5cdCQoJ3NlbGVjdCcsIGRpdilcblx0XHQudmFsKCBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggKVxuXHRcdC5vbiggJ2NoYW5nZS5EVCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0X2ZuTGVuZ3RoQ2hhbmdlKCBzZXR0aW5ncywgJCh0aGlzKS52YWwoKSApO1xuXHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9ICk7XG5cblx0Ly8gVXBkYXRlIG5vZGUgdmFsdWUgd2hlbmV2ZXIgYW55dGhpbmcgY2hhbmdlcyB0aGUgdGFibGUncyBsZW5ndGhcblx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnbGVuZ3RoLmR0LkRUJywgZnVuY3Rpb24gKGUsIHMsIGxlbikge1xuXHRcdGlmICggc2V0dGluZ3MgPT09IHMgKSB7XG5cdFx0XHQkKCdzZWxlY3QnLCBkaXYpLnZhbCggbGVuICk7XG5cblx0XHRcdC8vIFJlc29sdmUgcGx1cmFscyBpbiB0aGUgdGV4dCBmb3IgdGhlIG5ldyBsZW5ndGhcblx0XHRcdHVwZGF0ZUVudHJpZXMobGVuKTtcblx0XHR9XG5cdH0gKTtcblxuXHR1cGRhdGVFbnRyaWVzKHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCk7XG5cblx0cmV0dXJuIGRpdjtcbn0sICdsJyApO1xuXG4vLyBqUXVlcnkgYWNjZXNzXG4kLmZuLmRhdGFUYWJsZSA9IERhdGFUYWJsZTtcblxuLy8gUHJvdmlkZSBhY2Nlc3MgdG8gdGhlIGhvc3QgalF1ZXJ5IG9iamVjdCAoY2lyY3VsYXIgcmVmZXJlbmNlKVxuRGF0YVRhYmxlLiQgPSAkO1xuXG4vLyBMZWdhY3kgYWxpYXNlc1xuJC5mbi5kYXRhVGFibGVTZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcbiQuZm4uZGF0YVRhYmxlRXh0ID0gRGF0YVRhYmxlLmV4dDtcblxuLy8gV2l0aCBhIGNhcGl0YWwgYERgIHdlIHJldHVybiBhIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlIHJhdGhlciB0aGFuIGFcbi8vIGpRdWVyeSBvYmplY3RcbiQuZm4uRGF0YVRhYmxlID0gZnVuY3Rpb24gKCBvcHRzICkge1xuXHRyZXR1cm4gJCh0aGlzKS5kYXRhVGFibGUoIG9wdHMgKS5hcGkoKTtcbn07XG5cbi8vIEFsbCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGF2YWlsYWJsZSB0byAkLmZuLmRhdGFUYWJsZSBzaG91bGQgYWxzbyBiZVxuLy8gYXZhaWxhYmxlIG9uICQuZm4uRGF0YVRhYmxlXG4kLmVhY2goIERhdGFUYWJsZSwgZnVuY3Rpb24gKCBwcm9wLCB2YWwgKSB7XG5cdCQuZm4uRGF0YVRhYmxlWyBwcm9wIF0gPSB2YWw7XG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcGxhY2VRdWVyeVBhcmFtZXRlcnMgPSBleHBvcnRzLmV4dHJhY3RRdWVyeVBhcmFtZXRlcnMgPSBleHBvcnRzLnNwbGl0UXVlcnkgPSB2b2lkIDA7XG52YXIgc3BsaXRRdWVyeV8xID0gcmVxdWlyZShcIi4vc3BsaXRRdWVyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNwbGl0UXVlcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwbGl0UXVlcnlfMS5zcGxpdFF1ZXJ5OyB9IH0pO1xudmFyIHF1ZXJ5UGFyYW1IYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9xdWVyeVBhcmFtSGFuZGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImV4dHJhY3RRdWVyeVBhcmFtZXRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXJ5UGFyYW1IYW5kbGVyXzEuZXh0cmFjdFF1ZXJ5UGFyYW1ldGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlcGxhY2VRdWVyeVBhcmFtZXRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXJ5UGFyYW1IYW5kbGVyXzEucmVwbGFjZVF1ZXJ5UGFyYW1ldGVyczsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vcHRpb25zXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcmFjbGVTcGxpdHRlck9wdGlvbnMgPSBleHBvcnRzLnJlZGlzU3BsaXR0ZXJPcHRpb25zID0gZXhwb3J0cy5ub1NwbGl0U3BsaXR0ZXJPcHRpb25zID0gZXhwb3J0cy5tb25nb1NwbGl0dGVyT3B0aW9ucyA9IGV4cG9ydHMuc3FsaXRlU3BsaXR0ZXJPcHRpb25zID0gZXhwb3J0cy5wb3N0Z3JlU3BsaXR0ZXJPcHRpb25zID0gZXhwb3J0cy5tc3NxbFNwbGl0dGVyT3B0aW9ucyA9IGV4cG9ydHMubXlzcWxTcGxpdHRlck9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRTcGxpdHRlck9wdGlvbnMgPSB2b2lkIDA7XG5leHBvcnRzLmRlZmF1bHRTcGxpdHRlck9wdGlvbnMgPSB7XG4gICAgc3RyaW5nc0JlZ2luczogW1wiJ1wiXSxcbiAgICBzdHJpbmdzRW5kczogeyBcIidcIjogXCInXCIgfSxcbiAgICBzdHJpbmdFc2NhcGVzOiB7IFwiJ1wiOiBcIidcIiB9LFxuICAgIGFsbG93U2VtaWNvbG9uOiB0cnVlLFxuICAgIGFsbG93Q3VzdG9tRGVsaW1pdGVyOiBmYWxzZSxcbiAgICBhbGxvd0N1c3RvbVNxbFRlcm1pbmF0b3I6IGZhbHNlLFxuICAgIGFsbG93R29EZWxpbWl0ZXI6IGZhbHNlLFxuICAgIGFsbG93U2xhc2hEZWxpbWl0ZXI6IGZhbHNlLFxuICAgIGFsbG93RG9sbGFyRG9sbGFyU3RyaW5nOiBmYWxzZSxcbiAgICBub1NwbGl0OiBmYWxzZSxcbiAgICBza2lwU2VwYXJhdG9yQmVnaW5FbmQ6IGZhbHNlLFxuICAgIGRvdWJsZURhc2hDb21tZW50czogdHJ1ZSxcbiAgICBtdWx0aWxpbmVDb21tZW50czogdHJ1ZSxcbiAgICBqYXZhU2NyaXB0Q29tbWVudHM6IGZhbHNlLFxuICAgIHJldHVyblJpY2hJbmZvOiBmYWxzZSxcbiAgICBzcGxpdEJ5TGluZXM6IGZhbHNlLFxuICAgIHNwbGl0QnlFbXB0eUxpbmU6IGZhbHNlLFxuICAgIHByZXZlbnRTaW5nbGVMaW5lU3BsaXQ6IGZhbHNlLFxuICAgIGFkYXB0aXZlR29TcGxpdDogZmFsc2UsXG4gICAgaWdub3JlQ29tbWVudHM6IGZhbHNlLFxuICAgIGNvcHlGcm9tU3RkaW46IGZhbHNlLFxuICAgIHF1ZXJ5UGFyYW1ldGVyU3R5bGU6IG51bGwsXG59O1xuZXhwb3J0cy5teXNxbFNwbGl0dGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0U3BsaXR0ZXJPcHRpb25zKSwgeyBhbGxvd0N1c3RvbURlbGltaXRlcjogdHJ1ZSwgc3RyaW5nc0JlZ2luczogW1wiJ1wiLCAnYCddLCBzdHJpbmdzRW5kczogeyBcIidcIjogXCInXCIsICdgJzogJ2AnIH0sIHN0cmluZ0VzY2FwZXM6IHsgXCInXCI6ICdcXFxcJywgJ2AnOiAnYCcgfSB9KTtcbmV4cG9ydHMubXNzcWxTcGxpdHRlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4cG9ydHMuZGVmYXVsdFNwbGl0dGVyT3B0aW9ucyksIHsgYWxsb3dTZW1pY29sb246IGZhbHNlLCBhbGxvd0dvRGVsaW1pdGVyOiB0cnVlLCBzdHJpbmdzQmVnaW5zOiBbXCInXCIsICdbJ10sIHN0cmluZ3NFbmRzOiB7IFwiJ1wiOiBcIidcIiwgJ1snOiAnXScgfSwgc3RyaW5nRXNjYXBlczogeyBcIidcIjogXCInXCIgfSB9KTtcbmV4cG9ydHMucG9zdGdyZVNwbGl0dGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0U3BsaXR0ZXJPcHRpb25zKSwgeyBhbGxvd0RvbGxhckRvbGxhclN0cmluZzogdHJ1ZSwgc3RyaW5nc0JlZ2luczogW1wiJ1wiLCAnXCInXSwgc3RyaW5nc0VuZHM6IHsgXCInXCI6IFwiJ1wiLCAnXCInOiAnXCInIH0sIHN0cmluZ0VzY2FwZXM6IHsgXCInXCI6IFwiJ1wiLCAnXCInOiAnXCInIH0gfSk7XG5leHBvcnRzLnNxbGl0ZVNwbGl0dGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0U3BsaXR0ZXJPcHRpb25zKSwgeyBza2lwU2VwYXJhdG9yQmVnaW5FbmQ6IHRydWUsIHN0cmluZ3NCZWdpbnM6IFtcIidcIiwgJ1wiJ10sIHN0cmluZ3NFbmRzOiB7IFwiJ1wiOiBcIidcIiwgJ1wiJzogJ1wiJyB9LCBzdHJpbmdFc2NhcGVzOiB7IFwiJ1wiOiBcIidcIiwgJ1wiJzogJ1wiJyB9IH0pO1xuZXhwb3J0cy5tb25nb1NwbGl0dGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0U3BsaXR0ZXJPcHRpb25zKSwgeyBzdHJpbmdzQmVnaW5zOiBbXCInXCIsICdcIiddLCBzdHJpbmdzRW5kczogeyBcIidcIjogXCInXCIsICdcIic6ICdcIicgfSwgc3RyaW5nRXNjYXBlczogeyBcIidcIjogJ1xcXFwnLCAnXCInOiAnXFxcXCcgfSB9KTtcbmV4cG9ydHMubm9TcGxpdFNwbGl0dGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0U3BsaXR0ZXJPcHRpb25zKSwgeyBub1NwbGl0OiB0cnVlIH0pO1xuZXhwb3J0cy5yZWRpc1NwbGl0dGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0U3BsaXR0ZXJPcHRpb25zKSwgeyBzcGxpdEJ5TGluZXM6IHRydWUgfSk7XG5leHBvcnRzLm9yYWNsZVNwbGl0dGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5kZWZhdWx0U3BsaXR0ZXJPcHRpb25zKSwgeyBhbGxvd0N1c3RvbVNxbFRlcm1pbmF0b3I6IHRydWUsIGFsbG93U2xhc2hEZWxpbWl0ZXI6IHRydWUsIHN0cmluZ3NCZWdpbnM6IFtcIidcIiwgJ1wiJ10sIHN0cmluZ3NFbmRzOiB7IFwiJ1wiOiBcIidcIiwgJ1wiJzogJ1wiJyB9LCBzdHJpbmdFc2NhcGVzOiB7IFwiJ1wiOiBcIidcIiwgJ1wiJzogJ1wiJyB9IH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcGxhY2VRdWVyeVBhcmFtZXRlcnMgPSBleHBvcnRzLmV4dHJhY3RRdWVyeVBhcmFtZXRlcnMgPSB2b2lkIDA7XG5jb25zdCBzcGxpdFF1ZXJ5XzEgPSByZXF1aXJlKFwiLi9zcGxpdFF1ZXJ5XCIpO1xuZnVuY3Rpb24gY3JlYXRlUGFyYW1ldGVyaXplckNvbnRleHQoc3FsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgc291cmNlOiBzcWwsXG4gICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICBjdXJyZW50RGVsaW1pdGVyOiAoMCwgc3BsaXRRdWVyeV8xLmdldEluaXRpYWxEZWxpbWl0ZXIpKG9wdGlvbnMpLFxuICAgICAgICBlbmQ6IHNxbC5sZW5ndGgsXG4gICAgICAgIHdhc0RhdGFPbkxpbmU6IGZhbHNlLFxuICAgICAgICBpc0NvcHlGcm9tU3RkaW46IGZhbHNlLFxuICAgICAgICBpc0NvcHlGcm9tU3RkaW5DYW5kaWRhdGU6IGZhbHNlLFxuICAgICAgICBiZWdpbkVuZElkZW50TGV2ZWw6IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeVBhcmFtZXRlcnMoc3FsLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzcWwgfHwgIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlUGFyYW1ldGVyaXplckNvbnRleHQoc3FsLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKGNvbnRleHQucG9zaXRpb24gPCBjb250ZXh0LmVuZCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9ICgwLCBzcGxpdFF1ZXJ5XzEuc2NhblRva2VuKShjb250ZXh0KTtcbiAgICAgICAgaWYgKHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3BhcmFtZXRlcicpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PSAnPycpIHtcbiAgICAgICAgICAgICAgICByZXMuYWRkKGA/JHtyZXMuc2l6ZSArIDF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuYWRkKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnBvc2l0aW9uICs9IHRva2VuLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocmVzKTtcbn1cbmV4cG9ydHMuZXh0cmFjdFF1ZXJ5UGFyYW1ldGVycyA9IGV4dHJhY3RRdWVyeVBhcmFtZXRlcnM7XG5mdW5jdGlvbiByZXBsYWNlUXVlcnlQYXJhbWV0ZXJzKHNxbCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzcWwgfHwgIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHNxbDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVBhcmFtZXRlcml6ZXJDb250ZXh0KHNxbCwgb3B0aW9ucyk7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGxldCBxdWVzdGlvblBhcmFtQ291bnRlciA9IDA7XG4gICAgd2hpbGUgKGNvbnRleHQucG9zaXRpb24gPCBjb250ZXh0LmVuZCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9ICgwLCBzcGxpdFF1ZXJ5XzEuc2NhblRva2VuKShjb250ZXh0KTtcbiAgICAgICAgaWYgKHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3BhcmFtZXRlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHRva2VuLnZhbHVlID09ICc/JyA/IGA/JHsrK3F1ZXN0aW9uUGFyYW1Db3VudGVyfWAgOiB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbcGFyYW1OYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBwYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyArPSBzcWwuc3Vic3RyaW5nKGNvbnRleHQucG9zaXRpb24sIGNvbnRleHQucG9zaXRpb24gKyB0b2tlbi5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IHNxbC5zdWJzdHJpbmcoY29udGV4dC5wb3NpdGlvbiwgY29udGV4dC5wb3NpdGlvbiArIHRva2VuLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wb3NpdGlvbiArPSB0b2tlbi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnJlcGxhY2VRdWVyeVBhcmFtZXRlcnMgPSByZXBsYWNlUXVlcnlQYXJhbWV0ZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNwbGl0UXVlcnkgPSBleHBvcnRzLmZpbmlzaFNwbGl0U3RyZWFtID0gZXhwb3J0cy5nZXRJbml0aWFsRGVsaW1pdGVyID0gZXhwb3J0cy5zcGxpdFF1ZXJ5TGluZSA9IGV4cG9ydHMuc2NhblRva2VuID0gdm9pZCAwO1xuY29uc3Qgb3B0aW9uc18xID0gcmVxdWlyZShcIi4vb3B0aW9uc1wiKTtcbmNvbnN0IFNFTUlDT0xPTiA9ICc7JztcbmNvbnN0IEJFR0lOX0VYVFJBX0tFWVdPUkRTID0gWydERUZFUlJFRCcsICdJTU1FRElBVEUnLCAnRVhDTFVTSVZFJywgJ1RSQU5TQUNUSU9OJ107XG5jb25zdCBCRUdJTl9FWFRSQV9LRVlXT1JEU19SRUdFWCA9IG5ldyBSZWdFeHAoYF4oPzoke0JFR0lOX0VYVFJBX0tFWVdPUkRTLmpvaW4oJ3wnKX0pYCwgJ2knKTtcbmNvbnN0IEVORF9FWFRSQV9LRVlXT1JEUyA9IFsnVFJBTlNBQ1RJT04nLCAnSUYnXTtcbmNvbnN0IEVORF9FWFRSQV9LRVlXT1JEU19SRUdFWCA9IG5ldyBSZWdFeHAoYF4oPzoke0VORF9FWFRSQV9LRVlXT1JEUy5qb2luKCd8Jyl9KWAsICdpJyk7XG5mdW5jdGlvbiBtb3ZlUG9zaXRpb24oY29udGV4dCwgY291bnQsIGlzV2hpdGUpIHtcbiAgICBsZXQgeyBzb3VyY2UsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4sIHN0cmVhbVBvc2l0aW9uIH0gPSBjb250ZXh0O1xuICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgaWYgKHNvdXJjZVtwb3NpdGlvbl0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiArPSAxO1xuICAgICAgICBzdHJlYW1Qb3NpdGlvbiArPSAxO1xuICAgICAgICBjb3VudCAtPSAxO1xuICAgIH1cbiAgICBjb250ZXh0LnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgY29udGV4dC5zdHJlYW1Qb3NpdGlvbiA9IHN0cmVhbVBvc2l0aW9uO1xuICAgIGNvbnRleHQubGluZSA9IGxpbmU7XG4gICAgY29udGV4dC5jb2x1bW4gPSBjb2x1bW47XG4gICAgaWYgKCFjb250ZXh0Lndhc0RhdGFJbkNvbW1hbmQpIHtcbiAgICAgICAgaWYgKGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvbnRleHQudHJpbUNvbW1hbmRTdGFydFBvc2l0aW9uID0gc3RyZWFtUG9zaXRpb247XG4gICAgICAgICAgICBjb250ZXh0LnRyaW1Db21tYW5kU3RhcnRMaW5lID0gbGluZTtcbiAgICAgICAgICAgIGNvbnRleHQudHJpbUNvbW1hbmRTdGFydENvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQud2FzRGF0YUluQ29tbWFuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1doaXRlKSB7XG4gICAgICAgIGNvbnRleHQubm9XaGl0ZVBvc2l0aW9uID0gc3RyZWFtUG9zaXRpb247XG4gICAgICAgIGNvbnRleHQubm9XaGl0ZUxpbmUgPSBsaW5lO1xuICAgICAgICBjb250ZXh0Lm5vV2hpdGVDb2x1bW4gPSBjb2x1bW47XG4gICAgfVxufVxuY29uc3QgV0hJVEVTUEFDRV9UT0tFTiA9IHtcbiAgICB0eXBlOiAnd2hpdGVzcGFjZScsXG4gICAgbGVuZ3RoOiAxLFxufTtcbmNvbnN0IEVPTE5fVE9LRU4gPSB7XG4gICAgdHlwZTogJ2VvbG4nLFxuICAgIGxlbmd0aDogMSxcbn07XG5jb25zdCBEQVRBX1RPS0VOID0ge1xuICAgIHR5cGU6ICdkYXRhJyxcbiAgICBsZW5ndGg6IDEsXG59O1xuZnVuY3Rpb24gc2NhbkRvbGxhclF1b3RlZFN0cmluZyhjb250ZXh0KSB7XG4gICAgaWYgKCFjb250ZXh0Lm9wdGlvbnMuYWxsb3dEb2xsYXJEb2xsYXJTdHJpbmcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBwb3MgPSBjb250ZXh0LnBvc2l0aW9uO1xuICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcbiAgICBjb25zdCBtYXRjaCA9IC9eKFxcJFthLXpBLVowLTlfXSpcXCQpLy5leGVjKHMuc2xpY2UocG9zKSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbGFiZWwgPSBtYXRjaFsxXTtcbiAgICBwb3MgKz0gbGFiZWwubGVuZ3RoO1xuICAgIHdoaWxlIChwb3MgPCBjb250ZXh0LmVuZCkge1xuICAgICAgICBpZiAocy5zbGljZShwb3MpLnN0YXJ0c1dpdGgobGFiZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogcG9zICsgbGFiZWwubGVuZ3RoIC0gY29udGV4dC5wb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcG9zKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2NhblRva2VuKGNvbnRleHQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBvcyA9IGNvbnRleHQucG9zaXRpb247XG4gICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xuICAgIGNvbnN0IGNoID0gc1twb3NdO1xuICAgIGlmIChjb250ZXh0LmlzQ29weUZyb21TdGRpbikge1xuICAgICAgICBpZiAocy5zbGljZShwb3MpLnN0YXJ0c1dpdGgoJ1xcXFwuJykgJiYgIWNvbnRleHQud2FzRGF0YU9uTGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29weV9zdGRpbl9lbmQnLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvczIgPSBwb3M7XG4gICAgICAgIHdoaWxlIChwb3MyIDwgY29udGV4dC5lbmQgJiYgc1twb3MyXSAhPSAnXFxuJylcbiAgICAgICAgICAgIHBvczIrKztcbiAgICAgICAgaWYgKHBvczIgPCBjb250ZXh0LmVuZCAmJiBzW3BvczJdID09ICdcXG4nKVxuICAgICAgICAgICAgcG9zMisrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NvcHlfc3RkaW5fbGluZScsXG4gICAgICAgICAgICBsZW5ndGg6IHBvczIgLSBwb3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuc3RyaW5nc0JlZ2lucy5pbmNsdWRlcyhjaCkpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGNvbnN0IGVuZGNoID0gY29udGV4dC5vcHRpb25zLnN0cmluZ3NFbmRzW2NoXTtcbiAgICAgICAgY29uc3QgZXNjYXBlY2ggPSBjb250ZXh0Lm9wdGlvbnMuc3RyaW5nRXNjYXBlc1tjaF07XG4gICAgICAgIHdoaWxlIChwb3MgPCBjb250ZXh0LmVuZCkge1xuICAgICAgICAgICAgaWYgKHNbcG9zXSA9PSBlbmRjaCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVzY2FwZWNoICYmIHNbcG9zXSA9PSBlc2NhcGVjaCkge1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgbGVuZ3RoOiBwb3MgLSBjb250ZXh0LnBvc2l0aW9uICsgMSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5xdWVyeVBhcmFtZXRlclN0eWxlICYmXG4gICAgICAgICgoX2EgPSBjb250ZXh0Lm9wdGlvbnMucXVlcnlQYXJhbWV0ZXJTdHlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPT0gMSAmJlxuICAgICAgICBjaCA9PSBjb250ZXh0Lm9wdGlvbnMucXVlcnlQYXJhbWV0ZXJTdHlsZSAmJlxuICAgICAgICAoY29udGV4dC5vcHRpb25zLnF1ZXJ5UGFyYW1ldGVyU3R5bGUgPT0gJz8nIHx8IC9bYS16QS1aMC05X10vLnRlc3Qoc1twb3MgKyAxXSkpKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zLnF1ZXJ5UGFyYW1ldGVyU3R5bGUgIT0gJz8nKSB7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgY29udGV4dC5lbmQgJiYgL1thLXpBLVowLTlfXS8udGVzdChzW3Bvc10pKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncGFyYW1ldGVyJyxcbiAgICAgICAgICAgIHZhbHVlOiBzLnNsaWNlKGNvbnRleHQucG9zaXRpb24sIHBvcyksXG4gICAgICAgICAgICBsZW5ndGg6IHBvcyAtIGNvbnRleHQucG9zaXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzSW5CZWdpbkVuZCA9IGNvbnRleHQub3B0aW9ucy5za2lwU2VwYXJhdG9yQmVnaW5FbmQgJiYgY29udGV4dC5iZWdpbkVuZElkZW50TGV2ZWwgPiAwO1xuICAgIGlmIChjb250ZXh0LmN1cnJlbnREZWxpbWl0ZXIgJiYgcy5zbGljZShwb3MpLnN0YXJ0c1dpdGgoY29udGV4dC5jdXJyZW50RGVsaW1pdGVyKSAmJiAhaXNJbkJlZ2luRW5kKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZGVsaW1pdGVyJyxcbiAgICAgICAgICAgIGxlbmd0aDogY29udGV4dC5jdXJyZW50RGVsaW1pdGVyLmxlbmd0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNoID09ICcgJyB8fCBjaCA9PSAnXFx0JyB8fCBjaCA9PSAnXFxyJykge1xuICAgICAgICByZXR1cm4gV0hJVEVTUEFDRV9UT0tFTjtcbiAgICB9XG4gICAgaWYgKGNoID09ICdcXG4nKSB7XG4gICAgICAgIHJldHVybiBFT0xOX1RPS0VOO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmRvdWJsZURhc2hDb21tZW50cyAmJiBjaCA9PSAnLScgJiYgc1twb3MgKyAxXSA9PSAnLScpIHtcbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvbnRleHQuZW5kICYmIHNbcG9zXSAhPSAnXFxuJylcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICAgICAgbGVuZ3RoOiBwb3MgLSBjb250ZXh0LnBvc2l0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLm11bHRpbGluZUNvbW1lbnRzICYmIGNoID09ICcvJyAmJiBzW3BvcyArIDFdID09ICcqJykge1xuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvbnRleHQuZW5kKSB7XG4gICAgICAgICAgICBpZiAoc1twb3NdID09ICcqJyAmJiBzW3BvcyArIDFdID09ICcvJylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWVudCcsXG4gICAgICAgICAgICBsZW5ndGg6IHBvcyAtIGNvbnRleHQucG9zaXRpb24gKyAyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmFsbG93Q3VzdG9tRGVsaW1pdGVyICYmICFjb250ZXh0Lndhc0RhdGFPbkxpbmUpIHtcbiAgICAgICAgY29uc3QgbSA9IHMuc2xpY2UocG9zKS5tYXRjaCgvXkRFTElNSVRFUlsgXFx0XSsoW15cXG5dKykvaSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzZXRfZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbVsxXS50cmltKCksXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBtWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5hbGxvd0N1c3RvbVNxbFRlcm1pbmF0b3IpIHtcbiAgICAgICAgY29uc3QgbSA9IHMuc2xpY2UocG9zKS5tYXRjaCgvXlNFVFsgXFx0XStTUUxUKEVSTUlOQVRPUik/WyBcXHRdKyhPTnxPRkZ8XCIuXCIpL2kpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgaWYgKG1bMl0udG9VcHBlckNhc2UoKSA9PSAnT0ZGJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZXRfc3FsdGVybWluYXRvcicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IG1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobVsyXS50b1VwcGVyQ2FzZSgpID09ICdPTicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2V0X3NxbHRlcm1pbmF0b3InLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU0VNSUNPTE9OLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IG1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobVsyXS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NldF9zcWx0ZXJtaW5hdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1bMl0uc2xpY2UoMSwgLTEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IG1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChjb250ZXh0Lm9wdGlvbnMuYWxsb3dHb0RlbGltaXRlciB8fCBjb250ZXh0Lm9wdGlvbnMuYWRhcHRpdmVHb1NwbGl0KSAmJiAhY29udGV4dC53YXNEYXRhT25MaW5lKSB7XG4gICAgICAgIGNvbnN0IG0gPSBzLnNsaWNlKHBvcykubWF0Y2goL15HT1tcXHRcXHIgXSooXFxufCQpL2kpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZ29fZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IG1bMF0uZW5kc1dpdGgoJ1xcbicpID8gbVswXS5sZW5ndGggLSAxIDogbVswXS5sZW5ndGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuYWxsb3dTbGFzaERlbGltaXRlciAmJiAhY29udGV4dC53YXNEYXRhT25MaW5lKSB7XG4gICAgICAgIGNvbnN0IG0gPSBzLnNsaWNlKHBvcykubWF0Y2goL15cXC9bXFx0XFxyIF0qKFxcbnwkKS9pKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NsYXNoX2RlbGltaXRlcicsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBtWzBdLmVuZHNXaXRoKCdcXG4nKSA/IG1bMF0ubGVuZ3RoIC0gMSA6IG1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmFkYXB0aXZlR29TcGxpdCkge1xuICAgICAgICBjb25zdCBtID0gcy5zbGljZShwb3MpLm1hdGNoKC9eKENSRUFURXxBTFRFUilcXHMqKFBST0NFRFVSRXxGVU5DVElPTnxUUklHR0VSKS9pKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NyZWF0ZV9yb3V0aW5lJyxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IG1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmNvcHlGcm9tU3RkaW4gJiYgIWNvbnRleHQud2FzRGF0YU9uTGluZSAmJiBzLnNsaWNlKHBvcykuc3RhcnRzV2l0aCgnQ09QWSAnKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NvcHknLFxuICAgICAgICAgICAgbGVuZ3RoOiA1LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5pc0NvcHlGcm9tU3RkaW5DYW5kaWRhdGUgJiYgcy5zbGljZShwb3MpLnN0YXJ0c1dpdGgoJ0ZST00gc3RkaW47JykpIHtcbiAgICAgICAgbGV0IHBvczIgPSBwb3MgKyAnRlJPTSBzdGRpbjsnLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcG9zMCA9IHBvczIgLSAxO1xuICAgICAgICB3aGlsZSAocG9zMiA8IGNvbnRleHQuZW5kICYmIHNbcG9zMl0gIT0gJ1xcbicpXG4gICAgICAgICAgICBwb3MyKys7XG4gICAgICAgIGlmIChzW3BvczJdID09ICdcXG4nKVxuICAgICAgICAgICAgcG9zMisrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NvcHlfc3RkaW5fc3RhcnQnLFxuICAgICAgICAgICAgbGVuZ3RoOiBwb3MyIC0gcG9zLFxuICAgICAgICAgICAgbGVuZ3RoV2l0aG91dFdoaXRlc3BhY2U6IHBvczAgLSBwb3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuc2tpcFNlcGFyYXRvckJlZ2luRW5kICYmIHMuc2xpY2UocG9zKS5tYXRjaCgvXmJlZ2luL2kpKSB7XG4gICAgICAgIGxldCBwb3MyID0gcG9zICsgJ0JFR0lOJy5sZW5ndGg7XG4gICAgICAgIGxldCBwb3MwID0gcG9zMjtcbiAgICAgICAgd2hpbGUgKHBvczAgPCBjb250ZXh0LmVuZCAmJiAvW15hLXpBLVowLTldLy50ZXN0KHNbcG9zMF0pKVxuICAgICAgICAgICAgcG9zMCsrO1xuICAgICAgICBpZiAoIUJFR0lOX0VYVFJBX0tFWVdPUkRTX1JFR0VYLnRlc3Qocy5zbGljZShwb3MwKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JlZ2luJyxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHBvczIgLSBwb3MsXG4gICAgICAgICAgICAgICAgbGVuZ3RoV2l0aG91dFdoaXRlc3BhY2U6IHBvczAgLSBwb3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuc2tpcFNlcGFyYXRvckJlZ2luRW5kICYmIHMuc2xpY2UocG9zKS5tYXRjaCgvXmVuZC9pKSkge1xuICAgICAgICBsZXQgcG9zMiA9IHBvcyArICdFTkQnLmxlbmd0aDtcbiAgICAgICAgbGV0IHBvczAgPSBwb3MyO1xuICAgICAgICB3aGlsZSAocG9zMCA8IGNvbnRleHQuZW5kICYmIC9bXmEtekEtWjAtOV0vLnRlc3Qoc1twb3MwXSkpXG4gICAgICAgICAgICBwb3MwKys7XG4gICAgICAgIGlmICghRU5EX0VYVFJBX0tFWVdPUkRTX1JFR0VYLnRlc3Qocy5zbGljZShwb3MwKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2VuZCcsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBwb3MyIC0gcG9zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2xsYXJTdHJpbmcgPSBzY2FuRG9sbGFyUXVvdGVkU3RyaW5nKGNvbnRleHQpO1xuICAgIGlmIChkb2xsYXJTdHJpbmcpXG4gICAgICAgIHJldHVybiBkb2xsYXJTdHJpbmc7XG4gICAgcmV0dXJuIERBVEFfVE9LRU47XG59XG5leHBvcnRzLnNjYW5Ub2tlbiA9IHNjYW5Ub2tlbjtcbmZ1bmN0aW9uIGNvbnRhaW5zRGF0YUFmdGVyRGVsaW1pdGVyT25MaW5lKGNvbnRleHQsIGRlbGltaXRlcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjbG9uZWQgPSB7XG4gICAgICAgIG9wdGlvbnM6IGNvbnRleHQub3B0aW9ucyxcbiAgICAgICAgc291cmNlOiBjb250ZXh0LnNvdXJjZSxcbiAgICAgICAgcG9zaXRpb246IGNvbnRleHQucG9zaXRpb24sXG4gICAgICAgIGN1cnJlbnREZWxpbWl0ZXI6IGNvbnRleHQuY3VycmVudERlbGltaXRlcixcbiAgICAgICAgZW5kOiBjb250ZXh0LmVuZCxcbiAgICAgICAgd2FzRGF0YU9uTGluZTogY29udGV4dC53YXNEYXRhT25MaW5lLFxuICAgICAgICBpc0NvcHlGcm9tU3RkaW5DYW5kaWRhdGU6IGNvbnRleHQuaXNDb3B5RnJvbVN0ZGluQ2FuZGlkYXRlLFxuICAgICAgICBpc0NvcHlGcm9tU3RkaW46IGNvbnRleHQuaXNDb3B5RnJvbVN0ZGluLFxuICAgICAgICBiZWdpbkVuZElkZW50TGV2ZWw6IGNvbnRleHQuYmVnaW5FbmRJZGVudExldmVsLFxuICAgIH07XG4gICAgY2xvbmVkLnBvc2l0aW9uICs9IGRlbGltaXRlci5sZW5ndGg7XG4gICAgd2hpbGUgKGNsb25lZC5wb3NpdGlvbiA8IGNsb25lZC5lbmQpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBzY2FuVG9rZW4oY2xvbmVkKTtcbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY2xvbmVkLnBvc2l0aW9uICs9IDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3doaXRlc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNsb25lZC5wb3NpdGlvbiArPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdlb2xuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gdG9rZW4udmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNsb25lZC5wb3NpdGlvbiArPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFF1ZXJ5KGNvbnRleHQsIHNwZWNpYWxNYXJrZXIpIHtcbiAgICBjb250ZXh0LmNvbW1hbmRQYXJ0ICs9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRleHQuY3VycmVudENvbW1hbmRTdGFydCwgY29udGV4dC5wb3NpdGlvbik7XG4gICAgcHVzaEN1cnJlbnRRdWVyeVBhcnQoY29udGV4dCwgc3BlY2lhbE1hcmtlcik7XG59XG5mdW5jdGlvbiBwdXNoQ3VycmVudFF1ZXJ5UGFydChjb250ZXh0LCBzcGVjaWFsTWFya2VyKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGNvbnRleHQuY29tbWFuZFBhcnQuc3Vic3RyaW5nKGNvbnRleHQudHJpbUNvbW1hbmRTdGFydFBvc2l0aW9uIC0gY29udGV4dC5jb21tYW5kU3RhcnRQb3NpdGlvbiwgY29udGV4dC5ub1doaXRlUG9zaXRpb24gLSBjb250ZXh0LmNvbW1hbmRTdGFydFBvc2l0aW9uKTtcbiAgICBpZiAodHJpbW1lZC50cmltKCkpIHtcbiAgICAgICAgaWYgKGNvbnRleHQub3B0aW9ucy5yZXR1cm5SaWNoSW5mbykge1xuICAgICAgICAgICAgY29udGV4dC5wdXNoT3V0cHV0KHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0cmltbWVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBjb250ZXh0LmNvbW1hbmRTdGFydFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBjb250ZXh0LmNvbW1hbmRTdGFydExpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29udGV4dC5jb21tYW5kU3RhcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGNvbnRleHQuc3RyZWFtUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGNvbnRleHQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb250ZXh0LmNvbHVtbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyaW1TdGFydDoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogY29udGV4dC50cmltQ29tbWFuZFN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGNvbnRleHQudHJpbUNvbW1hbmRTdGFydExpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29udGV4dC50cmltQ29tbWFuZFN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJpbUVuZDoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogY29udGV4dC5ub1doaXRlUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGNvbnRleHQubm9XaGl0ZUxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29udGV4dC5ub1doaXRlQ29sdW1uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3BlY2lhbE1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5wdXNoT3V0cHV0KHRyaW1tZWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFya1N0YXJ0Q29tbWFuZChjb250ZXh0KSB7XG4gICAgY29udGV4dC5jb21tYW5kU3RhcnRQb3NpdGlvbiA9IGNvbnRleHQuc3RyZWFtUG9zaXRpb247XG4gICAgY29udGV4dC5jb21tYW5kU3RhcnRMaW5lID0gY29udGV4dC5saW5lO1xuICAgIGNvbnRleHQuY29tbWFuZFN0YXJ0Q29sdW1uID0gY29udGV4dC5jb2x1bW47XG4gICAgY29udGV4dC50cmltQ29tbWFuZFN0YXJ0UG9zaXRpb24gPSBjb250ZXh0LnN0cmVhbVBvc2l0aW9uO1xuICAgIGNvbnRleHQudHJpbUNvbW1hbmRTdGFydExpbmUgPSBjb250ZXh0LmxpbmU7XG4gICAgY29udGV4dC50cmltQ29tbWFuZFN0YXJ0Q29sdW1uID0gY29udGV4dC5jb2x1bW47XG4gICAgY29udGV4dC53YXNEYXRhSW5Db21tYW5kID0gZmFsc2U7XG59XG5mdW5jdGlvbiBzcGxpdEJ5TGluZXMoY29udGV4dCkge1xuICAgIHdoaWxlIChjb250ZXh0LnBvc2l0aW9uIDwgY29udGV4dC5lbmQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuc291cmNlW2NvbnRleHQucG9zaXRpb25dID09ICdcXG4nKSB7XG4gICAgICAgICAgICBwdXNoUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmNvbW1hbmRQYXJ0ID0gJyc7XG4gICAgICAgICAgICBtb3ZlUG9zaXRpb24oY29udGV4dCwgMSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRDb21tYW5kU3RhcnQgPSBjb250ZXh0LnBvc2l0aW9uO1xuICAgICAgICAgICAgbWFya1N0YXJ0Q29tbWFuZChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVQb3NpdGlvbihjb250ZXh0LCAxLCAvXFxzLy50ZXN0KGNvbnRleHQuc291cmNlW2NvbnRleHQucG9zaXRpb25dKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZW5kID4gY29udGV4dC5jdXJyZW50Q29tbWFuZFN0YXJ0KSB7XG4gICAgICAgIGNvbnRleHQuY29tbWFuZFBhcnQgKz0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGV4dC5jdXJyZW50Q29tbWFuZFN0YXJ0LCBjb250ZXh0LnBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzcGxpdFF1ZXJ5TGluZShjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5zcGxpdEJ5TGluZXMpIHtcbiAgICAgICAgc3BsaXRCeUxpbmVzKGNvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChjb250ZXh0LnBvc2l0aW9uIDwgY29udGV4dC5lbmQpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBzY2FuVG9rZW4oY29udGV4dCk7XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgc3BlY2lhbCwgbW92ZSBmb3J3YXJkXG4gICAgICAgICAgICBtb3ZlUG9zaXRpb24oY29udGV4dCwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbihjb250ZXh0LCB0b2tlbi5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lndhc0RhdGFPbkxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgISFjb250ZXh0Lm9wdGlvbnMuaWdub3JlQ29tbWVudHMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2FzRGF0YU9uTGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlb2xuJzpcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQud2FzRGF0YU9uTGluZSAmJiBjb250ZXh0Lm9wdGlvbnMuc3BsaXRCeUVtcHR5TGluZSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY29tbWFuZFBhcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRDb21tYW5kU3RhcnQgPSBjb250ZXh0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lndhc0RhdGFPbkxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbWFya1N0YXJ0Q29tbWFuZChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbihjb250ZXh0LCB0b2tlbi5sZW5ndGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2FzRGF0YU9uTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2FzRGF0YU9uTGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwYXJhbWV0ZXInOlxuICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbihjb250ZXh0LCB0b2tlbi5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lndhc0RhdGFPbkxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2hpdGVzcGFjZSc6XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZXRfZGVsaW1pdGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NldF9zcWx0ZXJtaW5hdG9yJzpcbiAgICAgICAgICAgICAgICBwdXNoUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21tYW5kUGFydCA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudERlbGltaXRlciA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbihjb250ZXh0LCB0b2tlbi5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRDb21tYW5kU3RhcnQgPSBjb250ZXh0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIG1hcmtTdGFydENvbW1hbmQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnb19kZWxpbWl0ZXInOlxuICAgICAgICAgICAgICAgIHB1c2hRdWVyeShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbW1hbmRQYXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudENvbW1hbmRTdGFydCA9IGNvbnRleHQucG9zaXRpb247XG4gICAgICAgICAgICAgICAgbWFya1N0YXJ0Q29tbWFuZChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zLmFkYXB0aXZlR29TcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnREZWxpbWl0ZXIgPSBTRU1JQ09MT047XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2xhc2hfZGVsaW1pdGVyJzpcbiAgICAgICAgICAgICAgICBwdXNoUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21tYW5kUGFydCA9ICcnO1xuICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbihjb250ZXh0LCB0b2tlbi5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRDb21tYW5kU3RhcnQgPSBjb250ZXh0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIG1hcmtTdGFydENvbW1hbmQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcmVhdGVfcm91dGluZSc6XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuYWRhcHRpdmVHb1NwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudERlbGltaXRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29weSc6XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaXNDb3B5RnJvbVN0ZGluQ2FuZGlkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lndhc0RhdGFPbkxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29weV9zdGRpbl9zdGFydCc6XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aFdpdGhvdXRXaGl0ZXNwYWNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCAtIHRva2VuLmxlbmd0aFdpdGhvdXRXaGl0ZXNwYWNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmlzQ29weUZyb21TdGRpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGV4dC5pc0NvcHlGcm9tU3RkaW5DYW5kaWRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lndhc0RhdGFPbkxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwdXNoUXVlcnkoY29udGV4dCwgJ2NvcHlfc3RkaW5fc3RhcnQnKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbW1hbmRQYXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Q29tbWFuZFN0YXJ0ID0gY29udGV4dC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBtYXJrU3RhcnRDb21tYW5kKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29weV9zdGRpbl9saW5lJzpcbiAgICAgICAgICAgICAgICBtb3ZlUG9zaXRpb24oY29udGV4dCwgdG9rZW4ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5pc0NvcHlGcm9tU3RkaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaXNDb3B5RnJvbVN0ZGluQ2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHVzaFF1ZXJ5KGNvbnRleHQsICdjb3B5X3N0ZGluX2xpbmUnKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbW1hbmRQYXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Q29tbWFuZFN0YXJ0ID0gY29udGV4dC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBtYXJrU3RhcnRDb21tYW5kKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29weV9zdGRpbl9lbmQnOlxuICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbihjb250ZXh0LCB0b2tlbi5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmlzQ29weUZyb21TdGRpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2FzRGF0YU9uTGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHVzaFF1ZXJ5KGNvbnRleHQsICdjb3B5X3N0ZGluX2VuZCcpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tbWFuZFBhcnQgPSAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRDb21tYW5kU3RhcnQgPSBjb250ZXh0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIG1hcmtTdGFydENvbW1hbmQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZWxpbWl0ZXInOlxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMucHJldmVudFNpbmdsZUxpbmVTcGxpdCAmJiBjb250YWluc0RhdGFBZnRlckRlbGltaXRlck9uTGluZShjb250ZXh0LCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lndhc0RhdGFPbkxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVzaFF1ZXJ5KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tbWFuZFBhcnQgPSAnJztcbiAgICAgICAgICAgICAgICBtb3ZlUG9zaXRpb24oY29udGV4dCwgdG9rZW4ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Q29tbWFuZFN0YXJ0ID0gY29udGV4dC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBtYXJrU3RhcnRDb21tYW5kKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaXNDb3B5RnJvbVN0ZGluQ2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiZWdpbic6XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQub3B0aW9ucy5za2lwU2VwYXJhdG9yQmVnaW5FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iZWdpbkVuZElkZW50TGV2ZWwrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zLnNraXBTZXBhcmF0b3JCZWdpbkVuZCAmJiBjb250ZXh0LmJlZ2luRW5kSWRlbnRMZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iZWdpbkVuZElkZW50TGV2ZWwtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uKGNvbnRleHQsIHRva2VuLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmVuZCA+IGNvbnRleHQuY3VycmVudENvbW1hbmRTdGFydCkge1xuICAgICAgICBjb250ZXh0LmNvbW1hbmRQYXJ0ICs9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRleHQuY3VycmVudENvbW1hbmRTdGFydCwgY29udGV4dC5wb3NpdGlvbik7XG4gICAgfVxufVxuZXhwb3J0cy5zcGxpdFF1ZXJ5TGluZSA9IHNwbGl0UXVlcnlMaW5lO1xuZnVuY3Rpb24gZ2V0SW5pdGlhbERlbGltaXRlcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hZGFwdGl2ZUdvU3BsaXQpXG4gICAgICAgIHJldHVybiBTRU1JQ09MT047XG4gICAgcmV0dXJuIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dTZW1pY29sb24pID09PSBmYWxzZSA/IG51bGwgOiBTRU1JQ09MT047XG59XG5leHBvcnRzLmdldEluaXRpYWxEZWxpbWl0ZXIgPSBnZXRJbml0aWFsRGVsaW1pdGVyO1xuZnVuY3Rpb24gZmluaXNoU3BsaXRTdHJlYW0oY29udGV4dCkge1xuICAgIHB1c2hDdXJyZW50UXVlcnlQYXJ0KGNvbnRleHQpO1xufVxuZXhwb3J0cy5maW5pc2hTcGxpdFN0cmVhbSA9IGZpbmlzaFNwbGl0U3RyZWFtO1xuZnVuY3Rpb24gc3BsaXRRdWVyeShzcWwsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHVzZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zXzEuZGVmYXVsdFNwbGl0dGVyT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIGlmICh1c2VkT3B0aW9ucy5ub1NwbGl0KSB7XG4gICAgICAgIGlmICh1c2VkT3B0aW9ucy5yZXR1cm5SaWNoSW5mbykge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzcWwuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHNxbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3FsLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogKChfYSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3FsXTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgc291cmNlOiBzcWwsXG4gICAgICAgIGVuZDogc3FsLmxlbmd0aCxcbiAgICAgICAgY3VycmVudERlbGltaXRlcjogZ2V0SW5pdGlhbERlbGltaXRlcihvcHRpb25zKSxcbiAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY3VycmVudENvbW1hbmRTdGFydDogMCxcbiAgICAgICAgY29tbWFuZFN0YXJ0TGluZTogMCxcbiAgICAgICAgY29tbWFuZFN0YXJ0Q29sdW1uOiAwLFxuICAgICAgICBjb21tYW5kU3RhcnRQb3NpdGlvbjogMCxcbiAgICAgICAgc3RyZWFtUG9zaXRpb246IDAsXG4gICAgICAgIG5vV2hpdGVMaW5lOiAwLFxuICAgICAgICBub1doaXRlQ29sdW1uOiAwLFxuICAgICAgICBub1doaXRlUG9zaXRpb246IDAsXG4gICAgICAgIHRyaW1Db21tYW5kU3RhcnRQb3NpdGlvbjogMCxcbiAgICAgICAgdHJpbUNvbW1hbmRTdGFydExpbmU6IDAsXG4gICAgICAgIHRyaW1Db21tYW5kU3RhcnRDb2x1bW46IDAsXG4gICAgICAgIGJlZ2luRW5kSWRlbnRMZXZlbDogMCxcbiAgICAgICAgd2FzRGF0YUluQ29tbWFuZDogZmFsc2UsXG4gICAgICAgIGlzQ29weUZyb21TdGRpbjogZmFsc2UsXG4gICAgICAgIGlzQ29weUZyb21TdGRpbkNhbmRpZGF0ZTogZmFsc2UsXG4gICAgICAgIHB1c2hPdXRwdXQ6IGNtZCA9PiBvdXRwdXQucHVzaChjbWQpLFxuICAgICAgICB3YXNEYXRhT25MaW5lOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uczogdXNlZE9wdGlvbnMsXG4gICAgICAgIGNvbW1hbmRQYXJ0OiAnJyxcbiAgICB9O1xuICAgIHNwbGl0UXVlcnlMaW5lKGNvbnRleHQpO1xuICAgIGZpbmlzaFNwbGl0U3RyZWFtKGNvbnRleHQpO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLnNwbGl0UXVlcnkgPSBzcGxpdFF1ZXJ5O1xuIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjcuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMy0wOC0yOFQxMzozN1pcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgdHJhYy0xNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGZsYXQgPSBhcnIuZmxhdCA/IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5mbGF0LmNhbGwoIGFycmF5ICk7XG59IDogZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmNvbmNhdC5hcHBseSggW10sIGFycmF5ICk7XG59O1xuXG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG5cdFx0Ly8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG5cdFx0Ly8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG5cdFx0Ly8gU3VwcG9ydDogUXRXZWIgPD0zLjguNSwgV2ViS2l0IDw9NTM0LjM0LCB3a2h0bWx0b3BkZiB0b29sIDw9MC4xMi41XG5cdFx0Ly8gUGx1cyBmb3Igb2xkIFdlYktpdCwgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIGNvbGxlY3Rpb25zXG5cdFx0Ly8gKGUuZy4sIGB0eXBlb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikgPT09IFwiZnVuY3Rpb25cImApLiAoZ2gtNDc1Nilcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCIgJiZcblx0XHRcdHR5cGVvZiBvYmouaXRlbSAhPT0gXCJmdW5jdGlvblwiO1xuXHR9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXIgdmVyc2lvbiA9IFwiMy43LjFcIixcblxuXHRyaHRtbFN1ZmZpeCA9IC9IVE1MJC9pLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuXHR0ZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbm9kZSxcblx0XHRcdHJldCA9IFwiXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBlbGVtWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRcdHJldCArPSBqUXVlcnkudGV4dCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnRFbGVtZW50LnRleHRDb250ZW50O1xuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0aXNYTUxEb2M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lc3BhY2UgPSBlbGVtICYmIGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdFx0ZG9jRWxlbSA9IGVsZW0gJiYgKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZVxuXHRcdC8vIGRvY3VtZW50IGZyYWdtZW50cy5cblx0XHRyZXR1cm4gIXJodG1sU3VmZml4LnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRcdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufVxudmFyIHBvcCA9IGFyci5wb3A7XG5cblxudmFyIHNvcnQgPSBhcnIuc29ydDtcblxuXG52YXIgc3BsaWNlID0gYXJyLnNwbGljZTtcblxuXG52YXIgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIjtcblxuXG52YXIgcnRyaW1DU1MgPSBuZXcgUmVnRXhwKFxuXHRcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLFxuXHRcImdcIlxuKTtcblxuXG5cblxuLy8gTm90ZTogYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxualF1ZXJ5LmNvbnRhaW5zID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdHZhciBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblxuXHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHQvLyBJRSBkb2Vzbid0IGhhdmUgYGNvbnRhaW5zYCBvbiBTVkcuXG5cdFx0YS5jb250YWlucyA/XG5cdFx0XHRhLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0KSApO1xufTtcblxuXG5cblxuLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xudmFyIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXHg4MC1cXHVGRkZGXFx3LV0vZztcblxuZnVuY3Rpb24gZmNzc2VzY2FwZSggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHR9XG5cblx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdH1cblxuXHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdHJldHVybiBcIlxcXFxcIiArIGNoO1xufVxuXG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKCBzZWwgKyBcIlwiICkucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuXG5cblxudmFyIHByZWZlcnJlZERvYyA9IGRvY3VtZW50LFxuXHRwdXNoTmF0aXZlID0gcHVzaDtcblxuKCBmdW5jdGlvbigpIHtcblxudmFyIGksXG5cdEV4cHIsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXHRwdXNoID0gcHVzaE5hdGl2ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdGRvY3VtZW50LFxuXHRkb2N1bWVudEVsZW1lbnQsXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdG1hdGNoZXMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0galF1ZXJ5LmV4cGFuZG8sXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8XCIgK1xuXHRcdFwibG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJsZWFkaW5nQ29tYmluYXRvciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0SUQ6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRDTEFTUzogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRUQUc6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRBVFRSOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRQU0VVRE86IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdENISUxEOiBuZXcgUmVnRXhwKFxuXHRcdFx0XCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdGJvb2w6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0bmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0aWYgKCBub25IZXggKSB7XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIG5vbkhleDtcblx0XHR9XG5cblx0XHQvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdHJldHVybiBoaWdoIDwgMCA/XG5cdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXM7IHNlZSBgc2V0RG9jdW1lbnRgLlxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRS9FZGdlLlxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgbm9kZU5hbWUoIGVsZW0sIFwiZmllbGRzZXRcIiApO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7XG5cdFx0YXBwbHk6IGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApICk7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBmaW5kKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoIGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSAmJlxuXHRcdFx0XHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCBybGVhZGluZ0NvbWJpbmF0b3IudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW5cblx0XHRcdFx0XHQvLyBzdHJpY3QtY29tcGFyaW5nIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICE9IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IGpRdWVyeS5lc2NhcGVTZWxlY3RvciggbmlkICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXNcblx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8xNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBqUXVlcnkgc2VsZWN0b3IgbW9kdWxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApIHx8IG5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgKSAmJlxuXHRcdFx0ZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExK1xuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIGpRdWVyeSBzZWxlY3RvciBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW25vZGVdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIHNldERvY3VtZW50KCBub2RlICkge1xuXHR2YXIgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhalF1ZXJ5LmlzWE1MRG9jKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA3IG9ubHksIElFIDkgLSAxMStcblx0Ly8gT2xkZXIgYnJvd3NlcnMgZGlkbid0IHN1cHBvcnQgdW5wcmVmaXhlZCBgbWF0Y2hlc2AuXG5cdG1hdGNoZXMgPSBkb2N1bWVudEVsZW1lbnQubWF0Y2hlcyB8fFxuXHRcdGRvY3VtZW50RWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3I7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnNcblx0Ly8gKHNlZSB0cmFjLTEzOTM2KS5cblx0Ly8gTGltaXQgdGhlIGZpeCB0byBJRSAmIEVkZ2UgTGVnYWN5OyBkZXNwaXRlIEVkZ2UgMTUrIGltcGxlbWVudGluZyBgbWF0Y2hlc2AsXG5cdC8vIGFsbCBJRSA5KyBhbmQgRWRnZSBMZWdhY3kgdmVyc2lvbnMgaW1wbGVtZW50IGBtc01hdGNoZXNTZWxlY3RvcmAgYXMgd2VsbC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgJiZcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0cHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGpRdWVyeS5leHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHxcblx0XHRcdCFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggalF1ZXJ5LmV4cGFuZG8gKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUuXG5cdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRyZXR1cm4gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gSUUvRWRnZSBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHRzdXBwb3J0LnNjb3BlID0gYXNzZXJ0KCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggXCI6c2NvcGVcIiApO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogQ2hyb21lIDEwNSAtIDExMSBvbmx5LCBTYWZhcmkgMTUuNCAtIDE2LjMgb25seVxuXHQvLyBNYWtlIHN1cmUgdGhlIGA6aGFzKClgIGFyZ3VtZW50IGlzIHBhcnNlZCB1bmZvcmdpdmluZ2x5LlxuXHQvLyBXZSBpbmNsdWRlIGAqYCBpbiB0aGUgdGVzdCB0byBkZXRlY3QgYnVnZ3kgaW1wbGVtZW50YXRpb25zIHRoYXQgYXJlXG5cdC8vIF9zZWxlY3RpdmVseV8gZm9yZ2l2aW5nIChzcGVjaWZpY2FsbHkgd2hlbiB0aGUgbGlzdCBpbmNsdWRlcyBhdCBsZWFzdFxuXHQvLyBvbmUgdmFsaWQgc2VsZWN0b3IpLlxuXHQvLyBOb3RlIHRoYXQgd2UgdHJlYXQgY29tcGxldGUgbGFjayBvZiBzdXBwb3J0IGZvciBgOmhhcygpYCBhcyBpZiBpdCB3ZXJlXG5cdC8vIHNwZWMtY29tcGxpYW50IHN1cHBvcnQsIHdoaWNoIGlzIGZpbmUgYmVjYXVzZSB1c2Ugb2YgYDpoYXMoKWAgaW4gc3VjaFxuXHQvLyBlbnZpcm9ubWVudHMgd2lsbCBmYWlsIGluIHRoZSBxU0EgcGF0aCBhbmQgZmFsbCBiYWNrIHRvIGpRdWVyeSB0cmF2ZXJzYWxcblx0Ly8gYW55d2F5LlxuXHRzdXBwb3J0LmNzc0hhcyA9IGFzc2VydCggZnVuY3Rpb24oKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIFwiOmhhcygqLDpqcWZha2UpXCIgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlci5JRCA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kLklEID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlci5JRCA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZC5UQUcgPSBmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZC5DTEFTUyA9IGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdHZhciBpbnB1dDtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPVxuXHRcdFx0XCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBkaXNhYmxlZD0nZGlzYWJsZWQnPlwiICtcblx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA4IG9ubHlcblx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5IGluIHNvbWUgWE1MIGRvY3VtZW50c1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOCBvbmx5XG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgOCBvbmx5XG5cdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTEwNSssIEZpcmVmb3ggPD0xMDQrLCBTYWZhcmkgPD0xNS40K1xuXHRcdC8vIEluIHNvbWUgb2YgdGhlIGRvY3VtZW50IGtpbmRzLCB0aGVzZSBzZWxlY3RvcnMgd291bGRuJ3Qgd29yayBuYXRpdmVseS5cblx0XHQvLyBUaGlzIGlzIHByb2JhYmx5IE9LIGJ1dCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2Ugd2FudCB0byBtYWludGFpblxuXHRcdC8vIGhhbmRsaW5nIHRoZW0gdGhyb3VnaCBqUXVlcnkgdHJhdmVyc2FsIGluIGpRdWVyeSAzLnguXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6Y2hlY2tlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG5cdFx0Ly8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuXHRcdC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG5cdFx0Ly8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXG5cdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdH1cblx0fSApO1xuXG5cdGlmICggIXN1cHBvcnQuY3NzSGFzICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDEwNSAtIDExMCssIFNhZmFyaSAxNS40IC0gMTYuMytcblx0XHQvLyBPdXIgcmVndWxhciBgdHJ5LWNhdGNoYCBtZWNoYW5pc20gZmFpbHMgdG8gZGV0ZWN0IG5hdGl2ZWx5LXVuc3VwcG9ydGVkXG5cdFx0Ly8gcHNldWRvLWNsYXNzZXMgaW5zaWRlIGA6aGFzKClgIChzdWNoIGFzIGA6aGFzKDpjb250YWlucyhcIkZvb1wiKSlgKVxuXHRcdC8vIGluIGJyb3dzZXJzIHRoYXQgcGFyc2UgdGhlIGA6aGFzKClgIGFyZ3VtZW50IGFzIGEgZm9yZ2l2aW5nIHNlbGVjdG9yIGxpc3QuXG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy8jcmVsYXRpb25hbCBub3cgcmVxdWlyZXMgdGhlIGFyZ3VtZW50XG5cdFx0Ly8gdG8gYmUgcGFyc2VkIHVuZm9yZ2l2aW5nbHksIGJ1dCBicm93c2VycyBoYXZlIG5vdCB5ZXQgZnVsbHkgYWRqdXN0ZWQuXG5cdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmhhc1wiICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGEgKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGZpbmQuY29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59XG5cbmZpbmQubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIGZpbmQoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5maW5kLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZpbmQoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5maW5kLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuXG5maW5kLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIHRyYWMtMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRpZiAoIHZhbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcbn07XG5cbmZpbmQuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0Ly9cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCtcblx0Ly8gVGVzdGluZyBmb3IgZGV0ZWN0aW5nIGR1cGxpY2F0ZXMgaXMgdW5wcmVkaWN0YWJsZSBzbyBpbnN0ZWFkIGFzc3VtZSB3ZSBjYW4ndFxuXHQvLyBkZXBlbmQgb24gZHVwbGljYXRlIGRldGVjdGlvbiBpbiBhbGwgYnJvd3NlcnMgd2l0aG91dCBhIHN0YWJsZSBzb3J0LlxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5zb3J0U3RhYmxlO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHNsaWNlLmNhbGwoIHJlc3VsdHMsIDAgKTtcblx0c29ydC5jYWxsKCByZXN1bHRzLCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHNwbGljZS5jYWxsKCByZXN1bHRzLCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbmpRdWVyeS5mbi51bmlxdWVTb3J0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LnVuaXF1ZVNvcnQoIHNsaWNlLmFwcGx5KCB0aGlzICkgKSApO1xufTtcblxuRXhwciA9IGpRdWVyeS5leHByID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdEFUVFI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiIClcblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDIgXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFsgMyBdID0gXCIgXCIgKyBtYXRjaFsgMyBdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRmaW5kLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XG5cdFx0XHRcdFx0bWF0Y2hbIDUgXSArICggbWF0Y2hbIDYgXSB8fCAxICkgOlxuXHRcdFx0XHRcdDIgKiAoIG1hdGNoWyAzIF0gPT09IFwiZXZlblwiIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRtYXRjaFsgNSBdID0gKyggKCBtYXRjaFsgNyBdICsgbWF0Y2hbIDggXSApIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRmaW5kLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0UFNFVURPOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByLkNISUxELnRlc3QoIG1hdGNoWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdCggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxuXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoIGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRUQUc6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGV4cGVjdGVkTm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBleHBlY3RlZE5vZGVOYW1lICk7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdENMQVNTOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICtcblx0XHRcdFx0XHRcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8XG5cdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdEFUVFI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBmaW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCI9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIhPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgIT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiXj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIqPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiJD1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwifj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiIClcblx0XHRcdFx0XHRcdC5pbmRleE9mKCBjaGVjayApID4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJ8PVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Q0hJTEQ6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlTmFtZSggbm9kZSwgbmFtZSApIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKCBwYXJlbnRbIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGVOYW1lKCBub2RlLCBuYW1lICkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0UFNFVURPOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblxuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0ZmluZC5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIGpRdWVyeSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZi5jYWxsKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdG5vdDogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpIF0gPSAhKCBtYXRjaGVzWyBpIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMjk5KVxuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRoYXM6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZmluZCggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRjb250YWluczogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgalF1ZXJ5LnRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRsYW5nOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KCBsYW5nIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0ZmluZC5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHR0YXJnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdHJvb3Q6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50RWxlbWVudDtcblx0XHR9LFxuXG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiZcblx0XHRcdFx0ZG9jdW1lbnQuaGFzRm9jdXMoKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRlbmFibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRkaXNhYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdGNoZWNrZWQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSggZWxlbSwgXCJvcHRpb25cIiApICYmICEhZWxlbS5zZWxlY3RlZCApO1xuXHRcdH0sXG5cblx0XHRzZWxlY3RlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcblx0XHRcdC8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgZGVmYXVsdCBvcHRpb24gYXNcblx0XHRcdC8vIHNlbGVjdGVkIHdoZW4gaW4gYW4gb3B0Z3JvdXAuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3MuZW1wdHkoIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdGhlYWRlcjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdGlucHV0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0YnV0dG9uOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8XG5cdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8MTAgb25seVxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyXG5cdFx0XHRcdC8vIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoICggYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICkgPT0gbnVsbCB8fFxuXHRcdFx0XHRcdGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdGZpcnN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRsYXN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdGVxOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9ICksXG5cblx0XHRldmVuOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0b2RkOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0bHQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKCBhcmd1bWVudCA8IDAgKSB7XG5cdFx0XHRcdGkgPSBhcmd1bWVudCArIGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAoIGFyZ3VtZW50ID4gbGVuZ3RoICkge1xuXHRcdFx0XHRpID0gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGFyZ3VtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0Z3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3MubnRoID0gRXhwci5wc2V1ZG9zLmVxO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbmZ1bmN0aW9uIHRva2VuaXplKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSBybGVhZGluZ0NvbWJpbmF0b3IuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbUNTUywgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRpZiAoIHBhcnNlT25seSApIHtcblx0XHRyZXR1cm4gc29GYXIubGVuZ3RoO1xuXHR9XG5cblx0cmV0dXJuIHNvRmFyID9cblx0XHRmaW5kLmVycm9yKCBzZWxlY3RvciApIDpcblxuXHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn1cblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgbm9kZU5hbWUoIGVsZW0sIHNraXAgKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAoIG9sZENhY2hlID0gb3V0ZXJDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRmaW5kKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLCBtYXRjaGVyT3V0LFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8XG5cdFx0XHRcdG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXM7XG5cblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyXG5cdFx0XHQvLyBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0bWF0Y2hlck91dCA9IHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRyZXN1bHRzO1xuXG5cdFx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXJJbjtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YuY2FsbCggc2VlZCwgZWxlbSApIDogcHJlTWFwWyBpIF0gKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkWyB0ZW1wIF0gPSAhKCByZXN1bHRzWyB0ZW1wIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAwIF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsgXCIgXCIgXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50XG5cdFx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGkgXS50eXBlIF0gKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKCBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlciApIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zWyBpIF0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbIGkgXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGogXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kLlRBRyggXCIqXCIsIG91dGVybW9zdCApLFxuXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOSBvbmx5XG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmdcblx0XHRcdC8vIGVsZW1lbnRzIGJ5IGlkLiAoc2VlIHRyYWMtMTQxNDIpXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cHVzaC5jYWxsKCByZXN1bHRzLCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3Rvcixcblx0XHRcdG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufVxuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggalF1ZXJ5J3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBqUXVlcnkgc2VsZWN0b3IgY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbmZ1bmN0aW9uIHNlbGVjdCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKCBzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yICkgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKCB0b2tlbiA9IHRva2Vuc1sgMCBdICkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmQuSUQoXG5cdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRjb250ZXh0XG5cdFx0XHQpIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHIubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKCB0eXBlID0gdG9rZW4udHlwZSApIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoIGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSApICkge1xuXG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoICggc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWyAwIF0udHlwZSApICYmXG5cdFx0XHRcdFx0XHR0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIC0gNC4xK1xuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoIFwiXCIgKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKCBcIlwiICkgPT09IGV4cGFuZG87XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCAtIDQuMStcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxualF1ZXJ5LmZpbmQgPSBmaW5kO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlID0galF1ZXJ5LnVuaXF1ZVNvcnQ7XG5cbi8vIFRoZXNlIGhhdmUgYWx3YXlzIGJlZW4gcHJpdmF0ZSwgYnV0IHRoZXkgdXNlZCB0byBiZSBkb2N1bWVudGVkIGFzIHBhcnQgb2Zcbi8vIFNpenpsZSBzbyBsZXQncyBtYWludGFpbiB0aGVtIGZvciBub3cgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuZmluZC5jb21waWxlID0gY29tcGlsZTtcbmZpbmQuc2VsZWN0ID0gc2VsZWN0O1xuZmluZC5zZXREb2N1bWVudCA9IHNldERvY3VtZW50O1xuZmluZC50b2tlbml6ZSA9IHRva2VuaXplO1xuXG5maW5kLmVzY2FwZSA9IGpRdWVyeS5lc2NhcGVTZWxlY3RvcjtcbmZpbmQuZ2V0VGV4dCA9IGpRdWVyeS50ZXh0O1xuZmluZC5pc1hNTCA9IGpRdWVyeS5pc1hNTERvYztcbmZpbmQuc2VsZWN0b3JzID0galF1ZXJ5LmV4cHI7XG5maW5kLnN1cHBvcnQgPSBqUXVlcnkuc3VwcG9ydDtcbmZpbmQudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWVTb3J0O1xuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxufSApKCk7XG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKHRyYWMtOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKHRyYWMtMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIGpRdWVyeSNmaW5kXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggZWxlbS5jb250ZW50RG9jdW1lbnQgIT0gbnVsbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG5cdFx0XHQvLyBgY29udGVudERvY3VtZW50YCB3aXRoIGEgYG51bGxgIHByb3RvdHlwZS5cblx0XHRcdGdldFByb3RvKCBlbGVtLmNvbnRlbnREb2N1bWVudCApICkge1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIF9pLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXJyb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgZXJyb3IsIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciA9IGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2soKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBkZXByZWNhdGVkIGFsaWFzIG9mIHRoZSBhYm92ZS4gV2hpbGUgdGhlIG5hbWUgc3VnZ2VzdHNcblx0XHRcdFx0XHRcdFx0XHQvLyByZXR1cm5pbmcgdGhlIHN0YWNrLCBub3QgYW4gZXJyb3IgaW5zdGFuY2UsIGpRdWVyeSBqdXN0IHBhc3Nlc1xuXHRcdFx0XHRcdFx0XHRcdC8vIGl0IGRpcmVjdGx5IHRvIGBjb25zb2xlLndhcm5gIHNvIGJvdGggd2lsbCB3b3JrOyBhbiBpbnN0YW5jZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGp1c3QgYmV0dGVyIGNvb3BlcmF0ZXMgd2l0aCBzb3VyY2UgbWFwcy5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBwcmltYXJ5IERlZmVycmVkXG5cdFx0XHRwcmltYXJ5ID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdHByaW1hcnkucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIHByaW1hcnkuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgcHJpbWFyeS5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBwcmltYXJ5LnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBwcmltYXJ5LnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIHByaW1hcnkucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByaW1hcnkucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG4vLyBJZiBgalF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9va2AgaXMgZGVmaW5lZCwgYGFzeW5jRXJyb3JgIGlzIGFuIGVycm9yXG4vLyBjYXB0dXJlZCBiZWZvcmUgdGhlIGFzeW5jIGJhcnJpZXIgdG8gZ2V0IHRoZSBvcmlnaW5hbCBlcnJvciBjYXVzZVxuLy8gd2hpY2ggbWF5IG90aGVyd2lzZSBiZSBoaWRkZW4uXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgYXN5bmNFcnJvciApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsXG5cdFx0XHRlcnJvci5zdGFjaywgYXN5bmNFcnJvciApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgdHJhYy02NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBfYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKHRyYWMtOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlIHRyYWMtODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKHRyYWMtMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKHRyYWMtMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICh0cmFjLTE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICh0cmFjLTEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5pZiAoICFzdXBwb3J0Lm9wdGlvbiApIHtcblx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uID0gWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdO1xufVxuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAodHJhYy0xNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKHRyYWMtMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgdGhhdCBhY2NlcHQgZGF0YVxuXHRcdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cblx0XHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApLFxuXG5cdFx0XHRoYW5kbGVycyA9IChcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICh0cmFjLTEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAodHJhYy02OTExLCB0cmFjLTgxNjUsIHRyYWMtMTEzODIsIHRyYWMtMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAodHJhYy0xMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBpc1NldHVwICkge1xuXG5cdC8vIE1pc3NpbmcgYGlzU2V0dXBgIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcblx0aWYgKCAhaXNTZXR1cCApIHtcblx0XHRpZiAoIGRhdGFQcml2LmdldCggZWwsIHR5cGUgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuXHRkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuXHRcdG5hbWVzcGFjZTogZmFsc2UsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0aWYgKCAhc2F2ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmdcblx0XHRcdFx0Ly8gdGhlIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZCApIHtcblxuXHRcdFx0XHQvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cdFx0XHRcdFx0c2F2ZWRbIDAgXSxcblx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnQgYnkgYWxsIGpRdWVyeSBoYW5kbGVycyB3aGlsZSBhbGxvd2luZ1xuXHRcdFx0XHQvLyBuYXRpdmUgaGFuZGxlcnMgb24gdGhlIHNhbWUgZWxlbWVudCB0byBydW4uIE9uIHRhcmdldCwgdGhpcyBpcyBhY2hpZXZlZFxuXHRcdFx0XHQvLyBieSBzdG9wcGluZyBpbW1lZGlhdGUgcHJvcGFnYXRpb24ganVzdCBvbiB0aGUgalF1ZXJ5IGV2ZW50LiBIb3dldmVyLFxuXHRcdFx0XHQvLyB0aGUgbmF0aXZlIGV2ZW50IGlzIHJlLXdyYXBwZWQgYnkgYSBqUXVlcnkgb25lIG9uIGVhY2ggbGV2ZWwgb2YgdGhlXG5cdFx0XHRcdC8vIHByb3BhZ2F0aW9uIHNvIHRoZSBvbmx5IHdheSB0byBzdG9wIGl0IGZvciBqUXVlcnkgaXMgdG8gc3RvcCBpdCBmb3Jcblx0XHRcdFx0Ly8gZXZlcnlvbmUgdmlhIG5hdGl2ZSBgc3RvcFByb3BhZ2F0aW9uKClgLiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gZm9yXG5cdFx0XHRcdC8vIGZvY3VzL2JsdXIgd2hpY2ggZG9uJ3QgYnViYmxlLCBidXQgaXQgZG9lcyBhbHNvIHN0b3AgY2xpY2sgb24gY2hlY2tib3hlc1xuXHRcdFx0XHQvLyBhbmQgcmFkaW9zLiBXZSBhY2NlcHQgdGhpcyBsaW1pdGF0aW9uLlxuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0ZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKHRyYWMtNTA0LCB0cmFjLTEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cdHdoaWNoOiB0cnVlXG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXG5cdGZ1bmN0aW9uIGZvY3VzTWFwcGVkSGFuZGxlciggbmF0aXZlRXZlbnQgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGZvY3VzaW4vZm9jdXNvdXQgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50c1xuXHRcdFx0Ly8gZm9jdXMvYmx1ci4gVGhpcyBpcyBiZWNhdXNlIHRoZSBmb3JtZXIgYXJlIHN5bmNocm9ub3VzIGluIElFIHdoaWxlIHRoZSBsYXR0ZXJcblx0XHRcdC8vIGFyZSBhc3luYy4gSW4gb3RoZXIgYnJvd3NlcnMsIGFsbCB0aG9zZSBoYW5kbGVycyBhcmUgaW52b2tlZCBzeW5jaHJvbm91c2x5LlxuXG5cdFx0XHQvLyBgaGFuZGxlYCBmcm9tIHByaXZhdGUgZGF0YSB3b3VsZCBhbHJlYWR5IHdyYXAgdGhlIGV2ZW50LCBidXQgd2UgbmVlZFxuXHRcdFx0Ly8gdG8gY2hhbmdlIHRoZSBgdHlwZWAgaGVyZS5cblx0XHRcdHZhciBoYW5kbGUgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiaGFuZGxlXCIgKSxcblx0XHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXHRcdFx0ZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGUgPT09IFwiZm9jdXNpblwiID8gXCJmb2N1c1wiIDogXCJibHVyXCI7XG5cdFx0XHRldmVudC5pc1NpbXVsYXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIEZpcnN0LCBoYW5kbGUgZm9jdXNpbi9mb2N1c291dFxuXHRcdFx0aGFuZGxlKCBuYXRpdmVFdmVudCApO1xuXG5cdFx0XHQvLyAuLi50aGVuLCBoYW5kbGUgZm9jdXMvYmx1clxuXHRcdFx0Ly9cblx0XHRcdC8vIGZvY3VzL2JsdXIgZG9uJ3QgYnViYmxlIHdoaWxlIGZvY3VzaW4vZm9jdXNvdXQgZG87IHNpbXVsYXRlIHRoZSBmb3JtZXIgYnkgb25seVxuXHRcdFx0Ly8gaW52b2tpbmcgdGhlIGhhbmRsZXIgYXQgdGhlIGxvd2VyIGxldmVsLlxuXHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIHNldHVwIHBhcnQgY2FsbHMgYGxldmVyYWdlTmF0aXZlYCwgd2hpY2gsIGluIHR1cm4sIGNhbGxzXG5cdFx0XHRcdC8vIGBqUXVlcnkuZXZlbnQuYWRkYCwgc28gZXZlbnQgaGFuZGxlIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gc2V0XG5cdFx0XHRcdC8vIGJ5IHRoaXMgcG9pbnQuXG5cdFx0XHRcdGhhbmRsZSggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3Igbm9uLUlFIGJyb3dzZXJzLCBhdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50XG5cdFx0XHQvLyB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXQuXG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGRlbGVnYXRlVHlwZSwgbmF0aXZlRXZlbnQudGFyZ2V0LFxuXHRcdFx0XHRqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApICk7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIGF0dGFjaGVzO1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIHRydWUgKTtcblxuXHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdFx0XHQvLyBXZSB1c2UgdGhlIHNhbWUgbmF0aXZlIGhhbmRsZXIgZm9yIGZvY3VzaW4gJiBmb2N1cyAoYW5kIGZvY3Vzb3V0ICYgYmx1cilcblx0XHRcdFx0Ly8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG5cdFx0XHRcdC8vIFVzZSBgZGVsZWdhdGVUeXBlYCBhcyB0aGUga2V5IGFzIGB0eXBlYCBpcyBhbHJlYWR5IHVzZWQgYnkgYGxldmVyYWdlTmF0aXZlYC5cblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXR0YWNoZXM7XG5cblx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggdGhpcywgZGVsZWdhdGVUeXBlICkgLSAxO1xuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGUgc3RhbmRhcmQgdGVhcmRvd24gc2hvdWxkIGJlIGFwcGxpZWRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBTdXBwcmVzcyBuYXRpdmUgZm9jdXMgb3IgYmx1ciBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlXG5cdFx0Ly8gYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGV2ZW50LnRhcmdldCwgdHlwZSApO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuXHQvLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuXHQvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcblx0Ly8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0Ly8gVG8gcHJlc2VydmUgcmVsYXRpdmUgZm9jdXNpbi9mb2N1cyAmIGZvY3Vzb3V0L2JsdXIgZXZlbnQgb3JkZXIgZ3VhcmFudGVlZCBvbiB0aGUgMy54IGJyYW5jaCxcblx0Ly8gYXR0YWNoIGEgc2luZ2xlIGhhbmRsZXIgZm9yIGJvdGggZXZlbnRzIGluIElFLlxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZGVsZWdhdGVUeXBlIF0gPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0Ly8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxuXHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdGRhdGFIb2xkZXIgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgPyB0aGlzIDogZG9jLFxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHRcdC8vIFdlIHVzZSB0aGUgc2FtZSBuYXRpdmUgaGFuZGxlciBmb3IgZm9jdXNpbiAmIGZvY3VzIChhbmQgZm9jdXNvdXQgJiBibHVyKVxuXHRcdFx0Ly8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG5cdFx0XHQvLyBVc2UgYGRlbGVnYXRlVHlwZWAgYXMgdGhlIGtleSBhcyBgdHlwZWAgaXMgYWxyZWFkeSB1c2VkIGJ5IGBsZXZlcmFnZU5hdGl2ZWAuXG5cdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBmb2N1c01hcHBlZEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGF0YVByaXYuc2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdH0sXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdGRhdGFIb2xkZXIgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgPyB0aGlzIDogZG9jLFxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICkgLSAxO1xuXG5cdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBmb2N1c01hcHBlZEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUsIGF0dGFjaGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8IVxcW0NEQVRBXFxbfFxcXVxcXT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KCBzcmMgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAodHJhYy04MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZS1lbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVW53cmFwIGEgQ0RBVEEgc2VjdGlvbiBjb250YWluaW5nIHNjcmlwdCBjb250ZW50cy4gVGhpcyBzaG91bGRuJ3QgYmVcblx0XHRcdFx0XHRcdFx0Ly8gbmVlZGVkIGFzIGluIFhNTCBkb2N1bWVudHMgdGhleSdyZSBhbHJlYWR5IG5vdCB2aXNpYmxlIHdoZW5cblx0XHRcdFx0XHRcdFx0Ly8gaW5zcGVjdGluZyBlbGVtZW50IGNvbnRlbnRzIGFuZCBpbiBIVE1MIGRvY3VtZW50cyB0aGV5IGhhdmUgbm9cblx0XHRcdFx0XHRcdFx0Ly8gbWVhbmluZyBidXQgd2UncmUgcHJlc2VydmluZyB0aGF0IGxvZ2ljIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIGJlIHJlbW92ZWQgY29tcGxldGVseSBpbiA0LjAuIFNlZSBnaC00OTA0LlxuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IGpRdWVyeSNmaW5kIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6XG5cdFx0XHQvLyBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciByY3VzdG9tUHJvcCA9IC9eLS0vO1xuXG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICh0cmFjLTE1MDk4LCB0cmFjLTE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAodHJhYy04OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG5cdFx0Ly8gc29tZSB2ZXJzaW9ucyBvZiB0aGlzIHRlc3Q7IG1ha2Ugc3VyZSBub3QgdG8gbWFrZSBpdCBwYXNzIHRoZXJlIVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA3MCtcblx0XHQvLyBPbmx5IEZpcmVmb3ggaW5jbHVkZXMgYm9yZGVyIHdpZHRoc1xuXHRcdC8vIGluIGNvbXB1dGVkIGRpbWVuc2lvbnMuIChnaC00NTI5KVxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0YWJsZSwgdHIsIHRyQ2hpbGQsIHRyU3R5bGU7XG5cdFx0XHRpZiAoIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0YWJsZVwiICk7XG5cdFx0XHRcdHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0clwiICk7XG5cdFx0XHRcdHRyQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHRcdFx0dGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGVcIjtcblx0XHRcdFx0dHIuc3R5bGUuY3NzVGV4dCA9IFwiYm94LXNpemluZzpjb250ZW50LWJveDtib3JkZXI6MXB4IHNvbGlkXCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBIZWlnaHQgc2V0IHRocm91Z2ggY3NzVGV4dCBkb2VzIG5vdCBnZXQgYXBwbGllZC5cblx0XHRcdFx0Ly8gQ29tcHV0ZWQgaGVpZ2h0IHRoZW4gY29tZXMgYmFjayBhcyAwLlxuXHRcdFx0XHR0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA4IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuXHRcdFx0XHQvLyBkaXNwbGF5IGZvciBhbGwgZGl2IGVsZW1lbnRzIGlzIHNldCB0byBcImlubGluZVwiLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYSBwcm9ibGVtIG9ubHkgaW4gQW5kcm9pZCA4IENocm9tZSA4Ni5cblx0XHRcdFx0Ly8gRW5zdXJpbmcgdGhlIGRpdiBpcyBgZGlzcGxheTogYmxvY2tgXG5cdFx0XHRcdC8vIGdldHMgYXJvdW5kIHRoaXMgaXNzdWUuXG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gKCBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTAgKSApID09PSB0ci5vZmZzZXRIZWlnaHQ7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgdHJhYy0xMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoZ2gtMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdC8vIElFIG9ubHkgc3VwcG9ydHMgYFwiZmxvYXRcImAgaW4gYGdldFByb3BlcnR5VmFsdWVgOyBpbiBjb21wdXRlZCBzdHlsZXNcblx0XHQvLyBpdCdzIG9ubHkgYXZhaWxhYmxlIGFzIGBcImNzc0Zsb2F0XCJgLiBXZSBubyBsb25nZXIgbW9kaWZ5IHByb3BlcnRpZXNcblx0XHQvLyBzZW50IHRvIGAuY3NzKClgIGFwYXJ0IGZyb20gY2FtZWxDYXNpbmcsIHNvIHdlIG5lZWQgdG8gY2hlY2sgYm90aC5cblx0XHQvLyBOb3JtYWxseSwgdGhpcyB3b3VsZCBjcmVhdGUgZGlmZmVyZW5jZSBpbiBiZWhhdmlvcjogaWZcblx0XHQvLyBgZ2V0UHJvcGVydHlWYWx1ZWAgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcsIHRoZSB2YWx1ZSByZXR1cm5lZFxuXHRcdC8vIGJ5IGAuY3NzKClgIHdvdWxkIGJlIGB1bmRlZmluZWRgLiBUaGlzIGlzIHVzdWFsbHkgdGhlIGNhc2UgZm9yXG5cdFx0Ly8gZGlzY29ubmVjdGVkIGVsZW1lbnRzLiBIb3dldmVyLCBpbiBJRSBldmVuIGRpc2Nvbm5lY3RlZCBlbGVtZW50c1xuXHRcdC8vIHdpdGggbm8gc3R5bGVzIHJldHVybiBgXCJub25lXCJgIGZvciBgZ2V0UHJvcGVydHlWYWx1ZSggXCJmbG9hdFwiIClgXG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIGlzQ3VzdG9tUHJvcCAmJiByZXQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMTA1KywgQ2hyb21lIDw9MTA1K1xuXHRcdFx0Ly8gU3BlYyByZXF1aXJlcyB0cmltbWluZyB3aGl0ZXNwYWNlIGZvciBjdXN0b20gcHJvcGVydGllcyAoZ2gtNDkyNikuXG5cdFx0XHQvLyBGaXJlZm94IG9ubHkgdHJpbXMgbGVhZGluZyB3aGl0ZXNwYWNlLiBDaHJvbWUganVzdCBjb2xsYXBzZXNcblx0XHRcdC8vIGJvdGggbGVhZGluZyAmIHRyYWlsaW5nIHdoaXRlc3BhY2UgdG8gYSBzaW5nbGUgc3BhY2UuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIGB1bmRlZmluZWRgIGlmIGVtcHR5IHN0cmluZyByZXR1cm5lZC5cblx0XHRcdC8vIFRoaXMgY29sbGFwc2VzIGEgbWlzc2luZyBkZWZpbml0aW9uIHdpdGggcHJvcGVydHkgZGVmaW5lZFxuXHRcdFx0Ly8gYW5kIHNldCB0byBhbiBlbXB0eSBzdHJpbmcgYnV0IHRoZXJlJ3Mgbm8gc3RhbmRhcmQgQVBJXG5cdFx0XHQvLyBhbGxvd2luZyB1cyB0byBkaWZmZXJlbnRpYXRlIHRoZW0gd2l0aG91dCBhIHBlcmZvcm1hbmNlIHBlbmFsdHlcblx0XHRcdC8vIGFuZCByZXR1cm5pbmcgYHVuZGVmaW5lZGAgYWxpZ25zIHdpdGggb2xkZXIgalF1ZXJ5LlxuXHRcdFx0Ly9cblx0XHRcdC8vIHJ0cmltQ1NTIHRyZWF0cyBVKzAwMEQgQ0FSUklBR0UgUkVUVVJOIGFuZCBVKzAwMEMgRk9STSBGRUVEXG5cdFx0XHQvLyBhcyB3aGl0ZXNwYWNlIHdoaWxlIENTUyBkb2VzIG5vdCwgYnV0IHRoaXMgaXMgbm90IGEgcHJvYmxlbVxuXHRcdFx0Ly8gYmVjYXVzZSBDU1MgcHJlcHJvY2Vzc2luZyByZXBsYWNlcyB0aGVtIHdpdGggVSswMDBBIExJTkUgRkVFRFxuXHRcdFx0Ly8gKHdoaWNoICppcyogQ1NTIHdoaXRlc3BhY2UpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpbnB1dC1wcmVwcm9jZXNzaW5nXG5cdFx0XHRyZXQgPSByZXQucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApIHx8IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBfZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDAsXG5cdFx0bWFyZ2luRGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdC8vIENvdW50IG1hcmdpbiBkZWx0YSBzZXBhcmF0ZWx5IHRvIG9ubHkgYWRkIGl0IGFmdGVyIHNjcm9sbCBndXR0ZXIgYWRqdXN0bWVudC5cblx0XHQvLyBUaGlzIGlzIG5lZWRlZCB0byBtYWtlIG5lZ2F0aXZlIG1hcmdpbnMgd29yayB3aXRoIGBvdXRlckhlaWdodCggdHJ1ZSApYCAoZ2gtMzk4MikuXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRtYXJnaW5EZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGEgKyBtYXJnaW5EZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG5cdFx0YXNwZWN0UmF0aW86IHRydWUsXG5cdFx0Ym9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcblx0XHRjb2x1bW5Db3VudDogdHJ1ZSxcblx0XHRmbGV4R3JvdzogdHJ1ZSxcblx0XHRmbGV4U2hyaW5rOiB0cnVlLFxuXHRcdGZvbnRXZWlnaHQ6IHRydWUsXG5cdFx0Z3JpZEFyZWE6IHRydWUsXG5cdFx0Z3JpZENvbHVtbjogdHJ1ZSxcblx0XHRncmlkQ29sdW1uRW5kOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcblx0XHRncmlkUm93OiB0cnVlLFxuXHRcdGdyaWRSb3dFbmQ6IHRydWUsXG5cdFx0Z3JpZFJvd1N0YXJ0OiB0cnVlLFxuXHRcdGxpbmVIZWlnaHQ6IHRydWUsXG5cdFx0b3BhY2l0eTogdHJ1ZSxcblx0XHRvcmRlcjogdHJ1ZSxcblx0XHRvcnBoYW5zOiB0cnVlLFxuXHRcdHNjYWxlOiB0cnVlLFxuXHRcdHdpZG93czogdHJ1ZSxcblx0XHR6SW5kZXg6IHRydWUsXG5cdFx0em9vbTogdHJ1ZSxcblxuXHRcdC8vIFNWRy1yZWxhdGVkXG5cdFx0ZmlsbE9wYWNpdHk6IHRydWUsXG5cdFx0Zmxvb2RPcGFjaXR5OiB0cnVlLFxuXHRcdHN0b3BPcGFjaXR5OiB0cnVlLFxuXHRcdHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG5cdFx0c3Ryb2tlT3BhY2l0eTogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAodHJhYy03MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgdHJhYy05MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKHRyYWMtNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICh0cmFjLTEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsICh0cmFjLTEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY3VyLCBjdXJWYWx1ZSwgY2xhc3NOYW1lLCBpLCBmaW5hbFZhbHVlO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzTmFtZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0Y3VyID0gdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY3VyLCBjdXJWYWx1ZSwgY2xhc3NOYW1lLCBpLCBmaW5hbFZhbHVlO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc05hbWVzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCB0aGlzICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY2xhc3NOYW1lLCBpLCBzZWxmLFxuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAodHJhYy0xNDY4NiwgdHJhYy0xNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKHRyYWMtMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCBwYXJzZXJFcnJvckVsZW07XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHt9XG5cblx0cGFyc2VyRXJyb3JFbGVtID0geG1sICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiIClbIDAgXTtcblx0aWYgKCAheG1sIHx8IHBhcnNlckVycm9yRWxlbSApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgKFxuXHRcdFx0cGFyc2VyRXJyb3JFbGVtID9cblx0XHRcdFx0alF1ZXJ5Lm1hcCggcGFyc2VyRXJyb3JFbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWwudGV4dENvbnRlbnQ7XG5cdFx0XHRcdH0gKS5qb2luKCBcIlxcblwiICkgOlxuXHRcdFx0XHRkYXRhXG5cdFx0KSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICh0cmFjLTk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICh0cmFjLTk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKHRyYWMtNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gdHJhYy03NjUzLCB0cmFjLTgxMjUsIHRyYWMtODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAodHJhYy0xMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cbm9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyB0cmFjLTk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICh0cmFjLTEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0IHRyYWMtMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICh0cmFjLTE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gdHJhYy05NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdCBidXQgbm90IGlmIGpzb25wXG5cdFx0XHRpZiAoICFpc1N1Y2Nlc3MgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwic2NyaXB0XCIsIHMuZGF0YVR5cGVzICkgPiAtMSAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJqc29uXCIsIHMuZGF0YVR5cGVzICkgPCAwICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICh0cmFjLTExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMsIGRvYyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyB0cmFjLTE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSB0cmFjLTg2MDUsIHRyYWMtMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vIHRyYWMtMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsXG5cdFx0Y29udGVudDogdHlwZSxcblx0XHRcIlwiOiBcIm91dGVyXCIgKyBuYW1lXG5cdH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIF9pLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5vbiggXCJtb3VzZWVudGVyXCIsIGZuT3ZlciApXG5cdFx0XHQub24oIFwibW91c2VsZWF2ZVwiLCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaChcblx0KCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fVxuKTtcblxuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4vLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcbi8vIFJlcXVpcmUgdGhhdCB0aGUgXCJ3aGl0ZXNwYWNlIHJ1blwiIHN0YXJ0cyBmcm9tIGEgbm9uLXdoaXRlc3BhY2Vcbi8vIHRvIGF2b2lkIE8oTl4yKSBiZWhhdmlvciB3aGVuIHRoZSBlbmdpbmUgd291bGQgdHJ5IG1hdGNoaW5nIFwiXFxzKyRcIiBhdCBlYWNoIHNwYWNlIHBvc2l0aW9uLlxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8KFteXFxzXFx1RkVGRlxceEEwXSlbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICk7XG59O1xuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICh0cmFjLTcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICh0cmFjLTEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsIi8vICdwYXRoJyBtb2R1bGUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xIChvbmx5IHRoZSBwb3NpeCBwYXJ0KVxuLy8gdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbFxuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KHBhdGgpKTtcbiAgfVxufVxuXG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsIGFsbG93QWJvdmVSb290KSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgdmFyIGxhc3RTbGFzaCA9IC0xO1xuICB2YXIgZG90cyA9IDA7XG4gIHZhciBjb2RlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoLmxlbmd0aClcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgZWxzZSBpZiAoY29kZSA9PT0gNDcgLyovKi8pXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBjb2RlID0gNDcgLyovKi87XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNsYXNoICE9PSBpIC0gMSAmJiBkb3RzID09PSAyKSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IDQ2IC8qLiovIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gNDYgLyouKi8pIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmVzICs9ICcvLi4nO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlcyA9ICcuLic7XG4gICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmVzICs9ICcvJyArIHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDYgLyouKi8gJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICsrZG90cztcbiAgICB9IGVsc2Uge1xuICAgICAgZG90cyA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xuICB2YXIgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xuICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCAocGF0aE9iamVjdC5uYW1lIHx8ICcnKSArIChwYXRoT2JqZWN0LmV4dCB8fCAnJyk7XG4gIGlmICghZGlyKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKGRpciA9PT0gcGF0aE9iamVjdC5yb290KSB7XG4gICAgcmV0dXJuIGRpciArIGJhc2U7XG4gIH1cbiAgcmV0dXJuIGRpciArIHNlcCArIGJhc2U7XG59XG5cbnZhciBwb3NpeCA9IHtcbiAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHZhciByZXNvbHZlZFBhdGggPSAnJztcbiAgICB2YXIgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgIHZhciBjd2Q7XG5cbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgdmFyIHBhdGg7XG4gICAgICBpZiAoaSA+PSAwKVxuICAgICAgICBwYXRoID0gYXJndW1lbnRzW2ldO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjd2QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICBwYXRoID0gY3dkO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHJlc29sdmVkUGF0aCwgIXJlc29sdmVkQWJzb2x1dGUpO1xuXG4gICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJy4nO1xuICAgIH1cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcblxuICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB2YXIgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcgLyovKi87XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgIWlzQWJzb2x1dGUpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwICYmICFpc0Fic29sdXRlKSBwYXRoID0gJy4nO1xuICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpIHBhdGggKz0gJy8nO1xuXG4gICAgaWYgKGlzQWJzb2x1dGUpIHJldHVybiAnLycgKyBwYXRoO1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHZhciBqb2luZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBhc3NlcnRQYXRoKGFyZyk7XG4gICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGpvaW5lZCA9IGFyZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGpvaW5lZCArPSAnLycgKyBhcmc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAnLic7XG4gICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpO1xuICB9LFxuXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgIGFzc2VydFBhdGgoZnJvbSk7XG4gICAgYXNzZXJ0UGF0aCh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIGZyb20gPSBwb3NpeC5yZXNvbHZlKGZyb20pO1xuICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgZnJvbVN0YXJ0ID0gMTtcbiAgICBmb3IgKDsgZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGg7ICsrZnJvbVN0YXJ0KSB7XG4gICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcbiAgICB2YXIgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIHRvU3RhcnQgPSAxO1xuICAgIGZvciAoOyB0b1N0YXJ0IDwgdG8ubGVuZ3RoOyArK3RvU3RhcnQpIHtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciB0b0VuZCA9IHRvLmxlbmd0aDtcbiAgICB2YXIgdG9MZW4gPSB0b0VuZCAtIHRvU3RhcnQ7XG5cbiAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XG4gICAgdmFyIGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcbiAgICB2YXIgbGFzdENvbW1vblNlcCA9IC0xO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8PSBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgICAgICBpZiAodG9MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvZm9vL2Jhci9iYXonXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkgKyAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy8nOyB0bz0nL2ZvbydcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28nOyB0bz0nLydcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgIHZhciB0b0NvZGUgPSB0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKTtcbiAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG9Db2RlKVxuICAgICAgICBicmVhaztcbiAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSA0NyAvKi8qLylcbiAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gXG4gICAgLy8gYW5kIGBmcm9tYFxuICAgIGZvciAoaSA9IGZyb21TdGFydCArIGxhc3RDb21tb25TZXAgKyAxOyBpIDw9IGZyb21FbmQ7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBvdXQgKz0gJy4uJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG91dCArPSAnLy4uJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxuICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0c1xuICAgIGlmIChvdXQubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBvdXQgKyB0by5zbGljZSh0b1N0YXJ0ICsgbGFzdENvbW1vblNlcCk7XG4gICAgZWxzZSB7XG4gICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gNDcgLyovKi8pXG4gICAgICAgICsrdG9TdGFydDtcbiAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0KTtcbiAgICB9XG4gIH0sXG5cbiAgX21ha2VMb25nOiBmdW5jdGlvbiBfbWFrZUxvbmcocGF0aCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGRpcm5hbWU6IGZ1bmN0aW9uIGRpcm5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHJldHVybiAnLy8nO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG5cbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZXh0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoLmxlbmd0aCAmJiBleHQgPT09IHBhdGgpIHJldHVybiAnJztcbiAgICAgIHZhciBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcbiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xuICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtlbHNlIGlmIChlbmQgPT09IC0xKSBlbmQgPSBwYXRoLmxlbmd0aDtcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIGV4dG5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHBhdGhPYmplY3QpIHtcbiAgICBpZiAocGF0aE9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2YgcGF0aE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgcGF0aE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBfZm9ybWF0KCcvJywgcGF0aE9iamVjdCk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJldDtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaXNBYnNvbHV0ZSA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBzdGFydDtcbiAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgcmV0LnJvb3QgPSAnLyc7XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuXG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcblxuICAgIC8vIEdldCBub24tZGlyIGluZm9cbiAgICBmb3IgKDsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHN0YXJ0RG90ID0gaTtlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtlbHNlIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZSgxLCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0UGFydCA+IDApIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO2Vsc2UgaWYgKGlzQWJzb2x1dGUpIHJldC5kaXIgPSAnLyc7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIHNlcDogJy8nLFxuICBkZWxpbWl0ZXI6ICc6JyxcbiAgd2luMzI6IG51bGwsXG4gIHBvc2l4OiBudWxsXG59O1xuXG5wb3NpeC5wb3NpeCA9IHBvc2l4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc2l4O1xuIiwidmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU1hcENvbnN1bWVyO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBmcztcbnRyeSB7XG4gIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFmcy5leGlzdHNTeW5jIHx8ICFmcy5yZWFkRmlsZVN5bmMpIHtcbiAgICAvLyBmcyBkb2Vzbid0IGhhdmUgYWxsIG1ldGhvZHMgd2UgbmVlZFxuICAgIGZzID0gbnVsbDtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8qIG5vcCAqL1xufVxuXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJyk7XG5cbi8qKlxuICogUmVxdWlyZXMgYSBtb2R1bGUgd2hpY2ggaXMgcHJvdGVjdGVkIGFnYWluc3QgYnVuZGxlciBtaW5pZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtOb2RlTW9kdWxlfSBtb2RcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWNSZXF1aXJlKG1vZCwgcmVxdWVzdCkge1xuICByZXR1cm4gbW9kLnJlcXVpcmUocmVxdWVzdCk7XG59XG5cbi8vIE9ubHkgaW5zdGFsbCBvbmNlIGlmIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xudmFyIGVycm9yRm9ybWF0dGVySW5zdGFsbGVkID0gZmFsc2U7XG52YXIgdW5jYXVnaHRTaGltSW5zdGFsbGVkID0gZmFsc2U7XG5cbi8vIElmIHRydWUsIHRoZSBjYWNoZXMgYXJlIHJlc2V0IGJlZm9yZSBhIHN0YWNrIHRyYWNlIGZvcm1hdHRpbmcgb3BlcmF0aW9uXG52YXIgZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zID0gZmFsc2U7XG5cbi8vIFN1cHBvcnRzIHticm93c2VyLCBub2RlLCBhdXRvfVxudmFyIGVudmlyb25tZW50ID0gXCJhdXRvXCI7XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSBjb250ZW50c1xudmFyIGZpbGVDb250ZW50c0NhY2hlID0ge307XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzb3VyY2UgbWFwIGZvciB0aGF0IGZpbGVcbnZhciBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuXG4vLyBSZWdleCBmb3IgZGV0ZWN0aW5nIHNvdXJjZSBtYXBzXG52YXIgcmVTb3VyY2VNYXAgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uW14sXStiYXNlNjQsLztcblxuLy8gUHJpb3JpdHkgbGlzdCBvZiByZXRyaWV2ZSBoYW5kbGVyc1xudmFyIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gW107XG52YXIgcmV0cmlldmVNYXBIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBpc0luQnJvd3NlcigpIHtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcImJyb3dzZXJcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcIm5vZGVcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSAmJiAhKHdpbmRvdy5yZXF1aXJlICYmIHdpbmRvdy5tb2R1bGUgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiKSk7XG59XG5cbmZ1bmN0aW9uIGhhc0dsb2JhbFByb2Nlc3NFdmVudEVtaXR0ZXIoKSB7XG4gIHJldHVybiAoKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JykgJiYgKHByb2Nlc3MgIT09IG51bGwpICYmICh0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gJ2Z1bmN0aW9uJykpO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxQcm9jZXNzVmVyc2lvbigpIHtcbiAgaWYgKCh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpICYmIChwcm9jZXNzICE9PSBudWxsKSkge1xuICAgIHJldHVybiBwcm9jZXNzLnZlcnNpb247XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdsb2JhbFByb2Nlc3NTdGRlcnIoKSB7XG4gIGlmICgodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnKSAmJiAocHJvY2VzcyAhPT0gbnVsbCkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5zdGRlcnI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2xvYmFsUHJvY2Vzc0V4aXQoY29kZSkge1xuICBpZiAoKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JykgJiYgKHByb2Nlc3MgIT09IG51bGwpICYmICh0eXBlb2YgcHJvY2Vzcy5leGl0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHJldHVybiBwcm9jZXNzLmV4aXQoY29kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlckV4ZWMobGlzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gbGlzdFtpXShhcmcpO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIHJldHJpZXZlRmlsZSA9IGhhbmRsZXJFeGVjKHJldHJpZXZlRmlsZUhhbmRsZXJzKTtcblxucmV0cmlldmVGaWxlSGFuZGxlcnMucHVzaChmdW5jdGlvbihwYXRoKSB7XG4gIC8vIFRyaW0gdGhlIHBhdGggdG8gbWFrZSBzdXJlIHRoZXJlIGlzIG5vIGV4dHJhIHdoaXRlc3BhY2UuXG4gIHBhdGggPSBwYXRoLnRyaW0oKTtcbiAgaWYgKC9eZmlsZTovLnRlc3QocGF0aCkpIHtcbiAgICAvLyBleGlzdHNTeW5jL3JlYWRGaWxlU3luYyBjYW4ndCBoYW5kbGUgZmlsZSBwcm90b2NvbCwgYnV0IG9uY2Ugc3RyaXBwZWQsIGl0IHdvcmtzXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvZmlsZTpcXC9cXC9cXC8oXFx3Oik/LywgZnVuY3Rpb24ocHJvdG9jb2wsIGRyaXZlKSB7XG4gICAgICByZXR1cm4gZHJpdmUgP1xuICAgICAgICAnJyA6IC8vIGZpbGU6Ly8vQzovZGlyL2ZpbGUgLT4gQzovZGlyL2ZpbGVcbiAgICAgICAgJy8nOyAvLyBmaWxlOi8vL3Jvb3QtZGlyL2ZpbGUgLT4gL3Jvb3QtZGlyL2ZpbGVcbiAgICB9KTtcbiAgfVxuICBpZiAocGF0aCBpbiBmaWxlQ29udGVudHNDYWNoZSkge1xuICAgIHJldHVybiBmaWxlQ29udGVudHNDYWNoZVtwYXRoXTtcbiAgfVxuXG4gIHZhciBjb250ZW50cyA9ICcnO1xuICB0cnkge1xuICAgIGlmICghZnMpIHtcbiAgICAgIC8vIFVzZSBTSkFYIGlmIHdlIGFyZSBpbiB0aGUgYnJvd3NlclxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgsIC8qKiBhc3luYyAqLyBmYWxzZSk7XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29udGVudHMgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGZpbGVzeXN0ZW1cbiAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHBhdGgsICd1dGY4Jyk7XG4gICAgfVxuICB9IGNhdGNoIChlcikge1xuICAgIC8qIGlnbm9yZSBhbnkgZXJyb3JzICovXG4gIH1cblxuICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF0gPSBjb250ZW50cztcbn0pO1xuXG4vLyBTdXBwb3J0IFVSTHMgcmVsYXRpdmUgdG8gYSBkaXJlY3RvcnksIGJ1dCBiZSBjYXJlZnVsIGFib3V0IGEgcHJvdG9jb2wgcHJlZml4XG4vLyBpbiBjYXNlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciAoaS5lLiBkaXJlY3RvcmllcyBtYXkgc3RhcnQgd2l0aCBcImh0dHA6Ly9cIiBvciBcImZpbGU6Ly8vXCIpXG5mdW5jdGlvbiBzdXBwb3J0UmVsYXRpdmVVUkwoZmlsZSwgdXJsKSB7XG4gIGlmICghZmlsZSkgcmV0dXJuIHVybDtcbiAgdmFyIGRpciA9IHBhdGguZGlybmFtZShmaWxlKTtcbiAgdmFyIG1hdGNoID0gL15cXHcrOlxcL1xcL1teXFwvXSovLmV4ZWMoZGlyKTtcbiAgdmFyIHByb3RvY29sID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICB2YXIgc3RhcnRQYXRoID0gZGlyLnNsaWNlKHByb3RvY29sLmxlbmd0aCk7XG4gIGlmIChwcm90b2NvbCAmJiAvXlxcL1xcd1xcOi8udGVzdChzdGFydFBhdGgpKSB7XG4gICAgLy8gaGFuZGxlIGZpbGU6Ly8vQzovIHBhdGhzXG4gICAgcHJvdG9jb2wgKz0gJy8nO1xuICAgIHJldHVybiBwcm90b2NvbCArIHBhdGgucmVzb2x2ZShkaXIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSwgdXJsKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH1cbiAgcmV0dXJuIHByb3RvY29sICsgcGF0aC5yZXNvbHZlKGRpci5zbGljZShwcm90b2NvbC5sZW5ndGgpLCB1cmwpO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZVNvdXJjZU1hcFVSTChzb3VyY2UpIHtcbiAgdmFyIGZpbGVEYXRhO1xuXG4gIGlmIChpc0luQnJvd3NlcigpKSB7XG4gICAgIHRyeSB7XG4gICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgIHhoci5vcGVuKCdHRVQnLCBzb3VyY2UsIGZhbHNlKTtcbiAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICBmaWxlRGF0YSA9IHhoci5yZWFkeVN0YXRlID09PSA0ID8geGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG5cbiAgICAgICAvLyBTdXBwb3J0IHByb3ZpZGluZyBhIHNvdXJjZU1hcHBpbmdVUkwgdmlhIHRoZSBTb3VyY2VNYXAgaGVhZGVyXG4gICAgICAgdmFyIHNvdXJjZU1hcEhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIlNvdXJjZU1hcFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJYLVNvdXJjZU1hcFwiKTtcbiAgICAgICBpZiAoc291cmNlTWFwSGVhZGVyKSB7XG4gICAgICAgICByZXR1cm4gc291cmNlTWFwSGVhZGVyO1xuICAgICAgIH1cbiAgICAgfSBjYXRjaCAoZSkge1xuICAgICB9XG4gIH1cblxuICAvLyBHZXQgdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcFxuICBmaWxlRGF0YSA9IHJldHJpZXZlRmlsZShzb3VyY2UpO1xuICB2YXIgcmUgPSAvKD86XFwvXFwvW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSspW1xcc10qJCl8KD86XFwvXFwqW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzKidcIl0rKVtcXHNdKig/OlxcKlxcLylbXFxzXSokKS9tZztcbiAgLy8gS2VlcCBleGVjdXRpbmcgdGhlIHNlYXJjaCB0byBmaW5kIHRoZSAqbGFzdCogc291cmNlTWFwcGluZ1VSTCB0byBhdm9pZFxuICAvLyBwaWNraW5nIHVwIHNvdXJjZU1hcHBpbmdVUkxzIGZyb20gY29tbWVudHMsIHN0cmluZ3MsIGV0Yy5cbiAgdmFyIGxhc3RNYXRjaCwgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoZmlsZURhdGEpKSBsYXN0TWF0Y2ggPSBtYXRjaDtcbiAgaWYgKCFsYXN0TWF0Y2gpIHJldHVybiBudWxsO1xuICByZXR1cm4gbGFzdE1hdGNoWzFdO1xufTtcblxuLy8gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHJldHJpZXZlU291cmNlTWFwIG9wdGlvbiB0byBpbnN0YWxsLiBUYWtlcyBhXG4vLyBnZW5lcmF0ZWQgc291cmNlIGZpbGVuYW1lOyByZXR1cm5zIGEge21hcCwgb3B0aW9uYWwgdXJsfSBvYmplY3QsIG9yIG51bGwgaWZcbi8vIHRoZXJlIGlzIG5vIHNvdXJjZSBtYXAuICBUaGUgbWFwIGZpZWxkIG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgdGhlIHBhcnNlZFxuLy8gSlNPTiBvYmplY3QgKGllLCBpdCBtdXN0IGJlIGEgdmFsaWQgYXJndW1lbnQgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyXG4vLyBjb25zdHJ1Y3RvcikuXG52YXIgcmV0cmlldmVTb3VyY2VNYXAgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZU1hcEhhbmRsZXJzKTtcbnJldHJpZXZlTWFwSGFuZGxlcnMucHVzaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZU1hcHBpbmdVUkwgPSByZXRyaWV2ZVNvdXJjZU1hcFVSTChzb3VyY2UpO1xuICBpZiAoIXNvdXJjZU1hcHBpbmdVUkwpIHJldHVybiBudWxsO1xuXG4gIC8vIFJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBzb3VyY2UgbWFwXG4gIHZhciBzb3VyY2VNYXBEYXRhO1xuICBpZiAocmVTb3VyY2VNYXAudGVzdChzb3VyY2VNYXBwaW5nVVJMKSkge1xuICAgIC8vIFN1cHBvcnQgc291cmNlIG1hcCBVUkwgYXMgYSBkYXRhIHVybFxuICAgIHZhciByYXdEYXRhID0gc291cmNlTWFwcGluZ1VSTC5zbGljZShzb3VyY2VNYXBwaW5nVVJMLmluZGV4T2YoJywnKSArIDEpO1xuICAgIHNvdXJjZU1hcERhdGEgPSBidWZmZXJGcm9tKHJhd0RhdGEsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gICAgc291cmNlTWFwcGluZ1VSTCA9IHNvdXJjZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMcyByZWxhdGl2ZSB0byB0aGUgc291cmNlIFVSTFxuICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBzdXBwb3J0UmVsYXRpdmVVUkwoc291cmNlLCBzb3VyY2VNYXBwaW5nVVJMKTtcbiAgICBzb3VyY2VNYXBEYXRhID0gcmV0cmlldmVGaWxlKHNvdXJjZU1hcHBpbmdVUkwpO1xuICB9XG5cbiAgaWYgKCFzb3VyY2VNYXBEYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVybDogc291cmNlTWFwcGluZ1VSTCxcbiAgICBtYXA6IHNvdXJjZU1hcERhdGFcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBtYXBTb3VyY2VQb3NpdGlvbihwb3NpdGlvbikge1xuICB2YXIgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXTtcbiAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAvLyBDYWxsIHRoZSAob3ZlcnJpZGVhYmxlKSByZXRyaWV2ZVNvdXJjZU1hcCBmdW5jdGlvbiB0byBnZXQgdGhlIHNvdXJjZSBtYXAuXG4gICAgdmFyIHVybEFuZE1hcCA9IHJldHJpZXZlU291cmNlTWFwKHBvc2l0aW9uLnNvdXJjZSk7XG4gICAgaWYgKHVybEFuZE1hcCkge1xuICAgICAgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXSA9IHtcbiAgICAgICAgdXJsOiB1cmxBbmRNYXAudXJsLFxuICAgICAgICBtYXA6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1cmxBbmRNYXAubWFwKVxuICAgICAgfTtcblxuICAgICAgLy8gTG9hZCBhbGwgc291cmNlcyBzdG9yZWQgaW5saW5lIHdpdGggdGhlIHNvdXJjZSBtYXAgaW50byB0aGUgZmlsZSBjYWNoZVxuICAgICAgLy8gdG8gcHJldGVuZCBsaWtlIHRoZXkgYXJlIGFscmVhZHkgbG9hZGVkLiBUaGV5IG1heSBub3QgZXhpc3Qgb24gZGlzay5cbiAgICAgIGlmIChzb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHNvdXJjZU1hcC5tYXAuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSwgaSkge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHNvdXJjZU1hcC5tYXAuc291cmNlc0NvbnRlbnRbaV07XG4gICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gc3VwcG9ydFJlbGF0aXZlVVJMKHNvdXJjZU1hcC51cmwsIHNvdXJjZSk7XG4gICAgICAgICAgICBmaWxlQ29udGVudHNDYWNoZVt1cmxdID0gY29udGVudHM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlTWFwID0gc291cmNlTWFwQ2FjaGVbcG9zaXRpb24uc291cmNlXSA9IHtcbiAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICBtYXA6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzb2x2ZSB0aGUgc291cmNlIFVSTCByZWxhdGl2ZSB0byB0aGUgVVJMIG9mIHRoZSBzb3VyY2UgbWFwXG4gIGlmIChzb3VyY2VNYXAgJiYgc291cmNlTWFwLm1hcCAmJiB0eXBlb2Ygc291cmNlTWFwLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG9yaWdpbmFsUG9zaXRpb24gPSBzb3VyY2VNYXAubWFwLm9yaWdpbmFsUG9zaXRpb25Gb3IocG9zaXRpb24pO1xuXG4gICAgLy8gT25seSByZXR1cm4gdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlmIGEgbWF0Y2hpbmcgbGluZSB3YXMgZm91bmQuIElmIG5vXG4gICAgLy8gbWF0Y2hpbmcgbGluZSBpcyBmb3VuZCB0aGVuIHdlIHJldHVybiBwb3NpdGlvbiBpbnN0ZWFkLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgLy8gdGhlIHN0YWNrIHRyYWNlIHRvIHByaW50IHRoZSBwYXRoIGFuZCBsaW5lIGZvciB0aGUgY29tcGlsZWQgZmlsZS4gSXQgaXNcbiAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSBhIHByZWNpc2UgbG9jYXRpb24gaW4gdGhlIGNvbXBpbGVkIGZpbGUgdGhhbiBhIHZhZ3VlXG4gICAgLy8gbG9jYXRpb24gaW4gdGhlIG9yaWdpbmFsIGZpbGUuXG4gICAgaWYgKG9yaWdpbmFsUG9zaXRpb24uc291cmNlICE9PSBudWxsKSB7XG4gICAgICBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSA9IHN1cHBvcnRSZWxhdGl2ZVVSTChcbiAgICAgICAgc291cmNlTWFwLnVybCwgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UpO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vLyBQYXJzZXMgY29kZSBnZW5lcmF0ZWQgYnkgRm9ybWF0RXZhbE9yaWdpbigpLCBhIGZ1bmN0aW9uIGluc2lkZSBWODpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanNcbmZ1bmN0aW9uIG1hcEV2YWxPcmlnaW4ob3JpZ2luKSB7XG4gIC8vIE1vc3QgZXZhbCgpIGNhbGxzIGFyZSBpbiB0aGlzIGZvcm1hdFxuICB2YXIgbWF0Y2ggPSAvXmV2YWwgYXQgKFteKF0rKSBcXCgoLispOihcXGQrKTooXFxkKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBwb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uKHtcbiAgICAgIHNvdXJjZTogbWF0Y2hbMl0sXG4gICAgICBsaW5lOiArbWF0Y2hbM10sXG4gICAgICBjb2x1bW46IG1hdGNoWzRdIC0gMVxuICAgIH0pO1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgcG9zaXRpb24uc291cmNlICsgJzonICtcbiAgICAgIHBvc2l0aW9uLmxpbmUgKyAnOicgKyAocG9zaXRpb24uY29sdW1uICsgMSkgKyAnKSc7XG4gIH1cblxuICAvLyBQYXJzZSBuZXN0ZWQgZXZhbCgpIGNhbGxzIHVzaW5nIHJlY3Vyc2lvblxuICBtYXRjaCA9IC9eZXZhbCBhdCAoW14oXSspIFxcKCguKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgbWFwRXZhbE9yaWdpbihtYXRjaFsyXSkgKyAnKSc7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2Ugc3RpbGwgcmV0dXJuIHVzZWZ1bCBpbmZvcm1hdGlvbiBpZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZ1xuICByZXR1cm4gb3JpZ2luO1xufVxuXG4vLyBUaGlzIGlzIGNvcGllZCBhbG1vc3QgdmVyYmF0aW0gZnJvbSB0aGUgVjggc291cmNlIGNvZGUgYXRcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanMuIFRoZVxuLy8gaW1wbGVtZW50YXRpb24gb2Ygd3JhcENhbGxTaXRlKCkgdXNlZCB0byBqdXN0IGZvcndhcmQgdG8gdGhlIGFjdHVhbCBzb3VyY2Vcbi8vIGNvZGUgb2YgQ2FsbFNpdGUucHJvdG90eXBlLnRvU3RyaW5nIGJ1dCB1bmZvcnR1bmF0ZWx5IGEgbmV3IHJlbGVhc2Ugb2YgVjhcbi8vIGRpZCBzb21ldGhpbmcgdG8gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgYnJva2UgdGhlIHNoaW0uIFRoZSBvbmx5IGZpeCBJXG4vLyBjb3VsZCBmaW5kIHdhcyBjb3B5L3Bhc3RlLlxuZnVuY3Rpb24gQ2FsbFNpdGVUb1N0cmluZygpIHtcbiAgdmFyIGZpbGVOYW1lO1xuICB2YXIgZmlsZUxvY2F0aW9uID0gXCJcIjtcbiAgaWYgKHRoaXMuaXNOYXRpdmUoKSkge1xuICAgIGZpbGVMb2NhdGlvbiA9IFwibmF0aXZlXCI7XG4gIH0gZWxzZSB7XG4gICAgZmlsZU5hbWUgPSB0aGlzLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICAgIGlmICghZmlsZU5hbWUgJiYgdGhpcy5pc0V2YWwoKSkge1xuICAgICAgZmlsZUxvY2F0aW9uID0gdGhpcy5nZXRFdmFsT3JpZ2luKCk7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCIsIFwiOyAgLy8gRXhwZWN0aW5nIHNvdXJjZSBwb3NpdGlvbiB0byBmb2xsb3cuXG4gICAgfVxuXG4gICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gZmlsZU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvdXJjZSBjb2RlIGRvZXMgbm90IG9yaWdpbmF0ZSBmcm9tIGEgZmlsZSBhbmQgaXMgbm90IG5hdGl2ZSwgYnV0IHdlXG4gICAgICAvLyBjYW4gc3RpbGwgZ2V0IHRoZSBzb3VyY2UgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2Ugc3RyaW5nLCBlLmcuIGluXG4gICAgICAvLyBhbiBldmFsIHN0cmluZy5cbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjxhbm9ueW1vdXM+XCI7XG4gICAgfVxuICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCk7XG4gICAgaWYgKGxpbmVOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgZmlsZUxvY2F0aW9uICs9IFwiOlwiICsgbGluZU51bWJlcjtcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpO1xuICAgICAgaWYgKGNvbHVtbk51bWJlcikge1xuICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBjb2x1bW5OdW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpbmUgPSBcIlwiO1xuICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgdmFyIGFkZFN1ZmZpeCA9IHRydWU7XG4gIHZhciBpc0NvbnN0cnVjdG9yID0gdGhpcy5pc0NvbnN0cnVjdG9yKCk7XG4gIHZhciBpc01ldGhvZENhbGwgPSAhKHRoaXMuaXNUb3BsZXZlbCgpIHx8IGlzQ29uc3RydWN0b3IpO1xuICBpZiAoaXNNZXRob2RDYWxsKSB7XG4gICAgdmFyIHR5cGVOYW1lID0gdGhpcy5nZXRUeXBlTmFtZSgpO1xuICAgIC8vIEZpeGVzIHNoaW0gdG8gYmUgYmFja3dhcmQgY29tcGF0YWJsZSB3aXRoIE5vZGUgdjAgdG8gdjRcbiAgICBpZiAodHlwZU5hbWUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgIHR5cGVOYW1lID0gXCJudWxsXCI7XG4gICAgfVxuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5nZXRNZXRob2ROYW1lKCk7XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgaWYgKHR5cGVOYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKHR5cGVOYW1lKSAhPSAwKSB7XG4gICAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICAgICAgaWYgKG1ldGhvZE5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YoXCIuXCIgKyBtZXRob2ROYW1lKSAhPSBmdW5jdGlvbk5hbWUubGVuZ3RoIC0gbWV0aG9kTmFtZS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGxpbmUgKz0gXCIgW2FzIFwiICsgbWV0aG9kTmFtZSArIFwiXVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IHR5cGVOYW1lICsgXCIuXCIgKyAobWV0aG9kTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NvbnN0cnVjdG9yKSB7XG4gICAgbGluZSArPSBcIm5ldyBcIiArIChmdW5jdGlvbk5hbWUgfHwgXCI8YW5vbnltb3VzPlwiKTtcbiAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICBsaW5lICs9IGZ1bmN0aW9uTmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lICs9IGZpbGVMb2NhdGlvbjtcbiAgICBhZGRTdWZmaXggPSBmYWxzZTtcbiAgfVxuICBpZiAoYWRkU3VmZml4KSB7XG4gICAgbGluZSArPSBcIiAoXCIgKyBmaWxlTG9jYXRpb24gKyBcIilcIjtcbiAgfVxuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDYWxsU2l0ZShmcmFtZSkge1xuICB2YXIgb2JqZWN0ID0ge307XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihmcmFtZSkpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIG9iamVjdFtuYW1lXSA9IC9eKD86aXN8Z2V0KS8udGVzdChuYW1lKSA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJhbWVbbmFtZV0uY2FsbChmcmFtZSk7IH0gOiBmcmFtZVtuYW1lXTtcbiAgfSk7XG4gIG9iamVjdC50b1N0cmluZyA9IENhbGxTaXRlVG9TdHJpbmc7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHdyYXBDYWxsU2l0ZShmcmFtZSwgc3RhdGUpIHtcbiAgLy8gcHJvdmlkZXMgaW50ZXJmYWNlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZSA9IHsgbmV4dFBvc2l0aW9uOiBudWxsLCBjdXJQb3NpdGlvbjogbnVsbCB9XG4gIH1cbiAgaWYoZnJhbWUuaXNOYXRpdmUoKSkge1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gbnVsbDtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBNb3N0IGNhbGwgc2l0ZXMgd2lsbCByZXR1cm4gdGhlIHNvdXJjZSBmaWxlIGZyb20gZ2V0RmlsZU5hbWUoKSwgYnV0IGNvZGVcbiAgLy8gcGFzc2VkIHRvIGV2YWwoKSBlbmRpbmcgaW4gXCIvLyMgc291cmNlVVJMPS4uLlwiIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZVxuICAvLyBmcm9tIGdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGluc3RlYWRcbiAgdmFyIHNvdXJjZSA9IGZyYW1lLmdldEZpbGVOYW1lKCkgfHwgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7XG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgbGluZSA9IGZyYW1lLmdldExpbmVOdW1iZXIoKTtcbiAgICB2YXIgY29sdW1uID0gZnJhbWUuZ2V0Q29sdW1uTnVtYmVyKCkgLSAxO1xuXG4gICAgLy8gRml4IHBvc2l0aW9uIGluIE5vZGUgd2hlcmUgc29tZSAoaW50ZXJuYWwpIGNvZGUgaXMgcHJlcGVuZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvaXNzdWVzLzM2XG4gICAgLy8gSGVhZGVyIHJlbW92ZWQgaW4gbm9kZSBhdCBeMTAuMTYgfHwgPj0xMS4xMS4wXG4gICAgLy8gdjExIGlzIG5vdCBhbiBMVFMgY2FuZGlkYXRlLCB3ZSBjYW4ganVzdCB0ZXN0IHRoZSBvbmUgdmVyc2lvbiB3aXRoIGl0LlxuICAgIC8vIFRlc3Qgbm9kZSB2ZXJzaW9ucyBmb3I6IDEwLjE2LTE5LCAxMC4yMCssIDEyLTE5LCAyMC05OSwgMTAwKywgb3IgMTEuMTFcbiAgICB2YXIgbm9IZWFkZXIgPSAvXnYoMTBcXC4xWzYtOV18MTBcXC5bMi05XVswLTldfDEwXFwuWzAtOV17Myx9fDFbMi05XVxcZCp8WzItOV1cXGR8XFxkezMsfXwxMVxcLjExKS87XG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IG5vSGVhZGVyLnRlc3QoZ2xvYmFsUHJvY2Vzc1ZlcnNpb24oKSkgPyAwIDogNjI7XG4gICAgaWYgKGxpbmUgPT09IDEgJiYgY29sdW1uID4gaGVhZGVyTGVuZ3RoICYmICFpc0luQnJvd3NlcigpICYmICFmcmFtZS5pc0V2YWwoKSkge1xuICAgICAgY29sdW1uIC09IGhlYWRlckxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBtYXBTb3VyY2VQb3NpdGlvbih7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGxpbmU6IGxpbmUsXG4gICAgICBjb2x1bW46IGNvbHVtblxuICAgIH0pO1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgZnJhbWUgPSBjbG9uZUNhbGxTaXRlKGZyYW1lKTtcbiAgICB2YXIgb3JpZ2luYWxGdW5jdGlvbk5hbWUgPSBmcmFtZS5nZXRGdW5jdGlvbk5hbWU7XG4gICAgZnJhbWUuZ2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhdGUubmV4dFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25OYW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUubmV4dFBvc2l0aW9uLm5hbWUgfHwgb3JpZ2luYWxGdW5jdGlvbk5hbWUoKTtcbiAgICB9O1xuICAgIGZyYW1lLmdldEZpbGVOYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgZnJhbWUuZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24ubGluZTsgfTtcbiAgICBmcmFtZS5nZXRDb2x1bW5OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmNvbHVtbiArIDE7IH07XG4gICAgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gQ29kZSBjYWxsZWQgdXNpbmcgZXZhbCgpIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgdmFyIG9yaWdpbiA9IGZyYW1lLmlzRXZhbCgpICYmIGZyYW1lLmdldEV2YWxPcmlnaW4oKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IG1hcEV2YWxPcmlnaW4ob3JpZ2luKTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEV2YWxPcmlnaW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbjsgfTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHdlIHdlcmUgdW5hYmxlIHRvIGNoYW5nZSB0aGUgc291cmNlIHBvc2l0aW9uXG4gIHJldHVybiBmcmFtZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHRoZSBWOCBzdGFjayB0cmFjZSBBUEksIGZvciBtb3JlIGluZm8gc2VlOlxuLy8gaHR0cHM6Ly92OC5kZXYvZG9jcy9zdGFjay10cmFjZS1hcGlcbmZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBzdGFjaykge1xuICBpZiAoZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcbiAgICBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIG5hbWUgPSBlcnJvci5uYW1lIHx8ICdFcnJvcic7XG4gIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgdmFyIGVycm9yU3RyaW5nID0gbmFtZSArIFwiOiBcIiArIG1lc3NhZ2U7XG5cbiAgdmFyIHN0YXRlID0geyBuZXh0UG9zaXRpb246IG51bGwsIGN1clBvc2l0aW9uOiBudWxsIH07XG4gIHZhciBwcm9jZXNzZWRTdGFjayA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwcm9jZXNzZWRTdGFjay5wdXNoKCdcXG4gICAgYXQgJyArIHdyYXBDYWxsU2l0ZShzdGFja1tpXSwgc3RhdGUpKTtcbiAgICBzdGF0ZS5uZXh0UG9zaXRpb24gPSBzdGF0ZS5jdXJQb3NpdGlvbjtcbiAgfVxuICBzdGF0ZS5jdXJQb3NpdGlvbiA9IHN0YXRlLm5leHRQb3NpdGlvbiA9IG51bGw7XG4gIHJldHVybiBlcnJvclN0cmluZyArIHByb2Nlc3NlZFN0YWNrLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cblxuLy8gR2VuZXJhdGUgcG9zaXRpb24gYW5kIHNuaXBwZXQgb2Ygb3JpZ2luYWwgc291cmNlIHdpdGggcG9pbnRlclxuZnVuY3Rpb24gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpIHtcbiAgdmFyIG1hdGNoID0gL1xcbiAgICBhdCBbXihdKyBcXCgoLiopOihcXGQrKTooXFxkKylcXCkvLmV4ZWMoZXJyb3Iuc3RhY2spO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgc291cmNlID0gbWF0Y2hbMV07XG4gICAgdmFyIGxpbmUgPSArbWF0Y2hbMl07XG4gICAgdmFyIGNvbHVtbiA9ICttYXRjaFszXTtcblxuICAgIC8vIFN1cHBvcnQgdGhlIGlubGluZSBzb3VyY2VDb250ZW50cyBpbnNpZGUgdGhlIHNvdXJjZSBtYXBcbiAgICB2YXIgY29udGVudHMgPSBmaWxlQ29udGVudHNDYWNoZVtzb3VyY2VdO1xuXG4gICAgLy8gU3VwcG9ydCBmaWxlcyBvbiBkaXNrXG4gICAgaWYgKCFjb250ZW50cyAmJiBmcyAmJiBmcy5leGlzdHNTeW5jKHNvdXJjZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnRlbnRzID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlIGxpa2Ugbm9kZSBkb2VzXG4gICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICB2YXIgY29kZSA9IGNvbnRlbnRzLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKVtsaW5lIC0gMV07XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICByZXR1cm4gc291cmNlICsgJzonICsgbGluZSArICdcXG4nICsgY29kZSArICdcXG4nICtcbiAgICAgICAgICBuZXcgQXJyYXkoY29sdW1uKS5qb2luKCcgJykgKyAnXic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwcmludEVycm9yQW5kRXhpdCAoZXJyb3IpIHtcbiAgdmFyIHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKTtcblxuICAvLyBFbnN1cmUgZXJyb3IgaXMgcHJpbnRlZCBzeW5jaHJvbm91c2x5IGFuZCBub3QgdHJ1bmNhdGVkXG4gIHZhciBzdGRlcnIgPSBnbG9iYWxQcm9jZXNzU3RkZXJyKCk7XG4gIGlmIChzdGRlcnIgJiYgc3RkZXJyLl9oYW5kbGUgJiYgc3RkZXJyLl9oYW5kbGUuc2V0QmxvY2tpbmcpIHtcbiAgICBzdGRlcnIuX2hhbmRsZS5zZXRCbG9ja2luZyh0cnVlKTtcbiAgfVxuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBjb25zb2xlLmVycm9yKCk7XG4gICAgY29uc29sZS5lcnJvcihzb3VyY2UpO1xuICB9XG5cbiAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XG4gIGdsb2JhbFByb2Nlc3NFeGl0KDEpO1xufVxuXG5mdW5jdGlvbiBzaGltRW1pdFVuY2F1Z2h0RXhjZXB0aW9uICgpIHtcbiAgdmFyIG9yaWdFbWl0ID0gcHJvY2Vzcy5lbWl0O1xuXG4gIHByb2Nlc3MuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICAgIHZhciBoYXNTdGFjayA9IChhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnN0YWNrKTtcbiAgICAgIHZhciBoYXNMaXN0ZW5lcnMgPSAodGhpcy5saXN0ZW5lcnModHlwZSkubGVuZ3RoID4gMCk7XG5cbiAgICAgIGlmIChoYXNTdGFjayAmJiAhaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBwcmludEVycm9yQW5kRXhpdChhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmlnRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycyA9IHJldHJpZXZlRmlsZUhhbmRsZXJzLnNsaWNlKDApO1xudmFyIG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycyA9IHJldHJpZXZlTWFwSGFuZGxlcnMuc2xpY2UoMCk7XG5cbmV4cG9ydHMud3JhcENhbGxTaXRlID0gd3JhcENhbGxTaXRlO1xuZXhwb3J0cy5nZXRFcnJvclNvdXJjZSA9IGdldEVycm9yU291cmNlO1xuZXhwb3J0cy5tYXBTb3VyY2VQb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uO1xuZXhwb3J0cy5yZXRyaWV2ZVNvdXJjZU1hcCA9IHJldHJpZXZlU291cmNlTWFwO1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50O1xuICAgIGlmIChbXCJub2RlXCIsIFwiYnJvd3NlclwiLCBcImF1dG9cIl0uaW5kZXhPZihlbnZpcm9ubWVudCkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnZpcm9ubWVudCBcIiArIGVudmlyb25tZW50ICsgXCIgd2FzIHVua25vd24uIEF2YWlsYWJsZSBvcHRpb25zIGFyZSB7YXV0bywgYnJvd3Nlciwgbm9kZX1cIilcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2VzIHRvIGJlIGZvdW5kIGJ5IG1ldGhvZHMgb3RoZXIgdGhhbiByZWFkaW5nIHRoZSBmaWxlc1xuICAvLyBkaXJlY3RseSBmcm9tIGRpc2suXG4gIGlmIChvcHRpb25zLnJldHJpZXZlRmlsZSkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVGaWxlKSB7XG4gICAgICByZXRyaWV2ZUZpbGVIYW5kbGVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZUZpbGUpO1xuICB9XG5cbiAgLy8gQWxsb3cgc291cmNlIG1hcHMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZVJldHJpZXZlU291cmNlTWFwKSB7XG4gICAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVNYXBIYW5kbGVycy51bnNoaWZ0KG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBydW50aW1lIHRyYW5zcGlsZXJzIHRoYXQgaW5jbHVkZSBpbmxpbmUgc291cmNlIG1hcHNcbiAgaWYgKG9wdGlvbnMuaG9va1JlcXVpcmUgJiYgIWlzSW5Ccm93c2VyKCkpIHtcbiAgICAvLyBVc2UgZHluYW1pY1JlcXVpcmUgdG8gYXZvaWQgaW5jbHVkaW5nIGluIGJyb3dzZXIgYnVuZGxlc1xuICAgIHZhciBNb2R1bGUgPSBkeW5hbWljUmVxdWlyZShtb2R1bGUsICdtb2R1bGUnKTtcbiAgICB2YXIgJGNvbXBpbGUgPSBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlO1xuXG4gICAgaWYgKCEkY29tcGlsZS5fX3NvdXJjZU1hcFN1cHBvcnQpIHtcbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbihjb250ZW50LCBmaWxlbmFtZSkge1xuICAgICAgICBmaWxlQ29udGVudHNDYWNoZVtmaWxlbmFtZV0gPSBjb250ZW50O1xuICAgICAgICBzb3VyY2VNYXBDYWNoZVtmaWxlbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAkY29tcGlsZS5jYWxsKHRoaXMsIGNvbnRlbnQsIGZpbGVuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUuX19zb3VyY2VNYXBTdXBwb3J0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDb25maWd1cmUgb3B0aW9uc1xuICBpZiAoIWVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucykge1xuICAgIGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA9ICdlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy5lbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgOiBmYWxzZTtcbiAgfVxuXG4gIC8vIEluc3RhbGwgdGhlIGVycm9yIHJlZm9ybWF0dGVyXG4gIGlmICghZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQpIHtcbiAgICBlcnJvckZvcm1hdHRlckluc3RhbGxlZCA9IHRydWU7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgfVxuXG4gIGlmICghdW5jYXVnaHRTaGltSW5zdGFsbGVkKSB7XG4gICAgdmFyIGluc3RhbGxIYW5kbGVyID0gJ2hhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucycgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucyA6IHRydWU7XG5cbiAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgJ3VuY2F1Z2h0RXhjZXB0aW9uJyB3aXRoIG91ciBvd24gaGFuZGxlciBpbiBOb2RlLmpzXG4gICAgLy8gV29ya2VyIHRocmVhZHMuIFdvcmtlcnMgcGFzcyB0aGUgZXJyb3IgdG8gdGhlIG1haW4gdGhyZWFkIGFzIGFuIGV2ZW50LFxuICAgIC8vIHJhdGhlciB0aGFuIHByaW50aW5nIHNvbWV0aGluZyB0byBzdGRlcnIgYW5kIGV4aXRpbmcuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGBkeW5hbWljUmVxdWlyZWAgYmVjYXVzZSBgcmVxdWlyZWAgb24gaXQncyBvd24gd2lsbCBiZSBvcHRpbWl6ZWQgYnkgV2ViUGFjay9Ccm93c2VyaWZ5LlxuICAgICAgdmFyIHdvcmtlcl90aHJlYWRzID0gZHluYW1pY1JlcXVpcmUobW9kdWxlLCAnd29ya2VyX3RocmVhZHMnKTtcbiAgICAgIGlmICh3b3JrZXJfdGhyZWFkcy5pc01haW5UaHJlYWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc3RhbGxIYW5kbGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7fVxuXG4gICAgLy8gUHJvdmlkZSB0aGUgb3B0aW9uIHRvIG5vdCBpbnN0YWxsIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlci4gVGhpcyBpc1xuICAgIC8vIHRvIHN1cHBvcnQgb3RoZXIgdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJzIChpbiB0ZXN0IGZyYW1ld29ya3MsIGZvclxuICAgIC8vIGV4YW1wbGUpLiBJZiB0aGlzIGhhbmRsZXIgaXMgbm90IGluc3RhbGxlZCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHVuY2F1Z2h0XG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIHdpbGwgYmUgY2F1Z2h0IGJ5IG5vZGUncyBidWlsdC1pblxuICAgIC8vIGV4Y2VwdGlvbiBoYW5kbGVyIGFuZCB0aGUgcHJvY2VzcyB3aWxsIHN0aWxsIGJlIHRlcm1pbmF0ZWQuIEhvd2V2ZXIsIHRoZVxuICAgIC8vIGdlbmVyYXRlZCBKYXZhU2NyaXB0IGNvZGUgd2lsbCBiZSBzaG93biBhYm92ZSB0aGUgc3RhY2sgdHJhY2UgaW5zdGVhZCBvZlxuICAgIC8vIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICBpZiAoaW5zdGFsbEhhbmRsZXIgJiYgaGFzR2xvYmFsUHJvY2Vzc0V2ZW50RW1pdHRlcigpKSB7XG4gICAgICB1bmNhdWdodFNoaW1JbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgc2hpbUVtaXRVbmNhdWdodEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5yZXNldFJldHJpZXZlSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0cmlldmVGaWxlSGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgcmV0cmlldmVNYXBIYW5kbGVycy5sZW5ndGggPSAwO1xuXG4gIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycy5zbGljZSgwKTtcbiAgcmV0cmlldmVNYXBIYW5kbGVycyA9IG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycy5zbGljZSgwKTtcblxuICByZXRyaWV2ZVNvdXJjZU1hcCA9IGhhbmRsZXJFeGVjKHJldHJpZXZlTWFwSGFuZGxlcnMpO1xuICByZXRyaWV2ZUZpbGUgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZUZpbGVIYW5kbGVycyk7XG59XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbmV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAvL1xuICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAvL1xuICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gIC8vICAgICAgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50LlxuICAvL1xuICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIHJldHVybiBtaWQ7XG4gIH1cbiAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICpcbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKi9cbmV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgLy8gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgc3VjaFxuICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgIGlmIChhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLCBhSGF5c3RhY2tbaW5kZXggLSAxXSwgdHJ1ZSkgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAtLWluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTCh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KGFTb3VyY2UpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IHJlbGF0aXZlU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyByZWxhdGl2ZVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTtcbiAgICBpZiAoc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpLCBhU291cmNlTWFwVVJMKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4gXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuX2ZpbmRTb3VyY2VJbmRleCh1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgc291cmNlUmVsYXRpdmUgPSBzb3VyY2VGaWxlO1xuICAgICAgaWYgKHNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc291cmNlUmVsYXRpdmUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdlbmVyYXRvci5fc291cmNlcy5oYXMoc291cmNlUmVsYXRpdmUpKSB7XG4gICAgICAgIGdlbmVyYXRvci5fc291cmNlcy5hZGQoc291cmNlUmVsYXRpdmUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIC8vIFdoZW4gYU9yaWdpbmFsIGlzIHRydXRoeSBidXQgaGFzIGVtcHR5IHZhbHVlcyBmb3IgLmxpbmUgYW5kIC5jb2x1bW4sXG4gICAgLy8gaXQgaXMgbW9zdCBsaWtlbHkgYSBwcm9ncmFtbWVyIGVycm9yLiBJbiB0aGlzIGNhc2Ugd2UgdGhyb3cgYSB2ZXJ5XG4gICAgLy8gc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0byB0cnkgdG8gZ3VpZGUgdGhlbSB0aGUgcmlnaHQgd2F5LlxuICAgIC8vIEZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyLWJ1bmRsZXIvcHVsbC81MTlcbiAgICBpZiAoYU9yaWdpbmFsICYmIHR5cGVvZiBhT3JpZ2luYWwubGluZSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGFPcmlnaW5hbC5jb2x1bW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvcmlnaW5hbC5saW5lIGFuZCBvcmlnaW5hbC5jb2x1bW4gYXJlIG5vdCBudW1iZXJzIC0tIHlvdSBwcm9iYWJseSBtZWFudCB0byBvbWl0ICcgK1xuICAgICAgICAgICAgJ3RoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyAnICtcbiAgICAgICAgICAgICdudWxsIGZvciB0aGUgb3JpZ2luYWwgbWFwcGluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGVtcHR5IG9yIG51bGwgdmFsdWVzLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciByZW1haW5pbmdMaW5lc0luZGV4ID0gMDtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IGdldE5leHRMaW5lKCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuXG4gICAgICBmdW5jdGlvbiBnZXROZXh0TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGggP1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gIH1cbn1cbmV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG52YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy4tXSopKD86OihcXGQrKSk/KC4qKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCB1cmxSZWdleHAudGVzdChhUGF0aCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxOyAvLyBhU3RyMiAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBhU3RyMSAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG4vKipcbiAqIFN0cmlwIGFueSBKU09OIFhTU0kgYXZvaWRhbmNlIHByZWZpeCBmcm9tIHRoZSBzdHJpbmcgKGFzIGRvY3VtZW50ZWRcbiAqIGluIHRoZSBzb3VyY2UgbWFwcyBzcGVjaWZpY2F0aW9uKSwgYW5kIHRoZW4gcGFyc2UgdGhlIHN0cmluZyBhc1xuICogSlNPTi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTb3VyY2VNYXBJbnB1dChzdHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLnJlcGxhY2UoL15cXCldfSdbXlxcbl0qXFxuLywgJycpKTtcbn1cbmV4cG9ydHMucGFyc2VTb3VyY2VNYXBJbnB1dCA9IHBhcnNlU291cmNlTWFwSW5wdXQ7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgVVJMIG9mIGEgc291cmNlIGdpdmVuIHRoZSB0aGUgc291cmNlIHJvb3QsIHRoZSBzb3VyY2Unc1xuICogVVJMLCBhbmQgdGhlIHNvdXJjZSBtYXAncyBVUkwuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpIHtcbiAgc291cmNlVVJMID0gc291cmNlVVJMIHx8ICcnO1xuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgLy8gVGhpcyBmb2xsb3dzIHdoYXQgQ2hyb21lIGRvZXMuXG4gICAgaWYgKHNvdXJjZVJvb3Rbc291cmNlUm9vdC5sZW5ndGggLSAxXSAhPT0gJy8nICYmIHNvdXJjZVVSTFswXSAhPT0gJy8nKSB7XG4gICAgICBzb3VyY2VSb290ICs9ICcvJztcbiAgICB9XG4gICAgLy8gVGhlIHNwZWMgc2F5czpcbiAgICAvLyAgIExpbmUgNDogQW4gb3B0aW9uYWwgc291cmNlIHJvb3QsIHVzZWZ1bCBmb3IgcmVsb2NhdGluZyBzb3VyY2VcbiAgICAvLyAgIGZpbGVzIG9uIGEgc2VydmVyIG9yIHJlbW92aW5nIHJlcGVhdGVkIHZhbHVlcyBpbiB0aGVcbiAgICAvLyAgIOKAnHNvdXJjZXPigJ0gZW50cnkuICBUaGlzIHZhbHVlIGlzIHByZXBlbmRlZCB0byB0aGUgaW5kaXZpZHVhbFxuICAgIC8vICAgZW50cmllcyBpbiB0aGUg4oCcc291cmNl4oCdIGZpZWxkLlxuICAgIHNvdXJjZVVSTCA9IHNvdXJjZVJvb3QgKyBzb3VyY2VVUkw7XG4gIH1cblxuICAvLyBIaXN0b3JpY2FsbHksIFNvdXJjZU1hcENvbnN1bWVyIGRpZCBub3QgdGFrZSB0aGUgc291cmNlTWFwVVJMIGFzXG4gIC8vIGEgcGFyYW1ldGVyLiAgVGhpcyBtb2RlIGlzIHN0aWxsIHNvbWV3aGF0IHN1cHBvcnRlZCwgd2hpY2ggaXMgd2h5XG4gIC8vIHRoaXMgY29kZSBibG9jayBpcyBjb25kaXRpb25hbC4gIEhvd2V2ZXIsIGl0J3MgcHJlZmVyYWJsZSB0byBwYXNzXG4gIC8vIHRoZSBzb3VyY2UgbWFwIFVSTCB0byBTb3VyY2VNYXBDb25zdW1lciwgc28gdGhhdCB0aGlzIGZ1bmN0aW9uXG4gIC8vIGNhbiBpbXBsZW1lbnQgdGhlIHNvdXJjZSBVUkwgcmVzb2x1dGlvbiBhbGdvcml0aG0gYXMgb3V0bGluZWQgaW5cbiAgLy8gdGhlIHNwZWMuICBUaGlzIGJsb2NrIGlzIGJhc2ljYWxseSB0aGUgZXF1aXZhbGVudCBvZjpcbiAgLy8gICAgbmV3IFVSTChzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkudG9TdHJpbmcoKVxuICAvLyAuLi4gZXhjZXB0IGl0IGF2b2lkcyB1c2luZyBVUkwsIHdoaWNoIHdhc24ndCBhdmFpbGFibGUgaW4gdGhlXG4gIC8vIG9sZGVyIHJlbGVhc2VzIG9mIG5vZGUgc3RpbGwgc3VwcG9ydGVkIGJ5IHRoaXMgbGlicmFyeS5cbiAgLy9cbiAgLy8gVGhlIHNwZWMgc2F5czpcbiAgLy8gICBJZiB0aGUgc291cmNlcyBhcmUgbm90IGFic29sdXRlIFVSTHMgYWZ0ZXIgcHJlcGVuZGluZyBvZiB0aGVcbiAgLy8gICDigJxzb3VyY2VSb2904oCdLCB0aGUgc291cmNlcyBhcmUgcmVzb2x2ZWQgcmVsYXRpdmUgdG8gdGhlXG4gIC8vICAgU291cmNlTWFwIChsaWtlIHJlc29sdmluZyBzY3JpcHQgc3JjIGluIGEgaHRtbCBkb2N1bWVudCkuXG4gIGlmIChzb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgcGFyc2VkID0gdXJsUGFyc2Uoc291cmNlTWFwVVJMKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic291cmNlTWFwVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWRcIik7XG4gICAgfVxuICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgLy8gU3RyaXAgdGhlIGxhc3QgcGF0aCBjb21wb25lbnQsIGJ1dCBrZWVwIHRoZSBcIi9cIi5cbiAgICAgIHZhciBpbmRleCA9IHBhcnNlZC5wYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IHBhcnNlZC5wYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VVUkwgPSBqb2luKHVybEdlbmVyYXRlKHBhcnNlZCksIHNvdXJjZVVSTCk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplKHNvdXJjZVVSTCk7XG59XG5leHBvcnRzLmNvbXB1dGVTb3VyY2VVUkwgPSBjb21wdXRlU291cmNlVVJMO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9hcHAuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5vcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYXBwLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIi8vIFNRTGl0ZSDjg6Ljgrjjg6Xjg7zjg6vjgpLjgqTjg7Pjg53jg7zjg4hcbmltcG9ydCB7IGRlZmF1bHQgYXMgaW5pdCB9IGZyb20gJ0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtJztcbmltcG9ydCAqIGFzIHNvdXJjZU1hcFN1cHBvcnQgZnJvbSAnc291cmNlLW1hcC1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgc3BsaXRRdWVyeSwgc3FsaXRlU3BsaXR0ZXJPcHRpb25zIH0gZnJvbSAnZGJnYXRlLXF1ZXJ5LXNwbGl0dGVyJztcblxuLy/jg4fjg5Djg4PjgrDnlKjjga5zb3VyY2VNYXDoqK3lrppcbnNvdXJjZU1hcFN1cHBvcnQuaW5zdGFsbCgpO1xuXG5jbGFzcyBTUUxpdGVNYW5hZ2VyIHtcbiAgc3RhdGljIGFzeW5jIGluaXRpYWxpemUoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gU1FMaXRlIOODouOCuOODpeODvOODq+OCkuWIneacn+WMllxuICAgIC8vIEVuc3VyZSBnbG9iYWwud2luZG93IGlzIHNldCB0byBzaW11bGF0ZSBicm93c2VyIGVudmlyb25tZW50IGZvciB3YXNtXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSBnbG9iYWwud2luZG93ID0ge307XG4gICAgLy8gRHluYW1pY2FsbHkgaW1wb3J0IHNxbGl0ZTMgd2FzbSBtb2R1bGUgb24gZmlyc3QgY2FsbFxuICAgIGxldCBzcWxpdGUzID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5lbnYgPT09ICdub2RlJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gbm9kZS5qc+eSsOWig1xuICAgICAgLy8gTG9hZCBzcWxpdGUzLndhc20gZnJvbSBkaXN0IG9yIHBrZyBvdXRwdXQgZGlyZWN0b3J5XG4gICAgICBjb25zdCBpc1BrZyA9IHByb2Nlc3MucGtnICE9PSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCB3YXNtUGF0aCA9IGlzUGtnXG4gICAgICAgID8gcGF0aC5qb2luKHBhdGguZGlybmFtZShwcm9jZXNzLmV4ZWNQYXRoKSwgJ3NxbGl0ZTMud2FzbScpXG4gICAgICAgIDogcGF0aC5qb2luKF9fZGlybmFtZSwgJ3NxbGl0ZTMud2FzbScpO1xuICAgICAgICAvL3BhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGlzdCcsICdzcWxpdGUzLndhc20nKTtcbiAgICAgIGNvbnN0IHdhc21CaW5hcnkgPSBmcy5yZWFkRmlsZVN5bmMod2FzbVBhdGgpO1xuICAgICAgLy8gSW5pdGlhbGl6ZSB3YXNtIG1vZHVsZVxuICAgICAgc3FsaXRlMyA9IGF3YWl0IGluaXQoe1xuICAgICAgICBwcmludDogb3B0aW9ucy5wcmludCB8fCAoKCkgPT4geyB9KSxcbiAgICAgICAgcHJpbnRFcnI6IG9wdGlvbnMucHJpbnRFcnIgfHwgKCgpID0+IHsgfSksXG4gICAgICAgIHdhc21CaW5hcnksXG4gICAgICAgIGluc3RhbnRpYXRlV2FzbTogKGltcG9ydHMsIHN1Y2Nlc3NDYWxsYmFjaykgPT4ge1xuICAgICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21CaW5hcnksIGltcG9ydHMpXG4gICAgICAgICAgICAudGhlbigoeyBpbnN0YW5jZSwgbW9kdWxlIH0pID0+IHN1Y2Nlc3NDYWxsYmFjayhpbnN0YW5jZSwgbW9kdWxlKSk7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgeyAvLyDjg5bjg6njgqbjgrbnkrDlooNcbiAgICAgICAgc3FsaXRlMyA9IGF3YWl0IGluaXQoe1xuICAgICAgICAgICAgcHJpbnQ6IG9wdGlvbnMucHJpbnQgfHwgKCgpID0+IHsgfSksXG4gICAgICAgICAgICBwcmludEVycjogb3B0aW9ucy5wcmludEVyciB8fCAoKCkgPT4geyB9KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAgICAgY29uc3Qgc3FsaXRlM19pbnN0YW5jZSA9IG5ldyBTUUxpdGVNYW5hZ2VyKHNxbGl0ZTMsIG9wdGlvbnMpO1xuICAgICAgICBhd2FpdCBzcWxpdGUzX2luc3RhbmNlLnNldHVwRW52aXJvbm1lbnQoZGF0YSk7XG4gICAgICAgIHJldHVybiBzcWxpdGUzX2luc3RhbmNlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHNxbGl0ZTMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnByaW50ID0gb3B0aW9ucy5wcmludCB8fCAoKCkgPT4geyB9KTtcbiAgICAgICAgdGhpcy5wcmludEVyciA9IG9wdGlvbnMucHJpbnRFcnIgfHwgKCgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMuc3FsaXRlMyA9IHNxbGl0ZTM7XG4gICAgICAgIHRoaXMub3JpZ2luYWwgPSB7IGRiOiB7fSB9O1xuICAgICAgICB0aGlzLmRiID0gbnVsbDtcbiAgICB9XG5cbiAgICBhc3luYyBzZXR1cEVudmlyb25tZW50KGRhdGEpIHtcbiAgICAgICAgLy8g44OV44Kh44Kk44Or5ZCN55Sf5oiQXG4gICAgICAgIHRoaXMuY3VycmVudEZpbGVuYW1lID0gXCJkYmZpbGVfXCIgKyAoMHhmZmZmZmZmZiAqIE1hdGgucmFuZG9tKCkgPj4+IDApO1xuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBWRlPjgpLkvb/nlKjjgZfjgabjg4fjg7zjgr/jgpLjgqTjg7Pjg53jg7zjg4hcbiAgICAgICAgICAgIHRoaXMuc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKFxuICAgICAgICAgICAgICAgICd1bml4JyxcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIOODh+ODvOOCv+ODmeODvOOCueOCkuS9nOaIkFxuICAgICAgICB0aGlzLmRiID0gbmV3IHRoaXMuc3FsaXRlMy5vbzEuREIodGhpcy5jdXJyZW50RmlsZW5hbWUsIFwiY1wiKTtcbiAgICAgICAgLy8gc3FsaXRlM19pbnN0YW5jZeOBq29yaWdpbmFs44OX44Ot44OR44OG44Kj44KS5L2c5oiQXG4gICAgICAgIHRoaXMub3JpZ2luYWwgPSB7IGRiOiB7fSB9O1xuXG4gICAgICAgIC8vIOWFg+OBrnByZXBhcmXjg6Hjgr3jg4Pjg4njgpLkv53lrZhcbiAgICAgICAgdGhpcy5vcmlnaW5hbC5kYi5wcmVwYXJlID0gdGhpcy5kYi5wcmVwYXJlO1xuICAgICAgICB0aGlzLm9yaWdpbmFsLmRiLmV4ZWMgPSB0aGlzLmRiLmV4ZWM7XG5cbiAgICAgICAgLy8gZGIucHJlcGFyZeOCkuOCquODvOODkOODvOODqeOCpOODiVxuICAgICAgICB0aGlzLmRiLnByZXBhcmUgPSAoc3FsKSA9PiB7XG4gICAgICAgICAgICAvLyDlhYPjga5wcmVwYXJl44Oh44K944OD44OJ44KS5ZG844Gz5Ye644GXXG4gICAgICAgICAgICBjb25zdCBzdG10ID0gdGhpcy5vcmlnaW5hbC5kYi5wcmVwYXJlLmNhbGwodGhpcy5kYiwgc3FsKTtcbiAgICAgICAgICAgIC8vIFNRTGl0ZU1hbmFnZXLjga7jgqvjgrnjgr/jg57jgqTjgrrjgpLpgannlKhcbiAgICAgICAgICAgIHN0bXQuZ2V0Um93QXNPYmplY3QgPSAoKSA9PiB0aGlzLmdldFJvd0FzT2JqZWN0LmNhbGwodGhpcywgc3RtdCk7XG4gICAgICAgICAgICBzdG10LmdldEFzT2JqZWN0ID0gKCkgPT4gdGhpcy5nZXRSb3dBc09iamVjdC5jYWxsKHRoaXMsIHN0bXQpOyAvL3NxbC5qc1xuICAgICAgICAgICAgc3RtdC5fYmluZCA9IHN0bXQuYmluZDtcbiAgICAgICAgICAgIHN0bXQuYmluZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZC5hcHBseSh0aGlzLCBbc3RtdCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGIuZXhlY+OCkuOCquODvOODkOODvOODqeOCpOODiVxuICAgICAgICB0aGlzLmRiLmV4ZWMgPSAoc3FsLCBiaW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgICAgICBsZXQgY29sdW1uTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbC5kYi5leGVjLmNhbGwodGhpcy5kYiwge1xuICAgICAgICAgICAgICAgICAgICBzcWw6IHNxbCxcbiAgICAgICAgICAgICAgICAgICAgYmluZDogYmluZCxcbiAgICAgICAgICAgICAgICAgICAgcm93TW9kZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAocm93KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OYW1lcyA9IEFycmF5LmZyb20obmV3IFNldChbLi4uY29sdW1uTmFtZXMsIC4uLk9iamVjdC5rZXlzKHJvdyldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goT2JqZWN0LnZhbHVlcyhyb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5OYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByZXN1bHRzXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICBzcGxpdFN0YXRlbWVudHMoc3FsKSB7XG4gICAgLy8gZGJnYXRlLXF1ZXJ5LXNwbGl0dGVy44GnU1FM5paH44KS5YiG5YmyXG4gICAgcmV0dXJuIHNwbGl0UXVlcnkoc3FsLCBzcWxpdGVTcGxpdHRlck9wdGlvbnMpO1xuICB9XG5cbiAgICAvLyDjg5jjg6vjg5Hjg7zjg6Hjgr3jg4Pjg4nvvJrooYzjg4fjg7zjgr/jgpLjgqrjg5bjgrjjgqfjgq/jg4jjgajjgZfjgablj5blvpdcbiAgICBnZXRSb3dBc09iamVjdChzdG10KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBjb25zdCBjb2x1bW5OYW1lcyA9IHN0bXQuZ2V0Q29sdW1uTmFtZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5OYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqW2NvbHVtbk5hbWVzW2ldXSA9IHN0bXQuZ2V0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLy8g44OY44Or44OR44O844Oh44K944OD44OJ77ya44OQ44Kk44Oz44OJ44Kq44OW44K444Kn44Kv44OI44KS44OV44Kj44Or44K/44Oq44Oz44Kw44GX44Gm44OQ44Kk44Oz44OJ44GZ44KLXG4gICAgZmlsdGVyZWRCaW5kT2JqZWN0KHN0bXQsIGJpbmRPYmplY3QpIHtcbiAgICAgICAgaWYgKGJpbmRPYmplY3QgJiYgdHlwZW9mIGJpbmRPYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGJpbmRPYmplY3QpLmZpbHRlcigoW2tleSwgX10pID0+IDAgIT09IHRoaXMuc3FsaXRlMy5jYXBpLnNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgoc3RtdC5wb2ludGVyLCBrZXkpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kT2JqZWN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmluZChzdG10LCAuLi5hcmdzKSB7XG4gICAgICAgIHN0bXQucmVzZXQoKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBiaW5kT2JqZWN0ID0gdGhpcy5maWx0ZXJlZEJpbmRPYmplY3Qoc3RtdCwgYXJnc1swXSk7XG4gICAgICAgICAgICByZXR1cm4gc3RtdC5fYmluZC5hcHBseShzdG10LCBbYmluZE9iamVjdF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0bXQuX2JpbmQuYXBwbHkoc3RtdCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgZXhlY3V0ZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZW1lbnRzID0gdGhpcy5zcGxpdFN0YXRlbWVudHMocXVlcnkpO1xuICAgICAgZm9yIChjb25zdCBzdG10U3FsIG9mIHN0YXRlbWVudHMpIHtcbiAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFtyZXN1bHRdID0gdGhpcy5kYi5leGVjKHN0bXRTcWwpO1xuICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmNvbHVtbnMgJiYgcmVzdWx0LmNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0bWFwID0gcmVzdWx0LnZhbHVlcy5tYXAodmFscyA9PiBPYmplY3QuZnJvbUVudHJpZXMocmVzdWx0LmNvbHVtbnMubWFwKChjLCBpKSA9PiBbYywgdmFsc1tpXV0pKSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goeyBzdWNjZXNzOiB0cnVlLCByZXN1bHRzOiByZXN1bHRtYXAsIGNvbHVtbnM6IHJlc3VsdC5jb2x1bW5zIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IHN1Y2Nlc3M6IHRydWUsIGluZm86IHt9IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXN1bHRzLnB1c2goeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH1cblxuICBnZXREYXRhYmFzZVNjaGVtYSgpIHtcbiAgICBjb25zdCBzcWwgPSBgU0VMRUNUIHR5cGUsIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHR5cGUgSU4gKCd0YWJsZScsJ3ZpZXcnLCdpbmRleCcsJ3RyaWdnZXInKSBPUkRFUiBCWSB0eXBlLG5hbWVgO1xuICAgIGNvbnN0IFtyb3dzXSA9IHRoaXMuZGIuZXhlYyhzcWwpO1xuICAgIGNvbnN0IHNjaGVtYSA9IHsgdGFibGVzOiBbXSwgdmlld3M6IFtdLCBpbmRleGVzOiBbXSwgdHJpZ2dlcnM6IFtdIH07XG4gICAgcm93cy52YWx1ZXMuZm9yRWFjaCh2YWxzID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB2YWxzWzBdLCBuYW1lID0gdmFsc1sxXTtcbiAgICAgIGlmICh0eXBlID09PSAndGFibGUnKSBzY2hlbWEudGFibGVzLnB1c2gobmFtZSk7XG4gICAgICBpZiAodHlwZSA9PT0gJ3ZpZXcnKSBzY2hlbWEudmlld3MucHVzaChuYW1lKTtcbiAgICAgIGlmICh0eXBlID09PSAnaW5kZXgnKSBzY2hlbWEuaW5kZXhlcy5wdXNoKG5hbWUpO1xuICAgICAgaWYgKHR5cGUgPT09ICd0cmlnZ2VyJykgc2NoZW1hLnRyaWdnZXJzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuXG4gIGdldFRhYmxlU3RydWN0dXJlKHRhYmxlTmFtZSkge1xuICAgIGNvbnN0IHNxbCA9IGBQUkFHTUEgdGFibGVfaW5mbygke3RhYmxlTmFtZX0pYDtcbiAgICBjb25zdCBbcm93c10gPSB0aGlzLmRiLmV4ZWMoc3FsKTtcbiAgICByZXR1cm4gcm93cy52YWx1ZXMubWFwKHZhbHMgPT4gT2JqZWN0LmZyb21FbnRyaWVzKHJvd3MuY29sdW1ucy5tYXAoKGMsIGkpID0+IFtjLCB2YWxzW2ldXSkpKTtcbiAgfVxuICBcbiAgICBleHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfZGJfZXhwb3J0KHRoaXMuZGIpO1xuICAgIH1cblxuICAgIGFzeW5jIGltcG9ydChjb250ZW50cykge1xuICAgICAgICB0aGlzLmRiLmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0dXBFbnZpcm9ubWVudChjb250ZW50cyk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZGIuY2xvc2UoKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBTUUxpdGVNYW5hZ2VyOyIsImltcG9ydCB7IFVJX0lEUyB9IGZyb20gJy4vdWkvY29uc3RhbnRzLmpzJzsgLy8gVXBkYXRlZCBpbXBvcnQgcGF0aFxuaW1wb3J0IHsgYWRkUmVzdWx0cyB9IGZyb20gJy4vdWkvSW1hZ2VzTm90RXhpc3RzLmpzJztcbmltcG9ydCB7IHVwZGF0ZVJlc3VsdHNHcmlkIH0gZnJvbSAnLi91aS9SZXN1bHRzLmpzJztcbi8vIGV2ZW50cy5qcyAtIOOCpOODmeODs+ODiOODj+ODs+ODieODqeODvOOCkuioreWumuOBmeOCi+ODouOCuOODpeODvOODq1xuXG4vLyDjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njg7zjga7jgrvjg4Pjg4jjgqLjg4Pjg5dcbmV4cG9ydCBjb25zdCBzZXR1cEV2ZW50SGFuZGxlcnMgPSAodWksIGRiLCB0YWJNYW5hZ2VyKSA9PiB7XG4gIC8vIOePvuWcqOOBruODh+ODvOOCv+ODmeODvOOCueODkeOCuVxuICBsZXQgY3VycmVudERiUGF0aCA9ICdVbnRpdGxlZC5kYic7XG5cbiAgLy8g44Kv44Ko44Oq5a6f6KGM5Yem55CGIChEQuOCquODluOCuOOCp+OCr+ODiOOCkuS9v+eUqOOBl+OBpuW4uOOBq+Wun+ihjClcbiAgY29uc3QgaGFuZGxlUXVlcnlFeGVjdXRpb24gPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzcWwtZWRpdG9yJyk7XG4gICAgICBpZiAoIWVkaXRvcikgdGhyb3cgbmV3IEVycm9yKCdTUUzjgqjjg4fjgqPjgr/jgYzopovjgaTjgYvjgorjgb7jgZvjgpMnKTtcblxuICAgICAgY29uc3QgcXVlcnkgPSBlZGl0b3IudmFsdWUudHJpbSgpO1xuICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICB1aS5zaG93RXJyb3IoJ+Wun+ihjOOBmeOCi1NRTOOCr+OCqOODquOCkuWFpeWKm+OBl+OBpuOBj+OBoOOBleOBhCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIOaXouWtmOOBrlJlc3VsdHPjgr/jg5bjg7vjg4bjg7zjg5bjg6vjgpLlhajjgabjgq/jg6rjgqLvvIhNZXNzYWdlc+S7peWklu+8iVxuICAgICAgY29uc3QgdGFicyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZXN1bHRzLXRhYnMnKTtcbiAgICAgIGNvbnN0IHJlc3VsdHNHcmlkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVUlfSURTLlJFU1VMVFNfR1JJRCk7XG4gICAgICAvLyDlhYjjgavlhajjgabliYrpmaRcbiAgICAgIGZvciAoY29uc3QgdGFiIG9mIEFycmF5LmZyb20odGFicy5xdWVyeVNlbGVjdG9yQWxsKCcucmVzdWx0LXRhYicpKSkge1xuICAgICAgICBpZiAodGFiLnRleHRDb250ZW50ICE9PSAnTWVzc2FnZXMnKSB0YWIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHRibCBvZiBBcnJheS5mcm9tKHJlc3VsdHNHcmlkLmNoaWxkcmVuKSkge1xuICAgICAgICBpZiAodGJsLmlkLnN0YXJ0c1dpdGgoJ3Jlc3VsdHMtdGFibGUnKSkgdGJsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgLy8g5b+F6KaB44Gq5pWw44Gg44GR44K/44OW44O744OG44O844OW44Or44KS5YaN55Sf5oiQXG4gICAgICBsZXQgaGFzUmVzdWx0cyA9IGZhbHNlO1xuICAgICAgbGV0IGFueVN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIGxldCBhbnlSZXN1bHQgPSBmYWxzZTtcbiAgICAgIGxldCBtZXNzYWdlcyA9IFtdO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gZGIuZXhlY3V0ZVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIGxldCBpZHggPSAwO1xuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gaWR4ID09PSAwID8gJ3Jlc3VsdHMtdGFibGUnIDogYHJlc3VsdHMtdGFibGUtJHtpZHgrMX1gO1xuICAgICAgICBjb25zdCB0YWJMYWJlbCA9IHJlc3VsdHMubGVuZ3RoID09PSAxID8gJ1Jlc3VsdHMnIDogYFJlc3VsdHMke2lkeCsxfWA7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5yZXN1bHRzICYmIHJlc3VsdC5yZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBoYXNSZXN1bHRzID0gdHJ1ZTtcbiAgICAgICAgICBhZGRSZXN1bHRzKHRhYkxhYmVsLCB0YWJsZUlkKTtcbiAgICAgICAgICB1cGRhdGVSZXN1bHRzR3JpZChyZXN1bHQsIHRhYmxlSWQpO1xuICAgICAgICAgIGFueVN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgIGFueVJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChg44Kv44Ko44OqJHtpZHgrMX06ICR7cmVzdWx0LnJlc3VsdHMubGVuZ3RofSDooYzjga7ntZDmnpxgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgKCFyZXN1bHQucmVzdWx0cyB8fCByZXN1bHQucmVzdWx0cy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYOOCr+OCqOODqiR7aWR4KzF944KS5a6f6KGM44GX44G+44GX44GfOiAke3Jlc3VsdC5pbmZvPy5jaGFuZ2VzIHx8IDB9IOihjOOBq+W9semfv2A7XG4gICAgICAgICAgdWkuc2hvd1N1Y2Nlc3MobXNnKTtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gYOOCr+OCqOODqiR7aWR4KzF944Ko44Op44O8OiAke3Jlc3VsdC5lcnJvcn1gO1xuICAgICAgICAgIHVpLnNob3dFcnJvcihlcnIpO1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZHgrKztcbiAgICAgIH1cbiAgICAgIGlmIChoYXNSZXN1bHRzKSB7XG4gICAgICAgIC8vIC0tLSDov73liqA6IOacgOWIneOBrlJlc3VsdOOCv+ODluOCkuOCouOCr+ODhuOCo+ODluOBqyAtLS1cbiAgICAgICAgY29uc3QgdGFicyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZXN1bHRzLXRhYnMnKTtcbiAgICAgICAgaWYgKHRhYnMpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdFJlc3VsdFRhYiA9IEFycmF5LmZyb20odGFicy5xdWVyeVNlbGVjdG9yQWxsKCcucmVzdWx0LXRhYicpKS5maW5kKHRhYiA9PiB0YWIudGV4dENvbnRlbnQgPT09ICdSZXN1bHRzJyB8fCB0YWIudGV4dENvbnRlbnQgPT09ICdSZXN1bHRzMScpO1xuICAgICAgICAgIGlmIChmaXJzdFJlc3VsdFRhYikge1xuICAgICAgICAgICAgdGFicy5xdWVyeVNlbGVjdG9yQWxsKCcucmVzdWx0LXRhYicpLmZvckVhY2godCA9PiB0LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpKTtcbiAgICAgICAgICAgIGZpcnN0UmVzdWx0VGFiLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0c0dyaWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChVSV9JRFMuUkVTVUxUU19HUklEKTtcbiAgICAgICAgICAgIEFycmF5LmZyb20ocmVzdWx0c0dyaWQuY2hpbGRyZW4pLmZvckVhY2godGJsID0+IHtcbiAgICAgICAgICAgICAgdGJsLnN0eWxlLmRpc3BsYXkgPSAodGJsLmlkID09PSAncmVzdWx0cy10YWJsZScgfHwgdGJsLmlkID09PSAncmVzdWx0cy10YWJsZS0xJykgPyAnJyA6ICdub25lJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0g6L+95Yqg44GT44GT44G+44GnIC0tLVxuICAgICAgfVxuICAgICAgLy8gTWVzc2FnZXPjgr/jg5bjgavjg63jgrDjg7vjgqjjg6njg7zjgpLooajnpLpcbiAgICAgIGNvbnN0IG1lc3NhZ2VzQXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZXNzYWdlcy1hcmVhJyk7XG4gICAgICBpZiAobWVzc2FnZXNBcmVhKSB7XG4gICAgICAgIG1lc3NhZ2VzQXJlYS5pbm5lckhUTUwgPSBtZXNzYWdlcy5tYXAobSA9PiBgPGRpdj4ke219PC9kaXY+YCkuam9pbignJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWFueVJlc3VsdCkge1xuICAgICAgICAvLyDntZDmnpzjgYznhKHjgYTloLTlkIjjga9NZXNzYWdlc+OCv+ODluOCkuOCouOCr+ODhuOCo+ODluOBq1xuICAgICAgICBjb25zdCBtc2dUYWIgPSB0YWJzLnF1ZXJ5U2VsZWN0b3IoJy5yZXN1bHQtdGFiOmxhc3QtY2hpbGQnKTtcbiAgICAgICAgaWYgKG1zZ1RhYikge1xuICAgICAgICAgIHRhYnMucXVlcnlTZWxlY3RvckFsbCgnLnJlc3VsdC10YWInKS5mb3JFYWNoKHQgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKSk7XG4gICAgICAgICAgbXNnVGFiLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIHJlc3VsdHNHcmlkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lc3NhZ2VzLWFyZWEnKS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYW55U3VjY2Vzcykge1xuICAgICAgICB1aS5zaG93U3VjY2Vzcyhg44Kv44Ko44Oq44KS5a6f6KGM44GX44G+44GX44GfOiAke3Jlc3VsdHMubGVuZ3RofSDku7ZgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdWkuc2hvd0Vycm9yKGDjgq/jgqjjg6rlrp/ooYzkuK3jgavjgqjjg6njg7zjgYznmbrnlJ/jgZfjgb7jgZfjgZ86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+OCr+OCqOODquWun+ihjOOCqOODqeODvDonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIOaWsOimj+ODh+ODvOOCv+ODmeODvOOCueS9nOaIkOODnOOCv+ODs1xuICBjb25zdCBuZXdEYkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXctZGItYnV0dG9uJyk7XG4gIGlmIChuZXdEYkJ1dHRvbikge1xuICAgIG5ld0RiQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc3QgZGJQYXRoID0gaGFuZGxlTmV3RGF0YWJhc2UodWksIGRiKTtcbiAgICAgIGlmIChkYlBhdGgpIGN1cnJlbnREYlBhdGggPSBkYlBhdGg7XG4gICAgfSk7XG4gIH1cblxuICAvLyBcIumWi+OBj1wi44Oc44K/44Oz44Gn44OV44Kh44Kk44Or6YG45oqe44Gr44KI44KLRELjgqTjg7Pjg53jg7zjg4hcbiAgY29uc3Qgb3BlbkRiQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29wZW4tZGItYnV0dG9uJyk7XG4gIGlmIChvcGVuRGJCdXR0b24pIHtcbiAgICBvcGVuRGJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYlBhdGggPSBhd2FpdCBnZXRGaWxlKCk7XG4gICAgICAgIGlmICghZGJQYXRoKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKCfpgbjmip7jgZXjgozjgZ9EQuODleOCoeOCpOODqzonLCBkYlBhdGgubmFtZSk7XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcmVhZEZpbGVBc0FycmF5QnVmZmVyKGRiUGF0aCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgIGF3YWl0IGRiLmltcG9ydChkYXRhKTtcbiAgICAgICAgdWkuc2hvd1N1Y2Nlc3MoYOODh+ODvOOCv+ODmeODvOOCuSAnJHtkYlBhdGgubmFtZX0nIOOCkumWi+OBjeOBvuOBl+OBn2ApO1xuICAgICAgICBjdXJyZW50RGJQYXRoID0gZGJQYXRoLm5hbWU7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGRiLmdldERhdGFiYXNlU2NoZW1hKGN1cnJlbnREYlBhdGgpO1xuICAgICAgICB1aS51cGRhdGVEYXRhYmFzZVRyZWUoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgZGJTdGF0dXNFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RiLXN0YXR1cycpO1xuICAgICAgICBpZiAoZGJTdGF0dXNFbGVtKSBkYlN0YXR1c0VsZW0udGV4dENvbnRlbnQgPSBjdXJyZW50RGJQYXRoO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdWkuc2hvd0Vycm9yKCfjgqTjg7Pjg53jg7zjg4jjgqjjg6njg7w6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBcIuS/neWtmFwi44Oc44K/44Oz44GnRELjgqjjgq/jgrnjg53jg7zjg4hcbiAgY29uc3Qgc2F2ZUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYXZlLWRiLWJ1dHRvbicpO1xuICBpZiAoc2F2ZUJ1dHRvbikge1xuICAgIHNhdmVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZGIuZXhwb3J0KCk7XG4gICAgICAgIHNhdmVGaWxlKCdleHBvcnRlZC5kYicsIGRhdGEpO1xuICAgICAgICB1aS5zaG93U3VjY2Vzcygn44OH44O844K/44OZ44O844K544KS44Ko44Kv44K544Od44O844OI44GX44G+44GX44GfJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB1aS5zaG93RXJyb3IoJ+OCqOOCr+OCueODneODvOODiOOCqOODqeODvDogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIOODhOODquODvOODk+ODpeODvOOBuOOBruODleOCoeOCpOODq+ODieODreODg+ODl+OBp+OCpOODs+ODneODvOODiFxuICBjb25zdCB0cmVlVmlld0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChVSV9JRFMuREJfVFJFRSk7XG4gIGlmICh0cmVlVmlld0VsZW0pIHtcbiAgICB0cmVlVmlld0VsZW0uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBlID0+IGUucHJldmVudERlZmF1bHQoKSk7XG4gICAgdHJlZVZpZXdFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBhc3luYyBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGRiUGF0aCA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzWzBdO1xuICAgICAgaWYgKCFkYlBhdGgpIHJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcmVhZEZpbGVBc0FycmF5QnVmZmVyKGRiUGF0aCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgIGF3YWl0IGRiLmltcG9ydChkYXRhKTtcbiAgICAgICAgdWkuc2hvd1N1Y2Nlc3MoYOODh+ODvOOCv+ODmeODvOOCuSAnJHtkYlBhdGh9JyDjgpLplovjgY3jgb7jgZfjgZ9gKTtcbiAgICAgICAgY3VycmVudERiUGF0aCA9IGRiUGF0aC5uYW1lO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBkYi5nZXREYXRhYmFzZVNjaGVtYShjdXJyZW50RGJQYXRoKTtcbiAgICAgICAgdWkudXBkYXRlRGF0YWJhc2VUcmVlKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGRiU3RhdHVzRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkYi1zdGF0dXMnKTtcbiAgICAgICAgaWYgKGRiU3RhdHVzRWxlbSkgZGJTdGF0dXNFbGVtLnRleHRDb250ZW50ID0gY3VycmVudERiUGF0aDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHVpLnNob3dFcnJvcign44Kk44Oz44Od44O844OI44Ko44Op44O8OiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyDjgq/jgqjjg6rlrp/ooYzjg5zjgr/jg7NcbiAgY29uc3QgcnVuQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3J1bi1idXR0b24nKTtcbiAgaWYgKHJ1bkJ1dHRvbikge1xuICAgIHJ1bkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVF1ZXJ5RXhlY3V0aW9uKTtcbiAgfVxuICAvLyDjgrXjgqTjg4njg5Djg7zjga7jg4bjg7zjg5bjg6vpgbjmip7jgoTjg6njg7PjgqTjg5njg7Pjg4jjga/ml6LlrZjjga7jgb7jgb5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQuY2xvc2VzdCgnLnRyZWUtbGFiZWwnKTtcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC50ZXh0Q29udGVudC5pbmNsdWRlcygnLmRiJykgJiYgY3VycmVudERiUGF0aCkge1xuICAgICAgLy8g44OH44O844K/44OZ44O844K544Kv44Oq44OD44Kv5pmC44Gu5Yem55CGXG4gICAgICBoYW5kbGVEYXRhYmFzZUNsaWNrKHVpLCBkYiwgY3VycmVudERiUGF0aCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmNsb3Nlc3QoJy5UYWJsZXMnKSkge1xuICAgICAgLy8g44OG44O844OW44Or44Kv44Oq44OD44Kv5pmC44Gu5Yem55CGIChjdXJyZW50RGJQYXRoIOOBjOacquioreWumuOBp+OCguODh+ODleOCqeODq+ODiERC44KS5L2/55SoKVxuICAgICAgY29uc3QgZGJQYXRoID0gY3VycmVudERiUGF0aCB8fCAnc2FtcGxlX2RhdGFiYXNlJztcbiAgICAgIC8vIGN1cnJlbnREYlBhdGgg44KS5pu05paw44GX44CB44Kv44Ko44Oq6Kit5a6a44Gu44G/6KGM44GGXG4gICAgICBjdXJyZW50RGJQYXRoID0gZGJQYXRoO1xuICAgICAgaGFuZGxlVGFibGVDbGljayh1aSwgZGIsIGRiUGF0aCwgdGFyZ2V0LmRhdGFzZXQubmFtZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyDjg6rjg5Xjg6zjg4Pjgrfjg6Xjg5zjgr/jg7Pjga7jg4/jg7Pjg4njg6nov73liqBcbiAgY29uc3QgcmVmcmVzaEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWZyZXNoLWRiLWJ1dHRvbicpO1xuICBpZiAocmVmcmVzaEJ1dHRvbikge1xuICAgIHJlZnJlc2hCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAvLyBjdXJyZW50RGJQYXRoIOOBq+mWouOCj+OCieOBmuODhOODquODvOODk+ODpeODvOOCkuabtOaWsFxuICAgICAgaGFuZGxlRGF0YWJhc2VDbGljayh1aSwgZGIsIGN1cnJlbnREYlBhdGgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gXCJRdWVyeeOCkumWi+OBj1wi44Oc44K/44OzXG4gIGNvbnN0IG9wZW5RdWVyeUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcGVuLXF1ZXJ5LWJ1dHRvbicpO1xuICBpZiAob3BlblF1ZXJ5QnV0dG9uKSB7XG4gICAgb3BlblF1ZXJ5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3FsRmlsZSA9IGF3YWl0IGdldFNxbEZpbGUoKTtcbiAgICAgICAgaWYgKCFzcWxGaWxlKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKCfpgbjmip7jgZXjgozjgZ9TUUzjg5XjgqHjgqTjg6s6Jywgc3FsRmlsZS5uYW1lKTtcbiAgICAgICAgY29uc3Qgc3FsQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXNUZXh0KHNxbEZpbGUpO1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3FsLWVkaXRvcicpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgZWRpdG9yLnZhbHVlID0gc3FsQ29udGVudDtcbiAgICAgICAgICB1aS5zaG93U3VjY2VzcyhgU1FM44OV44Kh44Kk44OrICcke3NxbEZpbGUubmFtZX0nIOOCkuiqreOBv+i+vOOBv+OBvuOBl+OBn2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU1FM44Ko44OH44Kj44K/44GM6KaL44Gk44GL44KK44G+44Gb44KTJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHVpLnNob3dFcnJvcihgU1FM44OV44Kh44Kk44Or6Kqt44G/6L6844G/44Ko44Op44O8OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NRTOODleOCoeOCpOODq+iqreOBv+i+vOOBv+OCqOODqeODvDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBcIlF1ZXJ544KS5L+d5a2YXCLjg5zjgr/jg7NcbiAgY29uc3Qgc2F2ZVF1ZXJ5QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NhdmUtcXVlcnktYnV0dG9uJyk7XG4gIGlmIChzYXZlUXVlcnlCdXR0b24pIHtcbiAgICBzYXZlUXVlcnlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3FsLWVkaXRvcicpO1xuICAgICAgICBpZiAoIWVkaXRvcikgdGhyb3cgbmV3IEVycm9yKCdTUUzjgqjjg4fjgqPjgr/jgYzopovjgaTjgYvjgorjgb7jgZvjgpMnKTtcblxuICAgICAgICBjb25zdCBxdWVyeSA9IGVkaXRvci52YWx1ZTtcbiAgICAgICAgaWYgKCFxdWVyeS50cmltKCkpIHtcbiAgICAgICAgICB1aS5zaG93RXJyb3IoJ+S/neWtmOOBmeOCi1NRTOOCr+OCqOODquOBjOOBguOCiuOBvuOBm+OCkycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhdmVUZXh0RmlsZSgncXVlcnkuc3FsJywgcXVlcnksICdhcHBsaWNhdGlvbi9zcWwnKTtcbiAgICAgICAgdWkuc2hvd1N1Y2Nlc3MoJ+OCr+OCqOODquOCkiBxdWVyeS5zcWwg44Go44GX44Gm5L+d5a2Y44GX44G+44GX44GfJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB1aS5zaG93RXJyb3IoYOOCr+OCqOODquS/neWtmOOCqOODqeODvDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKCfjgq/jgqjjg6rkv53lrZjjgqjjg6njg7w6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyDmlrDopo/jg4fjg7zjgr/jg5njg7zjgrnjgpLkvZzmiJDjgZnjgovlh6bnkIZcbmNvbnN0IGhhbmRsZU5ld0RhdGFiYXNlID0gKHVpLCBkYikgPT4ge1xuICB0cnkge1xuICAgIC8vIOODluODqeOCpuOCtueSsOWig1xuICAgIGxldCBkYlBhdGggPSAnbmV3X2RhdGFiYXNlLmRiJztcbiAgICAvLyDmlrDjgZfjgYTjg4fjg7zjgr/jg5njg7zjgrnjgpLkvZzmiJDjgZfjgabmjqXntppcbiAgICBkYi5pbXBvcnQobnVsbCk7XG5cbiAgICAvLyDjgrXjg7Pjg5fjg6vjg4bjg7zjg5bjg6vjgpLkvZzmiJDvvIjopIfmlbBTUUzjgpLjgZ3jgozjgZ7jgozlrp/ooYzvvIlcbiAgICBkYi5leGVjdXRlUXVlcnkoYENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIHRlc3QgKGNvbDEgSU5URUdFUiBQUklNQVJZIEtFWSwgY29sMiBURVhUKWApO1xuICAgIGRiLmV4ZWN1dGVRdWVyeShgSU5TRVJUIE9SIElHTk9SRSBJTlRPIHRlc3QgKGNvbDEsIGNvbDIpIFZBTFVFUyAoMSwgJzExMScpYCk7XG4gICAgZGIuZXhlY3V0ZVF1ZXJ5KGBJTlNFUlQgT1IgSUdOT1JFIElOVE8gdGVzdCAoY29sMSwgY29sMikgVkFMVUVTICgyLCAnMjIyJylgKTtcblxuICAgIHVpLnNob3dTdWNjZXNzKGDmlrDjgZfjgYTjg4fjg7zjgr/jg5njg7zjgrkgJyR7ZGJQYXRofScg44KS5L2c5oiQ44GX44G+44GX44GfYCk7XG5cbiAgICAvLyDjg4fjg7zjgr/jg5njg7zjgrnjg4Tjg6rjg7zjg5Pjg6Xjg7zjgpLmm7TmlrBcbiAgICBjb25zdCBzY2hlbWEgPSBkYi5nZXREYXRhYmFzZVNjaGVtYShkYlBhdGgpO1xuICAgIHVpLnVwZGF0ZURhdGFiYXNlVHJlZShzY2hlbWEpO1xuXG4gICAgY29uc3QgZGJTdGF0dXNFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RiLXN0YXR1cycpO1xuICAgIGlmIChkYlN0YXR1c0VsZW0pIHtcbiAgICAgIGRiU3RhdHVzRWxlbS50ZXh0Q29udGVudCA9IGRiUGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGJQYXRoO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHVpLnNob3dFcnJvcihg44OH44O844K/44OZ44O844K55L2c5oiQ44Ko44Op44O8OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgY29uc29sZS5lcnJvcign44OH44O844K/44OZ44O844K55L2c5oiQ44Ko44Op44O8OicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8g44OH44O844K/44OZ44O844K544Kv44Oq44OD44Kv5pmC44Gu5Yem55CGXG5jb25zdCBoYW5kbGVEYXRhYmFzZUNsaWNrID0gKHVpLCBkYiwgZGJQYXRoKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8g44OH44O844K/44OZ44O844K544K544Kt44O844Oe5oOF5aCx44KS5Y+W5b6XXG4gICAgY29uc3Qgc2NoZW1hID0gZGIuZ2V0RGF0YWJhc2VTY2hlbWEoZGJQYXRoKTtcbiAgICBjb25zdCBkYlN0YXR1c0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGItc3RhdHVzJyk7XG4gICAgaWYgKGRiU3RhdHVzRWxlbSkgZGJTdGF0dXNFbGVtLnRleHRDb250ZW50ID0gZGJQYXRoO1xuICAgIHVpLnVwZGF0ZURhdGFiYXNlVHJlZShzY2hlbWEpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHVpLnNob3dFcnJvcihg44OH44O844K/44OZ44O844K55oOF5aCx44Gu5Y+W5b6X44Gr5aSx5pWX44GX44G+44GX44GfOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8vIOODhuODvOODluODq+OCr+ODquODg+OCr+aZguOBruWHpueQhlxuY29uc3QgaGFuZGxlVGFibGVDbGljayA9ICh1aSwgZGIsIGRiUGF0aCwgdGFibGVOYW1lKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8g44OG44O844OW44Or44GuU0VMRUNU5paH44KS44Ko44OH44Kj44K/44Gr6Kit5a6aXG4gICAgY29uc3QgZWRpdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NxbC1lZGl0b3InKTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICBlZGl0b3IudmFsdWUgPSBgU0VMRUNUICogRlJPTSAke3RhYmxlTmFtZX0gTElNSVQgMTAwYDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdWkuc2hvd0Vycm9yKGDjg4bjg7zjg5bjg6vmg4XloLHjga7lj5blvpfjgavlpLHmlZfjgZfjgb7jgZfjgZ86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLy8g44OY44Or44OR44O8OiDjg5XjgqHjgqTjg6vkv53lrZggKERC55SoKVxuZnVuY3Rpb24gc2F2ZUZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudHNdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9zcWxpdGUuZGInIH0pO1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpOyBhLmhyZWYgPSB1cmw7IGEuZG93bmxvYWQgPSBmaWxlbmFtZTsgYS5jbGljaygpO1xuICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG59XG4vLyDjg5jjg6vjg5Hjg7w6IOODleOCoeOCpOODq+mBuOaKnuODgOOCpOOCouODreOCsFxuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZSgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTsgaW5wdXQudHlwZSA9ICdmaWxlJzsgaW5wdXQuYWNjZXB0ID0gJy5kYic7XG4gICAgaW5wdXQub25jaGFuZ2UgPSAoKSA9PiByZXNvbHZlKGlucHV0LmZpbGVzWzBdKTsgaW5wdXQuY2xpY2soKTtcbiAgfSk7XG59XG4vLyDjg5jjg6vjg5Hjg7w6IOODleOCoeOCpOODq+OCkkFycmF5QnVmZmVy44Gn6Kqt44G/5Y+W44KKXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZUFzQXJyYXlCdWZmZXIoZmlsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7IHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0OyByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gIH0pO1xufVxuLy8g44OY44Or44OR44O8OiDjg5XjgqHjgqTjg6vpgbjmip7jg4DjgqTjgqLjg63jgrAgKFNRTOeUqClcbmFzeW5jIGZ1bmN0aW9uIGdldFNxbEZpbGUoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7IGlucHV0LnR5cGUgPSAnZmlsZSc7IGlucHV0LmFjY2VwdCA9ICcuc3FsJztcbiAgICBpbnB1dC5vbmNoYW5nZSA9ICgpID0+IHJlc29sdmUoaW5wdXQuZmlsZXNbMF0pOyBpbnB1dC5jbGljaygpO1xuICB9KTtcbn1cbi8vIOODmOODq+ODkeODvDog44OV44Kh44Kk44Or44KS44OG44Kt44K544OI44Gn6Kqt44G/5Y+W44KKXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZUFzVGV4dChmaWxlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTsgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7IHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9KTtcbn1cbi8vIOODmOODq+ODkeODvDog44OG44Kt44K544OI44OV44Kh44Kk44Or5L+d5a2YXG5mdW5jdGlvbiBzYXZlVGV4dEZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzLCBtaW1lVHlwZSA9ICd0ZXh0L3BsYWluJykge1xuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRzXSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcbiAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTsgYS5ocmVmID0gdXJsOyBhLmRvd25sb2FkID0gZmlsZW5hbWU7IGEuY2xpY2soKTtcbiAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYk1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih7IGNvbnRhaW5lcklkLCBlZGl0b3JJZCwgcmVzdWx0c0lkLCBtZXNzYWdlc0lkIH0pIHtcbiAgICBjb25zb2xlLmxvZygnVGFiTWFuYWdlciBpbml0aWFsaXplZCB3aXRoIGNvbnRhaW5lcicsIGNvbnRhaW5lcklkKTtcbiAgICB0aGlzLnRhYnNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCk7XG4gICAgdGhpcy5lZGl0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlZGl0b3JJZCk7XG4gICAgdGhpcy5yZXN1bHRzQXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJlc3VsdHNJZCk7XG4gICAgdGhpcy5tZXNzYWdlc0FyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZXNzYWdlc0lkKTtcbiAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgIHRoaXMuYWN0aXZlVGFiSWQgPSAncXVlcnkxJztcbiAgICB0aGlzLnRhYlNlcmlhbCA9IDI7IC8vIOmAmueVquOCq+OCpuODs+OCv1xuICAgIC8vIOWIneacn+eKtuaFi+S/neWtmFxuICAgIHRoaXMuc3RhdGVzWydxdWVyeTEnXSA9IHtcbiAgICAgIHF1ZXJ5OiB0aGlzLmVkaXRvci52YWx1ZSxcbiAgICAgIHJlc3VsdHM6IHRoaXMucmVzdWx0c0FyZWEuaW5uZXJIVE1MLFxuICAgICAgbWVzc2FnZXM6IHRoaXMubWVzc2FnZXNBcmVhLmlubmVySFRNTFxuICAgIH07XG4gICAgLy8g5Yid5pyf44GucmVzdWx0cy9tZXNzYWdlcyBIVE1M44KS5L+d5a2YXG4gICAgdGhpcy5kZWZhdWx0UmVzdWx0c0hUTUwgPSB0aGlzLnN0YXRlc1sncXVlcnkxJ10ucmVzdWx0cztcbiAgICB0aGlzLmRlZmF1bHRNZXNzYWdlc0hUTUwgPSB0aGlzLnN0YXRlc1sncXVlcnkxJ10ubWVzc2FnZXM7XG4gICAgLy8g5Yid5pyf44K/44OW44KS44Ki44Kv44OG44Kj44OWXG4gICAgY29uc3QgZmlyc3RUYWIgPSB0aGlzLnRhYnNDb250YWluZXIucXVlcnlTZWxlY3RvcignLnF1ZXJ5LXRhYicpO1xuICAgIGlmIChmaXJzdFRhYikge1xuICAgICAgZmlyc3RUYWIuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAvLyDliJ3mnJ/jgr/jg5bjga7jgq/jg6rjg4Pjgq/jgafliIfjgormm7/jgYhcbiAgICAgIGZpcnN0VGFiLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5zd2l0Y2hUYWIoJ3F1ZXJ5MScpKTtcbiAgICB9XG4gIH1cblxuICBhZGRUYWIobGFiZWwpIHtcbiAgICBjb25zb2xlLmxvZygnVGFiTWFuYWdlci5hZGRUYWIgY2FsbGVkIHdpdGgnLCBsYWJlbCk7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnRhYnNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLnF1ZXJ5LXRhYicpLmxlbmd0aDtcbiAgICBjb25zdCB0YWJJZCA9IGBxdWVyeSR7dGhpcy50YWJTZXJpYWwrK31gO1xuICAgIC8vIOODmOODg+ODgOODvOOCv+ODlueUn+aIkFxuICAgIGNvbnN0IHRhYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRhYi5jbGFzc0xpc3QuYWRkKCdxdWVyeS10YWInKTtcbiAgICB0YWIuZGF0YXNldC50YWJJZCA9IHRhYklkO1xuICAgIHRhYi50ZXh0Q29udGVudCA9IGAke2xhYmVsfSR7dGFiSWQucmVwbGFjZSgncXVlcnknLCcnKX1gO1xuICAgIC8vIOOCv+ODluOCr+ODquODg+OCr+OBp+WIh+OCiuabv+OBiFxuICAgIHRhYi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuc3dpdGNoVGFiKHRhYklkKSk7XG4gICAgLy8g6ZaJ44GY44KL44Oc44K/44OzXG4gICAgY29uc3QgY2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgY2xvc2UuY2xhc3NMaXN0LmFkZCgnY2xvc2UtdGFiJyk7XG4gICAgY2xvc2UudGV4dENvbnRlbnQgPSAnw5cnO1xuICAgIGNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IHRoaXMuY2xvc2VUYWIodGFiSWQpOyB9KTtcbiAgICB0YWIuYXBwZW5kQ2hpbGQoY2xvc2UpO1xuICAgIHRoaXMudGFic0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0YWIpO1xuICAgIGNvbnNvbGUubG9nKCdUYWJNYW5hZ2VyOiBhZnRlciBhcHBlbmQsIHRhYiBjb3VudCA9JywgdGhpcy50YWJzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5xdWVyeS10YWInKS5sZW5ndGgpO1xuICAgIC8vIOeKtuaFi+WIneacn+WMljog44Ko44Oq44KiSFRNTOOCkuS/neaMgeOBl+OBpuOBiuOBj1xuICAgIHRoaXMuc3RhdGVzW3RhYklkXSA9IHtcbiAgICAgIHF1ZXJ5OiAnJyxcbiAgICAgIHJlc3VsdHM6IHRoaXMuZGVmYXVsdFJlc3VsdHNIVE1MLFxuICAgICAgbWVzc2FnZXM6IHRoaXMuZGVmYXVsdE1lc3NhZ2VzSFRNTFxuICAgIH07XG4gICAgLy8g5YiH44KK5pu/44GIXG4gICAgdGhpcy5zd2l0Y2hUYWIodGFiSWQpO1xuICAgIC8vIC0tLSDov73liqA6IOaWsOimj+OCv+ODluaZguOBq1VJ44KC5Yid5pyf5YyWIC0tLVxuICAgIC8vIOOCqOODh+OCo+OCv+OCkuepuuOBq1xuICAgIHRoaXMuZWRpdG9yLnZhbHVlID0gJyc7XG4gICAgLy8gUmVzdWx0c+OCsOODquODg+ODieOCkuepuuODhuODvOODluODq+OBq1xuICAgIGlmICh0aGlzLnJlc3VsdHNBcmVhKSB7XG4gICAgICB0aGlzLnJlc3VsdHNBcmVhLmlubmVySFRNTCA9ICcnO1xuICAgICAgLy8gcmVzdWx0cy10YWJsZSwgcmVzdWx0cy10YWJsZS0yLi4u44Gq44Gp44KC5YWo5YmK6ZmkXG4gICAgICBBcnJheS5mcm9tKHRoaXMucmVzdWx0c0FyZWEucXVlcnlTZWxlY3RvckFsbCgndGFibGUnKSkuZm9yRWFjaCh0YmwgPT4gdGJsLnJlbW92ZSgpKTtcbiAgICAgIC8vIFJlc3VsdHPjgr/jg5bjg7vjg4bjg7zjg5bjg6vjgpLlv4XjgZox44Gk44Gg44GR5YaN55Sf5oiQXG4gICAgICBjb25zdCB0YWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlc3VsdHMtdGFicycpO1xuICAgICAgY29uc3QgcmVzdWx0c0dyaWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzdWx0cy1ncmlkJyk7XG4gICAgICAvLyBSZXN1bHRz44K/44OW44KS5YWo5YmK6ZmkXG4gICAgICBBcnJheS5mcm9tKHRhYnMucXVlcnlTZWxlY3RvckFsbCgnLnJlc3VsdC10YWInKSkuZm9yRWFjaCh0YWIgPT4ge1xuICAgICAgICBpZiAodGFiLnRleHRDb250ZW50ID09PSAnUmVzdWx0cycpIHRhYi5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgLy8gUmVzdWx0c+ezu+ODhuODvOODluODq+OCkuWFqOWJiumZpFxuICAgICAgQXJyYXkuZnJvbShyZXN1bHRzR3JpZC5jaGlsZHJlbikuZm9yRWFjaCh0YmwgPT4ge1xuICAgICAgICBpZiAodGJsLmlkICYmIHRibC5pZC5zdGFydHNXaXRoKCdyZXN1bHRzLXRhYmxlJykpIHRibC5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgLy8gUmVzdWx0c+OCv+ODluODu+ODhuODvOODluODq+OCkjHjgaTjgaDjgZHlho3nlJ/miJBcbiAgICAgIGNvbnN0IHsgYWRkUmVzdWx0cyB9ID0gcmVxdWlyZSgnLi91aS9JbWFnZXNOb3RFeGlzdHMuanMnKTtcbiAgICAgIGFkZFJlc3VsdHMoJ1Jlc3VsdHMnLCAncmVzdWx0cy10YWJsZScpO1xuICAgIH1cbiAgICAvLyBNZXNzYWdlc+OCqOODquOCouOCguepuuOBq1xuICAgIGlmICh0aGlzLm1lc3NhZ2VzQXJlYSkge1xuICAgICAgdGhpcy5tZXNzYWdlc0FyZWEuaW5uZXJIVE1MID0gJyc7XG4gICAgfVxuICAgIC8vIC0tLSDov73liqDjgZPjgZPjgb7jgacgLS0tXG4gIH1cblxuICBjbG9zZVRhYih0YWJJZCkge1xuICAgIGNvbnN0IHRhYiA9IHRoaXMudGFic0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGBbZGF0YS10YWItaWQ9XCIke3RhYklkfVwiXWApO1xuICAgIGlmICghdGFiKSByZXR1cm47XG4gICAgZGVsZXRlIHRoaXMuc3RhdGVzW3RhYklkXTtcbiAgICB0YWIucmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMuYWN0aXZlVGFiSWQgPT09IHRhYklkKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhYklkID0gbnVsbDtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy50YWJzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5xdWVyeS10YWInKTtcbiAgICAgIGlmIChmaXJzdCkgdGhpcy5zd2l0Y2hUYWIoZmlyc3QuZGF0YXNldC50YWJJZCk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoVGFiKHRhYklkKSB7XG4gICAgY29uc29sZS5sb2coJ1RhYk1hbmFnZXIuc3dpdGNoVGFiIGNhbGxlZCBmb3InLCB0YWJJZCk7XG4gICAgaWYgKCF0aGlzLnN0YXRlc1t0YWJJZF0pIHJldHVybjtcbiAgICAvLyDml6fjgqLjgq/jg4bjgqPjg5bkv53lrZhcbiAgICBpZiAodGhpcy5hY3RpdmVUYWJJZCkge1xuICAgICAgdGhpcy5zdGF0ZXNbdGhpcy5hY3RpdmVUYWJJZF0ucXVlcnkgPSB0aGlzLmVkaXRvci52YWx1ZTtcbiAgICAgIC8vIFJlc3VsdHPjgr/jg5bjg7vjg4bjg7zjg5bjg6vmp4vmiJDjgpLkv53lrZhcbiAgICAgIGNvbnN0IHJlc3VsdHNUYWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlc3VsdHMtdGFicycpO1xuICAgICAgY29uc3QgcmVzdWx0c0dyaWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzdWx0cy1ncmlkJyk7XG4gICAgICB0aGlzLnN0YXRlc1t0aGlzLmFjdGl2ZVRhYklkXS5yZXN1bHRzID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB0YWJzOiByZXN1bHRzVGFicyA/IHJlc3VsdHNUYWJzLmlubmVySFRNTCA6ICcnLFxuICAgICAgICBncmlkOiByZXN1bHRzR3JpZCA/IHJlc3VsdHNHcmlkLmlubmVySFRNTCA6ICcnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RhdGVzW3RoaXMuYWN0aXZlVGFiSWRdLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlc0FyZWEuaW5uZXJIVE1MO1xuICAgIH1cbiAgICAvLyDjg5jjg4Pjg4Djg7zmm7TmlrBcbiAgICB0aGlzLnRhYnNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLnF1ZXJ5LXRhYicpLmZvckVhY2godCA9PiB0LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpKTtcbiAgICBjb25zdCBuZXdUYWIgPSB0aGlzLnRhYnNDb250YWluZXIucXVlcnlTZWxlY3RvcihgW2RhdGEtdGFiLWlkPVwiJHt0YWJJZH1cIl1gKTtcbiAgICBpZiAobmV3VGFiKSBuZXdUYWIuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgLy8g44Kz44Oz44OG44Oz44OE5b6p5YWDXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlc1t0YWJJZF07XG4gICAgdGhpcy5lZGl0b3IudmFsdWUgPSBzdGF0ZS5xdWVyeTtcbiAgICAvLyBSZXN1bHRz44K/44OW44O744OG44O844OW44Or44KS5b6p5YWDXG4gICAgaWYgKHN0YXRlLnJlc3VsdHMpIHtcbiAgICAgIGxldCBwYXJzZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHN0YXRlLnJlc3VsdHMpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHBhcnNlZCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkICYmIHBhcnNlZC50YWJzICE9PSB1bmRlZmluZWQgJiYgcGFyc2VkLmdyaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCByZXN1bHRzVGFicyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZXN1bHRzLXRhYnMnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0c0dyaWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzdWx0cy1ncmlkJyk7XG4gICAgICAgIGlmIChyZXN1bHRzVGFicyAmJiByZXN1bHRzR3JpZCkge1xuICAgICAgICAgIHJlc3VsdHNUYWJzLmlubmVySFRNTCA9IHBhcnNlZC50YWJzO1xuICAgICAgICAgIHJlc3VsdHNHcmlkLmlubmVySFRNTCA9IHBhcnNlZC5ncmlkO1xuICAgICAgICAgIC8vIOOCv+ODluWIh+abv+OCpOODmeODs+ODiOWGjeODkOOCpOODs+ODiVxuICAgICAgICAgIGNvbnN0IHsgc2V0dXBSZXN1bHRzTWVzc2FnZXNUb2dnbGUgfSA9IHJlcXVpcmUoJy4vdWkvSW1hZ2VzTm90RXhpc3RzLmpzJyk7XG4gICAgICAgICAgc2V0dXBSZXN1bHRzTWVzc2FnZXNUb2dnbGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g5pen5b2i5byP77yISFRNTOaWh+Wtl+WIl+OBruOBv++8iVxuICAgICAgICB0aGlzLnJlc3VsdHNBcmVhLmlubmVySFRNTCA9IHN0YXRlLnJlc3VsdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0c0FyZWEuaW5uZXJIVE1MID0gJyc7XG4gICAgfVxuICAgIC8vIE1lc3NhZ2Vz44KC5b6p5YWDXG4gICAgdGhpcy5tZXNzYWdlc0FyZWEuaW5uZXJIVE1MID0gc3RhdGUubWVzc2FnZXM7XG4gICAgdGhpcy5hY3RpdmVUYWJJZCA9IHRhYklkO1xuICB9XG59IiwiLy8gdWkuanMgLSBVSeOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9nOaIkOOBmeOCi+ODouOCuOODpeODvOODq1xuaW1wb3J0IHsgdXBkYXRlUmVzdWx0c0dyaWQgfSBmcm9tICcuL3VpL1Jlc3VsdHMnO1xuaW1wb3J0IHsgc2hvd0Vycm9yLCBzaG93U3VjY2VzcyB9IGZyb20gJy4vdWkvTWVzc2FnZXMnO1xuLy8gU2lkZWJhcuapn+iDveOCkuWklumDqOODouOCuOODpeODvOODq+OBi+OCieOCpOODs+ODneODvOODiFxuaW1wb3J0IHsgY3JlYXRlU2lkZWJhciwgdXBkYXRlRGF0YWJhc2VUcmVlIH0gZnJvbSAnLi91aS9TaWRlYmFyJztcbi8vIE1lbnVCYXLmqZ/og73jgpLlpJbpg6jjg6Ljgrjjg6Xjg7zjg6vjgYvjgonjgqTjg7Pjg53jg7zjg4hcbmltcG9ydCB7IGNyZWF0ZU1lbnVCYXIgfSBmcm9tICcuL3VpL01lbnVCYXInO1xuaW1wb3J0IHsgY3JlYXRlU3RhdHVzQmFyIH0gZnJvbSAnLi91aS9TdGF0dXNCYXInO1xuaW1wb3J0IHsgY3JlYXRlUmVzdWx0c1NlY3Rpb24gfSBmcm9tICcuL3VpL0ltYWdlc05vdEV4aXN0cy5qcyc7XG5pbXBvcnQgeyBVSV9JRFMgfSBmcm9tICcuL3VpL2NvbnN0YW50cy5qcyc7IC8vIEltcG9ydCBVSV9JRFMgZnJvbSB0aGUgbmV3IGZpbGVcbmltcG9ydCB7IGNyZWF0ZVNwbGl0dGVyIH0gZnJvbSAnLi91aS9zcGxpdHRlci5qcyc7IC8vIEltcG9ydCBjcmVhdGVTcGxpdHRlclxuaW1wb3J0IHsgY3JlYXRlUm93U3BsaXR0ZXIgfSBmcm9tICcuL3VpL3Jvd1NwbGl0dGVyLmpzJzsgLy8gSW1wb3J0IGNyZWF0ZVJvd1NwbGl0dGVyXG5cbi8vIFVJ44KS5L2c5oiQ44GZ44KL6Zai5pWwXG5leHBvcnQgY29uc3QgY3JlYXRlVUkgPSAoKSA9PiB7XG4gIC8vIOmHjeikh+WRvOOBs+WHuuOBl+Wvvuetljog5pei44GrVUnjgYznlJ/miJDmuIjjgb/jgarjgonlho3nlJ/miJDjgZfjgarjgYRcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFVJX0lEUy5BUFBfQ09OVEFJTkVSKSkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRFbGVtZW50OiBpZCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICB1cGRhdGVSZXN1bHRzR3JpZDogKGRhdGEpID0+IHVwZGF0ZVJlc3VsdHNHcmlkKGRhdGEsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFVJX0lEUy5SRVNVTFRTX0dSSUQpKSxcbiAgICAgIHVwZGF0ZURhdGFiYXNlVHJlZSxcbiAgICAgIHNob3dFcnJvcixcbiAgICAgIHNob3dTdWNjZXNzXG4gICAgfTtcbiAgfVxuICAvLyBIVE1M44GuYm9keeimgee0oOOCkuWPluW+l1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gIC8vIOODoeOCpOODs+OCs+ODs+ODhuODiuOCkuS9nOaIkFxuICBjb25zdCBhcHBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYXBwQ29udGFpbmVyLmlkID0gVUlfSURTLkFQUF9DT05UQUlORVI7XG4gIGFwcENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhcHAtY29udGFpbmVyJyk7XG5cbiAgLy8g44Oh44OL44Ol44O844OQ44O844KS5L2c5oiQXG4gIGNvbnN0IG1lbnVCYXIgPSBjcmVhdGVNZW51QmFyKCk7XG5cbiAgLy8g44Oh44Kk44Oz44Ko44Oq44Ki44Gu44Os44Kk44Ki44Km44OI77yI44K144Kk44OJ44OQ44O844Go44Kz44Oz44OG44Oz44OE44Ko44Oq44Ki77yJ44KS5L2c5oiQXG4gIGNvbnN0IG1haW5MYXlvdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbWFpbkxheW91dC5jbGFzc0xpc3QuYWRkKCdtYWluLWxheW91dCcpO1xuXG4gIGNvbnN0IHNpZGViYXIgPSBjcmVhdGVTaWRlYmFyKCk7XG4gIGNvbnN0IG1haW5BcmVhID0gY3JlYXRlTWFpbkFyZWEoKTtcblxuICAvLyDjgrXjgqTjg4njg5Djg7zjgajjg6HjgqTjg7Pjgqjjg6rjgqLjga7plpPjgavjg4njg6njg4PjgrDlj6/og73jgarjgrnjg5fjg6rjg4Pjgr/jg7zjgpLov73liqBcbiAgLy8gc3BsaXR0ZXLjga7kvZzmiJDjg63jgrjjg4Pjgq/jgpLlpJbpg6jjg6Ljgrjjg6Xjg7zjg6vlkbzjgbPlh7rjgZfjgavlpInmm7RcbiAgY29uc3Qgc3BsaXR0ZXIgPSBjcmVhdGVTcGxpdHRlcihzaWRlYmFyKTtcblxuICAvLyDjg6zjgqTjgqLjgqbjg4jopoHntKDjgavpoIbnlarjgavov73liqBcbiAgbWFpbkxheW91dC5hcHBlbmRDaGlsZChzaWRlYmFyKTtcbiAgbWFpbkxheW91dC5hcHBlbmRDaGlsZChzcGxpdHRlcik7XG4gIG1haW5MYXlvdXQuYXBwZW5kQ2hpbGQobWFpbkFyZWEpO1xuXG4gIC8vIOOCueODhuODvOOCv+OCueODkOODvOOCkuS9nOaIkFxuICBjb25zdCBzdGF0dXNCYXIgPSBjcmVhdGVTdGF0dXNCYXIoKTtcblxuICAvLyDopoHntKDjgpLov73liqBcbiAgYXBwQ29udGFpbmVyLmFwcGVuZENoaWxkKG1lbnVCYXIpO1xuICBhcHBDb250YWluZXIuYXBwZW5kQ2hpbGQobWFpbkxheW91dCk7XG4gIGFwcENvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0dXNCYXIpO1xuICBib2R5LmFwcGVuZENoaWxkKGFwcENvbnRhaW5lcik7XG5cbiAgLy8g44Kq44OW44K444Kn44Kv44OI44KS6L+U44GZXG4gIHJldHVybiB7XG4gICAgZ2V0RWxlbWVudDogKGlkKSA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgdXBkYXRlUmVzdWx0c0dyaWQ6IChkYXRhKSA9PiB1cGRhdGVSZXN1bHRzR3JpZChkYXRhLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChVSV9JRFMuUkVTVUxUU19HUklEKSksXG4gICAgdXBkYXRlRGF0YWJhc2VUcmVlOiAoc2NoZW1hKSA9PiB1cGRhdGVEYXRhYmFzZVRyZWUoc2NoZW1hKSxcbiAgICBzaG93RXJyb3I6IChtZXNzYWdlKSA9PiBzaG93RXJyb3IobWVzc2FnZSksXG4gICAgc2hvd1N1Y2Nlc3M6IChtZXNzYWdlKSA9PiBzaG93U3VjY2VzcyhtZXNzYWdlKVxuICB9O1xufTtcblxuLy8g44Oh44Kk44Oz44Kz44Oz44OG44Oz44OE44Ko44Oq44Ki44KS5L2c5oiQ44GZ44KL6Zai5pWwXG5jb25zdCBjcmVhdGVNYWluQXJlYSA9ICgpID0+IHtcbiAgY29uc3QgbWFpbkFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbWFpbkFyZWEuaWQgPSBVSV9JRFMuTUFJTl9BUkVBO1xuICBtYWluQXJlYS5jbGFzc0xpc3QuYWRkKCdtYWluLWFyZWEnKTtcblxuICAvLyDjgq/jgqjjg6rjgr/jg5bjgrPjg7Pjg4bjg4rjgpLkvZzmiJBcbiAgY29uc3QgcXVlcnlUYWJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHF1ZXJ5VGFicy5pZCA9IFVJX0lEUy5RVUVSWV9UQUJTO1xuICBxdWVyeVRhYnMuY2xhc3NMaXN0LmFkZCgncXVlcnktdGFicycpO1xuICAvLyDliJ3mnJ/jgr/jg5bjgpLov73liqBcbiAgY29uc3QgaW5pdGlhbFRhYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbml0aWFsVGFiLmNsYXNzTGlzdC5hZGQoJ3F1ZXJ5LXRhYicsICdhY3RpdmUnKTtcbiAgaW5pdGlhbFRhYi5kYXRhc2V0LnRhYklkID0gJ3F1ZXJ5MSc7XG4gIGluaXRpYWxUYWIudGV4dENvbnRlbnQgPSAnUXVlcnkxJztcbiAgcXVlcnlUYWJzLmFwcGVuZENoaWxkKGluaXRpYWxUYWIpO1xuXG4gIGNvbnN0IHF1ZXJ5RWRpdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHF1ZXJ5RWRpdG9yLmlkID0gVUlfSURTLlFVRVJZX0VESVRPUjtcbiAgcXVlcnlFZGl0b3IuY2xhc3NMaXN0LmFkZCgncXVlcnktZWRpdG9yJyk7XG4gIGNvbnN0IGVkaXRvclRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgZWRpdG9yVGV4dGFyZWEuaWQgPSAnc3FsLWVkaXRvcic7XG4gIGVkaXRvclRleHRhcmVhLnBsYWNlaG9sZGVyID0gJ1NRTOOCr+OCqOODquOCkuWFpeWKm+OBl+OBpuOBj+OBoOOBleOBhCc7XG4gIGVkaXRvclRleHRhcmVhLnZhbHVlID0gJyc7XG4gIHF1ZXJ5RWRpdG9yLmFwcGVuZENoaWxkKGVkaXRvclRleHRhcmVhKTtcblxuICBtYWluQXJlYS5hcHBlbmRDaGlsZChxdWVyeVRhYnMpO1xuICBtYWluQXJlYS5hcHBlbmRDaGlsZChxdWVyeUVkaXRvcik7XG5cbiAgLy8g44Kv44Ko44Oq44Ko44OH44Kj44K/44Go57WQ5p6c6KGo56S644K744Kv44K344On44Oz6ZaT44Gu5rC05bmz44K544OX44Oq44OD44K/44O8XG4gIC8vIHJvd1NwbGl0dGVy44Gu5L2c5oiQ44Ot44K444OD44Kv44KS5aSW6YOo44Oi44K444Ol44O844Or5ZG844Gz5Ye644GX44Gr5aSJ5pu0XG4gIGNvbnN0IHJvd1NwbGl0dGVyID0gY3JlYXRlUm93U3BsaXR0ZXIocXVlcnlFZGl0b3IpO1xuICBtYWluQXJlYS5hcHBlbmRDaGlsZChyb3dTcGxpdHRlcik7XG5cbiAgLy8g57WQ5p6c6KGo56S644K/44OWIChSZXN1bHRzL01lc3NhZ2VzKSDjgpIgSW1hZ2VzTm90RXhpc3RzLmpzIOOBi+OCieS9nOaIkFxuICBjb25zdCB7IHJlc3VsdHNUYWJzLCByZXN1bHRzR3JpZCwgbWVzc2FnZXNBcmVhIH0gPSBjcmVhdGVSZXN1bHRzU2VjdGlvbigpO1xuICBtYWluQXJlYS5hcHBlbmRDaGlsZChyZXN1bHRzVGFicyk7XG4gIG1haW5BcmVhLmFwcGVuZENoaWxkKHJlc3VsdHNHcmlkKTtcbiAgbWFpbkFyZWEuYXBwZW5kQ2hpbGQobWVzc2FnZXNBcmVhKTtcblxuICByZXR1cm4gbWFpbkFyZWE7XG59O1xuXG4vLyBsb2NhbCB1cGRhdGVSZXN1bHRzR3JpZCBpbXBsZW1lbnRhdGlvbiByZW1vdmVkOyB1c2luZyBleHRlcm5hbCBSZXN1bHRzIG1vZHVsZSIsImltcG9ydCB7IFVJX0lEUyB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuLy8gUmVzdWx0cyDjgaggTWVzc2FnZXMg44Gu44K744Kv44K344On44Oz44KS5L2c5oiQXG5leHBvcnQgY29uc3QgY3JlYXRlUmVzdWx0c1NlY3Rpb24gPSAoKSA9PiB7XG4gIGNvbnN0IHJlc3VsdHNUYWJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHJlc3VsdHNUYWJzLmNsYXNzTGlzdC5hZGQoJ3Jlc3VsdHMtdGFicycpO1xuICBjb25zdCByZXNUYWIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcmVzVGFiLmNsYXNzTGlzdC5hZGQoJ3Jlc3VsdC10YWInLCAnYWN0aXZlJyk7XG4gIHJlc1RhYi50ZXh0Q29udGVudCA9ICdSZXN1bHRzJztcbiAgY29uc3QgbXNnVGFiID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG1zZ1RhYi5jbGFzc0xpc3QuYWRkKCdyZXN1bHQtdGFiJyk7XG4gIG1zZ1RhYi50ZXh0Q29udGVudCA9ICdNZXNzYWdlcyc7XG4gIHJlc3VsdHNUYWJzLmFwcGVuZENoaWxkKHJlc1RhYik7XG4gIHJlc3VsdHNUYWJzLmFwcGVuZENoaWxkKG1zZ1RhYik7XG5cbiAgLy8g44Kw44Oq44OD44OJ44Ko44Oq44KiXG4gIGNvbnN0IHJlc3VsdHNHcmlkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHJlc3VsdHNHcmlkLmlkID0gVUlfSURTLlJFU1VMVFNfR1JJRDtcbiAgcmVzdWx0c0dyaWQuY2xhc3NMaXN0LmFkZCgncmVzdWx0cy1ncmlkJyk7XG4gIC8vIERhdGFUYWJsZXMg55So44GuIHRhYmxlIOimgee0oOOCkuW4uOOBq+eUqOaEj1xuICBjb25zdCByZXN1bHRzVGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICByZXN1bHRzVGFibGUuaWQgPSAncmVzdWx0cy10YWJsZSc7XG4gIC8vIERhdGFUYWJsZXPjga7jgrnjgr/jgqTjg6vjgpLpgannlKjjgZnjgovjgq/jg6njgrnjgpLov73liqBcbiAgcmVzdWx0c1RhYmxlLmNsYXNzTGlzdC5hZGQoJ2Rpc3BsYXknLCAnZGF0YVRhYmxlJyk7XG4gIC8vIOWIneacn+eKtuaFi+OBp+epuuOBrnRib2R544KS5L2c5oiQ44GX44Gm44GK44GPXG4gIGNvbnN0IGVtcHR5VGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xuICByZXN1bHRzVGFibGUuYXBwZW5kQ2hpbGQoZW1wdHlUYm9keSk7XG4gIHJlc3VsdHNHcmlkLmFwcGVuZENoaWxkKHJlc3VsdHNUYWJsZSk7XG5cbiAgY29uc3QgbWVzc2FnZXNBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG1lc3NhZ2VzQXJlYS5pZCA9ICdtZXNzYWdlcy1hcmVhJztcbiAgbWVzc2FnZXNBcmVhLmNsYXNzTGlzdC5hZGQoJ21lc3NhZ2VzLWFyZWEnKTtcbiAgbWVzc2FnZXNBcmVhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgcmV0dXJuIHsgcmVzdWx0c1RhYnMsIHJlc3VsdHNHcmlkLCBtZXNzYWdlc0FyZWEgfTtcbn07XG5cbi8vIOikh+aVsFJlc3VsdHPjgr/jg5bjg7vjg4bjg7zjg5bjg6vov73liqDnlKhcbmV4cG9ydCBjb25zdCBhZGRSZXN1bHRzID0gKGxhYmVsLCB0YWJsZUlkID0gbnVsbCkgPT4ge1xuICBjb25zdCB0YWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlc3VsdHMtdGFicycpO1xuICBjb25zdCByZXN1bHRzR3JpZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFVJX0lEUy5SRVNVTFRTX0dSSUQpO1xuICBpZiAoIXRhYnMgfHwgIXJlc3VsdHNHcmlkKSByZXR1cm47XG5cbiAgLy8g44K/44OW5L2c5oiQXG4gIGNvbnN0IHJlc1RhYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICByZXNUYWIuY2xhc3NMaXN0LmFkZCgncmVzdWx0LXRhYicpO1xuICByZXNUYWIudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgcmVzVGFiLmRhdGFzZXQucmVzdWx0c0lkID0gdGFibGVJZCB8fCBgcmVzdWx0cy10YWJsZS0ke2xhYmVsfWA7XG4gIC8vIE1lc3NhZ2Vz44K/44OW44Gu55u05YmN44Gr5oy/5YWlXG4gIGNvbnN0IG1zZ1RhYiA9IHRhYnMucXVlcnlTZWxlY3RvcignLnJlc3VsdC10YWI6bGFzdC1jaGlsZCcpO1xuICB0YWJzLmluc2VydEJlZm9yZShyZXNUYWIsIG1zZ1RhYik7XG5cbiAgLy8g44OG44O844OW44Or5L2c5oiQXG4gIGNvbnN0IHJlc3VsdHNUYWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gIHJlc3VsdHNUYWJsZS5pZCA9IHJlc1RhYi5kYXRhc2V0LnJlc3VsdHNJZDtcbiAgcmVzdWx0c1RhYmxlLmNsYXNzTGlzdC5hZGQoJ2Rpc3BsYXknLCAnZGF0YVRhYmxlJyk7XG4gIHJlc3VsdHNUYWJsZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBjb25zdCBlbXB0eVRib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgcmVzdWx0c1RhYmxlLmFwcGVuZENoaWxkKGVtcHR5VGJvZHkpO1xuICByZXN1bHRzR3JpZC5hcHBlbmRDaGlsZChyZXN1bHRzVGFibGUpO1xuXG4gIC8vIOacgOWIneOBrui/veWKoOaZguOBr2FjdGl2ZeOBq1xuICBpZiAodGFicy5xdWVyeVNlbGVjdG9yQWxsKCcucmVzdWx0LXRhYicpLmxlbmd0aCA9PT0gMykge1xuICAgIHRhYnMucXVlcnlTZWxlY3RvckFsbCgnLnJlc3VsdC10YWInKS5mb3JFYWNoKHQgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKSk7XG4gICAgcmVzVGFiLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgIEFycmF5LmZyb20ocmVzdWx0c0dyaWQuY2hpbGRyZW4pLmZvckVhY2godGJsID0+IHRibC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcbiAgICByZXN1bHRzVGFibGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9XG4gIHJldHVybiByZXN1bHRzVGFibGU7XG59O1xuXG4vLyBSZXN1bHRzL01lc3NhZ2VzIOOCv+ODluWIh+OCiuabv+OBiOOBruOCpOODmeODs+ODiOOCkuOCu+ODg+ODiOOCouODg+ODl1xuZXhwb3J0IGNvbnN0IHNldHVwUmVzdWx0c01lc3NhZ2VzVG9nZ2xlID0gKCkgPT4ge1xuICBjb25zdCB0YWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlc3VsdHMtdGFicycpO1xuICBpZiAoIXRhYnMpIHJldHVybjtcbiAgdGFicy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgY29uc3QgdGFiID0gZS50YXJnZXQuY2xvc2VzdCgnLnJlc3VsdC10YWInKTtcbiAgICBpZiAoIXRhYikgcmV0dXJuO1xuICAgIHRhYnMucXVlcnlTZWxlY3RvckFsbCgnLnJlc3VsdC10YWInKS5mb3JFYWNoKHQgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKSk7XG4gICAgdGFiLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgIGNvbnN0IHJlc3VsdHNHcmlkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVUlfSURTLlJFU1VMVFNfR1JJRCk7XG4gICAgY29uc3QgbWVzc2FnZXNBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lc3NhZ2VzLWFyZWEnKTtcbiAgICBpZiAodGFiLnRleHRDb250ZW50ID09PSAnTWVzc2FnZXMnKSB7XG4gICAgICByZXN1bHRzR3JpZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgbWVzc2FnZXNBcmVhLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0c0dyaWQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgbWVzc2FnZXNBcmVhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAvLyDopIfmlbDjg4bjg7zjg5bjg6vliIfjgormm7/jgYhcbiAgICAgIEFycmF5LmZyb20ocmVzdWx0c0dyaWQuY2hpbGRyZW4pLmZvckVhY2godGJsID0+IHtcbiAgICAgICAgdGJsLnN0eWxlLmRpc3BsYXkgPSAodGJsLmlkID09PSB0YWIuZGF0YXNldC5yZXN1bHRzSWQpID8gJycgOiAnbm9uZSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTsiLCJpbXBvcnQgeyBVSV9JRFMgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7IC8vIFVwZGF0ZWQgaW1wb3J0IHBhdGhcblxuLy8g44Oh44OL44Ol44O844OQ44O844KS5L2c5oiQ44GZ44KL6Zai5pWwXG5leHBvcnQgY29uc3QgY3JlYXRlTWVudUJhciA9ICgpID0+IHtcbiAgY29uc3QgbWVudUJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBtZW51QmFyLmlkID0gVUlfSURTLk1FTlVfQkFSO1xuICBtZW51QmFyLmNsYXNzTGlzdC5hZGQoJ21lbnUtYmFyJyk7XG5cbiAgLy8g44OV44Kh44Kk44Or44Oh44OL44Ol44O844Kw44Or44O844OXXG4gIGNvbnN0IGZpbGVHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmaWxlR3JvdXAuY2xhc3NMaXN0LmFkZCgnbWVudS1ncm91cCcpO1xuXG4gIC8vIOaWsOimj+ODh+ODvOOCv+ODmeODvOOCueODnOOCv+ODs1xuICBjb25zdCBuZXdEYkJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICBuZXdEYkJ1dHRvbi5pZCA9ICduZXctZGItYnV0dG9uJztcbiAgbmV3RGJCdXR0b24uY2xhc3NMaXN0LmFkZCgnbWVudS1idXR0b24nKTtcbiAgbmV3RGJCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZFwiPmRhdGFiYXNlPC9zcGFuPiDmlrDopo9EQic7XG5cbiAgLy8gRELjgpLplovjgY/jg5zjgr/jg7NcbiAgY29uc3Qgb3BlbkRiQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gIG9wZW5EYkJ1dHRvbi5pZCA9ICdvcGVuLWRiLWJ1dHRvbic7XG4gIG9wZW5EYkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtZW51LWJ1dHRvbicpO1xuICBvcGVuRGJCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZFwiPmRhdGFiYXNlX3VwbG9hZDwvc3Bhbj4g6ZaL44GPJztcblxuICAvLyDkv53lrZjjg5zjgr/jg7NcbiAgY29uc3Qgc2F2ZURiQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gIHNhdmVEYkJ1dHRvbi5pZCA9ICdzYXZlLWRiLWJ1dHRvbic7XG4gIHNhdmVEYkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtZW51LWJ1dHRvbicpO1xuICBzYXZlRGJCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZFwiPnNhdmU8L3NwYW4+IOS/neWtmCc7XG5cbiAgLy8g44Kv44Ko44Oq44Oh44OL44Ol44O844Kw44Or44O844OXXG4gIGNvbnN0IHF1ZXJ5R3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcXVlcnlHcm91cC5jbGFzc0xpc3QuYWRkKCdtZW51LWdyb3VwJyk7XG5cbiAgLy8g5paw6KaP44Kv44Ko44Oq44Oc44K/44OzXG4gIGNvbnN0IG5ld1F1ZXJ5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gIG5ld1F1ZXJ5QnV0dG9uLmlkID0gJ25ldy1xdWVyeS1idXR0b24nO1xuICBuZXdRdWVyeUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtZW51LWJ1dHRvbicpO1xuICBuZXdRdWVyeUJ1dHRvbi5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJtYXRlcmlhbC1zeW1ib2xzLW91dGxpbmVkXCI+cG9zdF9hZGQ8L3NwYW4+IOaWsOimj1F1ZXJ5JztcblxuICAvLyDjgq/jgqjjg6rjgpLplovjgY/jg5zjgr/jg7NcbiAgY29uc3Qgb3BlblF1ZXJ5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gIG9wZW5RdWVyeUJ1dHRvbi5pZCA9ICdvcGVuLXF1ZXJ5LWJ1dHRvbic7XG4gIG9wZW5RdWVyeUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtZW51LWJ1dHRvbicpO1xuICBvcGVuUXVlcnlCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZFwiPmZvbGRlcl9vcGVuPC9zcGFuPiBRdWVyeeOCkumWi+OBjyc7XG5cbiAgLy8g5L+d5a2Y44Oc44K/44OzXG4gIGNvbnN0IHNhdmVRdWVyeUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICBzYXZlUXVlcnlCdXR0b24uaWQgPSAnc2F2ZS1xdWVyeS1idXR0b24nO1xuICBzYXZlUXVlcnlCdXR0b24uY2xhc3NMaXN0LmFkZCgnbWVudS1idXR0b24nKTtcbiAgc2F2ZVF1ZXJ5QnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cIm1hdGVyaWFsLXN5bWJvbHMtb3V0bGluZWRcIj5zYXZlPC9zcGFuPiBRdWVyeeOCkuS/neWtmCc7XG5cbiAgLy8g5a6f6KGM44Oc44K/44OzXG4gIGNvbnN0IHJ1bkJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICBydW5CdXR0b24uaWQgPSAncnVuLWJ1dHRvbic7XG4gIHJ1bkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtZW51LWJ1dHRvbicpO1xuICBydW5CdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZFwiPnBsYXlfYXJyb3c8L3NwYW4+IOWun+ihjCc7XG5cbiAgLy8g6KaB57Sg44KS6L+95YqgXG4gIGZpbGVHcm91cC5hcHBlbmRDaGlsZChuZXdEYkJ1dHRvbik7XG4gIGZpbGVHcm91cC5hcHBlbmRDaGlsZChvcGVuRGJCdXR0b24pO1xuICBmaWxlR3JvdXAuYXBwZW5kQ2hpbGQoc2F2ZURiQnV0dG9uKTtcbiAgcXVlcnlHcm91cC5hcHBlbmRDaGlsZChuZXdRdWVyeUJ1dHRvbik7XG4gIHF1ZXJ5R3JvdXAuYXBwZW5kQ2hpbGQob3BlblF1ZXJ5QnV0dG9uKTtcbiAgcXVlcnlHcm91cC5hcHBlbmRDaGlsZChzYXZlUXVlcnlCdXR0b24pO1xuICBxdWVyeUdyb3VwLmFwcGVuZENoaWxkKHJ1bkJ1dHRvbik7XG5cbiAgbWVudUJhci5hcHBlbmRDaGlsZChmaWxlR3JvdXApO1xuICBtZW51QmFyLmFwcGVuZENoaWxkKHF1ZXJ5R3JvdXApO1xuXG4gIHJldHVybiBtZW51QmFyO1xufTsiLCJpbXBvcnQgeyBVSV9JRFMgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7IC8vIFVwZGF0ZWQgaW1wb3J0IHBhdGhcblxuLy8g44Ko44Op44O844Oh44OD44K744O844K444KS6KGo56S644GZ44KL6Zai5pWwXG5leHBvcnQgY29uc3Qgc2hvd0Vycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgY29uc3Qgc3RhdHVzQmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVUlfSURTLlNUQVRVU19CQVIpO1xuICBjb25zdCBkYlN0YXR1c0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RiLXN0YXR1cycpO1xuICBjb25zdCBjdXJyZW50RGJOYW1lID0gZGJTdGF0dXNFbCA/IGRiU3RhdHVzRWwudGV4dENvbnRlbnQgOiAnJztcbiAgc3RhdHVzQmFyLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwic3RhdHVzLWVycm9yXCI+JHttZXNzYWdlfTwvZGl2PmA7XG5cbiAgLy8gNeenkuW+jOOBq+OCueODhuODvOOCv+OCueODkOODvOOCkuOCr+ODquOColxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBzdGF0dXNCYXIuaW5uZXJIVE1MID0gYDxkaXYgaWQ9XCJkYi1zdGF0dXNcIiBjbGFzcz1cInN0YXR1cy1pdGVtXCI+JHtjdXJyZW50RGJOYW1lfTwvZGl2PmA7XG4gIH0sIDUwMDApO1xufTtcblxuLy8g5oiQ5Yqf44Oh44OD44K744O844K444KS6KGo56S644GZ44KL6Zai5pWwXG5leHBvcnQgY29uc3Qgc2hvd1N1Y2Nlc3MgPSAobWVzc2FnZSkgPT4ge1xuICBjb25zdCBzdGF0dXNCYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChVSV9JRFMuU1RBVFVTX0JBUik7XG4gIGNvbnN0IGRiU3RhdHVzRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGItc3RhdHVzJyk7XG4gIGNvbnN0IGN1cnJlbnREYk5hbWUgPSBkYlN0YXR1c0VsID8gZGJTdGF0dXNFbC50ZXh0Q29udGVudCA6ICcnO1xuICBzdGF0dXNCYXIuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJzdGF0dXMtc3VjY2Vzc1wiPiR7bWVzc2FnZX08L2Rpdj5gO1xuXG4gIC8vIDPnp5Llvozjgavjgrnjg4bjg7zjgr/jgrnjg5Djg7zjgpLjgq/jg6rjgqJcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgc3RhdHVzQmFyLmlubmVySFRNTCA9IGA8ZGl2IGlkPVwiZGItc3RhdHVzXCIgY2xhc3M9XCJzdGF0dXMtaXRlbVwiPiR7Y3VycmVudERiTmFtZX08L2Rpdj5gO1xuICB9LCAzMDAwKTtcbn07IiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCB7IFVJX0lEUyB9IGZyb20gJy4vY29uc3RhbnRzLmpzJzsgLy8gVXBkYXRlZCBpbXBvcnQgcGF0aFxuLy8gRGF0YVRhYmxlc+ODl+ODqeOCsOOCpOODs+OCkuWIneacn+WMllxuaW1wb3J0ICdkYXRhdGFibGVzLm5ldC1kdCc7XG5pbXBvcnQgJ2RhdGF0YWJsZXMubmV0LWR0L2Nzcy9kYXRhVGFibGVzLmRhdGFUYWJsZXMubWluLmNzcyc7XG4vLyBGaXhlZEhlYWRlcuaLoeW8teapn+iDvVxuaW1wb3J0ICdkYXRhdGFibGVzLm5ldC1maXhlZGhlYWRlci1kdCc7XG5pbXBvcnQgJ2RhdGF0YWJsZXMubmV0LWZpeGVkaGVhZGVyLWR0L2Nzcy9maXhlZEhlYWRlci5kYXRhVGFibGVzLm1pbi5jc3MnO1xuY29uc3QgRGF0YVRhYmxlID0gJC5mbi5EYXRhVGFibGU7XG5cbi8vIOe1kOaenOOCsOODquODg+ODieOCkuabtOaWsOOBmeOCi+mWouaVsO+8iHRhYmxlSWTmjIflrprlr77lv5zvvIlcbmV4cG9ydCBjb25zdCB1cGRhdGVSZXN1bHRzR3JpZCA9IChkYXRhLCB0YWJsZUlkID0gJ3Jlc3VsdHMtdGFibGUnKSA9PiB7XG4gIGlmICghZGF0YSB8fCAhZGF0YS5yZXN1bHRzKSByZXR1cm47XG4gIC8vIOODhuODvOODluODq+OCkuWPluW+l+OBl+OBpuS4rei6q+OCkuOCr+ODquOColxuICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhYmxlSWQpO1xuICBpZiAoIXRhYmxlKSByZXR1cm47XG4gIC8vIOODmOODg+ODgOODvOOBqOODnOODh+OCo+OCkuS9nOOCiuebtOOBl1xuICB0YWJsZS5pbm5lckhUTUwgPSAnJztcbiAgLy8gdGhlYWRcbiAgY29uc3QgdGhlYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aGVhZCcpO1xuICBjb25zdCBoZWFkZXJSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICBkYXRhLmNvbHVtbnMuZm9yRWFjaChjb2wgPT4ge1xuICAgIGNvbnN0IHRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcbiAgICB0aC50ZXh0Q29udGVudCA9IGNvbDtcbiAgICBoZWFkZXJSb3cuYXBwZW5kQ2hpbGQodGgpO1xuICB9KTtcbiAgdGhlYWQuYXBwZW5kQ2hpbGQoaGVhZGVyUm93KTtcbiAgdGFibGUuYXBwZW5kQ2hpbGQodGhlYWQpO1xuICAvLyB0Ym9keVxuICBjb25zdCB0Ym9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG4gIGRhdGEucmVzdWx0cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgIGRhdGEuY29sdW1ucy5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICBjb25zdCB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICB0ZC50ZXh0Q29udGVudCA9IHJvd1tjb2xdICE9IG51bGwgPyByb3dbY29sXSA6ICcnO1xuICAgICAgdHIuYXBwZW5kQ2hpbGQodGQpO1xuICAgIH0pO1xuICAgIHRib2R5LmFwcGVuZENoaWxkKHRyKTtcbiAgfSk7XG4gIHRhYmxlLmFwcGVuZENoaWxkKHRib2R5KTtcbn07IiwiaW1wb3J0IHsgVUlfSURTIH0gZnJvbSAnLi9jb25zdGFudHMuanMnOyAvLyBVcGRhdGVkIGltcG9ydCBwYXRoXG5cbi8vIOOCteOCpOODieODkOODvO+8iOODh+ODvOOCv+ODmeODvOOCueODhOODquODvOODk+ODpeODvO+8ieOCkuS9nOaIkOOBmeOCi+mWouaVsFxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNpZGViYXIgPSAoKSA9PiB7XG4gIGNvbnN0IHNpZGViYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2lkZWJhci5pZCA9IFVJX0lEUy5TSURFQkFSO1xuICBzaWRlYmFyLmNsYXNzTGlzdC5hZGQoJ3NpZGViYXInKTtcblxuICBjb25zdCB0cmVlVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdHJlZVRpdGxlLmNsYXNzTGlzdC5hZGQoJ3RyZWUtdGl0bGUnKTtcbiAgdHJlZVRpdGxlLnRleHRDb250ZW50ID0gJ0RhdGFiYXNlcyc7XG5cbiAgLy8g5pu05paw44Oc44K/44OzXG4gIGNvbnN0IHJlZnJlc2hCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgcmVmcmVzaEJ1dHRvbi5pZCA9ICdyZWZyZXNoLWRiLWJ1dHRvbic7XG4gIHJlZnJlc2hCdXR0b24uY2xhc3NMaXN0LmFkZCgnbWVudS1idXR0b24nKTtcbiAgcmVmcmVzaEJ1dHRvbi5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJtYXRlcmlhbC1zeW1ib2xzLW91dGxpbmVkXCI+cmVmcmVzaDwvc3Bhbj4nOyAvLyDjgqLjgqTjgrPjg7PlpInmm7RcbiAgdHJlZVRpdGxlLmFwcGVuZENoaWxkKHJlZnJlc2hCdXR0b24pO1xuICBzaWRlYmFyLmFwcGVuZENoaWxkKHRyZWVUaXRsZSk7XG5cbiAgY29uc3QgdHJlZVZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdHJlZVZpZXcuaWQgPSBVSV9JRFMuREJfVFJFRTtcbiAgdHJlZVZpZXcuY2xhc3NMaXN0LmFkZCgndHJlZS12aWV3Jyk7XG4gIHNpZGViYXIuYXBwZW5kQ2hpbGQodHJlZVZpZXcpO1xuXG4gIHJldHVybiBzaWRlYmFyO1xufTtcblxuLy8g44OH44O844K/44OZ44O844K544OE44Oq44O844OT44Ol44O844KS5pu05paw44GZ44KL6Zai5pWwXG5leHBvcnQgY29uc3QgdXBkYXRlRGF0YWJhc2VUcmVlID0gKHNjaGVtYSkgPT4ge1xuICBjb25zdCB0cmVlVmlldyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFVJX0lEUy5EQl9UUkVFKTtcbiAgdHJlZVZpZXcuaW5uZXJIVE1MID0gJyc7XG4gIGlmICghc2NoZW1hKSByZXR1cm47XG5cbiAgY29uc3QgZGJJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRiSXRlbS5jbGFzc0xpc3QuYWRkKCd0cmVlLWl0ZW0nLCAnZXhwYW5kZWQnKTtcblxuICAvLyBEYXRhYmFzZeOBr+S4gOOBpOOBoOOBkeOBquOBruOBp+OAgeOBk+OBrumajuWxpOOBr+ecgeeVpVxuICAvLyBjb25zdCBkYkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIC8vIGRiTGFiZWwuY2xhc3NMaXN0LmFkZCgndHJlZS1sYWJlbCcpO1xuICAvLyAvLyDjg4fjg5Xjgqnjg6vjg4jjga/mipjjgornlbPjgb8o4oqeKeOAgeOCr+ODquODg+OCr+OBp+WxlemWi1xuICAvLyBkYkxhYmVsLmlubmVySFRNTCA9IGA8aSBjbGFzcz1cInRvZ2dsZS1pY29uXCI+4oqePC9pPjxpIGNsYXNzPVwiaWNvblwiPvCfk4I8L2k+IFVudGl0bGVkLmRiYDtcbiAgLy8gLy8g44Kv44Oq44OD44Kv44Gn44Kw44Or44O844OX6KGo56S644Gu44OI44Kw44OrXG4gIC8vIGRiTGFiZWwuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAvLyBkYkxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAvLyAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkYkl0ZW0uY2hpbGRyZW4pLnNsaWNlKDEpO1xuICAvLyAgIGNoaWxkcmVuLmZvckVhY2gobm9kZSA9PiBub2RlLnN0eWxlLmRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogJ25vbmUnKTtcbiAgLy8gICAvLyDjg4jjgrDjg6vjgqLjgqTjgrPjg7PjgpLmm7TmlrBcbiAgLy8gICBjb25zdCBpc0NvbGxhcHNlZCA9IGNoaWxkcmVuWzBdLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJztcbiAgLy8gICBkYkxhYmVsLnF1ZXJ5U2VsZWN0b3IoJy50b2dnbGUtaWNvbicpLnRleHRDb250ZW50ID0gaXNDb2xsYXBzZWQgPyAn4oqeJyA6ICfiip8nO1xuICAvLyB9KTtcbiAgLy8gZGJJdGVtLmFwcGVuZENoaWxkKGRiTGFiZWwpO1xuXG4gIGNvbnN0IHRhYmxlc0dyb3VwID0gY3JlYXRlVHJlZUdyb3VwKCdUYWJsZXMnLCBzY2hlbWEudGFibGVzIHx8IFtdLCAndGFibGUnKTsgLy8g44Ki44Kk44Kz44Oz5ZCN5aSJ5pu0XG4gIGNvbnN0IHZpZXdzR3JvdXAgPSBjcmVhdGVUcmVlR3JvdXAoJ1ZpZXdzJywgc2NoZW1hLnZpZXdzIHx8IFtdLCAnZGF0YXNldCcpOyAvLyDjgqLjgqTjgrPjg7PlkI3lpInmm7RcbiAgY29uc3QgaW5kZXhlc0dyb3VwID0gY3JlYXRlVHJlZUdyb3VwKCdJbmRleGVzJywgc2NoZW1hLmluZGV4ZXMgfHwgW10sICd0YWJsZV9yb3dzX25hcnJvdycpOyAvLyDjgqLjgqTjgrPjg7PlkI3lpInmm7RcbiAgY29uc3QgdHJpZ2dlcnNHcm91cCA9IGNyZWF0ZVRyZWVHcm91cCgnVHJpZ2dlcnMnLCBzY2hlbWEudHJpZ2dlcnMgfHwgW10sICdib2x0Jyk7IC8vIOOCouOCpOOCs+ODs+WQjeWkieabtFxuXG4gIC8vIOODhuOCueODiOOBp+imgee0oOOCkuWPr+imluOBq+OBmeOCi+OBn+OCgeOAgeWFqOOCsOODq+ODvOODl+OCkuWIneacn+WxlemWi1xuICBbdGFibGVzR3JvdXAsIHZpZXdzR3JvdXAsIGluZGV4ZXNHcm91cCwgdHJpZ2dlcnNHcm91cF0uZm9yRWFjaChncm91cCA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBncm91cC5xdWVyeVNlbGVjdG9yKCcudHJlZS1pdGVtcycpO1xuICAgIGl0ZW1zLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICBncm91cC5xdWVyeVNlbGVjdG9yKCcudG9nZ2xlLWljb24nKS50ZXh0Q29udGVudCA9ICdleHBhbmRfbW9yZSc7IC8vIOOCouOCpOOCs+ODs+WkieabtFxuICB9KTtcblxuICBkYkl0ZW0uYXBwZW5kQ2hpbGQodGFibGVzR3JvdXApO1xuICBkYkl0ZW0uYXBwZW5kQ2hpbGQodmlld3NHcm91cCk7XG4gIGRiSXRlbS5hcHBlbmRDaGlsZChpbmRleGVzR3JvdXApO1xuICBkYkl0ZW0uYXBwZW5kQ2hpbGQodHJpZ2dlcnNHcm91cCk7XG5cbiAgdHJlZVZpZXcuYXBwZW5kQ2hpbGQoZGJJdGVtKTtcbn07XG5cbi8vIOODhOODquODvOODk+ODpeODvOOBruOCsOODq+ODvOODl+OCkuS9nOaIkOOBmeOCi+ODmOODq+ODkeODvOmWouaVsFxuY29uc3QgY3JlYXRlVHJlZUdyb3VwID0gKHRpdGxlLCBpdGVtcywgaWNvbk5hbWUpID0+IHsgLy8g5byV5pWw5ZCN44KSIGljb24gLT4gaWNvbk5hbWUg44Gr5aSJ5pu0XG4gIGNvbnN0IGdyb3VwQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGdyb3VwQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3RyZWUtZ3JvdXAnKTtcblxuICBjb25zdCBncm91cExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGdyb3VwTGFiZWwuY2xhc3NMaXN0LmFkZCgndHJlZS1sYWJlbCcsYCR7dGl0bGV9LXJvb3RgKTtcbiAgLy8g44OH44OV44Kp44Or44OI44Gv5oqY44KK55Wz44G/KGNoZXZyb25fcmlnaHQp44CB44Kv44Oq44OD44Kv44Gn5bGV6ZaLXG4gIGdyb3VwTGFiZWwuaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtc3ltYm9scy1vdXRsaW5lZCB0b2dnbGUtaWNvblwiPmNoZXZyb25fcmlnaHQ8L3NwYW4+PHNwYW4gY2xhc3M9XCJtYXRlcmlhbC1zeW1ib2xzLW91dGxpbmVkIGljb25cIj4ke2ljb25OYW1lfTwvc3Bhbj4gJHt0aXRsZX1gOyAvLyDjgqLjgqTjgrPjg7PlpInmm7RcbiAgZ3JvdXBDb250YWluZXIuYXBwZW5kQ2hpbGQoZ3JvdXBMYWJlbCk7XG5cbiAgY29uc3QgaXRlbXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaXRlbXNDb250YWluZXIuY2xhc3NMaXN0LmFkZCgndHJlZS1pdGVtcycpO1xuICAvLyDliJ3mnJ/jga/mipjjgornlbPjgb9cbiAgaXRlbXNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGNvbnN0IGl0ZW1FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaXRlbUVsZW0uY2xhc3NMaXN0LmFkZCgndHJlZS1pdGVtJyk7XG4gICAgaXRlbUVsZW0uaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XFxcInRyZWUtbGFiZWwgJHt0aXRsZX1cXFwiIGRhdGEtbmFtZT1cXFwiJHtpdGVtfVxcXCI+PHNwYW4gY2xhc3M9XFxcIm1hdGVyaWFsLXN5bWJvbHMtb3V0bGluZWQgaWNvblxcXCI+JHtpY29uTmFtZX08L3NwYW4+ICR7aXRlbX08L2Rpdj5gOyAvLyDjgqLjgqTjgrPjg7PlpInmm7RcbiAgICBpdGVtc0NvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtRWxlbSk7XG4gIH0pO1xuXG4gIGdyb3VwQ29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zQ29udGFpbmVyKTtcbiAgLy8g44Kv44Oq44OD44Kv44Gn44Ki44Kk44OG44Og44Gu6KGo56S6L+mdnuihqOekuuOCkuODiOOCsOODq+OBl+OAgeOCouOCpOOCs+ODs+WIh+OCiuabv+OBiFxuICBncm91cExhYmVsLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgZ3JvdXBMYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBjb25zdCBpc0NvbGxhcHNlZCA9IGl0ZW1zQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJztcbiAgICBpdGVtc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gaXNDb2xsYXBzZWQgPyAnJyA6ICdub25lJztcbiAgICBncm91cExhYmVsLnF1ZXJ5U2VsZWN0b3IoJy50b2dnbGUtaWNvbicpLnRleHRDb250ZW50ID0gaXNDb2xsYXBzZWQgPyAnZXhwYW5kX21vcmUnIDogJ2NoZXZyb25fcmlnaHQnOyAvLyDjgqLjgqTjgrPjg7PlpInmm7RcbiAgfSk7XG4gIHJldHVybiBncm91cENvbnRhaW5lcjtcbn07IiwiaW1wb3J0IHsgVUlfSURTIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG4vLyDjgrnjg4bjg7zjgr/jgrnjg5Djg7zjgpLkvZzmiJDjgZnjgovplqLmlbBcbmV4cG9ydCBjb25zdCBjcmVhdGVTdGF0dXNCYXIgPSAoKSA9PiB7XG4gIGNvbnN0IHN0YXR1c0JhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzdGF0dXNCYXIuaWQgPSBVSV9JRFMuU1RBVFVTX0JBUjtcbiAgc3RhdHVzQmFyLmNsYXNzTGlzdC5hZGQoJ3N0YXR1cy1iYXInKTtcblxuICBjb25zdCBkYlN0YXR1cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkYlN0YXR1cy5pZCA9ICdkYi1zdGF0dXMnO1xuICBkYlN0YXR1cy5jbGFzc0xpc3QuYWRkKCdzdGF0dXMtaXRlbScpO1xuICBkYlN0YXR1cy50ZXh0Q29udGVudCA9ICdVbnRpdGxlZC5kYic7XG5cbiAgc3RhdHVzQmFyLmFwcGVuZENoaWxkKGRiU3RhdHVzKTtcbiAgcmV0dXJuIHN0YXR1c0Jhcjtcbn07IiwiLy8gY29uc3RhbnRzLmpzIC0gVUnopoHntKDjga5JROOCkuWumue+qeOBmeOCi+ODouOCuOODpeODvOODq1xuXG5leHBvcnQgY29uc3QgVUlfSURTID0ge1xuICBBUFBfQ09OVEFJTkVSOiAnYXBwLWNvbnRhaW5lcicsXG4gIE1FTlVfQkFSOiAnbWVudS1iYXInLFxuICBTSURFQkFSOiAnc2lkZWJhcicsXG4gIE1BSU5fQVJFQTogJ21haW4tYXJlYScsXG4gIFFVRVJZX1RBQlM6ICdxdWVyeS10YWJzJyxcbiAgUVVFUllfRURJVE9SOiAncXVlcnktZWRpdG9yJyxcbiAgUkVTVUxUU19HUklEOiAncmVzdWx0cy1ncmlkJyxcbiAgU1RBVFVTX0JBUjogJ3N0YXR1cy1iYXInLFxuICBEQl9UUkVFOiAnZGItdHJlZSdcbn07XG4iLCIvLyByb3dTcGxpdHRlci5qcyAtIOawtOW5s+OCueODl+ODquODg+OCv+ODvOimgee0oOOCkuS9nOaIkOOBmeOCi+ODouOCuOODpeODvOODq1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUm93U3BsaXR0ZXIgPSAocXVlcnlFZGl0b3JFbGVtZW50KSA9PiB7XG4gIGNvbnN0IHJvd1NwbGl0dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHJvd1NwbGl0dGVyLmNsYXNzTGlzdC5hZGQoJ3Jvdy1zcGxpdHRlcicpO1xuXG4gIHJvd1NwbGl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGUuY2xpZW50WTtcbiAgICAvLyBxdWVyeUVkaXRvckVsZW1lbnQg44KS55u05o6l5Y+C54Wn44GZ44KL44KI44GG44Gr5aSJ5pu0XG4gICAgY29uc3Qgc3RhcnRIZWlnaHQgPSBxdWVyeUVkaXRvckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGUyKSA9PiB7XG4gICAgICBjb25zdCBkeSA9IGUyLmNsaWVudFkgLSBzdGFydFk7XG4gICAgICBxdWVyeUVkaXRvckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7c3RhcnRIZWlnaHQgKyBkeX1weGA7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvd1NwbGl0dGVyO1xufTtcbiIsIi8vIHNwbGl0dGVyLmpzIC0g44K544OX44Oq44OD44K/44O86KaB57Sg44KS5L2c5oiQ44GZ44KL44Oi44K444Ol44O844OrXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTcGxpdHRlciA9IChzaWRlYmFyRWxlbWVudCkgPT4ge1xuICBjb25zdCBzcGxpdHRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzcGxpdHRlci5jbGFzc0xpc3QuYWRkKCdzcGxpdHRlcicpO1xuXG4gIHNwbGl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGUyKSA9PiB7XG4gICAgICAvLyBzaWRlYmFyRWxlbWVudCDjgpLnm7TmjqXlj4LnhafjgZnjgovjgojjgYbjgavlpInmm7RcbiAgICAgIHNpZGViYXJFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7ZTIuY2xpZW50WH1weGA7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNwbGl0dGVyO1xufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIi4vY2h1bmsvXCIgKyBjaHVua0lkICsgXCIuXCIgKyB7XCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19zcWxpdGVfb3JnX3NxbGl0ZS13YXNtX3NxbGl0ZS13YXNtX2pzd2FzbV9zcWxpdGUzLW9wZnMtYXN5bmMtcHJveHlfanNcIjpcIjYyNDA0MDQ0Mzc1NmU0M2Y3ZDk5XCIsXCJ2ZW5kb3JzLW5vZGVfbW9kdWxlc19zcWxpdGVfb3JnX3NxbGl0ZS13YXNtX3NxbGl0ZS13YXNtX2pzd2FzbV9zcWxpdGUzLXdvcmtlcjEtYnVuZGxlci1mcmllbmRseV9tanNcIjpcImI5NGM2Y2RkZTNmNzU1ODcxYzNkXCJ9W2NodW5rSWRdICsgXCIuanNcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGkgPSBzY3JpcHRzLmxlbmd0aCAtIDE7XG5cdFx0XHR3aGlsZSAoaSA+IC0xICYmICghc2NyaXB0VXJsIHx8ICEvXmh0dHAocz8pOi8udGVzdChzY3JpcHRVcmwpKSkgc2NyaXB0VXJsID0gc2NyaXB0c1tpLS1dLnNyYztcblx0XHR9XG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvXmJsb2I6LywgXCJcIikucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIl9fd2VicGFja19yZXF1aXJlX18uYiA9IGRvY3VtZW50LmJhc2VVUkkgfHwgc2VsZi5sb2NhdGlvbi5ocmVmO1xuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwibWFpblwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIG5vIGpzb25wIGZ1bmN0aW9uIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCIvLyBTUUxpdGUgU2FtcGxlIC0gU1FM44Kv44Op44Kk44Ki44Oz44OI44Ki44OX44Oq44Kx44O844K344On44OzXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0ICcuLi9jc3MvYXBwLmNzcyc7XG4vLyBEYXRhVGFibGVz44Gu44K544K/44Kk44Or44KS44OQ44Oz44OJ44Or77yIYXBwLmNzc+OBruW+jOOBq+iqreOBv+i+vOOCgO+8iVxuaW1wb3J0ICdkYXRhdGFibGVzLm5ldC1kdC9jc3MvZGF0YVRhYmxlcy5kYXRhVGFibGVzLm1pbi5jc3MnO1xuaW1wb3J0ICdkYXRhdGFibGVzLm5ldC1maXhlZGhlYWRlci1kdC9jc3MvZml4ZWRIZWFkZXIuZGF0YVRhYmxlcy5taW4uY3NzJztcbmltcG9ydCB7IGNyZWF0ZVVJIH0gZnJvbSAnLi91aS5qcyc7XG5pbXBvcnQgeyBzZXR1cEV2ZW50SGFuZGxlcnMgfSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgU1FMaXRlTWFuYWdlciBmcm9tICcuL1NRTGl0ZU1hbmFnZXIuanMnO1xuaW1wb3J0IFRhYk1hbmFnZXIgZnJvbSAnLi90YWJNYW5hZ2VyLmpzJztcbmltcG9ydCB7IHNldHVwUmVzdWx0c01lc3NhZ2VzVG9nZ2xlIH0gZnJvbSAnLi91aS9JbWFnZXNOb3RFeGlzdHMuanMnOyAvLyBJbXBvcnQgYWRkZWRcblxuLy8gRGF0YVRhYmxlc+ODl+ODqeOCsOOCpOODs+OBruWIneacn+WMllxud2luZG93LiQgPSB3aW5kb3cualF1ZXJ5ID0gJDtcbmNvbnNvbGUubG9nKCfjg5bjg6njgqbjgrbnkrDlooPjgadEYXRhVGFibGVz44KS5Yid5pyf5YyW44GX44G+44GX44GfJyk7XG5cbi8vIOOCouODl+ODquOCseODvOOCt+ODp+ODs+OBruODoeOCpOODs+OCqOODs+ODiOODquODneOCpOODs+ODiFxuY29uc3QgbWFpbiA9IGFzeW5jICgpID0+IHtcbiAgY29uc29sZS5sb2coJ1NRTGl0ZSBTYW1wbGXjgqLjg5fjg6rjgrHjg7zjgrfjg6fjg7PjgpLotbfli5XkuK0uLi4nKTtcbiAgLy8g44OW44Op44Km44K255Kw5aKD44Gn44Gu44G/VUnjgpLlhYjooYzjgZfjgabliJ3mnJ/ljJZcbiAgbGV0IHVpID0gbnVsbDtcbiAgbGV0IHRhYk1hbmFnZXIgPSBudWxsO1xuICB1aSA9IGNyZWF0ZVVJKCk7XG4gIHRhYk1hbmFnZXIgPSBuZXcgVGFiTWFuYWdlcih7XG4gICAgY29udGFpbmVySWQ6ICdxdWVyeS10YWJzJyxcbiAgICBlZGl0b3JJZDogJ3NxbC1lZGl0b3InLFxuICAgIHJlc3VsdHNJZDogJ3Jlc3VsdHMtZ3JpZCcsXG4gICAgbWVzc2FnZXNJZDogJ21lc3NhZ2VzLWFyZWEnXG4gIH0pO1xuXG4gIC8vIOWNs+aZguODkOOCpOODs+ODiTog5paw6KaPUXVlcnnjg5zjgr/jg7Pjgafjgr/jg5bov73liqBcbiAgY29uc3QgbmV3UXVlcnlCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV3LXF1ZXJ5LWJ1dHRvbicpO1xuICBpZiAobmV3UXVlcnlCdG4pIHtcbiAgICBuZXdRdWVyeUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRhYk1hbmFnZXIuYWRkVGFiKCdRdWVyeScpKTtcbiAgfVxuICAvLyDljbPmmYLjg5DjgqTjg7Pjg4k6IFJlc3VsdHMvTWVzc2FnZXPjgr/jg5bliIfjgormm7/jgYhcbiAgc2V0dXBSZXN1bHRzTWVzc2FnZXNUb2dnbGUoKTsgLy8gUmVwbGFjZWQgdGhlIGV2ZW50IGxpc3RlbmVyIGJsb2NrIHdpdGggdGhpcyBmdW5jdGlvbiBjYWxsXG5cbiAgLy8g44OH44O844K/44OZ44O844K55qmf6IO944KSIFNRTGl0ZU1hbmFnZXIg44Gn44K744OD44OI44Ki44OD44OXIChwcmludCwgcHJpbnRFcnIg44KS5oyH5a6aKVxuICBjb25zdCBkYiA9IGF3YWl0IFNRTGl0ZU1hbmFnZXIuaW5pdGlhbGl6ZShudWxsLCB7IHByaW50OiBjb25zb2xlLmxvZywgcHJpbnRFcnI6IGNvbnNvbGUuZXJyb3IgfSk7XG4gIC8vIOODluODqeOCpuOCtueSsOWig+OBp+OBr+OCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOWIneacn0RC6KGo56S644KS44K744OD44OI44Ki44OD44OXXG4gIHNldHVwRXZlbnRIYW5kbGVycyh1aSwgZGIsIHRhYk1hbmFnZXIpO1xuICBkYi5leGVjdXRlUXVlcnkoYENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIHRlc3QgKGNvbDEgSU5URUdFUiBQUklNQVJZIEtFWSwgY29sMiBURVhUKWApO1xuICBkYi5leGVjdXRlUXVlcnkoYElOU0VSVCBPUiBJR05PUkUgSU5UTyB0ZXN0IChjb2wxLCBjb2wyKSBWQUxVRVMgKDEsICcxMTEnKWApO1xuICBkYi5leGVjdXRlUXVlcnkoYElOU0VSVCBPUiBJR05PUkUgSU5UTyB0ZXN0IChjb2wxLCBjb2wyKSBWQUxVRVMgKDIsICcyMjInKWApO1xuICAvLyDjgrnjgq3jg7zjg57lj5blvpfjgajjg4Tjg6rjg7zjg5Pjg6Xjg7zmm7TmlrBcbiAgY29uc3Qgc2NoZW1hID0gZGIuZ2V0RGF0YWJhc2VTY2hlbWEoKTtcbiAgdWkudXBkYXRlRGF0YWJhc2VUcmVlKHNjaGVtYSk7XG5cbiAgY29uc29sZS5sb2coJ1NRTGl0ZSBTYW1wbGXjga7otbfli5XjgYzlrozkuobjgZfjgb7jgZfjgZ/vvIEnKTtcbn07XG5cbi8vIOOCouODl+ODquOCseODvOOCt+ODp+ODs+OCkuWun+ihjFxuKGFzeW5jICgpID0+IHtcbiAgYXdhaXQgbWFpbigpO1xufSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=