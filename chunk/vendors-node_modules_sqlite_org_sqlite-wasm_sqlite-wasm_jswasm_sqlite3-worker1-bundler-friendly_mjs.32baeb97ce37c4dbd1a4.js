(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 ** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.
 **
 ** This bundle (typically released as sqlite3.js or sqlite3.mjs)
 ** is an amalgamation of JavaScript source code from two projects:
 **
 ** 1) https://emscripten.org: the Emscripten "glue code" is covered by
 **    the terms of the MIT license and University of Illinois/NCSA
 **    Open Source License, as described at:
 **
 **    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html
 **
 ** 2) https://sqlite.org: all code and documentation labeled as being
 **    from this source are released under the same terms as the sqlite3
 **    C library:
 **
 ** 2022-10-16
 **
 ** The author disclaims copyright to this source code.  In place of a
 ** legal notice, here is a blessing:
 **
 ** *   May you do good and not evil.
 ** *   May you find forgiveness for yourself and forgive others.
 ** *   May you share freely, never taking more than you give.
 */
/*
 ** This code was built from sqlite3 version...
 **
 ** SQLITE_VERSION "3.45.3"
 ** SQLITE_VERSION_NUMBER 3045003
 ** SQLITE_SOURCE_ID "2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355"
 **
 ** Using the Emscripten SDK version 3.1.30.
 */

var sqlite3InitModule = (() => {
  var _scriptDir = "file:///home/runner/work/SQLite-WebClient/SQLite-WebClient/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs";

  return function (config) {
    var sqlite3InitModule = config || {};

    var Module =
      typeof sqlite3InitModule != 'undefined' ? sqlite3InitModule : {};

    var readyPromiseResolve, readyPromiseReject;
    Module['ready'] = new Promise(function (resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });

    const sqlite3InitModuleState =
      globalThis.sqlite3InitModuleState ||
      Object.assign(Object.create(null), {
        debugModule: () => {},
      });
    delete globalThis.sqlite3InitModuleState;
    sqlite3InitModuleState.debugModule(
      'globalThis.location =',
      globalThis.location,
    );

    const xNameOfInstantiateWasm =  false
      ? 0
      : 'emscripten-bug-17951';
    Module[xNameOfInstantiateWasm] = function callee(imports, onSuccess) {
      imports.env.foo = function () {};
      const uri = Module.locateFile(
        callee.uri,
        'undefined' === typeof scriptDirectory ? '' : scriptDirectory,
      );
      sqlite3InitModuleState.debugModule('instantiateWasm() uri =', uri);
      const wfetch = () => fetch(uri, { credentials: 'same-origin' });
      const loadWasm = WebAssembly.instantiateStreaming
        ? async () => {
            return WebAssembly.instantiateStreaming(wfetch(), imports).then(
              (arg) => onSuccess(arg.instance, arg.module),
            );
          }
        : async () => {
            return wfetch()
              .then((response) => response.arrayBuffer())
              .then((bytes) => WebAssembly.instantiate(bytes, imports))
              .then((arg) => onSuccess(arg.instance, arg.module));
          };
      loadWasm();
      return {};
    };

    Module[xNameOfInstantiateWasm].uri = 'sqlite3.wasm';

    var moduleOverrides = Object.assign({}, Module);

    var arguments_ = [];
    var thisProgram = './this.program';
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };

    var ENVIRONMENT_IS_WEB = typeof window == 'object';
    var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';

    var ENVIRONMENT_IS_NODE =
      typeof process == 'object' &&
      typeof process.versions == 'object' &&
      typeof process.versions.node == 'string';
    var ENVIRONMENT_IS_SHELL =
      !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

    var scriptDirectory = '';
    function locateFile(path) {
      if (Module['locateFile']) {
        return Module['locateFile'](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }

    var read_, readAsync, readBinary, setWindowTitle;

    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != 'undefined' && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }

      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }

      if (scriptDirectory.indexOf('blob:') !== 0) {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,
        );
      } else {
        scriptDirectory = '';
      }

      {
        read_ = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.send(null);
          return xhr.responseText;
        };

        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            xhr.responseType = 'arraybuffer';
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }

        readAsync = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = () => {
            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }

      setWindowTitle = (title) => (document.title = title);
    } else {
    }

    var out = Module['print'] || console.log.bind(console);
    var err = Module['printErr'] || console.warn.bind(console);

    Object.assign(Module, moduleOverrides);

    moduleOverrides = null;

    if (Module['arguments']) arguments_ = Module['arguments'];

    if (Module['thisProgram']) thisProgram = Module['thisProgram'];

    if (Module['quit']) quit_ = Module['quit'];

    var STACK_ALIGN = 16;
    var POINTER_SIZE = 4;

    function getNativeTypeSize(type) {
      switch (type) {
        case 'i1':
        case 'i8':
        case 'u8':
          return 1;
        case 'i16':
        case 'u16':
          return 2;
        case 'i32':
        case 'u32':
          return 4;
        case 'i64':
        case 'u64':
          return 8;
        case 'float':
          return 4;
        case 'double':
          return 8;
        default: {
          if (type[type.length - 1] === '*') {
            return POINTER_SIZE;
          }
          if (type[0] === 'i') {
            const bits = Number(type.substr(1));
            assert(
              bits % 8 === 0,
              'getNativeTypeSize invalid bits ' + bits + ', type ' + type,
            );
            return bits / 8;
          }
          return 0;
        }
      }
    }

    var wasmBinary;
    if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
    var noExitRuntime = Module['noExitRuntime'] || true;

    if (typeof WebAssembly != 'object') {
      abort('no native wasm support detected');
    }

    var wasmMemory;

    var ABORT = false;

    var EXITSTATUS;

    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }

    var UTF8Decoder =
      typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;

      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';

      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xe0) == 0xc0) {
          str += String.fromCharCode(((u0 & 31) << 6) | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xf0) == 0xe0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          u0 =
            ((u0 & 7) << 18) |
            (u1 << 12) |
            (u2 << 6) |
            (heapOrArray[idx++] & 63);
        }

        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(
            0xd800 | (ch >> 10),
            0xdc00 | (ch & 0x3ff),
          );
        }
      }
      return str;
    }

    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
    }

    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0)) return 0;

      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 0xd800 && u <= 0xdfff) {
          var u1 = str.charCodeAt(++i);
          u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);
        }
        if (u <= 0x7f) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7ff) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xc0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xffff) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xe0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 0xf0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        }
      }

      heap[outIdx] = 0;
      return outIdx - startIdx;
    }

    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }

    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 0x7f) {
          len++;
        } else if (c <= 0x7ff) {
          len += 2;
        } else if (c >= 0xd800 && c <= 0xdfff) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    }

    var HEAP,
      HEAP8,
      HEAPU8,
      HEAP16,
      HEAPU16,
      HEAP32,
      HEAPU32,
      HEAPF32,
      HEAP64,
      HEAPU64,
      HEAPF64;

    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module['HEAP8'] = HEAP8 = new Int8Array(b);
      Module['HEAP16'] = HEAP16 = new Int16Array(b);
      Module['HEAP32'] = HEAP32 = new Int32Array(b);
      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
      Module['HEAP64'] = HEAP64 = new BigInt64Array(b);
      Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);
    }

    var STACK_SIZE = 524288;

    var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;

    if (Module['wasmMemory']) {
      wasmMemory = Module['wasmMemory'];
    } else {
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_MEMORY / 65536,

        maximum: 2147483648 / 65536,
      });
    }

    updateMemoryViews();

    INITIAL_MEMORY = wasmMemory.buffer.byteLength;

    var wasmTable;

    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATEXIT__ = [];
    var __ATPOSTRUN__ = [];

    var runtimeInitialized = false;

    function keepRuntimeAlive() {
      return noExitRuntime;
    }

    function preRun() {
      if (Module['preRun']) {
        if (typeof Module['preRun'] == 'function')
          Module['preRun'] = [Module['preRun']];
        while (Module['preRun'].length) {
          addOnPreRun(Module['preRun'].shift());
        }
      }

      callRuntimeCallbacks(__ATPRERUN__);
    }

    function initRuntime() {
      runtimeInitialized = true;

      if (!Module['noFSInit'] && !FS.init.initialized) FS.init();
      FS.ignorePermissions = false;

      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }

    function postRun() {
      if (Module['postRun']) {
        if (typeof Module['postRun'] == 'function')
          Module['postRun'] = [Module['postRun']];
        while (Module['postRun'].length) {
          addOnPostRun(Module['postRun'].shift());
        }
      }

      callRuntimeCallbacks(__ATPOSTRUN__);
    }

    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }

    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }

    function addOnExit(cb) {}

    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }

    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;

    function getUniqueRunDependency(id) {
      return id;
    }

    function addRunDependency(id) {
      runDependencies++;

      if (Module['monitorRunDependencies']) {
        Module['monitorRunDependencies'](runDependencies);
      }
    }

    function removeRunDependency(id) {
      runDependencies--;

      if (Module['monitorRunDependencies']) {
        Module['monitorRunDependencies'](runDependencies);
      }

      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }

    function abort(what) {
      if (Module['onAbort']) {
        Module['onAbort'](what);
      }

      what = 'Aborted(' + what + ')';

      err(what);

      ABORT = true;
      EXITSTATUS = 1;

      what += '. Build with -sASSERTIONS for more info.';

      var e = new WebAssembly.RuntimeError(what);

      readyPromiseReject(e);

      throw e;
    }

    var dataURIPrefix = 'data:application/octet-stream;base64,';

    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }

    function isFileURI(filename) {
      return filename.startsWith('file://');
    }

    var wasmBinaryFile;
    if (Module['locateFile']) {
      wasmBinaryFile = 'sqlite3.wasm';
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
    } else {
      wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! sqlite3.wasm */ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm"), __webpack_require__.b).href;
    }

    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw 'both async and sync fetching of the wasm failed';
      } catch (err) {
        abort(err);
      }
    }

    function getBinaryPromise() {
      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
        if (typeof fetch == 'function') {
          return fetch(wasmBinaryFile, { credentials: 'same-origin' })
            .then(function (response) {
              if (!response['ok']) {
                throw (
                  "failed to load wasm binary file at '" + wasmBinaryFile + "'"
                );
              }
              return response['arrayBuffer']();
            })
            .catch(function () {
              return getBinary(wasmBinaryFile);
            });
        }
      }

      return Promise.resolve().then(function () {
        return getBinary(wasmBinaryFile);
      });
    }

    function createWasm() {
      var info = {
        env: asmLibraryArg,
        wasi_snapshot_preview1: asmLibraryArg,
      };

      function receiveInstance(instance, module) {
        var exports = instance.exports;

        Module['asm'] = exports;

        wasmTable = Module['asm']['__indirect_function_table'];

        addOnInit(Module['asm']['__wasm_call_ctors']);

        removeRunDependency('wasm-instantiate');
      }

      addRunDependency('wasm-instantiate');

      function receiveInstantiationResult(result) {
        receiveInstance(result['instance']);
      }

      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise()
          .then(function (binary) {
            return WebAssembly.instantiate(binary, info);
          })
          .then(function (instance) {
            return instance;
          })
          .then(receiver, function (reason) {
            err('failed to asynchronously prepare wasm: ' + reason);

            abort(reason);
          });
      }

      function instantiateAsync() {
        if (
          !wasmBinary &&
          typeof WebAssembly.instantiateStreaming == 'function' &&
          !isDataURI(wasmBinaryFile) &&
          typeof fetch == 'function'
        ) {
          return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(
            function (response) {
              var result = WebAssembly.instantiateStreaming(response, info);

              return result.then(receiveInstantiationResult, function (reason) {
                err('wasm streaming compile failed: ' + reason);
                err('falling back to ArrayBuffer instantiation');
                return instantiateArrayBuffer(receiveInstantiationResult);
              });
            },
          );
        } else {
          return instantiateArrayBuffer(receiveInstantiationResult);
        }
      }

      if (Module['instantiateWasm']) {
        try {
          var exports = Module['instantiateWasm'](info, receiveInstance);
          return exports;
        } catch (e) {
          err('Module.instantiateWasm callback failed with error: ' + e);

          readyPromiseReject(e);
        }
      }

      instantiateAsync().catch(readyPromiseReject);
      return {};
    }

    var tempDouble;
    var tempI64;

    var ASM_CONSTS = {};

    function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = 'Program terminated with exit(' + status + ')';
      this.status = status;
    }

    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }

    function getValue(ptr, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1':
          return HEAP8[ptr >> 0];
        case 'i8':
          return HEAP8[ptr >> 0];
        case 'i16':
          return HEAP16[ptr >> 1];
        case 'i32':
          return HEAP32[ptr >> 2];
        case 'i64':
          return HEAP64[ptr >> 3];
        case 'float':
          return HEAPF32[ptr >> 2];
        case 'double':
          return HEAPF64[ptr >> 3];
        case '*':
          return HEAPU32[ptr >> 2];
        default:
          abort('invalid type for getValue: ' + type);
      }
      return null;
    }

    function setValue(ptr, value, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1':
          HEAP8[ptr >> 0] = value;
          break;
        case 'i8':
          HEAP8[ptr >> 0] = value;
          break;
        case 'i16':
          HEAP16[ptr >> 1] = value;
          break;
        case 'i32':
          HEAP32[ptr >> 2] = value;
          break;
        case 'i64':
          (tempI64 = [
            value >>> 0,
            ((tempDouble = value),
            +Math.abs(tempDouble) >= 1.0
              ? tempDouble > 0.0
                ? (Math.min(
                    +Math.floor(tempDouble / 4294967296.0),
                    4294967295.0,
                  ) |
                    0) >>>
                  0
                : ~~+Math.ceil(
                    (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                  ) >>> 0
              : 0),
          ]),
            (HEAP32[ptr >> 2] = tempI64[0]),
            (HEAP32[(ptr + 4) >> 2] = tempI64[1]);
          break;
        case 'float':
          HEAPF32[ptr >> 2] = value;
          break;
        case 'double':
          HEAPF64[ptr >> 3] = value;
          break;
        case '*':
          HEAPU32[ptr >> 2] = value;
          break;
        default:
          abort('invalid type for setValue: ' + type);
      }
    }

    var PATH = {
      isAbs: (path) => path.charAt(0) === '/',
      splitPath: (filename) => {
        var splitPathRe =
          /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts, allowAboveRoot) => {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }

        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },
      normalize: (path) => {
        var isAbsolute = PATH.isAbs(path),
          trailingSlash = path.substr(-1) === '/';

        path = PATH.normalizeArray(
          path.split('/').filter((p) => !!p),
          !isAbsolute,
        ).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },
      dirname: (path) => {
        var result = PATH.splitPath(path),
          root = result[0],
          dir = result[1];
        if (!root && !dir) {
          return '.';
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path) => {
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, '');
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash + 1);
      },
      join: function () {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join('/'));
      },
      join2: (l, r) => {
        return PATH.normalize(l + '/' + r);
      },
    };

    function getRandomDevice() {
      if (
        typeof crypto == 'object' &&
        typeof crypto['getRandomValues'] == 'function'
      ) {
        var randomBuffer = new Uint8Array(1);
        return () => {
          crypto.getRandomValues(randomBuffer);
          return randomBuffer[0];
        };
      } else return () => abort('randomDevice');
    }

    var PATH_FS = {
      resolve: function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : FS.cwd();

          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return '';
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }

        resolvedPath = PATH.normalizeArray(
          resolvedPath.split('/').filter((p) => !!p),
          !resolvedAbsolute,
        ).join('/');
        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
      },
      relative: (from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      },
    };

    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(
        stringy,
        u8array,
        0,
        u8array.length,
      );
      if (dontAddNull) u8array.length = numBytesWritten;
      return u8array;
    }
    var TTY = {
      ttys: [],
      init: function () {},
      shutdown: function () {},
      register: function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close: function (stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        fsync: function (stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        read: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        },
      },
      default_tty_ops: {
        get_char: function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (
              typeof window != 'undefined' &&
              typeof window.prompt == 'function'
            ) {
              result = window.prompt('Input: ');
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        fsync: function (tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
      default_tty1_ops: {
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        fsync: function (tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
    };

    function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
      return address;
    }

    function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
    function mmapAlloc(size) {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      return zeroMemory(ptr, size);
    }
    var MEMFS = {
      ops_table: null,
      mount: function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511, 0);
      },
      createNode: function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink,
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
              },
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync,
              },
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink,
              },
              stream: {},
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
              },
              stream: FS.chrdev_stream_ops,
            },
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;

          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();

        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray: function (node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage: function (node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return;

        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(
          newCapacity,
          (prevCapacity *
            (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>>
            0,
        );
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage: function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(
              oldContents.subarray(0, Math.min(newSize, node.usedBytes)),
            );
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr: function (node) {
          var attr = {};

          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);

          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr: function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function (parent, name) {
          throw FS.genericErrors[44];
        },
        mknod: function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename: function (old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {}
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }

          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },
        unlink: function (parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        rmdir: function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        readdir: function (node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },
        symlink: function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink: function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        },
      },
      stream_ops: {
        read: function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer[offset + i] = contents[position + i];
          }
          return size;
        },
        write: function (stream, buffer, offset, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }

          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();

          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(
                buffer.subarray(offset, offset + length),
                position,
              );
              return length;
            }
          }

          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position,
            );
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek: function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate: function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(
            stream.node.usedBytes,
            offset + length,
          );
        },
        mmap: function (stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;

          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length,
                );
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },
        msync: function (stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);

          return 0;
        },
      },
    };

    function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(
        url,
        (arrayBuffer) => {
          assert(
            arrayBuffer,
            'Loading data file "' + url + '" failed (no arrayBuffer).',
          );
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency(dep);
        },
        (event) => {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        },
      );
      if (dep) addRunDependency(dep);
    }

    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: '/',
      initialized: false,
      ignorePermissions: true,
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      lookupPath: (path, opts = {}) => {
        path = PATH_FS.resolve(path);

        if (!path) return { path: '', node: null };

        var defaults = {
          follow_mount: true,
          recurse_count: 0,
        };
        opts = Object.assign(defaults, opts);

        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }

        var parts = path.split('/').filter((p) => !!p);

        var current = FS.root;
        var current_path = '/';

        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }

          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);

          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }

          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);

              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count + 1,
              });
              current = lookup.node;

              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }

        return { path: current_path, node: current };
      },
      getPath: (node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length - 1] !== '/'
              ? mount + '/' + path
              : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },
      hashName: (parentid, name) => {
        var hash = 0;

        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },
      hashAddNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode: (parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }

        return FS.lookup(parent, name);
      },
      createNode: (parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);

        FS.hashAddNode(node);

        return node;
      },
      destroyNode: (node) => {
        FS.hashRemoveNode(node);
      },
      isRoot: (node) => {
        return node === node.parent;
      },
      isMountpoint: (node) => {
        return !!node.mounted;
      },
      isFile: (mode) => {
        return (mode & 61440) === 32768;
      },
      isDir: (mode) => {
        return (mode & 61440) === 16384;
      },
      isLink: (mode) => {
        return (mode & 61440) === 40960;
      },
      isChrdev: (mode) => {
        return (mode & 61440) === 8192;
      },
      isBlkdev: (mode) => {
        return (mode & 61440) === 24576;
      },
      isFIFO: (mode) => {
        return (mode & 61440) === 4096;
      },
      isSocket: (mode) => {
        return (mode & 49152) === 49152;
      },
      flagModes: { r: 0, 'r+': 2, w: 577, 'w+': 578, a: 1089, 'a+': 1090 },
      modeStringToFlags: (str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },
      flagsToPermissionString: (flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if (flag & 512) {
          perms += 'w';
        }
        return perms;
      },
      nodePermissions: (node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }

        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup: (dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
      mayCreate: (dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {}
        return FS.nodePermissions(dir, 'wx');
      },
      mayDelete: (dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen: (node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStream: (fd) => FS.streams[fd],
      createStream: (stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = function () {
            this.shared = {};
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function () {
                return this.node;
              },

              set: function (val) {
                this.node = val;
              },
            },
            isRead: {
              get: function () {
                return (this.flags & 2097155) !== 1;
              },
            },
            isWrite: {
              get: function () {
                return (this.flags & 2097155) !== 0;
              },
            },
            isAppend: {
              get: function () {
                return this.flags & 1024;
              },
            },
            flags: {
              get: function () {
                return this.shared.flags;
              },

              set: function (val) {
                this.shared.flags = val;
              },
            },
            position: {
              get: function () {
                return this.shared.position;
              },

              set: function (val) {
                this.shared.position = val;
              },
            },
          });
        }

        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream: (fd) => {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: (stream) => {
          var device = FS.getDevice(stream.node.rdev);

          stream.stream_ops = device.stream_ops;

          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: () => {
          throw new FS.ErrnoError(70);
        },
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 0xff,
      makedev: (ma, mi) => (ma << 8) | mi,
      registerDevice: (dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts: (mount) => {
        var mounts = [];
        var check = [mount];

        while (check.length) {
          var m = check.pop();

          mounts.push(m);

          check.push.apply(check, m.mounts);
        }

        return mounts;
      },
      syncfs: (populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }

        FS.syncFSRequests++;

        if (FS.syncFSRequests > 1) {
          err(
            'warning: ' +
              FS.syncFSRequests +
              ' FS.syncfs operations in flight at once, probably just doing extra work',
          );
        }

        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;

        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }

        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }

        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: (type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;

        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

          mountpoint = lookup.path;
          node = lookup.node;

          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }

          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }

        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: [],
        };

        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;

        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;

          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }

        return mountRoot;
      },
      unmount: (mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }

        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);

        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];

          while (current) {
            var next = current.name_next;

            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }

            current = next;
          }
        });

        node.mounted = null;

        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: (parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },
      mknod: (path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create: (path, mode) => {
        mode = mode !== undefined ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
      mkdir: (path, mode) => {
        mode = mode !== undefined ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
      mkdirTree: (path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20) throw e;
          }
        }
      },
      mkdev: (path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
      symlink: (oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename: (old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);

        var lookup, old_dir, new_dir;

        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;

        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);

        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }

        var old_node = FS.lookupNode(old_dir, old_name);

        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }

        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }

        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {}

        if (old_node === new_node) {
          return;
        }

        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        errCode = new_node
          ? FS.mayDelete(new_dir, new_name, isdir)
          : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (
          FS.isMountpoint(old_node) ||
          (new_node && FS.isMountpoint(new_node))
        ) {
          throw new FS.ErrnoError(10);
        }

        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }

        FS.hashRemoveNode(old_node);

        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir: (path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
      readdir: (path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink: (path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
      readlink: (path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(
          FS.getPath(link.parent),
          link.node_ops.readlink(link),
        );
      },
      stat: (path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat: (path) => {
        return FS.stat(path, true);
      },
      chmod: (path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now(),
        });
      },
      lchmod: (path, mode) => {
        FS.chmod(path, mode, true);
      },
      fchmod: (fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },
      chown: (path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now(),
        });
      },
      lchown: (path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },
      fchown: (fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },
      truncate: (path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now(),
        });
      },
      ftruncate: (fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime: (path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime),
        });
      },
      open: (path, flags, mode) => {
        if (path === '') {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 : mode;
        if (flags & 64) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072),
            });
            node = lookup.node;
          } catch (e) {}
        }

        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }

        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }

        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }

        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }

        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }

        flags &= ~(128 | 512 | 131072);

        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,

          ungotten: [],
          error: false,
        });

        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
      close: (stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed: (stream) => {
        return stream.fd === null;
      },
      llseek: (stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read: (stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(
          stream,
          buffer,
          offset,
          length,
          position,
        );
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
      write: (stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(
          stream,
          buffer,
          offset,
          length,
          position,
          canOwn,
        );
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate: (stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap: (stream, length, position, prot, flags) => {
        if (
          (prot & 2) !== 0 &&
          (flags & 2) === 0 &&
          (stream.flags & 2097155) !== 2
        ) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
      msync: (stream, buffer, offset, length, mmapFlags) => {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(
          stream,
          buffer,
          offset,
          length,
          mmapFlags,
        );
      },
      munmap: (stream) => 0,
      ioctl: (stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile: (path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile: (path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },
      cwd: () => FS.currentPath,
      chdir: (path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: () => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },
      createDefaultDevices: () => {
        FS.mkdir('/dev');

        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));

        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));

        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);

        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },
      createSpecialDirectories: () => {
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount(
          {
            mount: () => {
              var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73);
              node.node_ops = {
                lookup: (parent, name) => {
                  var fd = +name;
                  var stream = FS.getStream(fd);
                  if (!stream) throw new FS.ErrnoError(8);
                  var ret = {
                    parent: null,
                    mount: { mountpoint: 'fake' },
                    node_ops: { readlink: () => stream.path },
                  };
                  ret.parent = ret;
                  return ret;
                },
              };
              return node;
            },
          },
          {},
          '/proc/self/fd',
        );
      },
      createStandardStreams: () => {
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }

        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },
      ensureErrnoError: () => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function (errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;

        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },
      staticInit: () => {
        FS.ensureErrnoError();

        FS.nameTable = new Array(4096);

        FS.mount(MEMFS, {}, '/');

        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();

        FS.filesystems = {
          MEMFS: MEMFS,
        };
      },
      init: (input, output, error) => {
        FS.init.initialized = true;

        FS.ensureErrnoError();

        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];

        FS.createStandardStreams();
      },
      quit: () => {
        FS.init.initialized = false;

        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      getMode: (canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },
      findObject: (path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath: (path, dontResolveLastLink) => {
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {}
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null,
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        }
        return ret;
      },
      createPath: (parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {}
          parent = current;
        }
        return current;
      },
      createFile: (parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(
          typeof parent == 'string' ? parent : FS.getPath(parent),
          name,
        );
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
      createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i)
              arr[i] = data.charCodeAt(i);
            data = arr;
          }

          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },
      createDevice: (parent, name, input, output) => {
        var path = PATH.join2(
          typeof parent == 'string' ? parent : FS.getPath(parent),
          name,
        );
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);

        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          },
        });
        return FS.mkdev(path, mode, dev);
      },
      forceLoadFile: (obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error(
            'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.',
          );
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },
      createLazyFile: (parent, name, url, canRead, canWrite) => {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize) | 0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter =
          function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
        LazyUint8Array.prototype.cacheLength =
          function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (
              !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
            )
              throw new Error(
                "Couldn't load " + url + '. Status: ' + xhr.status,
              );
            var datalength = Number(xhr.getResponseHeader('Content-length'));
            var header;
            var hasByteServing =
              (header = xhr.getResponseHeader('Accept-Ranges')) &&
              header === 'bytes';
            var usesGzip =
              (header = xhr.getResponseHeader('Content-Encoding')) &&
              header === 'gzip';

            var chunkSize = 1024 * 1024;

            if (!hasByteServing) chunkSize = datalength;

            var doXHR = (from, to) => {
              if (from > to)
                throw new Error(
                  'invalid range (' +
                    from +
                    ', ' +
                    to +
                    ') or no bytes requested!',
                );
              if (to > datalength - 1)
                throw new Error(
                  'only ' + datalength + ' bytes available! programmer error!',
                );

              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize)
                xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);

              xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }

              xhr.send(null);
              if (
                !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
              )
                throw new Error(
                  "Couldn't load " + url + '. Status: ' + xhr.status,
                );
              if (xhr.response !== undefined) {
                return new Uint8Array(xhr.response || []);
              }
              return intArrayFromString(xhr.responseText || '', true);
            };
            var lazyArray = this;
            lazyArray.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray.chunks[chunkNum] == 'undefined')
                throw new Error('doXHR failed!');
              return lazyArray.chunks[chunkNum];
            });

            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out(
                'LazyFiles on gzip forces download of the whole file when length is accessed',
              );
            }

            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER)
            throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              },
            },
            chunkSize: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              },
            },
          });

          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }

        var node = FS.createFile(parent, name, properties, canRead, canWrite);

        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }

        Object.defineProperties(node, {
          usedBytes: {
            get: function () {
              return this.contents.length;
            },
          },
        });

        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length) return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }

        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position);
        };

        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr: ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
      createPreloadedFile: (
        parent,
        name,
        url,
        canRead,
        canWrite,
        onload,
        onerror,
        dontCreateFile,
        canOwn,
        preFinish,
      ) => {
        var fullname = name
          ? PATH_FS.resolve(PATH.join2(parent, name))
          : parent;
        var dep = getUniqueRunDependency('cp ' + fullname);
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(
                parent,
                name,
                byteArray,
                canRead,
                canWrite,
                canOwn,
              );
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (
            Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
              if (onerror) onerror();
              removeRunDependency(dep);
            })
          ) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },
      indexedDB: () => {
        return (
          window.indexedDB ||
          window.mozIndexedDB ||
          window.webkitIndexedDB ||
          window.msIndexedDB
        );
      },
      DB_NAME: () => {
        return 'EM_FS_' + window.location.pathname;
      },
      DB_VERSION: 20,
      DB_STORE_NAME: 'FILE_DATA',
      saveFilesToDB: (paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(
              FS.analyzePath(path).object.contents,
              path,
            );
            putRequest.onsuccess = () => {
              ok++;
              if (ok + fail == total) finish();
            };
            putRequest.onerror = () => {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      loadFilesFromDB: (paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch (e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(
                PATH.dirname(path),
                PATH.basename(path),
                getRequest.result,
                true,
                true,
                true,
              );
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt: function (dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }

        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },
      doStat: function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (
            e &&
            e.node &&
            PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))
          ) {
            return -54;
          }
          throw e;
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[(buf + 8) >> 2] = stat.ino;
        HEAP32[(buf + 12) >> 2] = stat.mode;
        HEAPU32[(buf + 16) >> 2] = stat.nlink;
        HEAP32[(buf + 20) >> 2] = stat.uid;
        HEAP32[(buf + 24) >> 2] = stat.gid;
        HEAP32[(buf + 28) >> 2] = stat.rdev;
        (tempI64 = [
          stat.size >>> 0,
          ((tempDouble = stat.size),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 40) >> 2] = tempI64[0]),
          (HEAP32[(buf + 44) >> 2] = tempI64[1]);
        HEAP32[(buf + 48) >> 2] = 4096;
        HEAP32[(buf + 52) >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        (tempI64 = [
          Math.floor(atime / 1000) >>> 0,
          ((tempDouble = Math.floor(atime / 1000)),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 56) >> 2] = tempI64[0]),
          (HEAP32[(buf + 60) >> 2] = tempI64[1]);
        HEAPU32[(buf + 64) >> 2] = (atime % 1000) * 1000;
        (tempI64 = [
          Math.floor(mtime / 1000) >>> 0,
          ((tempDouble = Math.floor(mtime / 1000)),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 72) >> 2] = tempI64[0]),
          (HEAP32[(buf + 76) >> 2] = tempI64[1]);
        HEAPU32[(buf + 80) >> 2] = (mtime % 1000) * 1000;
        (tempI64 = [
          Math.floor(ctime / 1000) >>> 0,
          ((tempDouble = Math.floor(ctime / 1000)),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 88) >> 2] = tempI64[0]),
          (HEAP32[(buf + 92) >> 2] = tempI64[1]);
        HEAPU32[(buf + 96) >> 2] = (ctime % 1000) * 1000;
        (tempI64 = [
          stat.ino >>> 0,
          ((tempDouble = stat.ino),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[(buf + 104) >> 2] = tempI64[0]),
          (HEAP32[(buf + 108) >> 2] = tempI64[1]);
        return 0;
      },
      doMsync: function (addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
      varargs: undefined,
      get: function () {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
        return ret;
      },
      getStr: function (ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
      getStreamFromFD: function (fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },
    };
    function ___syscall_chmod(path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        FS.chmod(path, mode);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_faccessat(dirfd, path, amode, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (amode & ~7) {
          return -28;
        }
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_fchmod(fd, mode) {
      try {
        FS.fchmod(fd, mode);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_fchown32(fd, owner, group) {
      try {
        FS.fchown(fd, owner, group);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function setErrNo(value) {
      HEAP32[___errno_location() >> 2] = value;
      return value;
    }

    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = SYSCALLS.get();
            if (arg < 0) {
              return -28;
            }
            var newStream;
            newStream = FS.createStream(stream, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = SYSCALLS.get();
            stream.flags |= arg;
            return 0;
          }
          case 5: {
            var arg = SYSCALLS.get();
            var offset = 0;

            HEAP16[(arg + offset) >> 1] = 2;
            return 0;
          }
          case 6:
          case 7:
            return 0;
          case 16:
          case 8:
            return -28;
          case 9:
            setErrNo(28);
            return -1;
          default: {
            return -28;
          }
        }
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    var MAX_INT53 = 9007199254740992;

    var MIN_INT53 = -9007199254740992;
    function bigintToI53Checked(num) {
      return num < MIN_INT53 || num > MAX_INT53 ? NaN : Number(num);
    }

    function ___syscall_ftruncate64(fd, length) {
      try {
        length = bigintToI53Checked(length);
        if (isNaN(length)) return -61;
        FS.ftruncate(fd, length);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_getcwd(buf, size) {
      try {
        if (size === 0) return -28;
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
        if (size < cwdLengthInBytes) return -68;
        stringToUTF8(cwd, buf, size);
        return cwdLengthInBytes;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509:
          case 21505: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21519: {
            if (!stream.tty) return -59;
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty) return -59;
            return -28;
          }
          case 21531: {
            var argp = SYSCALLS.get();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21524: {
            if (!stream.tty) return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_lstat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.lstat, path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_mkdirat(dirfd, path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);

        path = PATH.normalize(path);
        if (path[path.length - 1] === '/')
          path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_newfstatat(dirfd, path, buf, flags) {
      try {
        path = SYSCALLS.getStr(path);
        var nofollow = flags & 256;
        var allowEmpty = flags & 4096;
        flags = flags & ~6400;
        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_openat(dirfd, path, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        var mode = varargs ? SYSCALLS.get() : 0;
        return FS.open(path, flags, mode).fd;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);

        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);

        HEAP8[buf + len] = endChar;
        return len;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_rmdir(path) {
      try {
        path = SYSCALLS.getStr(path);
        FS.rmdir(path);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_stat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function ___syscall_unlinkat(dirfd, path, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (flags === 0) {
          FS.unlink(path);
        } else if (flags === 512) {
          FS.rmdir(path);
        } else {
          abort('Invalid flags passed to unlinkat');
        }
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function readI53FromI64(ptr) {
      return HEAPU32[ptr >> 2] + HEAP32[(ptr + 4) >> 2] * 4294967296;
    }

    function ___syscall_utimensat(dirfd, path, times, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path, true);
        if (!times) {
          var atime = Date.now();
          var mtime = atime;
        } else {
          var seconds = readI53FromI64(times);
          var nanoseconds = HEAP32[(times + 8) >> 2];
          atime = seconds * 1000 + nanoseconds / (1000 * 1000);
          times += 16;
          seconds = readI53FromI64(times);
          nanoseconds = HEAP32[(times + 8) >> 2];
          mtime = seconds * 1000 + nanoseconds / (1000 * 1000);
        }
        FS.utime(path, atime, mtime);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    var nowIsMonotonic = true;
    function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

    function __isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }

    var __MONTH_DAYS_LEAP_CUMULATIVE = [
      0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335,
    ];

    var __MONTH_DAYS_REGULAR_CUMULATIVE = [
      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
    ];
    function __yday_from_date(date) {
      var isLeapYear = __isLeapYear(date.getFullYear());
      var monthDaysCumulative = isLeapYear
        ? __MONTH_DAYS_LEAP_CUMULATIVE
        : __MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;

      return yday;
    }
    function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time) * 1000);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();
      HEAP32[(tmPtr + 8) >> 2] = date.getHours();
      HEAP32[(tmPtr + 12) >> 2] = date.getDate();
      HEAP32[(tmPtr + 16) >> 2] = date.getMonth();
      HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;
      HEAP32[(tmPtr + 24) >> 2] = date.getDay();

      var yday = __yday_from_date(date) | 0;
      HEAP32[(tmPtr + 28) >> 2] = yday;
      HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);

      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst =
        (summerOffset != winterOffset &&
          date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[(tmPtr + 32) >> 2] = dst;
    }

    function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream, len, off, prot, flags);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr >> 2] = ptr;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function __munmap_js(addr, len, prot, flags, fd, offset) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, flags, offset);
        }
        FS.munmap(stream);
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return -e.errno;
      }
    }

    function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }
    function __tzset_js(timezone, daylight, tzname) {
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();

      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);

      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;

      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);

      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : 'GMT';
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        HEAPU32[tzname >> 2] = winterNamePtr;
        HEAPU32[(tzname + 4) >> 2] = summerNamePtr;
      } else {
        HEAPU32[tzname >> 2] = summerNamePtr;
        HEAPU32[(tzname + 4) >> 2] = winterNamePtr;
      }
    }

    function _emscripten_date_now() {
      return Date.now();
    }

    var _emscripten_get_now;
    _emscripten_get_now = () => performance.now();
    function getHeapMax() {
      return 2147483648;
    }

    function emscripten_realloc_buffer(size) {
      var b = wasmMemory.buffer;
      try {
        wasmMemory.grow((size - b.byteLength + 65535) >>> 16);
        updateMemoryViews();
        return 1;
      } catch (e) {}
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;

      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }

      let alignUp = (x, multiple) =>
        x + ((multiple - (x % multiple)) % multiple);

      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);

        overGrownHeapSize = Math.min(
          overGrownHeapSize,
          requestedSize + 100663296,
        );

        var newSize = Math.min(
          maxHeapSize,
          alignUp(Math.max(requestedSize, overGrownHeapSize), 65536),
        );

        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }

    var ENV = {};

    function getExecutableName() {
      return thisProgram || './this.program';
    }
    function getEnvStrings() {
      if (!getEnvStrings.strings) {
        var lang =
          (
            (typeof navigator == 'object' &&
              navigator.languages &&
              navigator.languages[0]) ||
            'C'
          ).replace('-', '_') + '.UTF-8';
        var env = {
          USER: 'web_user',
          LOGNAME: 'web_user',
          PATH: '/',
          PWD: '/',
          HOME: '/home/web_user',
          LANG: lang,
          _: getExecutableName(),
        };

        for (var x in ENV) {
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }

    function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i);
      }

      if (!dontAddNull) HEAP8[buffer >> 0] = 0;
    }

    function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function (string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(__environ + i * 4) >> 2] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

    function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach(function (string) {
        bufSize += string.length + 1;
      });
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    }

    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function _fd_fdstat_get(fd, pbuf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);

        var type = stream.tty
          ? 2
          : FS.isDir(stream.mode)
            ? 3
            : FS.isLink(stream.mode)
              ? 7
              : 4;
        HEAP8[pbuf >> 0] = type;

        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[(iov + 4) >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }

    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function _fd_seek(fd, offset, whence, newOffset) {
      try {
        offset = bigintToI53Checked(offset);
        if (isNaN(offset)) return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset, whence);
        (tempI64 = [
          stream.position >>> 0,
          ((tempDouble = stream.position),
          +Math.abs(tempDouble) >= 1.0
            ? tempDouble > 0.0
              ? (Math.min(
                  +Math.floor(tempDouble / 4294967296.0),
                  4294967295.0,
                ) |
                  0) >>>
                0
              : ~~+Math.ceil(
                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                ) >>> 0
            : 0),
        ]),
          (HEAP32[newOffset >> 2] = tempI64[0]),
          (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function _fd_sync(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (stream.stream_ops && stream.stream_ops.fsync) {
          return stream.stream_ops.fsync(stream);
        }
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[(iov + 4) >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }

    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
        return e.errno;
      }
    }

    var FSNode = function (parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, {
      read: {
        get: function () {
          return (this.mode & readMode) === readMode;
        },
        set: function (val) {
          val ? (this.mode |= readMode) : (this.mode &= ~readMode);
        },
      },
      write: {
        get: function () {
          return (this.mode & writeMode) === writeMode;
        },
        set: function (val) {
          val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
        },
      },
      isFolder: {
        get: function () {
          return FS.isDir(this.mode);
        },
      },
      isDevice: {
        get: function () {
          return FS.isChrdev(this.mode);
        },
      },
    });
    FS.FSNode = FSNode;
    FS.staticInit();
    var ASSERTIONS = false;

    var asmLibraryArg = {
      __syscall_chmod: ___syscall_chmod,
      __syscall_faccessat: ___syscall_faccessat,
      __syscall_fchmod: ___syscall_fchmod,
      __syscall_fchown32: ___syscall_fchown32,
      __syscall_fcntl64: ___syscall_fcntl64,
      __syscall_fstat64: ___syscall_fstat64,
      __syscall_ftruncate64: ___syscall_ftruncate64,
      __syscall_getcwd: ___syscall_getcwd,
      __syscall_ioctl: ___syscall_ioctl,
      __syscall_lstat64: ___syscall_lstat64,
      __syscall_mkdirat: ___syscall_mkdirat,
      __syscall_newfstatat: ___syscall_newfstatat,
      __syscall_openat: ___syscall_openat,
      __syscall_readlinkat: ___syscall_readlinkat,
      __syscall_rmdir: ___syscall_rmdir,
      __syscall_stat64: ___syscall_stat64,
      __syscall_unlinkat: ___syscall_unlinkat,
      __syscall_utimensat: ___syscall_utimensat,
      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
      _localtime_js: __localtime_js,
      _mmap_js: __mmap_js,
      _munmap_js: __munmap_js,
      _tzset_js: __tzset_js,
      emscripten_date_now: _emscripten_date_now,
      emscripten_get_now: _emscripten_get_now,
      emscripten_resize_heap: _emscripten_resize_heap,
      environ_get: _environ_get,
      environ_sizes_get: _environ_sizes_get,
      fd_close: _fd_close,
      fd_fdstat_get: _fd_fdstat_get,
      fd_read: _fd_read,
      fd_seek: _fd_seek,
      fd_sync: _fd_sync,
      fd_write: _fd_write,
      memory: wasmMemory,
    };
    var asm = createWasm();

    var ___wasm_call_ctors = (Module['___wasm_call_ctors'] = function () {
      return (___wasm_call_ctors = Module['___wasm_call_ctors'] =
        Module['asm']['__wasm_call_ctors']).apply(null, arguments);
    });

    var _sqlite3_status64 = (Module['_sqlite3_status64'] = function () {
      return (_sqlite3_status64 = Module['_sqlite3_status64'] =
        Module['asm']['sqlite3_status64']).apply(null, arguments);
    });

    var _sqlite3_status = (Module['_sqlite3_status'] = function () {
      return (_sqlite3_status = Module['_sqlite3_status'] =
        Module['asm']['sqlite3_status']).apply(null, arguments);
    });

    var _sqlite3_db_status = (Module['_sqlite3_db_status'] = function () {
      return (_sqlite3_db_status = Module['_sqlite3_db_status'] =
        Module['asm']['sqlite3_db_status']).apply(null, arguments);
    });

    var _sqlite3_msize = (Module['_sqlite3_msize'] = function () {
      return (_sqlite3_msize = Module['_sqlite3_msize'] =
        Module['asm']['sqlite3_msize']).apply(null, arguments);
    });

    var _sqlite3_vfs_find = (Module['_sqlite3_vfs_find'] = function () {
      return (_sqlite3_vfs_find = Module['_sqlite3_vfs_find'] =
        Module['asm']['sqlite3_vfs_find']).apply(null, arguments);
    });

    var _sqlite3_initialize = (Module['_sqlite3_initialize'] = function () {
      return (_sqlite3_initialize = Module['_sqlite3_initialize'] =
        Module['asm']['sqlite3_initialize']).apply(null, arguments);
    });

    var _sqlite3_malloc = (Module['_sqlite3_malloc'] = function () {
      return (_sqlite3_malloc = Module['_sqlite3_malloc'] =
        Module['asm']['sqlite3_malloc']).apply(null, arguments);
    });

    var _sqlite3_free = (Module['_sqlite3_free'] = function () {
      return (_sqlite3_free = Module['_sqlite3_free'] =
        Module['asm']['sqlite3_free']).apply(null, arguments);
    });

    var _sqlite3_vfs_register = (Module['_sqlite3_vfs_register'] = function () {
      return (_sqlite3_vfs_register = Module['_sqlite3_vfs_register'] =
        Module['asm']['sqlite3_vfs_register']).apply(null, arguments);
    });

    var _sqlite3_vfs_unregister = (Module['_sqlite3_vfs_unregister'] =
      function () {
        return (_sqlite3_vfs_unregister = Module['_sqlite3_vfs_unregister'] =
          Module['asm']['sqlite3_vfs_unregister']).apply(null, arguments);
      });

    var _sqlite3_malloc64 = (Module['_sqlite3_malloc64'] = function () {
      return (_sqlite3_malloc64 = Module['_sqlite3_malloc64'] =
        Module['asm']['sqlite3_malloc64']).apply(null, arguments);
    });

    var _sqlite3_realloc = (Module['_sqlite3_realloc'] = function () {
      return (_sqlite3_realloc = Module['_sqlite3_realloc'] =
        Module['asm']['sqlite3_realloc']).apply(null, arguments);
    });

    var _sqlite3_realloc64 = (Module['_sqlite3_realloc64'] = function () {
      return (_sqlite3_realloc64 = Module['_sqlite3_realloc64'] =
        Module['asm']['sqlite3_realloc64']).apply(null, arguments);
    });

    var _sqlite3_value_text = (Module['_sqlite3_value_text'] = function () {
      return (_sqlite3_value_text = Module['_sqlite3_value_text'] =
        Module['asm']['sqlite3_value_text']).apply(null, arguments);
    });

    var _sqlite3_randomness = (Module['_sqlite3_randomness'] = function () {
      return (_sqlite3_randomness = Module['_sqlite3_randomness'] =
        Module['asm']['sqlite3_randomness']).apply(null, arguments);
    });

    var _sqlite3_stricmp = (Module['_sqlite3_stricmp'] = function () {
      return (_sqlite3_stricmp = Module['_sqlite3_stricmp'] =
        Module['asm']['sqlite3_stricmp']).apply(null, arguments);
    });

    var _sqlite3_strnicmp = (Module['_sqlite3_strnicmp'] = function () {
      return (_sqlite3_strnicmp = Module['_sqlite3_strnicmp'] =
        Module['asm']['sqlite3_strnicmp']).apply(null, arguments);
    });

    var _sqlite3_uri_parameter = (Module['_sqlite3_uri_parameter'] =
      function () {
        return (_sqlite3_uri_parameter = Module['_sqlite3_uri_parameter'] =
          Module['asm']['sqlite3_uri_parameter']).apply(null, arguments);
      });

    var ___errno_location = (Module['___errno_location'] = function () {
      return (___errno_location = Module['___errno_location'] =
        Module['asm']['__errno_location']).apply(null, arguments);
    });

    var _sqlite3_uri_boolean = (Module['_sqlite3_uri_boolean'] = function () {
      return (_sqlite3_uri_boolean = Module['_sqlite3_uri_boolean'] =
        Module['asm']['sqlite3_uri_boolean']).apply(null, arguments);
    });

    var _sqlite3_serialize = (Module['_sqlite3_serialize'] = function () {
      return (_sqlite3_serialize = Module['_sqlite3_serialize'] =
        Module['asm']['sqlite3_serialize']).apply(null, arguments);
    });

    var _sqlite3_prepare_v2 = (Module['_sqlite3_prepare_v2'] = function () {
      return (_sqlite3_prepare_v2 = Module['_sqlite3_prepare_v2'] =
        Module['asm']['sqlite3_prepare_v2']).apply(null, arguments);
    });

    var _sqlite3_step = (Module['_sqlite3_step'] = function () {
      return (_sqlite3_step = Module['_sqlite3_step'] =
        Module['asm']['sqlite3_step']).apply(null, arguments);
    });

    var _sqlite3_column_int64 = (Module['_sqlite3_column_int64'] = function () {
      return (_sqlite3_column_int64 = Module['_sqlite3_column_int64'] =
        Module['asm']['sqlite3_column_int64']).apply(null, arguments);
    });

    var _sqlite3_reset = (Module['_sqlite3_reset'] = function () {
      return (_sqlite3_reset = Module['_sqlite3_reset'] =
        Module['asm']['sqlite3_reset']).apply(null, arguments);
    });

    var _sqlite3_exec = (Module['_sqlite3_exec'] = function () {
      return (_sqlite3_exec = Module['_sqlite3_exec'] =
        Module['asm']['sqlite3_exec']).apply(null, arguments);
    });

    var _sqlite3_column_int = (Module['_sqlite3_column_int'] = function () {
      return (_sqlite3_column_int = Module['_sqlite3_column_int'] =
        Module['asm']['sqlite3_column_int']).apply(null, arguments);
    });

    var _sqlite3_finalize = (Module['_sqlite3_finalize'] = function () {
      return (_sqlite3_finalize = Module['_sqlite3_finalize'] =
        Module['asm']['sqlite3_finalize']).apply(null, arguments);
    });

    var _sqlite3_file_control = (Module['_sqlite3_file_control'] = function () {
      return (_sqlite3_file_control = Module['_sqlite3_file_control'] =
        Module['asm']['sqlite3_file_control']).apply(null, arguments);
    });

    var _sqlite3_column_name = (Module['_sqlite3_column_name'] = function () {
      return (_sqlite3_column_name = Module['_sqlite3_column_name'] =
        Module['asm']['sqlite3_column_name']).apply(null, arguments);
    });

    var _sqlite3_column_text = (Module['_sqlite3_column_text'] = function () {
      return (_sqlite3_column_text = Module['_sqlite3_column_text'] =
        Module['asm']['sqlite3_column_text']).apply(null, arguments);
    });

    var _sqlite3_column_type = (Module['_sqlite3_column_type'] = function () {
      return (_sqlite3_column_type = Module['_sqlite3_column_type'] =
        Module['asm']['sqlite3_column_type']).apply(null, arguments);
    });

    var _sqlite3_errmsg = (Module['_sqlite3_errmsg'] = function () {
      return (_sqlite3_errmsg = Module['_sqlite3_errmsg'] =
        Module['asm']['sqlite3_errmsg']).apply(null, arguments);
    });

    var _sqlite3_deserialize = (Module['_sqlite3_deserialize'] = function () {
      return (_sqlite3_deserialize = Module['_sqlite3_deserialize'] =
        Module['asm']['sqlite3_deserialize']).apply(null, arguments);
    });

    var _sqlite3_clear_bindings = (Module['_sqlite3_clear_bindings'] =
      function () {
        return (_sqlite3_clear_bindings = Module['_sqlite3_clear_bindings'] =
          Module['asm']['sqlite3_clear_bindings']).apply(null, arguments);
      });

    var _sqlite3_value_blob = (Module['_sqlite3_value_blob'] = function () {
      return (_sqlite3_value_blob = Module['_sqlite3_value_blob'] =
        Module['asm']['sqlite3_value_blob']).apply(null, arguments);
    });

    var _sqlite3_value_bytes = (Module['_sqlite3_value_bytes'] = function () {
      return (_sqlite3_value_bytes = Module['_sqlite3_value_bytes'] =
        Module['asm']['sqlite3_value_bytes']).apply(null, arguments);
    });

    var _sqlite3_value_double = (Module['_sqlite3_value_double'] = function () {
      return (_sqlite3_value_double = Module['_sqlite3_value_double'] =
        Module['asm']['sqlite3_value_double']).apply(null, arguments);
    });

    var _sqlite3_value_int = (Module['_sqlite3_value_int'] = function () {
      return (_sqlite3_value_int = Module['_sqlite3_value_int'] =
        Module['asm']['sqlite3_value_int']).apply(null, arguments);
    });

    var _sqlite3_value_int64 = (Module['_sqlite3_value_int64'] = function () {
      return (_sqlite3_value_int64 = Module['_sqlite3_value_int64'] =
        Module['asm']['sqlite3_value_int64']).apply(null, arguments);
    });

    var _sqlite3_value_subtype = (Module['_sqlite3_value_subtype'] =
      function () {
        return (_sqlite3_value_subtype = Module['_sqlite3_value_subtype'] =
          Module['asm']['sqlite3_value_subtype']).apply(null, arguments);
      });

    var _sqlite3_value_pointer = (Module['_sqlite3_value_pointer'] =
      function () {
        return (_sqlite3_value_pointer = Module['_sqlite3_value_pointer'] =
          Module['asm']['sqlite3_value_pointer']).apply(null, arguments);
      });

    var _sqlite3_value_type = (Module['_sqlite3_value_type'] = function () {
      return (_sqlite3_value_type = Module['_sqlite3_value_type'] =
        Module['asm']['sqlite3_value_type']).apply(null, arguments);
    });

    var _sqlite3_value_nochange = (Module['_sqlite3_value_nochange'] =
      function () {
        return (_sqlite3_value_nochange = Module['_sqlite3_value_nochange'] =
          Module['asm']['sqlite3_value_nochange']).apply(null, arguments);
      });

    var _sqlite3_value_frombind = (Module['_sqlite3_value_frombind'] =
      function () {
        return (_sqlite3_value_frombind = Module['_sqlite3_value_frombind'] =
          Module['asm']['sqlite3_value_frombind']).apply(null, arguments);
      });

    var _sqlite3_value_dup = (Module['_sqlite3_value_dup'] = function () {
      return (_sqlite3_value_dup = Module['_sqlite3_value_dup'] =
        Module['asm']['sqlite3_value_dup']).apply(null, arguments);
    });

    var _sqlite3_value_free = (Module['_sqlite3_value_free'] = function () {
      return (_sqlite3_value_free = Module['_sqlite3_value_free'] =
        Module['asm']['sqlite3_value_free']).apply(null, arguments);
    });

    var _sqlite3_result_blob = (Module['_sqlite3_result_blob'] = function () {
      return (_sqlite3_result_blob = Module['_sqlite3_result_blob'] =
        Module['asm']['sqlite3_result_blob']).apply(null, arguments);
    });

    var _sqlite3_result_error_toobig = (Module['_sqlite3_result_error_toobig'] =
      function () {
        return (_sqlite3_result_error_toobig = Module[
          '_sqlite3_result_error_toobig'
        ] =
          Module['asm']['sqlite3_result_error_toobig']).apply(null, arguments);
      });

    var _sqlite3_result_error_nomem = (Module['_sqlite3_result_error_nomem'] =
      function () {
        return (_sqlite3_result_error_nomem = Module[
          '_sqlite3_result_error_nomem'
        ] =
          Module['asm']['sqlite3_result_error_nomem']).apply(null, arguments);
      });

    var _sqlite3_result_double = (Module['_sqlite3_result_double'] =
      function () {
        return (_sqlite3_result_double = Module['_sqlite3_result_double'] =
          Module['asm']['sqlite3_result_double']).apply(null, arguments);
      });

    var _sqlite3_result_error = (Module['_sqlite3_result_error'] = function () {
      return (_sqlite3_result_error = Module['_sqlite3_result_error'] =
        Module['asm']['sqlite3_result_error']).apply(null, arguments);
    });

    var _sqlite3_result_int = (Module['_sqlite3_result_int'] = function () {
      return (_sqlite3_result_int = Module['_sqlite3_result_int'] =
        Module['asm']['sqlite3_result_int']).apply(null, arguments);
    });

    var _sqlite3_result_int64 = (Module['_sqlite3_result_int64'] = function () {
      return (_sqlite3_result_int64 = Module['_sqlite3_result_int64'] =
        Module['asm']['sqlite3_result_int64']).apply(null, arguments);
    });

    var _sqlite3_result_null = (Module['_sqlite3_result_null'] = function () {
      return (_sqlite3_result_null = Module['_sqlite3_result_null'] =
        Module['asm']['sqlite3_result_null']).apply(null, arguments);
    });

    var _sqlite3_result_pointer = (Module['_sqlite3_result_pointer'] =
      function () {
        return (_sqlite3_result_pointer = Module['_sqlite3_result_pointer'] =
          Module['asm']['sqlite3_result_pointer']).apply(null, arguments);
      });

    var _sqlite3_result_subtype = (Module['_sqlite3_result_subtype'] =
      function () {
        return (_sqlite3_result_subtype = Module['_sqlite3_result_subtype'] =
          Module['asm']['sqlite3_result_subtype']).apply(null, arguments);
      });

    var _sqlite3_result_text = (Module['_sqlite3_result_text'] = function () {
      return (_sqlite3_result_text = Module['_sqlite3_result_text'] =
        Module['asm']['sqlite3_result_text']).apply(null, arguments);
    });

    var _sqlite3_result_zeroblob = (Module['_sqlite3_result_zeroblob'] =
      function () {
        return (_sqlite3_result_zeroblob = Module['_sqlite3_result_zeroblob'] =
          Module['asm']['sqlite3_result_zeroblob']).apply(null, arguments);
      });

    var _sqlite3_result_zeroblob64 = (Module['_sqlite3_result_zeroblob64'] =
      function () {
        return (_sqlite3_result_zeroblob64 = Module[
          '_sqlite3_result_zeroblob64'
        ] =
          Module['asm']['sqlite3_result_zeroblob64']).apply(null, arguments);
      });

    var _sqlite3_result_error_code = (Module['_sqlite3_result_error_code'] =
      function () {
        return (_sqlite3_result_error_code = Module[
          '_sqlite3_result_error_code'
        ] =
          Module['asm']['sqlite3_result_error_code']).apply(null, arguments);
      });

    var _sqlite3_user_data = (Module['_sqlite3_user_data'] = function () {
      return (_sqlite3_user_data = Module['_sqlite3_user_data'] =
        Module['asm']['sqlite3_user_data']).apply(null, arguments);
    });

    var _sqlite3_context_db_handle = (Module['_sqlite3_context_db_handle'] =
      function () {
        return (_sqlite3_context_db_handle = Module[
          '_sqlite3_context_db_handle'
        ] =
          Module['asm']['sqlite3_context_db_handle']).apply(null, arguments);
      });

    var _sqlite3_vtab_nochange = (Module['_sqlite3_vtab_nochange'] =
      function () {
        return (_sqlite3_vtab_nochange = Module['_sqlite3_vtab_nochange'] =
          Module['asm']['sqlite3_vtab_nochange']).apply(null, arguments);
      });

    var _sqlite3_vtab_in_first = (Module['_sqlite3_vtab_in_first'] =
      function () {
        return (_sqlite3_vtab_in_first = Module['_sqlite3_vtab_in_first'] =
          Module['asm']['sqlite3_vtab_in_first']).apply(null, arguments);
      });

    var _sqlite3_vtab_in_next = (Module['_sqlite3_vtab_in_next'] = function () {
      return (_sqlite3_vtab_in_next = Module['_sqlite3_vtab_in_next'] =
        Module['asm']['sqlite3_vtab_in_next']).apply(null, arguments);
    });

    var _sqlite3_aggregate_context = (Module['_sqlite3_aggregate_context'] =
      function () {
        return (_sqlite3_aggregate_context = Module[
          '_sqlite3_aggregate_context'
        ] =
          Module['asm']['sqlite3_aggregate_context']).apply(null, arguments);
      });

    var _sqlite3_get_auxdata = (Module['_sqlite3_get_auxdata'] = function () {
      return (_sqlite3_get_auxdata = Module['_sqlite3_get_auxdata'] =
        Module['asm']['sqlite3_get_auxdata']).apply(null, arguments);
    });

    var _sqlite3_set_auxdata = (Module['_sqlite3_set_auxdata'] = function () {
      return (_sqlite3_set_auxdata = Module['_sqlite3_set_auxdata'] =
        Module['asm']['sqlite3_set_auxdata']).apply(null, arguments);
    });

    var _sqlite3_column_count = (Module['_sqlite3_column_count'] = function () {
      return (_sqlite3_column_count = Module['_sqlite3_column_count'] =
        Module['asm']['sqlite3_column_count']).apply(null, arguments);
    });

    var _sqlite3_data_count = (Module['_sqlite3_data_count'] = function () {
      return (_sqlite3_data_count = Module['_sqlite3_data_count'] =
        Module['asm']['sqlite3_data_count']).apply(null, arguments);
    });

    var _sqlite3_column_blob = (Module['_sqlite3_column_blob'] = function () {
      return (_sqlite3_column_blob = Module['_sqlite3_column_blob'] =
        Module['asm']['sqlite3_column_blob']).apply(null, arguments);
    });

    var _sqlite3_column_bytes = (Module['_sqlite3_column_bytes'] = function () {
      return (_sqlite3_column_bytes = Module['_sqlite3_column_bytes'] =
        Module['asm']['sqlite3_column_bytes']).apply(null, arguments);
    });

    var _sqlite3_column_double = (Module['_sqlite3_column_double'] =
      function () {
        return (_sqlite3_column_double = Module['_sqlite3_column_double'] =
          Module['asm']['sqlite3_column_double']).apply(null, arguments);
      });

    var _sqlite3_column_value = (Module['_sqlite3_column_value'] = function () {
      return (_sqlite3_column_value = Module['_sqlite3_column_value'] =
        Module['asm']['sqlite3_column_value']).apply(null, arguments);
    });

    var _sqlite3_bind_blob = (Module['_sqlite3_bind_blob'] = function () {
      return (_sqlite3_bind_blob = Module['_sqlite3_bind_blob'] =
        Module['asm']['sqlite3_bind_blob']).apply(null, arguments);
    });

    var _sqlite3_bind_double = (Module['_sqlite3_bind_double'] = function () {
      return (_sqlite3_bind_double = Module['_sqlite3_bind_double'] =
        Module['asm']['sqlite3_bind_double']).apply(null, arguments);
    });

    var _sqlite3_bind_int = (Module['_sqlite3_bind_int'] = function () {
      return (_sqlite3_bind_int = Module['_sqlite3_bind_int'] =
        Module['asm']['sqlite3_bind_int']).apply(null, arguments);
    });

    var _sqlite3_bind_int64 = (Module['_sqlite3_bind_int64'] = function () {
      return (_sqlite3_bind_int64 = Module['_sqlite3_bind_int64'] =
        Module['asm']['sqlite3_bind_int64']).apply(null, arguments);
    });

    var _sqlite3_bind_null = (Module['_sqlite3_bind_null'] = function () {
      return (_sqlite3_bind_null = Module['_sqlite3_bind_null'] =
        Module['asm']['sqlite3_bind_null']).apply(null, arguments);
    });

    var _sqlite3_bind_pointer = (Module['_sqlite3_bind_pointer'] = function () {
      return (_sqlite3_bind_pointer = Module['_sqlite3_bind_pointer'] =
        Module['asm']['sqlite3_bind_pointer']).apply(null, arguments);
    });

    var _sqlite3_bind_text = (Module['_sqlite3_bind_text'] = function () {
      return (_sqlite3_bind_text = Module['_sqlite3_bind_text'] =
        Module['asm']['sqlite3_bind_text']).apply(null, arguments);
    });

    var _sqlite3_bind_parameter_count = (Module[
      '_sqlite3_bind_parameter_count'
    ] = function () {
      return (_sqlite3_bind_parameter_count = Module[
        '_sqlite3_bind_parameter_count'
      ] =
        Module['asm']['sqlite3_bind_parameter_count']).apply(null, arguments);
    });

    var _sqlite3_bind_parameter_index = (Module[
      '_sqlite3_bind_parameter_index'
    ] = function () {
      return (_sqlite3_bind_parameter_index = Module[
        '_sqlite3_bind_parameter_index'
      ] =
        Module['asm']['sqlite3_bind_parameter_index']).apply(null, arguments);
    });

    var _sqlite3_db_handle = (Module['_sqlite3_db_handle'] = function () {
      return (_sqlite3_db_handle = Module['_sqlite3_db_handle'] =
        Module['asm']['sqlite3_db_handle']).apply(null, arguments);
    });

    var _sqlite3_stmt_readonly = (Module['_sqlite3_stmt_readonly'] =
      function () {
        return (_sqlite3_stmt_readonly = Module['_sqlite3_stmt_readonly'] =
          Module['asm']['sqlite3_stmt_readonly']).apply(null, arguments);
      });

    var _sqlite3_stmt_isexplain = (Module['_sqlite3_stmt_isexplain'] =
      function () {
        return (_sqlite3_stmt_isexplain = Module['_sqlite3_stmt_isexplain'] =
          Module['asm']['sqlite3_stmt_isexplain']).apply(null, arguments);
      });

    var _sqlite3_stmt_status = (Module['_sqlite3_stmt_status'] = function () {
      return (_sqlite3_stmt_status = Module['_sqlite3_stmt_status'] =
        Module['asm']['sqlite3_stmt_status']).apply(null, arguments);
    });

    var _sqlite3_sql = (Module['_sqlite3_sql'] = function () {
      return (_sqlite3_sql = Module['_sqlite3_sql'] =
        Module['asm']['sqlite3_sql']).apply(null, arguments);
    });

    var _sqlite3_expanded_sql = (Module['_sqlite3_expanded_sql'] = function () {
      return (_sqlite3_expanded_sql = Module['_sqlite3_expanded_sql'] =
        Module['asm']['sqlite3_expanded_sql']).apply(null, arguments);
    });

    var _sqlite3_preupdate_old = (Module['_sqlite3_preupdate_old'] =
      function () {
        return (_sqlite3_preupdate_old = Module['_sqlite3_preupdate_old'] =
          Module['asm']['sqlite3_preupdate_old']).apply(null, arguments);
      });

    var _sqlite3_preupdate_count = (Module['_sqlite3_preupdate_count'] =
      function () {
        return (_sqlite3_preupdate_count = Module['_sqlite3_preupdate_count'] =
          Module['asm']['sqlite3_preupdate_count']).apply(null, arguments);
      });

    var _sqlite3_preupdate_depth = (Module['_sqlite3_preupdate_depth'] =
      function () {
        return (_sqlite3_preupdate_depth = Module['_sqlite3_preupdate_depth'] =
          Module['asm']['sqlite3_preupdate_depth']).apply(null, arguments);
      });

    var _sqlite3_preupdate_blobwrite = (Module['_sqlite3_preupdate_blobwrite'] =
      function () {
        return (_sqlite3_preupdate_blobwrite = Module[
          '_sqlite3_preupdate_blobwrite'
        ] =
          Module['asm']['sqlite3_preupdate_blobwrite']).apply(null, arguments);
      });

    var _sqlite3_preupdate_new = (Module['_sqlite3_preupdate_new'] =
      function () {
        return (_sqlite3_preupdate_new = Module['_sqlite3_preupdate_new'] =
          Module['asm']['sqlite3_preupdate_new']).apply(null, arguments);
      });

    var _sqlite3_value_numeric_type = (Module['_sqlite3_value_numeric_type'] =
      function () {
        return (_sqlite3_value_numeric_type = Module[
          '_sqlite3_value_numeric_type'
        ] =
          Module['asm']['sqlite3_value_numeric_type']).apply(null, arguments);
      });

    var _sqlite3_set_authorizer = (Module['_sqlite3_set_authorizer'] =
      function () {
        return (_sqlite3_set_authorizer = Module['_sqlite3_set_authorizer'] =
          Module['asm']['sqlite3_set_authorizer']).apply(null, arguments);
      });

    var _sqlite3_strglob = (Module['_sqlite3_strglob'] = function () {
      return (_sqlite3_strglob = Module['_sqlite3_strglob'] =
        Module['asm']['sqlite3_strglob']).apply(null, arguments);
    });

    var _sqlite3_strlike = (Module['_sqlite3_strlike'] = function () {
      return (_sqlite3_strlike = Module['_sqlite3_strlike'] =
        Module['asm']['sqlite3_strlike']).apply(null, arguments);
    });

    var _sqlite3_auto_extension = (Module['_sqlite3_auto_extension'] =
      function () {
        return (_sqlite3_auto_extension = Module['_sqlite3_auto_extension'] =
          Module['asm']['sqlite3_auto_extension']).apply(null, arguments);
      });

    var _sqlite3_cancel_auto_extension = (Module[
      '_sqlite3_cancel_auto_extension'
    ] = function () {
      return (_sqlite3_cancel_auto_extension = Module[
        '_sqlite3_cancel_auto_extension'
      ] =
        Module['asm']['sqlite3_cancel_auto_extension']).apply(null, arguments);
    });

    var _sqlite3_reset_auto_extension = (Module[
      '_sqlite3_reset_auto_extension'
    ] = function () {
      return (_sqlite3_reset_auto_extension = Module[
        '_sqlite3_reset_auto_extension'
      ] =
        Module['asm']['sqlite3_reset_auto_extension']).apply(null, arguments);
    });

    var _sqlite3_prepare_v3 = (Module['_sqlite3_prepare_v3'] = function () {
      return (_sqlite3_prepare_v3 = Module['_sqlite3_prepare_v3'] =
        Module['asm']['sqlite3_prepare_v3']).apply(null, arguments);
    });

    var _sqlite3_create_module = (Module['_sqlite3_create_module'] =
      function () {
        return (_sqlite3_create_module = Module['_sqlite3_create_module'] =
          Module['asm']['sqlite3_create_module']).apply(null, arguments);
      });

    var _sqlite3_create_module_v2 = (Module['_sqlite3_create_module_v2'] =
      function () {
        return (_sqlite3_create_module_v2 = Module[
          '_sqlite3_create_module_v2'
        ] =
          Module['asm']['sqlite3_create_module_v2']).apply(null, arguments);
      });

    var _sqlite3_drop_modules = (Module['_sqlite3_drop_modules'] = function () {
      return (_sqlite3_drop_modules = Module['_sqlite3_drop_modules'] =
        Module['asm']['sqlite3_drop_modules']).apply(null, arguments);
    });

    var _sqlite3_declare_vtab = (Module['_sqlite3_declare_vtab'] = function () {
      return (_sqlite3_declare_vtab = Module['_sqlite3_declare_vtab'] =
        Module['asm']['sqlite3_declare_vtab']).apply(null, arguments);
    });

    var _sqlite3_vtab_on_conflict = (Module['_sqlite3_vtab_on_conflict'] =
      function () {
        return (_sqlite3_vtab_on_conflict = Module[
          '_sqlite3_vtab_on_conflict'
        ] =
          Module['asm']['sqlite3_vtab_on_conflict']).apply(null, arguments);
      });

    var _sqlite3_vtab_collation = (Module['_sqlite3_vtab_collation'] =
      function () {
        return (_sqlite3_vtab_collation = Module['_sqlite3_vtab_collation'] =
          Module['asm']['sqlite3_vtab_collation']).apply(null, arguments);
      });

    var _sqlite3_vtab_in = (Module['_sqlite3_vtab_in'] = function () {
      return (_sqlite3_vtab_in = Module['_sqlite3_vtab_in'] =
        Module['asm']['sqlite3_vtab_in']).apply(null, arguments);
    });

    var _sqlite3_vtab_rhs_value = (Module['_sqlite3_vtab_rhs_value'] =
      function () {
        return (_sqlite3_vtab_rhs_value = Module['_sqlite3_vtab_rhs_value'] =
          Module['asm']['sqlite3_vtab_rhs_value']).apply(null, arguments);
      });

    var _sqlite3_vtab_distinct = (Module['_sqlite3_vtab_distinct'] =
      function () {
        return (_sqlite3_vtab_distinct = Module['_sqlite3_vtab_distinct'] =
          Module['asm']['sqlite3_vtab_distinct']).apply(null, arguments);
      });

    var _sqlite3_keyword_name = (Module['_sqlite3_keyword_name'] = function () {
      return (_sqlite3_keyword_name = Module['_sqlite3_keyword_name'] =
        Module['asm']['sqlite3_keyword_name']).apply(null, arguments);
    });

    var _sqlite3_keyword_count = (Module['_sqlite3_keyword_count'] =
      function () {
        return (_sqlite3_keyword_count = Module['_sqlite3_keyword_count'] =
          Module['asm']['sqlite3_keyword_count']).apply(null, arguments);
      });

    var _sqlite3_keyword_check = (Module['_sqlite3_keyword_check'] =
      function () {
        return (_sqlite3_keyword_check = Module['_sqlite3_keyword_check'] =
          Module['asm']['sqlite3_keyword_check']).apply(null, arguments);
      });

    var _sqlite3_complete = (Module['_sqlite3_complete'] = function () {
      return (_sqlite3_complete = Module['_sqlite3_complete'] =
        Module['asm']['sqlite3_complete']).apply(null, arguments);
    });

    var _sqlite3_libversion = (Module['_sqlite3_libversion'] = function () {
      return (_sqlite3_libversion = Module['_sqlite3_libversion'] =
        Module['asm']['sqlite3_libversion']).apply(null, arguments);
    });

    var _sqlite3_libversion_number = (Module['_sqlite3_libversion_number'] =
      function () {
        return (_sqlite3_libversion_number = Module[
          '_sqlite3_libversion_number'
        ] =
          Module['asm']['sqlite3_libversion_number']).apply(null, arguments);
      });

    var _sqlite3_shutdown = (Module['_sqlite3_shutdown'] = function () {
      return (_sqlite3_shutdown = Module['_sqlite3_shutdown'] =
        Module['asm']['sqlite3_shutdown']).apply(null, arguments);
    });

    var _sqlite3_last_insert_rowid = (Module['_sqlite3_last_insert_rowid'] =
      function () {
        return (_sqlite3_last_insert_rowid = Module[
          '_sqlite3_last_insert_rowid'
        ] =
          Module['asm']['sqlite3_last_insert_rowid']).apply(null, arguments);
      });

    var _sqlite3_set_last_insert_rowid = (Module[
      '_sqlite3_set_last_insert_rowid'
    ] = function () {
      return (_sqlite3_set_last_insert_rowid = Module[
        '_sqlite3_set_last_insert_rowid'
      ] =
        Module['asm']['sqlite3_set_last_insert_rowid']).apply(null, arguments);
    });

    var _sqlite3_changes64 = (Module['_sqlite3_changes64'] = function () {
      return (_sqlite3_changes64 = Module['_sqlite3_changes64'] =
        Module['asm']['sqlite3_changes64']).apply(null, arguments);
    });

    var _sqlite3_changes = (Module['_sqlite3_changes'] = function () {
      return (_sqlite3_changes = Module['_sqlite3_changes'] =
        Module['asm']['sqlite3_changes']).apply(null, arguments);
    });

    var _sqlite3_total_changes64 = (Module['_sqlite3_total_changes64'] =
      function () {
        return (_sqlite3_total_changes64 = Module['_sqlite3_total_changes64'] =
          Module['asm']['sqlite3_total_changes64']).apply(null, arguments);
      });

    var _sqlite3_total_changes = (Module['_sqlite3_total_changes'] =
      function () {
        return (_sqlite3_total_changes = Module['_sqlite3_total_changes'] =
          Module['asm']['sqlite3_total_changes']).apply(null, arguments);
      });

    var _sqlite3_txn_state = (Module['_sqlite3_txn_state'] = function () {
      return (_sqlite3_txn_state = Module['_sqlite3_txn_state'] =
        Module['asm']['sqlite3_txn_state']).apply(null, arguments);
    });

    var _sqlite3_close_v2 = (Module['_sqlite3_close_v2'] = function () {
      return (_sqlite3_close_v2 = Module['_sqlite3_close_v2'] =
        Module['asm']['sqlite3_close_v2']).apply(null, arguments);
    });

    var _sqlite3_busy_handler = (Module['_sqlite3_busy_handler'] = function () {
      return (_sqlite3_busy_handler = Module['_sqlite3_busy_handler'] =
        Module['asm']['sqlite3_busy_handler']).apply(null, arguments);
    });

    var _sqlite3_progress_handler = (Module['_sqlite3_progress_handler'] =
      function () {
        return (_sqlite3_progress_handler = Module[
          '_sqlite3_progress_handler'
        ] =
          Module['asm']['sqlite3_progress_handler']).apply(null, arguments);
      });

    var _sqlite3_busy_timeout = (Module['_sqlite3_busy_timeout'] = function () {
      return (_sqlite3_busy_timeout = Module['_sqlite3_busy_timeout'] =
        Module['asm']['sqlite3_busy_timeout']).apply(null, arguments);
    });

    var _sqlite3_create_function = (Module['_sqlite3_create_function'] =
      function () {
        return (_sqlite3_create_function = Module['_sqlite3_create_function'] =
          Module['asm']['sqlite3_create_function']).apply(null, arguments);
      });

    var _sqlite3_create_function_v2 = (Module['_sqlite3_create_function_v2'] =
      function () {
        return (_sqlite3_create_function_v2 = Module[
          '_sqlite3_create_function_v2'
        ] =
          Module['asm']['sqlite3_create_function_v2']).apply(null, arguments);
      });

    var _sqlite3_create_window_function = (Module[
      '_sqlite3_create_window_function'
    ] = function () {
      return (_sqlite3_create_window_function = Module[
        '_sqlite3_create_window_function'
      ] =
        Module['asm']['sqlite3_create_window_function']).apply(null, arguments);
    });

    var _sqlite3_overload_function = (Module['_sqlite3_overload_function'] =
      function () {
        return (_sqlite3_overload_function = Module[
          '_sqlite3_overload_function'
        ] =
          Module['asm']['sqlite3_overload_function']).apply(null, arguments);
      });

    var _sqlite3_trace_v2 = (Module['_sqlite3_trace_v2'] = function () {
      return (_sqlite3_trace_v2 = Module['_sqlite3_trace_v2'] =
        Module['asm']['sqlite3_trace_v2']).apply(null, arguments);
    });

    var _sqlite3_commit_hook = (Module['_sqlite3_commit_hook'] = function () {
      return (_sqlite3_commit_hook = Module['_sqlite3_commit_hook'] =
        Module['asm']['sqlite3_commit_hook']).apply(null, arguments);
    });

    var _sqlite3_update_hook = (Module['_sqlite3_update_hook'] = function () {
      return (_sqlite3_update_hook = Module['_sqlite3_update_hook'] =
        Module['asm']['sqlite3_update_hook']).apply(null, arguments);
    });

    var _sqlite3_rollback_hook = (Module['_sqlite3_rollback_hook'] =
      function () {
        return (_sqlite3_rollback_hook = Module['_sqlite3_rollback_hook'] =
          Module['asm']['sqlite3_rollback_hook']).apply(null, arguments);
      });

    var _sqlite3_preupdate_hook = (Module['_sqlite3_preupdate_hook'] =
      function () {
        return (_sqlite3_preupdate_hook = Module['_sqlite3_preupdate_hook'] =
          Module['asm']['sqlite3_preupdate_hook']).apply(null, arguments);
      });

    var _sqlite3_error_offset = (Module['_sqlite3_error_offset'] = function () {
      return (_sqlite3_error_offset = Module['_sqlite3_error_offset'] =
        Module['asm']['sqlite3_error_offset']).apply(null, arguments);
    });

    var _sqlite3_errcode = (Module['_sqlite3_errcode'] = function () {
      return (_sqlite3_errcode = Module['_sqlite3_errcode'] =
        Module['asm']['sqlite3_errcode']).apply(null, arguments);
    });

    var _sqlite3_extended_errcode = (Module['_sqlite3_extended_errcode'] =
      function () {
        return (_sqlite3_extended_errcode = Module[
          '_sqlite3_extended_errcode'
        ] =
          Module['asm']['sqlite3_extended_errcode']).apply(null, arguments);
      });

    var _sqlite3_errstr = (Module['_sqlite3_errstr'] = function () {
      return (_sqlite3_errstr = Module['_sqlite3_errstr'] =
        Module['asm']['sqlite3_errstr']).apply(null, arguments);
    });

    var _sqlite3_limit = (Module['_sqlite3_limit'] = function () {
      return (_sqlite3_limit = Module['_sqlite3_limit'] =
        Module['asm']['sqlite3_limit']).apply(null, arguments);
    });

    var _sqlite3_open = (Module['_sqlite3_open'] = function () {
      return (_sqlite3_open = Module['_sqlite3_open'] =
        Module['asm']['sqlite3_open']).apply(null, arguments);
    });

    var _sqlite3_open_v2 = (Module['_sqlite3_open_v2'] = function () {
      return (_sqlite3_open_v2 = Module['_sqlite3_open_v2'] =
        Module['asm']['sqlite3_open_v2']).apply(null, arguments);
    });

    var _sqlite3_create_collation = (Module['_sqlite3_create_collation'] =
      function () {
        return (_sqlite3_create_collation = Module[
          '_sqlite3_create_collation'
        ] =
          Module['asm']['sqlite3_create_collation']).apply(null, arguments);
      });

    var _sqlite3_create_collation_v2 = (Module['_sqlite3_create_collation_v2'] =
      function () {
        return (_sqlite3_create_collation_v2 = Module[
          '_sqlite3_create_collation_v2'
        ] =
          Module['asm']['sqlite3_create_collation_v2']).apply(null, arguments);
      });

    var _sqlite3_collation_needed = (Module['_sqlite3_collation_needed'] =
      function () {
        return (_sqlite3_collation_needed = Module[
          '_sqlite3_collation_needed'
        ] =
          Module['asm']['sqlite3_collation_needed']).apply(null, arguments);
      });

    var _sqlite3_get_autocommit = (Module['_sqlite3_get_autocommit'] =
      function () {
        return (_sqlite3_get_autocommit = Module['_sqlite3_get_autocommit'] =
          Module['asm']['sqlite3_get_autocommit']).apply(null, arguments);
      });

    var _sqlite3_table_column_metadata = (Module[
      '_sqlite3_table_column_metadata'
    ] = function () {
      return (_sqlite3_table_column_metadata = Module[
        '_sqlite3_table_column_metadata'
      ] =
        Module['asm']['sqlite3_table_column_metadata']).apply(null, arguments);
    });

    var _sqlite3_extended_result_codes = (Module[
      '_sqlite3_extended_result_codes'
    ] = function () {
      return (_sqlite3_extended_result_codes = Module[
        '_sqlite3_extended_result_codes'
      ] =
        Module['asm']['sqlite3_extended_result_codes']).apply(null, arguments);
    });

    var _sqlite3_uri_key = (Module['_sqlite3_uri_key'] = function () {
      return (_sqlite3_uri_key = Module['_sqlite3_uri_key'] =
        Module['asm']['sqlite3_uri_key']).apply(null, arguments);
    });

    var _sqlite3_uri_int64 = (Module['_sqlite3_uri_int64'] = function () {
      return (_sqlite3_uri_int64 = Module['_sqlite3_uri_int64'] =
        Module['asm']['sqlite3_uri_int64']).apply(null, arguments);
    });

    var _sqlite3_db_name = (Module['_sqlite3_db_name'] = function () {
      return (_sqlite3_db_name = Module['_sqlite3_db_name'] =
        Module['asm']['sqlite3_db_name']).apply(null, arguments);
    });

    var _sqlite3_db_filename = (Module['_sqlite3_db_filename'] = function () {
      return (_sqlite3_db_filename = Module['_sqlite3_db_filename'] =
        Module['asm']['sqlite3_db_filename']).apply(null, arguments);
    });

    var _sqlite3_compileoption_used = (Module['_sqlite3_compileoption_used'] =
      function () {
        return (_sqlite3_compileoption_used = Module[
          '_sqlite3_compileoption_used'
        ] =
          Module['asm']['sqlite3_compileoption_used']).apply(null, arguments);
      });

    var _sqlite3_compileoption_get = (Module['_sqlite3_compileoption_get'] =
      function () {
        return (_sqlite3_compileoption_get = Module[
          '_sqlite3_compileoption_get'
        ] =
          Module['asm']['sqlite3_compileoption_get']).apply(null, arguments);
      });

    var _sqlite3session_diff = (Module['_sqlite3session_diff'] = function () {
      return (_sqlite3session_diff = Module['_sqlite3session_diff'] =
        Module['asm']['sqlite3session_diff']).apply(null, arguments);
    });

    var _sqlite3session_attach = (Module['_sqlite3session_attach'] =
      function () {
        return (_sqlite3session_attach = Module['_sqlite3session_attach'] =
          Module['asm']['sqlite3session_attach']).apply(null, arguments);
      });

    var _sqlite3session_create = (Module['_sqlite3session_create'] =
      function () {
        return (_sqlite3session_create = Module['_sqlite3session_create'] =
          Module['asm']['sqlite3session_create']).apply(null, arguments);
      });

    var _sqlite3session_delete = (Module['_sqlite3session_delete'] =
      function () {
        return (_sqlite3session_delete = Module['_sqlite3session_delete'] =
          Module['asm']['sqlite3session_delete']).apply(null, arguments);
      });

    var _sqlite3session_table_filter = (Module['_sqlite3session_table_filter'] =
      function () {
        return (_sqlite3session_table_filter = Module[
          '_sqlite3session_table_filter'
        ] =
          Module['asm']['sqlite3session_table_filter']).apply(null, arguments);
      });

    var _sqlite3session_changeset = (Module['_sqlite3session_changeset'] =
      function () {
        return (_sqlite3session_changeset = Module[
          '_sqlite3session_changeset'
        ] =
          Module['asm']['sqlite3session_changeset']).apply(null, arguments);
      });

    var _sqlite3session_changeset_strm = (Module[
      '_sqlite3session_changeset_strm'
    ] = function () {
      return (_sqlite3session_changeset_strm = Module[
        '_sqlite3session_changeset_strm'
      ] =
        Module['asm']['sqlite3session_changeset_strm']).apply(null, arguments);
    });

    var _sqlite3session_patchset_strm = (Module[
      '_sqlite3session_patchset_strm'
    ] = function () {
      return (_sqlite3session_patchset_strm = Module[
        '_sqlite3session_patchset_strm'
      ] =
        Module['asm']['sqlite3session_patchset_strm']).apply(null, arguments);
    });

    var _sqlite3session_patchset = (Module['_sqlite3session_patchset'] =
      function () {
        return (_sqlite3session_patchset = Module['_sqlite3session_patchset'] =
          Module['asm']['sqlite3session_patchset']).apply(null, arguments);
      });

    var _sqlite3session_enable = (Module['_sqlite3session_enable'] =
      function () {
        return (_sqlite3session_enable = Module['_sqlite3session_enable'] =
          Module['asm']['sqlite3session_enable']).apply(null, arguments);
      });

    var _sqlite3session_indirect = (Module['_sqlite3session_indirect'] =
      function () {
        return (_sqlite3session_indirect = Module['_sqlite3session_indirect'] =
          Module['asm']['sqlite3session_indirect']).apply(null, arguments);
      });

    var _sqlite3session_isempty = (Module['_sqlite3session_isempty'] =
      function () {
        return (_sqlite3session_isempty = Module['_sqlite3session_isempty'] =
          Module['asm']['sqlite3session_isempty']).apply(null, arguments);
      });

    var _sqlite3session_memory_used = (Module['_sqlite3session_memory_used'] =
      function () {
        return (_sqlite3session_memory_used = Module[
          '_sqlite3session_memory_used'
        ] =
          Module['asm']['sqlite3session_memory_used']).apply(null, arguments);
      });

    var _sqlite3session_object_config = (Module[
      '_sqlite3session_object_config'
    ] = function () {
      return (_sqlite3session_object_config = Module[
        '_sqlite3session_object_config'
      ] =
        Module['asm']['sqlite3session_object_config']).apply(null, arguments);
    });

    var _sqlite3session_changeset_size = (Module[
      '_sqlite3session_changeset_size'
    ] = function () {
      return (_sqlite3session_changeset_size = Module[
        '_sqlite3session_changeset_size'
      ] =
        Module['asm']['sqlite3session_changeset_size']).apply(null, arguments);
    });

    var _sqlite3changeset_start = (Module['_sqlite3changeset_start'] =
      function () {
        return (_sqlite3changeset_start = Module['_sqlite3changeset_start'] =
          Module['asm']['sqlite3changeset_start']).apply(null, arguments);
      });

    var _sqlite3changeset_start_v2 = (Module['_sqlite3changeset_start_v2'] =
      function () {
        return (_sqlite3changeset_start_v2 = Module[
          '_sqlite3changeset_start_v2'
        ] =
          Module['asm']['sqlite3changeset_start_v2']).apply(null, arguments);
      });

    var _sqlite3changeset_start_strm = (Module['_sqlite3changeset_start_strm'] =
      function () {
        return (_sqlite3changeset_start_strm = Module[
          '_sqlite3changeset_start_strm'
        ] =
          Module['asm']['sqlite3changeset_start_strm']).apply(null, arguments);
      });

    var _sqlite3changeset_start_v2_strm = (Module[
      '_sqlite3changeset_start_v2_strm'
    ] = function () {
      return (_sqlite3changeset_start_v2_strm = Module[
        '_sqlite3changeset_start_v2_strm'
      ] =
        Module['asm']['sqlite3changeset_start_v2_strm']).apply(null, arguments);
    });

    var _sqlite3changeset_next = (Module['_sqlite3changeset_next'] =
      function () {
        return (_sqlite3changeset_next = Module['_sqlite3changeset_next'] =
          Module['asm']['sqlite3changeset_next']).apply(null, arguments);
      });

    var _sqlite3changeset_op = (Module['_sqlite3changeset_op'] = function () {
      return (_sqlite3changeset_op = Module['_sqlite3changeset_op'] =
        Module['asm']['sqlite3changeset_op']).apply(null, arguments);
    });

    var _sqlite3changeset_pk = (Module['_sqlite3changeset_pk'] = function () {
      return (_sqlite3changeset_pk = Module['_sqlite3changeset_pk'] =
        Module['asm']['sqlite3changeset_pk']).apply(null, arguments);
    });

    var _sqlite3changeset_old = (Module['_sqlite3changeset_old'] = function () {
      return (_sqlite3changeset_old = Module['_sqlite3changeset_old'] =
        Module['asm']['sqlite3changeset_old']).apply(null, arguments);
    });

    var _sqlite3changeset_new = (Module['_sqlite3changeset_new'] = function () {
      return (_sqlite3changeset_new = Module['_sqlite3changeset_new'] =
        Module['asm']['sqlite3changeset_new']).apply(null, arguments);
    });

    var _sqlite3changeset_conflict = (Module['_sqlite3changeset_conflict'] =
      function () {
        return (_sqlite3changeset_conflict = Module[
          '_sqlite3changeset_conflict'
        ] =
          Module['asm']['sqlite3changeset_conflict']).apply(null, arguments);
      });

    var _sqlite3changeset_fk_conflicts = (Module[
      '_sqlite3changeset_fk_conflicts'
    ] = function () {
      return (_sqlite3changeset_fk_conflicts = Module[
        '_sqlite3changeset_fk_conflicts'
      ] =
        Module['asm']['sqlite3changeset_fk_conflicts']).apply(null, arguments);
    });

    var _sqlite3changeset_finalize = (Module['_sqlite3changeset_finalize'] =
      function () {
        return (_sqlite3changeset_finalize = Module[
          '_sqlite3changeset_finalize'
        ] =
          Module['asm']['sqlite3changeset_finalize']).apply(null, arguments);
      });

    var _sqlite3changeset_invert = (Module['_sqlite3changeset_invert'] =
      function () {
        return (_sqlite3changeset_invert = Module['_sqlite3changeset_invert'] =
          Module['asm']['sqlite3changeset_invert']).apply(null, arguments);
      });

    var _sqlite3changeset_invert_strm = (Module[
      '_sqlite3changeset_invert_strm'
    ] = function () {
      return (_sqlite3changeset_invert_strm = Module[
        '_sqlite3changeset_invert_strm'
      ] =
        Module['asm']['sqlite3changeset_invert_strm']).apply(null, arguments);
    });

    var _sqlite3changeset_apply_v2 = (Module['_sqlite3changeset_apply_v2'] =
      function () {
        return (_sqlite3changeset_apply_v2 = Module[
          '_sqlite3changeset_apply_v2'
        ] =
          Module['asm']['sqlite3changeset_apply_v2']).apply(null, arguments);
      });

    var _sqlite3changeset_apply = (Module['_sqlite3changeset_apply'] =
      function () {
        return (_sqlite3changeset_apply = Module['_sqlite3changeset_apply'] =
          Module['asm']['sqlite3changeset_apply']).apply(null, arguments);
      });

    var _sqlite3changeset_apply_v2_strm = (Module[
      '_sqlite3changeset_apply_v2_strm'
    ] = function () {
      return (_sqlite3changeset_apply_v2_strm = Module[
        '_sqlite3changeset_apply_v2_strm'
      ] =
        Module['asm']['sqlite3changeset_apply_v2_strm']).apply(null, arguments);
    });

    var _sqlite3changeset_apply_strm = (Module['_sqlite3changeset_apply_strm'] =
      function () {
        return (_sqlite3changeset_apply_strm = Module[
          '_sqlite3changeset_apply_strm'
        ] =
          Module['asm']['sqlite3changeset_apply_strm']).apply(null, arguments);
      });

    var _sqlite3changegroup_new = (Module['_sqlite3changegroup_new'] =
      function () {
        return (_sqlite3changegroup_new = Module['_sqlite3changegroup_new'] =
          Module['asm']['sqlite3changegroup_new']).apply(null, arguments);
      });

    var _sqlite3changegroup_add = (Module['_sqlite3changegroup_add'] =
      function () {
        return (_sqlite3changegroup_add = Module['_sqlite3changegroup_add'] =
          Module['asm']['sqlite3changegroup_add']).apply(null, arguments);
      });

    var _sqlite3changegroup_output = (Module['_sqlite3changegroup_output'] =
      function () {
        return (_sqlite3changegroup_output = Module[
          '_sqlite3changegroup_output'
        ] =
          Module['asm']['sqlite3changegroup_output']).apply(null, arguments);
      });

    var _sqlite3changegroup_add_strm = (Module['_sqlite3changegroup_add_strm'] =
      function () {
        return (_sqlite3changegroup_add_strm = Module[
          '_sqlite3changegroup_add_strm'
        ] =
          Module['asm']['sqlite3changegroup_add_strm']).apply(null, arguments);
      });

    var _sqlite3changegroup_output_strm = (Module[
      '_sqlite3changegroup_output_strm'
    ] = function () {
      return (_sqlite3changegroup_output_strm = Module[
        '_sqlite3changegroup_output_strm'
      ] =
        Module['asm']['sqlite3changegroup_output_strm']).apply(null, arguments);
    });

    var _sqlite3changegroup_delete = (Module['_sqlite3changegroup_delete'] =
      function () {
        return (_sqlite3changegroup_delete = Module[
          '_sqlite3changegroup_delete'
        ] =
          Module['asm']['sqlite3changegroup_delete']).apply(null, arguments);
      });

    var _sqlite3changeset_concat = (Module['_sqlite3changeset_concat'] =
      function () {
        return (_sqlite3changeset_concat = Module['_sqlite3changeset_concat'] =
          Module['asm']['sqlite3changeset_concat']).apply(null, arguments);
      });

    var _sqlite3changeset_concat_strm = (Module[
      '_sqlite3changeset_concat_strm'
    ] = function () {
      return (_sqlite3changeset_concat_strm = Module[
        '_sqlite3changeset_concat_strm'
      ] =
        Module['asm']['sqlite3changeset_concat_strm']).apply(null, arguments);
    });

    var _sqlite3session_config = (Module['_sqlite3session_config'] =
      function () {
        return (_sqlite3session_config = Module['_sqlite3session_config'] =
          Module['asm']['sqlite3session_config']).apply(null, arguments);
      });

    var _sqlite3_sourceid = (Module['_sqlite3_sourceid'] = function () {
      return (_sqlite3_sourceid = Module['_sqlite3_sourceid'] =
        Module['asm']['sqlite3_sourceid']).apply(null, arguments);
    });

    var _sqlite3_wasm_pstack_ptr = (Module['_sqlite3_wasm_pstack_ptr'] =
      function () {
        return (_sqlite3_wasm_pstack_ptr = Module['_sqlite3_wasm_pstack_ptr'] =
          Module['asm']['sqlite3_wasm_pstack_ptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_pstack_restore = (Module['_sqlite3_wasm_pstack_restore'] =
      function () {
        return (_sqlite3_wasm_pstack_restore = Module[
          '_sqlite3_wasm_pstack_restore'
        ] =
          Module['asm']['sqlite3_wasm_pstack_restore']).apply(null, arguments);
      });

    var _sqlite3_wasm_pstack_alloc = (Module['_sqlite3_wasm_pstack_alloc'] =
      function () {
        return (_sqlite3_wasm_pstack_alloc = Module[
          '_sqlite3_wasm_pstack_alloc'
        ] =
          Module['asm']['sqlite3_wasm_pstack_alloc']).apply(null, arguments);
      });

    var _sqlite3_wasm_pstack_remaining = (Module[
      '_sqlite3_wasm_pstack_remaining'
    ] = function () {
      return (_sqlite3_wasm_pstack_remaining = Module[
        '_sqlite3_wasm_pstack_remaining'
      ] =
        Module['asm']['sqlite3_wasm_pstack_remaining']).apply(null, arguments);
    });

    var _sqlite3_wasm_pstack_quota = (Module['_sqlite3_wasm_pstack_quota'] =
      function () {
        return (_sqlite3_wasm_pstack_quota = Module[
          '_sqlite3_wasm_pstack_quota'
        ] =
          Module['asm']['sqlite3_wasm_pstack_quota']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_error = (Module['_sqlite3_wasm_db_error'] =
      function () {
        return (_sqlite3_wasm_db_error = Module['_sqlite3_wasm_db_error'] =
          Module['asm']['sqlite3_wasm_db_error']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_struct = (Module['_sqlite3_wasm_test_struct'] =
      function () {
        return (_sqlite3_wasm_test_struct = Module[
          '_sqlite3_wasm_test_struct'
        ] =
          Module['asm']['sqlite3_wasm_test_struct']).apply(null, arguments);
      });

    var _sqlite3_wasm_enum_json = (Module['_sqlite3_wasm_enum_json'] =
      function () {
        return (_sqlite3_wasm_enum_json = Module['_sqlite3_wasm_enum_json'] =
          Module['asm']['sqlite3_wasm_enum_json']).apply(null, arguments);
      });

    var _sqlite3_wasm_vfs_unlink = (Module['_sqlite3_wasm_vfs_unlink'] =
      function () {
        return (_sqlite3_wasm_vfs_unlink = Module['_sqlite3_wasm_vfs_unlink'] =
          Module['asm']['sqlite3_wasm_vfs_unlink']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_vfs = (Module['_sqlite3_wasm_db_vfs'] = function () {
      return (_sqlite3_wasm_db_vfs = Module['_sqlite3_wasm_db_vfs'] =
        Module['asm']['sqlite3_wasm_db_vfs']).apply(null, arguments);
    });

    var _sqlite3_wasm_db_reset = (Module['_sqlite3_wasm_db_reset'] =
      function () {
        return (_sqlite3_wasm_db_reset = Module['_sqlite3_wasm_db_reset'] =
          Module['asm']['sqlite3_wasm_db_reset']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_export_chunked = (Module[
      '_sqlite3_wasm_db_export_chunked'
    ] = function () {
      return (_sqlite3_wasm_db_export_chunked = Module[
        '_sqlite3_wasm_db_export_chunked'
      ] =
        Module['asm']['sqlite3_wasm_db_export_chunked']).apply(null, arguments);
    });

    var _sqlite3_wasm_db_serialize = (Module['_sqlite3_wasm_db_serialize'] =
      function () {
        return (_sqlite3_wasm_db_serialize = Module[
          '_sqlite3_wasm_db_serialize'
        ] =
          Module['asm']['sqlite3_wasm_db_serialize']).apply(null, arguments);
      });

    var _sqlite3_wasm_vfs_create_file = (Module[
      '_sqlite3_wasm_vfs_create_file'
    ] = function () {
      return (_sqlite3_wasm_vfs_create_file = Module[
        '_sqlite3_wasm_vfs_create_file'
      ] =
        Module['asm']['sqlite3_wasm_vfs_create_file']).apply(null, arguments);
    });

    var _sqlite3_wasm_posix_create_file = (Module[
      '_sqlite3_wasm_posix_create_file'
    ] = function () {
      return (_sqlite3_wasm_posix_create_file = Module[
        '_sqlite3_wasm_posix_create_file'
      ] =
        Module['asm']['sqlite3_wasm_posix_create_file']).apply(null, arguments);
    });

    var _sqlite3_wasm_kvvfsMakeKeyOnPstack = (Module[
      '_sqlite3_wasm_kvvfsMakeKeyOnPstack'
    ] = function () {
      return (_sqlite3_wasm_kvvfsMakeKeyOnPstack = Module[
        '_sqlite3_wasm_kvvfsMakeKeyOnPstack'
      ] =
        Module['asm']['sqlite3_wasm_kvvfsMakeKeyOnPstack']).apply(
        null,
        arguments,
      );
    });

    var _sqlite3_wasm_kvvfs_methods = (Module['_sqlite3_wasm_kvvfs_methods'] =
      function () {
        return (_sqlite3_wasm_kvvfs_methods = Module[
          '_sqlite3_wasm_kvvfs_methods'
        ] =
          Module['asm']['sqlite3_wasm_kvvfs_methods']).apply(null, arguments);
      });

    var _sqlite3_wasm_vtab_config = (Module['_sqlite3_wasm_vtab_config'] =
      function () {
        return (_sqlite3_wasm_vtab_config = Module[
          '_sqlite3_wasm_vtab_config'
        ] =
          Module['asm']['sqlite3_wasm_vtab_config']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_config_ip = (Module['_sqlite3_wasm_db_config_ip'] =
      function () {
        return (_sqlite3_wasm_db_config_ip = Module[
          '_sqlite3_wasm_db_config_ip'
        ] =
          Module['asm']['sqlite3_wasm_db_config_ip']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_config_pii = (Module['_sqlite3_wasm_db_config_pii'] =
      function () {
        return (_sqlite3_wasm_db_config_pii = Module[
          '_sqlite3_wasm_db_config_pii'
        ] =
          Module['asm']['sqlite3_wasm_db_config_pii']).apply(null, arguments);
      });

    var _sqlite3_wasm_db_config_s = (Module['_sqlite3_wasm_db_config_s'] =
      function () {
        return (_sqlite3_wasm_db_config_s = Module[
          '_sqlite3_wasm_db_config_s'
        ] =
          Module['asm']['sqlite3_wasm_db_config_s']).apply(null, arguments);
      });

    var _sqlite3_wasm_config_i = (Module['_sqlite3_wasm_config_i'] =
      function () {
        return (_sqlite3_wasm_config_i = Module['_sqlite3_wasm_config_i'] =
          Module['asm']['sqlite3_wasm_config_i']).apply(null, arguments);
      });

    var _sqlite3_wasm_config_ii = (Module['_sqlite3_wasm_config_ii'] =
      function () {
        return (_sqlite3_wasm_config_ii = Module['_sqlite3_wasm_config_ii'] =
          Module['asm']['sqlite3_wasm_config_ii']).apply(null, arguments);
      });

    var _sqlite3_wasm_config_j = (Module['_sqlite3_wasm_config_j'] =
      function () {
        return (_sqlite3_wasm_config_j = Module['_sqlite3_wasm_config_j'] =
          Module['asm']['sqlite3_wasm_config_j']).apply(null, arguments);
      });

    var _sqlite3_wasm_init_wasmfs = (Module['_sqlite3_wasm_init_wasmfs'] =
      function () {
        return (_sqlite3_wasm_init_wasmfs = Module[
          '_sqlite3_wasm_init_wasmfs'
        ] =
          Module['asm']['sqlite3_wasm_init_wasmfs']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_intptr = (Module['_sqlite3_wasm_test_intptr'] =
      function () {
        return (_sqlite3_wasm_test_intptr = Module[
          '_sqlite3_wasm_test_intptr'
        ] =
          Module['asm']['sqlite3_wasm_test_intptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_voidptr = (Module['_sqlite3_wasm_test_voidptr'] =
      function () {
        return (_sqlite3_wasm_test_voidptr = Module[
          '_sqlite3_wasm_test_voidptr'
        ] =
          Module['asm']['sqlite3_wasm_test_voidptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_int64_max = (Module['_sqlite3_wasm_test_int64_max'] =
      function () {
        return (_sqlite3_wasm_test_int64_max = Module[
          '_sqlite3_wasm_test_int64_max'
        ] =
          Module['asm']['sqlite3_wasm_test_int64_max']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_int64_min = (Module['_sqlite3_wasm_test_int64_min'] =
      function () {
        return (_sqlite3_wasm_test_int64_min = Module[
          '_sqlite3_wasm_test_int64_min'
        ] =
          Module['asm']['sqlite3_wasm_test_int64_min']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_int64_times2 = (Module[
      '_sqlite3_wasm_test_int64_times2'
    ] = function () {
      return (_sqlite3_wasm_test_int64_times2 = Module[
        '_sqlite3_wasm_test_int64_times2'
      ] =
        Module['asm']['sqlite3_wasm_test_int64_times2']).apply(null, arguments);
    });

    var _sqlite3_wasm_test_int64_minmax = (Module[
      '_sqlite3_wasm_test_int64_minmax'
    ] = function () {
      return (_sqlite3_wasm_test_int64_minmax = Module[
        '_sqlite3_wasm_test_int64_minmax'
      ] =
        Module['asm']['sqlite3_wasm_test_int64_minmax']).apply(null, arguments);
    });

    var _sqlite3_wasm_test_int64ptr = (Module['_sqlite3_wasm_test_int64ptr'] =
      function () {
        return (_sqlite3_wasm_test_int64ptr = Module[
          '_sqlite3_wasm_test_int64ptr'
        ] =
          Module['asm']['sqlite3_wasm_test_int64ptr']).apply(null, arguments);
      });

    var _sqlite3_wasm_test_stack_overflow = (Module[
      '_sqlite3_wasm_test_stack_overflow'
    ] = function () {
      return (_sqlite3_wasm_test_stack_overflow = Module[
        '_sqlite3_wasm_test_stack_overflow'
      ] =
        Module['asm']['sqlite3_wasm_test_stack_overflow']).apply(
        null,
        arguments,
      );
    });

    var _sqlite3_wasm_test_str_hello = (Module['_sqlite3_wasm_test_str_hello'] =
      function () {
        return (_sqlite3_wasm_test_str_hello = Module[
          '_sqlite3_wasm_test_str_hello'
        ] =
          Module['asm']['sqlite3_wasm_test_str_hello']).apply(null, arguments);
      });

    var _sqlite3_wasm_SQLTester_strglob = (Module[
      '_sqlite3_wasm_SQLTester_strglob'
    ] = function () {
      return (_sqlite3_wasm_SQLTester_strglob = Module[
        '_sqlite3_wasm_SQLTester_strglob'
      ] =
        Module['asm']['sqlite3_wasm_SQLTester_strglob']).apply(null, arguments);
    });

    var _malloc = (Module['_malloc'] = function () {
      return (_malloc = Module['_malloc'] = Module['asm']['malloc']).apply(
        null,
        arguments,
      );
    });

    var _free = (Module['_free'] = function () {
      return (_free = Module['_free'] = Module['asm']['free']).apply(
        null,
        arguments,
      );
    });

    var _realloc = (Module['_realloc'] = function () {
      return (_realloc = Module['_realloc'] = Module['asm']['realloc']).apply(
        null,
        arguments,
      );
    });

    var _emscripten_builtin_memalign = (Module['_emscripten_builtin_memalign'] =
      function () {
        return (_emscripten_builtin_memalign = Module[
          '_emscripten_builtin_memalign'
        ] =
          Module['asm']['emscripten_builtin_memalign']).apply(null, arguments);
      });

    var stackSave = (Module['stackSave'] = function () {
      return (stackSave = Module['stackSave'] =
        Module['asm']['stackSave']).apply(null, arguments);
    });

    var stackRestore = (Module['stackRestore'] = function () {
      return (stackRestore = Module['stackRestore'] =
        Module['asm']['stackRestore']).apply(null, arguments);
    });

    var stackAlloc = (Module['stackAlloc'] = function () {
      return (stackAlloc = Module['stackAlloc'] =
        Module['asm']['stackAlloc']).apply(null, arguments);
    });

    Module['wasmMemory'] = wasmMemory;

    var calledRun;

    dependenciesFulfilled = function runCaller() {
      if (!calledRun) run();
      if (!calledRun) dependenciesFulfilled = runCaller;
    };

    function run(args) {
      args = args || arguments_;

      if (runDependencies > 0) {
        return;
      }

      preRun();

      if (runDependencies > 0) {
        return;
      }

      function doRun() {
        if (calledRun) return;
        calledRun = true;
        Module['calledRun'] = true;

        if (ABORT) return;

        initRuntime();

        readyPromiseResolve(Module);
        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

        postRun();
      }

      if (Module['setStatus']) {
        Module['setStatus']('Running...');
        setTimeout(function () {
          setTimeout(function () {
            Module['setStatus']('');
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }

    if (Module['preInit']) {
      if (typeof Module['preInit'] == 'function')
        Module['preInit'] = [Module['preInit']];
      while (Module['preInit'].length > 0) {
        Module['preInit'].pop()();
      }
    }

    run();

    if (!Module.postRun) Module.postRun = [];
    Module.postRun.push(function (Module) {
      'use strict';

      'use strict';
      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(
        apiConfig = globalThis.sqlite3ApiConfig ||
          sqlite3ApiBootstrap.defaultConfig,
      ) {
        if (sqlite3ApiBootstrap.sqlite3) {
          console.warn(
            'sqlite3ApiBootstrap() called multiple times.',
            'Config and external initializers are ignored on calls after the first.',
          );
          return sqlite3ApiBootstrap.sqlite3;
        }
        const config = Object.assign(
          Object.create(null),
          {
            exports: undefined,
            memory: undefined,
            bigIntEnabled: (() => {
              if ('undefined' !== typeof Module) {
                return !!Module.HEAPU64;
              }
              return !!globalThis.BigInt64Array;
            })(),
            debug: console.debug.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console),
            log: console.log.bind(console),
            wasmfsOpfsDir: '/opfs',

            useStdAlloc: false,
          },
          apiConfig || {},
        );

        Object.assign(
          config,
          {
            allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',
            deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',
            reallocExportName: config.useStdAlloc
              ? 'realloc'
              : 'sqlite3_realloc',
          },
          config,
        );

        ['exports', 'memory', 'wasmfsOpfsDir'].forEach((k) => {
          if ('function' === typeof config[k]) {
            config[k] = config[k]();
          }
        });

        const capi = Object.create(null);

        const wasm = Object.create(null);

        const __rcStr = (rc) => {
          return (
            (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc)) ||
            'Unknown result code #' + rc
          );
        };

        const __isInt = (n) => 'number' === typeof n && n === (n | 0);

        class SQLite3Error extends Error {
          constructor(...args) {
            let rc;
            if (args.length) {
              if (__isInt(args[0])) {
                rc = args[0];
                if (1 === args.length) {
                  super(__rcStr(args[0]));
                } else {
                  const rcStr = __rcStr(rc);
                  if ('object' === typeof args[1]) {
                    super(rcStr, args[1]);
                  } else {
                    args[0] = rcStr + ':';
                    super(args.join(' '));
                  }
                }
              } else {
                if (2 === args.length && 'object' === typeof args[1]) {
                  super(...args);
                } else {
                  super(args.join(' '));
                }
              }
            }
            this.resultCode = rc || capi.SQLITE_ERROR;
            this.name = 'SQLite3Error';
          }
        }

        SQLite3Error.toss = (...args) => {
          throw new SQLite3Error(...args);
        };
        const toss3 = SQLite3Error.toss;

        if (config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)) {
          toss3(
            "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.",
          );
        }

        const isInt32 = (n) => {
          return (
            'bigint' !== typeof n &&
            !!(n === (n | 0) && n <= 2147483647 && n >= -2147483648)
          );
        };

        const bigIntFits64 = function f(b) {
          if (!f._max) {
            f._max = BigInt('0x7fffffffffffffff');
            f._min = ~f._max;
          }
          return b >= f._min && b <= f._max;
        };

        const bigIntFits32 = (b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn;

        const bigIntFitsDouble = function f(b) {
          if (!f._min) {
            f._min = Number.MIN_SAFE_INTEGER;
            f._max = Number.MAX_SAFE_INTEGER;
          }
          return b >= f._min && b <= f._max;
        };

        const isTypedArray = (v) => {
          return v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)
            ? v
            : false;
        };

        const __SAB =
          'undefined' === typeof SharedArrayBuffer
            ? function () {}
            : SharedArrayBuffer;

        const isSharedTypedArray = (aTypedArray) =>
          aTypedArray.buffer instanceof __SAB;

        const typedArrayPart = (aTypedArray, begin, end) => {
          return isSharedTypedArray(aTypedArray)
            ? aTypedArray.slice(begin, end)
            : aTypedArray.subarray(begin, end);
        };

        const isBindableTypedArray = (v) => {
          return (
            v &&
            (v instanceof Uint8Array ||
              v instanceof Int8Array ||
              v instanceof ArrayBuffer)
          );
        };

        const isSQLableTypedArray = (v) => {
          return (
            v &&
            (v instanceof Uint8Array ||
              v instanceof Int8Array ||
              v instanceof ArrayBuffer)
          );
        };

        const affirmBindableTypedArray = (v) => {
          return (
            isBindableTypedArray(v) ||
            toss3('Value is not of a supported TypedArray type.')
          );
        };

        const utf8Decoder = new TextDecoder('utf-8');

        const typedArrayToString = function (typedArray, begin, end) {
          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
        };

        const flexibleString = function (v) {
          if (isSQLableTypedArray(v)) {
            return typedArrayToString(
              v instanceof ArrayBuffer ? new Uint8Array(v) : v,
            );
          } else if (Array.isArray(v)) return v.join('');
          else if (wasm.isPtr(v)) v = wasm.cstrToJs(v);
          return v;
        };

        class WasmAllocError extends Error {
          constructor(...args) {
            if (2 === args.length && 'object' === typeof args[1]) {
              super(...args);
            } else if (args.length) {
              super(args.join(' '));
            } else {
              super('Allocation failed.');
            }
            this.resultCode = capi.SQLITE_NOMEM;
            this.name = 'WasmAllocError';
          }
        }

        WasmAllocError.toss = (...args) => {
          throw new WasmAllocError(...args);
        };

        Object.assign(capi, {
          sqlite3_bind_blob: undefined,

          sqlite3_bind_text: undefined,

          sqlite3_create_function_v2: (
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
            xDestroy,
          ) => {},

          sqlite3_create_function: (
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
          ) => {},

          sqlite3_create_window_function: (
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xStep,
            xFinal,
            xValue,
            xInverse,
            xDestroy,
          ) => {},

          sqlite3_prepare_v3: (
            dbPtr,
            sql,
            sqlByteLen,
            prepFlags,
            stmtPtrPtr,
            strPtrPtr,
          ) => {},

          sqlite3_prepare_v2: (
            dbPtr,
            sql,
            sqlByteLen,
            stmtPtrPtr,
            strPtrPtr,
          ) => {},

          sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg) => {},

          sqlite3_randomness: (n, outPtr) => {},
        });

        const util = {
          affirmBindableTypedArray,
          flexibleString,
          bigIntFits32,
          bigIntFits64,
          bigIntFitsDouble,
          isBindableTypedArray,
          isInt32,
          isSQLableTypedArray,
          isTypedArray,
          typedArrayToString,
          isUIThread: () =>
            globalThis.window === globalThis && !!globalThis.document,

          isSharedTypedArray,
          toss: function (...args) {
            throw new Error(args.join(' '));
          },
          toss3,
          typedArrayPart,

          affirmDbHeader: function (bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            const header = 'SQLite format 3';
            if (header.length > bytes.byteLength) {
              toss3('Input does not contain an SQLite3 database header.');
            }
            for (let i = 0; i < header.length; ++i) {
              if (header.charCodeAt(i) !== bytes[i]) {
                toss3('Input does not contain an SQLite3 database header.');
              }
            }
          },

          affirmIsDb: function (bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            const n = bytes.byteLength;
            if (n < 512 || n % 512 !== 0) {
              toss3('Byte array size', n, 'is invalid for an SQLite3 db.');
            }
            util.affirmDbHeader(bytes);
          },
        };

        Object.assign(wasm, {
          ptrSizeof: config.wasmPtrSizeof || 4,

          ptrIR: config.wasmPtrIR || 'i32',

          bigIntEnabled: !!config.bigIntEnabled,

          exports:
            config.exports ||
            toss3('Missing API config.exports (WASM module exports).'),

          memory:
            config.memory ||
            config.exports['memory'] ||
            toss3(
              'API config object requires a WebAssembly.Memory object',
              'in either config.exports.memory (exported)',
              'or config.memory (imported).',
            ),

          alloc: undefined,

          realloc: undefined,

          dealloc: undefined,
        });

        wasm.allocFromTypedArray = function (srcTypedArray) {
          if (srcTypedArray instanceof ArrayBuffer) {
            srcTypedArray = new Uint8Array(srcTypedArray);
          }
          affirmBindableTypedArray(srcTypedArray);
          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
          wasm
            .heapForSize(srcTypedArray.constructor)
            .set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
          return pRet;
        };

        {
          const keyAlloc = config.allocExportName,
            keyDealloc = config.deallocExportName,
            keyRealloc = config.reallocExportName;
          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {
            const f = wasm.exports[key];
            if (!(f instanceof Function))
              toss3('Missing required exports[', key, '] function.');
          }

          wasm.alloc = function f(n) {
            return (
              f.impl(n) ||
              WasmAllocError.toss('Failed to allocate', n, ' bytes.')
            );
          };
          wasm.alloc.impl = wasm.exports[keyAlloc];
          wasm.realloc = function f(m, n) {
            const m2 = f.impl(m, n);
            return n
              ? m2 || WasmAllocError.toss('Failed to reallocate', n, ' bytes.')
              : 0;
          };
          wasm.realloc.impl = wasm.exports[keyRealloc];
          wasm.dealloc = wasm.exports[keyDealloc];
        }

        wasm.compileOptionUsed = function f(optName) {
          if (!arguments.length) {
            if (f._result) return f._result;
            else if (!f._opt) {
              f._rx = /^([^=]+)=(.+)/;
              f._rxInt = /^-?\d+$/;
              f._opt = function (opt, rv) {
                const m = f._rx.exec(opt);
                rv[0] = m ? m[1] : opt;
                rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;
              };
            }
            const rc = {},
              ov = [0, 0];
            let i = 0,
              k;
            while ((k = capi.sqlite3_compileoption_get(i++))) {
              f._opt(k, ov);
              rc[ov[0]] = ov[1];
            }
            return (f._result = rc);
          } else if (Array.isArray(optName)) {
            const rc = {};
            optName.forEach((v) => {
              rc[v] = capi.sqlite3_compileoption_used(v);
            });
            return rc;
          } else if ('object' === typeof optName) {
            Object.keys(optName).forEach((k) => {
              optName[k] = capi.sqlite3_compileoption_used(k);
            });
            return optName;
          }
          return 'string' === typeof optName
            ? !!capi.sqlite3_compileoption_used(optName)
            : false;
        };

        wasm.pstack = Object.assign(Object.create(null), {
          restore: wasm.exports.sqlite3_wasm_pstack_restore,

          alloc: function (n) {
            if ('string' === typeof n && !(n = wasm.sizeofIR(n))) {
              WasmAllocError.toss(
                'Invalid value for pstack.alloc(',
                arguments[0],
                ')',
              );
            }
            return (
              wasm.exports.sqlite3_wasm_pstack_alloc(n) ||
              WasmAllocError.toss(
                'Could not allocate',
                n,
                'bytes from the pstack.',
              )
            );
          },

          allocChunks: function (n, sz) {
            if ('string' === typeof sz && !(sz = wasm.sizeofIR(sz))) {
              WasmAllocError.toss(
                'Invalid size value for allocChunks(',
                arguments[1],
                ')',
              );
            }
            const mem = wasm.pstack.alloc(n * sz);
            const rc = [];
            let i = 0,
              offset = 0;
            for (; i < n; ++i, offset += sz) rc.push(mem + offset);
            return rc;
          },

          allocPtr: (n = 1, safePtrSize = true) => {
            return 1 === n
              ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)
              : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);
          },

          call: function (f) {
            const stackPos = wasm.pstack.pointer;
            try {
              return f(sqlite3);
            } finally {
              wasm.pstack.restore(stackPos);
            }
          },
        });
        Object.defineProperties(wasm.pstack, {
          pointer: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3_wasm_pstack_ptr,
          },

          quota: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3_wasm_pstack_quota,
          },

          remaining: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3_wasm_pstack_remaining,
          },
        });

        capi.sqlite3_randomness = (...args) => {
          if (
            1 === args.length &&
            util.isTypedArray(args[0]) &&
            1 === args[0].BYTES_PER_ELEMENT
          ) {
            const ta = args[0];
            if (0 === ta.byteLength) {
              wasm.exports.sqlite3_randomness(0, 0);
              return ta;
            }
            const stack = wasm.pstack.pointer;
            try {
              let n = ta.byteLength,
                offset = 0;
              const r = wasm.exports.sqlite3_randomness;
              const heap = wasm.heap8u();
              const nAlloc = n < 512 ? n : 512;
              const ptr = wasm.pstack.alloc(nAlloc);
              do {
                const j = n > nAlloc ? nAlloc : n;
                r(j, ptr);
                ta.set(typedArrayPart(heap, ptr, ptr + j), offset);
                n -= j;
                offset += j;
              } while (n > 0);
            } catch (e) {
              console.error(
                'Highly unexpected (and ignored!) ' +
                  'exception in sqlite3_randomness():',
                e,
              );
            } finally {
              wasm.pstack.restore(stack);
            }
            return ta;
          }
          wasm.exports.sqlite3_randomness(...args);
        };

        let __wasmfsOpfsDir = undefined;

        capi.sqlite3_wasmfs_opfs_dir = function () {
          if (undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;

          const pdir = config.wasmfsOpfsDir;
          if (
            !pdir ||
            !globalThis.FileSystemHandle ||
            !globalThis.FileSystemDirectoryHandle ||
            !globalThis.FileSystemFileHandle
          ) {
            return (__wasmfsOpfsDir = '');
          }
          try {
            if (
              pdir &&
              0 ===
                wasm.xCallWrapped(
                  'sqlite3_wasm_init_wasmfs',
                  'i32',
                  ['string'],
                  pdir,
                )
            ) {
              return (__wasmfsOpfsDir = pdir);
            } else {
              return (__wasmfsOpfsDir = '');
            }
          } catch (e) {
            return (__wasmfsOpfsDir = '');
          }
        };

        capi.sqlite3_wasmfs_filename_is_persistent = function (name) {
          const p = capi.sqlite3_wasmfs_opfs_dir();
          return p && name ? name.startsWith(p + '/') : false;
        };

        capi.sqlite3_js_db_uses_vfs = function (pDb, vfsName, dbName = 0) {
          try {
            const pK = capi.sqlite3_vfs_find(vfsName);
            if (!pK) return false;
            else if (!pDb) {
              return pK === capi.sqlite3_vfs_find(0) ? pK : false;
            } else {
              return pK === capi.sqlite3_js_db_vfs(pDb, dbName) ? pK : false;
            }
          } catch (e) {
            return false;
          }
        };

        capi.sqlite3_js_vfs_list = function () {
          const rc = [];
          let pVfs = capi.sqlite3_vfs_find(0);
          while (pVfs) {
            const oVfs = new capi.sqlite3_vfs(pVfs);
            rc.push(wasm.cstrToJs(oVfs.$zName));
            pVfs = oVfs.$pNext;
            oVfs.dispose();
          }
          return rc;
        };

        capi.sqlite3_js_db_export = function (pDb, schema = 0) {
          pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);
          if (!pDb) toss3('Invalid sqlite3* argument.');
          if (!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');
          const scope = wasm.scopedAllocPush();
          let pOut;
          try {
            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
            const ppOut = pSize + 8;

            const zSchema = schema
              ? wasm.isPtr(schema)
                ? schema
                : wasm.scopedAllocCString('' + schema)
              : 0;
            let rc = wasm.exports.sqlite3_wasm_db_serialize(
              pDb,
              zSchema,
              ppOut,
              pSize,
              0,
            );
            if (rc) {
              toss3(
                'Database serialization failed with code',
                sqlite3.capi.sqlite3_js_rc_str(rc),
              );
            }
            pOut = wasm.peekPtr(ppOut);
            const nOut = wasm.peek(pSize, 'i64');
            rc = nOut
              ? wasm.heap8u().slice(pOut, pOut + Number(nOut))
              : new Uint8Array();
            return rc;
          } finally {
            if (pOut) wasm.exports.sqlite3_free(pOut);
            wasm.scopedAllocPop(scope);
          }
        };

        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) =>
          wasm.sqlite3_wasm_db_vfs(dbPointer, dbName);

        capi.sqlite3_js_aggregate_context = (pCtx, n) => {
          return (
            capi.sqlite3_aggregate_context(pCtx, n) ||
            (n
              ? WasmAllocError.toss(
                  'Cannot allocate',
                  n,
                  'bytes for sqlite3_aggregate_context()',
                )
              : 0)
          );
        };

        capi.sqlite3_js_posix_create_file = function (filename, data, dataLen) {
          let pData;
          if (data && wasm.isPtr(data)) {
            pData = data;
          } else if (
            data instanceof ArrayBuffer ||
            data instanceof Uint8Array
          ) {
            pData = wasm.allocFromTypedArray(data);
            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
              dataLen = data.byteLength;
            }
          } else {
            SQLite3Error.toss(
              'Invalid 2nd argument for sqlite3_js_posix_create_file().',
            );
          }
          try {
            if (!util.isInt32(dataLen) || dataLen < 0) {
              SQLite3Error.toss(
                'Invalid 3rd argument for sqlite3_js_posix_create_file().',
              );
            }
            const rc = wasm.sqlite3_wasm_posix_create_file(
              filename,
              pData,
              dataLen,
            );
            if (rc)
              SQLite3Error.toss(
                'Creation of file failed with sqlite3 result code',
                capi.sqlite3_js_rc_str(rc),
              );
          } finally {
            wasm.dealloc(pData);
          }
        };

        capi.sqlite3_js_vfs_create_file = function (
          vfs,
          filename,
          data,
          dataLen,
        ) {
          config.warn(
            'sqlite3_js_vfs_create_file() is deprecated and',
            'should be avoided because it can lead to C-level crashes.',
            'See its documentation for alternative options.',
          );
          let pData;
          if (data) {
            if (wasm.isPtr(data)) {
              pData = data;
            } else if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            if (data instanceof Uint8Array) {
              pData = wasm.allocFromTypedArray(data);
              if (
                arguments.length < 4 ||
                !util.isInt32(dataLen) ||
                dataLen < 0
              ) {
                dataLen = data.byteLength;
              }
            } else {
              SQLite3Error.toss(
                'Invalid 3rd argument type for sqlite3_js_vfs_create_file().',
              );
            }
          } else {
            pData = 0;
          }
          if (!util.isInt32(dataLen) || dataLen < 0) {
            wasm.dealloc(pData);
            SQLite3Error.toss(
              'Invalid 4th argument for sqlite3_js_vfs_create_file().',
            );
          }
          try {
            const rc = wasm.sqlite3_wasm_vfs_create_file(
              vfs,
              filename,
              pData,
              dataLen,
            );
            if (rc)
              SQLite3Error.toss(
                'Creation of file failed with sqlite3 result code',
                capi.sqlite3_js_rc_str(rc),
              );
          } finally {
            wasm.dealloc(pData);
          }
        };

        capi.sqlite3_js_sql_to_string = (sql) => {
          if ('string' === typeof sql) {
            return sql;
          }
          const x = flexibleString(v);
          return x === v ? undefined : x;
        };

        if (util.isUIThread()) {
          const __kvvfsInfo = function (which) {
            const rc = Object.create(null);
            rc.prefix = 'kvvfs-' + which;
            rc.stores = [];
            if ('session' === which || '' === which)
              rc.stores.push(globalThis.sessionStorage);
            if ('local' === which || '' === which)
              rc.stores.push(globalThis.localStorage);
            return rc;
          };

          capi.sqlite3_js_kvvfs_clear = function (which = '') {
            let rc = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s) => {
              const toRm = [];
              let i;
              for (i = 0; i < s.length; ++i) {
                const k = s.key(i);
                if (k.startsWith(kvinfo.prefix)) toRm.push(k);
              }
              toRm.forEach((kk) => s.removeItem(kk));
              rc += toRm.length;
            });
            return rc;
          };

          capi.sqlite3_js_kvvfs_size = function (which = '') {
            let sz = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s) => {
              let i;
              for (i = 0; i < s.length; ++i) {
                const k = s.key(i);
                if (k.startsWith(kvinfo.prefix)) {
                  sz += k.length;
                  sz += s.getItem(k).length;
                }
              }
            });
            return sz * 2;
          };
        }

        capi.sqlite3_db_config = function (pDb, op, ...args) {
          if (!this.s) {
            this.s = wasm.xWrap('sqlite3_wasm_db_config_s', 'int', [
              'sqlite3*',
              'int',
              'string:static',
            ]);
            this.pii = wasm.xWrap('sqlite3_wasm_db_config_pii', 'int', [
              'sqlite3*',
              'int',
              '*',
              'int',
              'int',
            ]);
            this.ip = wasm.xWrap('sqlite3_wasm_db_config_ip', 'int', [
              'sqlite3*',
              'int',
              'int',
              '*',
            ]);
          }
          switch (op) {
            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
            case capi.SQLITE_DBCONFIG_RESET_DATABASE:
            case capi.SQLITE_DBCONFIG_DEFENSIVE:
            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
            case capi.SQLITE_DBCONFIG_DQS_DML:
            case capi.SQLITE_DBCONFIG_DQS_DDL:
            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
              return this.ip(pDb, op, args[0], args[1] || 0);
            case capi.SQLITE_DBCONFIG_LOOKASIDE:
              return this.pii(pDb, op, args[0], args[1], args[2]);
            case capi.SQLITE_DBCONFIG_MAINDBNAME:
              return this.s(pDb, op, args[0]);
            default:
              return capi.SQLITE_MISUSE;
          }
        }.bind(Object.create(null));

        capi.sqlite3_value_to_js = function (
          pVal,
          throwIfCannotConvert = true,
        ) {
          let arg;
          const valType = capi.sqlite3_value_type(pVal);
          switch (valType) {
            case capi.SQLITE_INTEGER:
              if (wasm.bigIntEnabled) {
                arg = capi.sqlite3_value_int64(pVal);
                if (util.bigIntFitsDouble(arg)) arg = Number(arg);
              } else arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_FLOAT:
              arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_TEXT:
              arg = capi.sqlite3_value_text(pVal);
              break;
            case capi.SQLITE_BLOB: {
              const n = capi.sqlite3_value_bytes(pVal);
              const pBlob = capi.sqlite3_value_blob(pVal);
              if (n && !pBlob)
                sqlite3.WasmAllocError.toss(
                  'Cannot allocate memory for blob argument of',
                  n,
                  'byte(s)',
                );
              arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;
              break;
            }
            case capi.SQLITE_NULL:
              arg = null;
              break;
            default:
              if (throwIfCannotConvert) {
                toss3(
                  capi.SQLITE_MISMATCH,
                  'Unhandled sqlite3_value_type():',
                  valType,
                );
              }
              arg = undefined;
          }
          return arg;
        };

        capi.sqlite3_values_to_js = function (
          argc,
          pArgv,
          throwIfCannotConvert = true,
        ) {
          let i;
          const tgt = [];
          for (i = 0; i < argc; ++i) {
            tgt.push(
              capi.sqlite3_value_to_js(
                wasm.peekPtr(pArgv + wasm.ptrSizeof * i),
                throwIfCannotConvert,
              ),
            );
          }
          return tgt;
        };

        capi.sqlite3_result_error_js = function (pCtx, e) {
          if (e instanceof WasmAllocError) {
            capi.sqlite3_result_error_nomem(pCtx);
          } else {
            capi.sqlite3_result_error(pCtx, '' + e, -1);
          }
        };

        capi.sqlite3_result_js = function (pCtx, val) {
          if (val instanceof Error) {
            capi.sqlite3_result_error_js(pCtx, val);
            return;
          }
          try {
            switch (typeof val) {
              case 'undefined':
                break;
              case 'boolean':
                capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                break;
              case 'bigint':
                if (util.bigIntFits32(val)) {
                  capi.sqlite3_result_int(pCtx, Number(val));
                } else if (util.bigIntFitsDouble(val)) {
                  capi.sqlite3_result_double(pCtx, Number(val));
                } else if (wasm.bigIntEnabled) {
                  if (util.bigIntFits64(val))
                    capi.sqlite3_result_int64(pCtx, val);
                  else
                    toss3(
                      'BigInt value',
                      val.toString(),
                      'is too BigInt for int64.',
                    );
                } else {
                  toss3('BigInt value', val.toString(), 'is too BigInt.');
                }
                break;
              case 'number': {
                let f;
                if (util.isInt32(val)) {
                  f = capi.sqlite3_result_int;
                } else if (
                  wasm.bigIntEnabled &&
                  Number.isInteger(val) &&
                  util.bigIntFits64(BigInt(val))
                ) {
                  f = capi.sqlite3_result_int64;
                } else {
                  f = capi.sqlite3_result_double;
                }
                f(pCtx, val);
                break;
              }
              case 'string': {
                const [p, n] = wasm.allocCString(val, true);
                capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);
                break;
              }
              case 'object':
                if (null === val) {
                  capi.sqlite3_result_null(pCtx);
                  break;
                } else if (util.isBindableTypedArray(val)) {
                  const pBlob = wasm.allocFromTypedArray(val);
                  capi.sqlite3_result_blob(
                    pCtx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC,
                  );
                  break;
                }

              default:
                toss3(
                  "Don't not how to handle this UDF result value:",
                  typeof val,
                  val,
                );
            }
          } catch (e) {
            capi.sqlite3_result_error_js(pCtx, e);
          }
        };

        capi.sqlite3_column_js = function (
          pStmt,
          iCol,
          throwIfCannotConvert = true,
        ) {
          const v = capi.sqlite3_column_value(pStmt, iCol);
          return 0 === v
            ? undefined
            : capi.sqlite3_value_to_js(v, throwIfCannotConvert);
        };

        const __newOldValue = function (pObj, iCol, impl) {
          impl = capi[impl];
          if (!this.ptr) this.ptr = wasm.allocPtr();
          else wasm.pokePtr(this.ptr, 0);
          const rc = impl(pObj, iCol, this.ptr);
          if (rc)
            return SQLite3Error.toss(
              rc,
              arguments[2] + '() failed with code ' + rc,
            );
          const pv = wasm.peekPtr(this.ptr);
          return pv ? capi.sqlite3_value_to_js(pv, true) : undefined;
        }.bind(Object.create(null));

        capi.sqlite3_preupdate_new_js = (pDb, iCol) =>
          __newOldValue(pDb, iCol, 'sqlite3_preupdate_new');

        capi.sqlite3_preupdate_old_js = (pDb, iCol) =>
          __newOldValue(pDb, iCol, 'sqlite3_preupdate_old');

        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) =>
          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_new');

        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) =>
          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_old');

        const sqlite3 = {
          WasmAllocError: WasmAllocError,
          SQLite3Error: SQLite3Error,
          capi,
          util,
          wasm,
          config,

          version: Object.create(null),

          client: undefined,

          asyncPostInit: async function ff() {
            if (ff.isReady instanceof Promise) return ff.isReady;
            let lia = sqlite3ApiBootstrap.initializersAsync;
            delete sqlite3ApiBootstrap.initializersAsync;
            const postInit = async () => {
              if (!sqlite3.__isUnderTest) {
                delete sqlite3.util;

                delete sqlite3.StructBinder;
              }
              return sqlite3;
            };
            const catcher = (e) => {
              config.error('an async sqlite3 initializer failed:', e);
              throw e;
            };
            if (!lia || !lia.length) {
              return (ff.isReady = postInit().catch(catcher));
            }
            lia = lia.map((f) => {
              return f instanceof Function ? async (x) => f(sqlite3) : f;
            });
            lia.push(postInit);
            let p = Promise.resolve(sqlite3);
            while (lia.length) p = p.then(lia.shift());
            return (ff.isReady = p.catch(catcher));
          },

          scriptInfo: undefined,
        };
        try {
          sqlite3ApiBootstrap.initializers.forEach((f) => {
            f(sqlite3);
          });
        } catch (e) {
          console.error('sqlite3 bootstrap initializer threw:', e);
          throw e;
        }
        delete sqlite3ApiBootstrap.initializers;
        sqlite3ApiBootstrap.sqlite3 = sqlite3;
        return sqlite3;
      };

      globalThis.sqlite3ApiBootstrap.initializers = [];

      globalThis.sqlite3ApiBootstrap.initializersAsync = [];

      globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);

      globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;

      globalThis.WhWasmUtilInstaller = function (target) {
        'use strict';
        if (undefined === target.bigIntEnabled) {
          target.bigIntEnabled = !!globalThis['BigInt64Array'];
        }

        const toss = (...args) => {
          throw new Error(args.join(' '));
        };

        if (!target.exports) {
          Object.defineProperty(target, 'exports', {
            enumerable: true,
            configurable: true,
            get: () => target.instance && target.instance.exports,
          });
        }

        const ptrIR = target.pointerIR || 'i32';
        const ptrSizeof = (target.ptrSizeof =
          'i32' === ptrIR
            ? 4
            : 'i64' === ptrIR
              ? 8
              : toss('Unhandled ptrSizeof:', ptrIR));

        const cache = Object.create(null);

        cache.heapSize = 0;

        cache.memory = null;

        cache.freeFuncIndexes = [];

        cache.scopedAlloc = [];

        cache.utf8Decoder = new TextDecoder();
        cache.utf8Encoder = new TextEncoder('utf-8');

        target.sizeofIR = (n) => {
          switch (n) {
            case 'i8':
              return 1;
            case 'i16':
              return 2;
            case 'i32':
            case 'f32':
            case 'float':
              return 4;
            case 'i64':
            case 'f64':
            case 'double':
              return 8;
            case '*':
              return ptrSizeof;
            default:
              return ('' + n).endsWith('*') ? ptrSizeof : undefined;
          }
        };

        const heapWrappers = function () {
          if (!cache.memory) {
            cache.memory =
              target.memory instanceof WebAssembly.Memory
                ? target.memory
                : target.exports.memory;
          } else if (cache.heapSize === cache.memory.buffer.byteLength) {
            return cache;
          }

          const b = cache.memory.buffer;
          cache.HEAP8 = new Int8Array(b);
          cache.HEAP8U = new Uint8Array(b);
          cache.HEAP16 = new Int16Array(b);
          cache.HEAP16U = new Uint16Array(b);
          cache.HEAP32 = new Int32Array(b);
          cache.HEAP32U = new Uint32Array(b);
          if (target.bigIntEnabled) {
            cache.HEAP64 = new BigInt64Array(b);
            cache.HEAP64U = new BigUint64Array(b);
          }
          cache.HEAP32F = new Float32Array(b);
          cache.HEAP64F = new Float64Array(b);
          cache.heapSize = b.byteLength;
          return cache;
        };

        target.heap8 = () => heapWrappers().HEAP8;

        target.heap8u = () => heapWrappers().HEAP8U;

        target.heap16 = () => heapWrappers().HEAP16;

        target.heap16u = () => heapWrappers().HEAP16U;

        target.heap32 = () => heapWrappers().HEAP32;

        target.heap32u = () => heapWrappers().HEAP32U;

        target.heapForSize = function (n, unsigned = true) {
          let ctor;
          const c =
            cache.memory && cache.heapSize === cache.memory.buffer.byteLength
              ? cache
              : heapWrappers();
          switch (n) {
            case Int8Array:
              return c.HEAP8;
            case Uint8Array:
              return c.HEAP8U;
            case Int16Array:
              return c.HEAP16;
            case Uint16Array:
              return c.HEAP16U;
            case Int32Array:
              return c.HEAP32;
            case Uint32Array:
              return c.HEAP32U;
            case 8:
              return unsigned ? c.HEAP8U : c.HEAP8;
            case 16:
              return unsigned ? c.HEAP16U : c.HEAP16;
            case 32:
              return unsigned ? c.HEAP32U : c.HEAP32;
            case 64:
              if (c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;
              break;
            default:
              if (target.bigIntEnabled) {
                if (n === globalThis['BigUint64Array']) return c.HEAP64U;
                else if (n === globalThis['BigInt64Array']) return c.HEAP64;
                break;
              }
          }
          toss(
            'Invalid heapForSize() size: expecting 8, 16, 32,',
            'or (if BigInt is enabled) 64.',
          );
        };

        target.functionTable = function () {
          return target.exports.__indirect_function_table;
        };

        target.functionEntry = function (fptr) {
          const ft = target.functionTable();
          return fptr < ft.length ? ft.get(fptr) : undefined;
        };

        target.jsFuncToWasm = function f(func, sig) {
          if (!f._) {
            f._ = {
              sigTypes: Object.assign(Object.create(null), {
                i: 'i32',
                p: 'i32',
                P: 'i32',
                s: 'i32',
                j: 'i64',
                f: 'f32',
                d: 'f64',
              }),

              typeCodes: Object.assign(Object.create(null), {
                f64: 0x7c,
                f32: 0x7d,
                i64: 0x7e,
                i32: 0x7f,
              }),

              uleb128Encode: function (tgt, method, n) {
                if (n < 128) tgt[method](n);
                else tgt[method](n % 128 | 128, n >> 7);
              },

              rxJSig: /^(\w)\((\w*)\)$/,

              sigParams: function (sig) {
                const m = f._.rxJSig.exec(sig);
                return m ? m[2] : sig.substr(1);
              },

              letterType: (x) =>
                f._.sigTypes[x] || toss('Invalid signature letter:', x),

              pushSigType: (dest, letter) =>
                dest.push(f._.typeCodes[f._.letterType(letter)]),
            };
          }
          if ('string' === typeof func) {
            const x = sig;
            sig = func;
            func = x;
          }
          const sigParams = f._.sigParams(sig);
          const wasmCode = [0x01, 0x60];
          f._.uleb128Encode(wasmCode, 'push', sigParams.length);
          for (const x of sigParams) f._.pushSigType(wasmCode, x);
          if ('v' === sig[0]) wasmCode.push(0);
          else {
            wasmCode.push(1);
            f._.pushSigType(wasmCode, sig[0]);
          }
          f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);
          wasmCode.unshift(
            0x00,
            0x61,
            0x73,
            0x6d,
            0x01,
            0x00,
            0x00,
            0x00,
            0x01,
          );
          wasmCode.push(
            0x02,
            0x07,

            0x01,
            0x01,
            0x65,
            0x01,
            0x66,
            0x00,
            0x00,
            0x07,
            0x05,

            0x01,
            0x01,
            0x66,
            0x00,
            0x00,
          );
          return new WebAssembly.Instance(
            new WebAssembly.Module(new Uint8Array(wasmCode)),
            {
              e: { f: func },
            },
          ).exports['f'];
        };

        const __installFunction = function f(func, sig, scoped) {
          if (scoped && !cache.scopedAlloc.length) {
            toss('No scopedAllocPush() scope is active.');
          }
          if ('string' === typeof func) {
            const x = sig;
            sig = func;
            func = x;
          }
          if ('string' !== typeof sig || !(func instanceof Function)) {
            toss(
              'Invalid arguments: expecting (function,signature) ' +
                'or (signature,function).',
            );
          }
          const ft = target.functionTable();
          const oldLen = ft.length;
          let ptr;
          while (cache.freeFuncIndexes.length) {
            ptr = cache.freeFuncIndexes.pop();
            if (ft.get(ptr)) {
              ptr = null;
              continue;
            } else {
              break;
            }
          }
          if (!ptr) {
            ptr = oldLen;
            ft.grow(1);
          }
          try {
            ft.set(ptr, func);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
            return ptr;
          } catch (e) {
            if (!(e instanceof TypeError)) {
              if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
              throw e;
            }
          }

          try {
            const fptr = target.jsFuncToWasm(func, sig);
            ft.set(ptr, fptr);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
          } catch (e) {
            if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
            throw e;
          }
          return ptr;
        };

        target.installFunction = (func, sig) =>
          __installFunction(func, sig, false);

        target.scopedInstallFunction = (func, sig) =>
          __installFunction(func, sig, true);

        target.uninstallFunction = function (ptr) {
          if (!ptr && 0 !== ptr) return undefined;
          const fi = cache.freeFuncIndexes;
          const ft = target.functionTable();
          fi.push(ptr);
          const rc = ft.get(ptr);
          ft.set(ptr, null);
          return rc;
        };

        target.peek = function f(ptr, type = 'i8') {
          if (type.endsWith('*')) type = ptrIR;
          const c =
            cache.memory && cache.heapSize === cache.memory.buffer.byteLength
              ? cache
              : heapWrappers();
          const list = Array.isArray(ptr) ? [] : undefined;
          let rc;
          do {
            if (list) ptr = arguments[0].shift();
            switch (type) {
              case 'i1':
              case 'i8':
                rc = c.HEAP8[ptr >> 0];
                break;
              case 'i16':
                rc = c.HEAP16[ptr >> 1];
                break;
              case 'i32':
                rc = c.HEAP32[ptr >> 2];
                break;
              case 'float':
              case 'f32':
                rc = c.HEAP32F[ptr >> 2];
                break;
              case 'double':
              case 'f64':
                rc = Number(c.HEAP64F[ptr >> 3]);
                break;
              case 'i64':
                if (target.bigIntEnabled) {
                  rc = BigInt(c.HEAP64[ptr >> 3]);
                  break;
                }

              default:
                toss('Invalid type for peek():', type);
            }
            if (list) list.push(rc);
          } while (list && arguments[0].length);
          return list || rc;
        };

        target.poke = function (ptr, value, type = 'i8') {
          if (type.endsWith('*')) type = ptrIR;
          const c =
            cache.memory && cache.heapSize === cache.memory.buffer.byteLength
              ? cache
              : heapWrappers();
          for (const p of Array.isArray(ptr) ? ptr : [ptr]) {
            switch (type) {
              case 'i1':
              case 'i8':
                c.HEAP8[p >> 0] = value;
                continue;
              case 'i16':
                c.HEAP16[p >> 1] = value;
                continue;
              case 'i32':
                c.HEAP32[p >> 2] = value;
                continue;
              case 'float':
              case 'f32':
                c.HEAP32F[p >> 2] = value;
                continue;
              case 'double':
              case 'f64':
                c.HEAP64F[p >> 3] = value;
                continue;
              case 'i64':
                if (c.HEAP64) {
                  c.HEAP64[p >> 3] = BigInt(value);
                  continue;
                }

              default:
                toss('Invalid type for poke(): ' + type);
            }
          }
          return this;
        };

        target.peekPtr = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);

        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);

        target.peek8 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i8');

        target.poke8 = (ptr, value) => target.poke(ptr, value, 'i8');

        target.peek16 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i16');

        target.poke16 = (ptr, value) => target.poke(ptr, value, 'i16');

        target.peek32 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i32');

        target.poke32 = (ptr, value) => target.poke(ptr, value, 'i32');

        target.peek64 = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i64');

        target.poke64 = (ptr, value) => target.poke(ptr, value, 'i64');

        target.peek32f = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f32');

        target.poke32f = (ptr, value) => target.poke(ptr, value, 'f32');

        target.peek64f = (...ptr) =>
          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f64');

        target.poke64f = (ptr, value) => target.poke(ptr, value, 'f64');

        target.getMemValue = target.peek;

        target.getPtrValue = target.peekPtr;

        target.setMemValue = target.poke;

        target.setPtrValue = target.pokePtr;

        target.isPtr32 = (ptr) =>
          'number' === typeof ptr && ptr === (ptr | 0) && ptr >= 0;

        target.isPtr = target.isPtr32;

        target.cstrlen = function (ptr) {
          if (!ptr || !target.isPtr(ptr)) return null;
          const h = heapWrappers().HEAP8U;
          let pos = ptr;
          for (; h[pos] !== 0; ++pos) {}
          return pos - ptr;
        };

        const __SAB =
          'undefined' === typeof SharedArrayBuffer
            ? function () {}
            : SharedArrayBuffer;
        const __utf8Decode = function (arrayBuffer, begin, end) {
          return cache.utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB
              ? arrayBuffer.slice(begin, end)
              : arrayBuffer.subarray(begin, end),
          );
        };

        target.cstrToJs = function (ptr) {
          const n = target.cstrlen(ptr);
          return n
            ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n)
            : null === n
              ? n
              : '';
        };

        target.jstrlen = function (str) {
          if ('string' !== typeof str) return null;
          const n = str.length;
          let len = 0;
          for (let i = 0; i < n; ++i) {
            let u = str.charCodeAt(i);
            if (u >= 0xd800 && u <= 0xdfff) {
              u =
                (0x10000 + ((u & 0x3ff) << 10)) | (str.charCodeAt(++i) & 0x3ff);
            }
            if (u <= 0x7f) ++len;
            else if (u <= 0x7ff) len += 2;
            else if (u <= 0xffff) len += 3;
            else len += 4;
          }
          return len;
        };

        target.jstrcpy = function (
          jstr,
          tgt,
          offset = 0,
          maxBytes = -1,
          addNul = true,
        ) {
          if (
            !tgt ||
            (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))
          ) {
            toss('jstrcpy() target must be an Int8Array or Uint8Array.');
          }
          if (maxBytes < 0) maxBytes = tgt.length - offset;
          if (!(maxBytes > 0) || !(offset >= 0)) return 0;
          let i = 0,
            max = jstr.length;
          const begin = offset,
            end = offset + maxBytes - (addNul ? 1 : 0);
          for (; i < max && offset < end; ++i) {
            let u = jstr.charCodeAt(i);
            if (u >= 0xd800 && u <= 0xdfff) {
              u =
                (0x10000 + ((u & 0x3ff) << 10)) |
                (jstr.charCodeAt(++i) & 0x3ff);
            }
            if (u <= 0x7f) {
              if (offset >= end) break;
              tgt[offset++] = u;
            } else if (u <= 0x7ff) {
              if (offset + 1 >= end) break;
              tgt[offset++] = 0xc0 | (u >> 6);
              tgt[offset++] = 0x80 | (u & 0x3f);
            } else if (u <= 0xffff) {
              if (offset + 2 >= end) break;
              tgt[offset++] = 0xe0 | (u >> 12);
              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
              tgt[offset++] = 0x80 | (u & 0x3f);
            } else {
              if (offset + 3 >= end) break;
              tgt[offset++] = 0xf0 | (u >> 18);
              tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);
              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
              tgt[offset++] = 0x80 | (u & 0x3f);
            }
          }
          if (addNul) tgt[offset++] = 0;
          return offset - begin;
        };

        target.cstrncpy = function (tgtPtr, srcPtr, n) {
          if (!tgtPtr || !srcPtr)
            toss('cstrncpy() does not accept NULL strings.');
          if (n < 0) n = target.cstrlen(strPtr) + 1;
          else if (!(n > 0)) return 0;
          const heap = target.heap8u();
          let i = 0,
            ch;
          for (; i < n && (ch = heap[srcPtr + i]); ++i) {
            heap[tgtPtr + i] = ch;
          }
          if (i < n) heap[tgtPtr + i++] = 0;
          return i;
        };

        target.jstrToUintArray = (str, addNul = false) => {
          return cache.utf8Encoder.encode(addNul ? str + '\0' : str);
        };

        const __affirmAlloc = (obj, funcName) => {
          if (
            !(obj.alloc instanceof Function) ||
            !(obj.dealloc instanceof Function)
          ) {
            toss(
              'Object is missing alloc() and/or dealloc() function(s)',
              'required by',
              funcName + '().',
            );
          }
        };

        const __allocCStr = function (
          jstr,
          returnWithLength,
          allocator,
          funcName,
        ) {
          __affirmAlloc(target, funcName);
          if ('string' !== typeof jstr) return null;
          if (false) {} else {
            const u = cache.utf8Encoder.encode(jstr),
              ptr = allocator(u.length + 1),
              heap = heapWrappers().HEAP8U;
            heap.set(u, ptr);
            heap[ptr + u.length] = 0;
            return returnWithLength ? [ptr, u.length] : ptr;
          }
        };

        target.allocCString = (jstr, returnWithLength = false) =>
          __allocCStr(jstr, returnWithLength, target.alloc, 'allocCString()');

        target.scopedAllocPush = function () {
          __affirmAlloc(target, 'scopedAllocPush');
          const a = [];
          cache.scopedAlloc.push(a);
          return a;
        };

        target.scopedAllocPop = function (state) {
          __affirmAlloc(target, 'scopedAllocPop');
          const n = arguments.length
            ? cache.scopedAlloc.indexOf(state)
            : cache.scopedAlloc.length - 1;
          if (n < 0) toss('Invalid state object for scopedAllocPop().');
          if (0 === arguments.length) state = cache.scopedAlloc[n];
          cache.scopedAlloc.splice(n, 1);
          for (let p; (p = state.pop()); ) {
            if (target.functionEntry(p)) {
              target.uninstallFunction(p);
            } else target.dealloc(p);
          }
        };

        target.scopedAlloc = function (n) {
          if (!cache.scopedAlloc.length) {
            toss('No scopedAllocPush() scope is active.');
          }
          const p = target.alloc(n);
          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p);
          return p;
        };

        Object.defineProperty(target.scopedAlloc, 'level', {
          configurable: false,
          enumerable: false,
          get: () => cache.scopedAlloc.length,
          set: () => toss("The 'active' property is read-only."),
        });

        target.scopedAllocCString = (jstr, returnWithLength = false) =>
          __allocCStr(
            jstr,
            returnWithLength,
            target.scopedAlloc,
            'scopedAllocCString()',
          );

        const __allocMainArgv = function (isScoped, list) {
          const pList = target[isScoped ? 'scopedAlloc' : 'alloc'](
            (list.length + 1) * target.ptrSizeof,
          );
          let i = 0;
          list.forEach((e) => {
            target.pokePtr(
              pList + target.ptrSizeof * i++,
              target[isScoped ? 'scopedAllocCString' : 'allocCString']('' + e),
            );
          });
          target.pokePtr(pList + target.ptrSizeof * i, 0);
          return pList;
        };

        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);

        target.allocMainArgv = (list) => __allocMainArgv(false, list);

        target.cArgvToJs = (argc, pArgv) => {
          const list = [];
          for (let i = 0; i < argc; ++i) {
            const arg = target.peekPtr(pArgv + target.ptrSizeof * i);
            list.push(arg ? target.cstrToJs(arg) : null);
          }
          return list;
        };

        target.scopedAllocCall = function (func) {
          target.scopedAllocPush();
          try {
            return func();
          } finally {
            target.scopedAllocPop();
          }
        };

        const __allocPtr = function (howMany, safePtrSize, method) {
          __affirmAlloc(target, method);
          const pIr = safePtrSize ? 'i64' : ptrIR;
          let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
          target.poke(m, 0, pIr);
          if (1 === howMany) {
            return m;
          }
          const a = [m];
          for (let i = 1; i < howMany; ++i) {
            m += safePtrSize ? 8 : ptrSizeof;
            a[i] = m;
            target.poke(m, 0, pIr);
          }
          return a;
        };

        target.allocPtr = (howMany = 1, safePtrSize = true) =>
          __allocPtr(howMany, safePtrSize, 'alloc');

        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) =>
          __allocPtr(howMany, safePtrSize, 'scopedAlloc');

        target.xGet = function (name) {
          return (
            target.exports[name] || toss('Cannot find exported symbol:', name)
          );
        };

        const __argcMismatch = (f, n) =>
          toss(f + '() requires', n, 'argument(s).');

        target.xCall = function (fname, ...args) {
          const f = target.xGet(fname);
          if (!(f instanceof Function))
            toss('Exported symbol', fname, 'is not a function.');
          if (f.length !== args.length) __argcMismatch(fname, f.length);
          return 2 === arguments.length && Array.isArray(arguments[1])
            ? f.apply(null, arguments[1])
            : f.apply(null, args);
        };

        cache.xWrap = Object.create(null);
        cache.xWrap.convert = Object.create(null);

        cache.xWrap.convert.arg = new Map();

        cache.xWrap.convert.result = new Map();
        const xArg = cache.xWrap.convert.arg,
          xResult = cache.xWrap.convert.result;

        if (target.bigIntEnabled) {
          xArg.set('i64', (i) => BigInt(i));
        }
        const __xArgPtr =
          'i32' === ptrIR ? (i) => i | 0 : (i) => BigInt(i) | BigInt(0);
        xArg
          .set('i32', __xArgPtr)
          .set('i16', (i) => (i | 0) & 0xffff)
          .set('i8', (i) => (i | 0) & 0xff)
          .set('f32', (i) => Number(i).valueOf())
          .set('float', xArg.get('f32'))
          .set('f64', xArg.get('f32'))
          .set('double', xArg.get('f64'))
          .set('int', xArg.get('i32'))
          .set('null', (i) => i)
          .set(null, xArg.get('null'))
          .set('**', __xArgPtr)
          .set('*', __xArgPtr);
        xResult
          .set('*', __xArgPtr)
          .set('pointer', __xArgPtr)
          .set('number', (v) => Number(v))
          .set('void', (v) => undefined)
          .set('null', (v) => v)
          .set(null, xResult.get('null'));

        {
          const copyToResult = [
            'i8',
            'i16',
            'i32',
            'int',
            'f32',
            'float',
            'f64',
            'double',
          ];
          if (target.bigIntEnabled) copyToResult.push('i64');
          const adaptPtr = xArg.get(ptrIR);
          for (const t of copyToResult) {
            xArg.set(t + '*', adaptPtr);
            xResult.set(t + '*', adaptPtr);
            xResult.set(t, xArg.get(t) || toss('Missing arg converter:', t));
          }
        }

        const __xArgString = function (v) {
          if ('string' === typeof v) return target.scopedAllocCString(v);
          return v ? __xArgPtr(v) : null;
        };
        xArg
          .set('string', __xArgString)
          .set('utf8', __xArgString)
          .set('pointer', __xArgString);

        xResult
          .set('string', (i) => target.cstrToJs(i))
          .set('utf8', xResult.get('string'))
          .set('string:dealloc', (i) => {
            try {
              return i ? target.cstrToJs(i) : null;
            } finally {
              target.dealloc(i);
            }
          })
          .set('utf8:dealloc', xResult.get('string:dealloc'))
          .set('json', (i) => JSON.parse(target.cstrToJs(i)))
          .set('json:dealloc', (i) => {
            try {
              return i ? JSON.parse(target.cstrToJs(i)) : null;
            } finally {
              target.dealloc(i);
            }
          });

        const AbstractArgAdapter = class {
          constructor(opt) {
            this.name = opt.name || 'unnamed adapter';
          }

          convertArg(v, argv, argIndex) {
            toss('AbstractArgAdapter must be subclassed.');
          }
        };

        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
          constructor(opt) {
            super(opt);
            if (xArg.FuncPtrAdapter.warnOnUse) {
              console.warn(
                'xArg.FuncPtrAdapter is an internal-only API',
                'and is not intended to be invoked from',
                'client-level code. Invoked with:',
                opt,
              );
            }
            this.name = opt.name || 'unnamed';
            this.signature = opt.signature;
            if (opt.contextKey instanceof Function) {
              this.contextKey = opt.contextKey;
              if (!opt.bindScope) opt.bindScope = 'context';
            }
            this.bindScope =
              opt.bindScope ||
              toss(
                'FuncPtrAdapter options requires a bindScope (explicit or implied).',
              );
            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
              toss(
                'Invalid options.bindScope (' +
                  opt.bindMod +
                  ') for FuncPtrAdapter. ' +
                  'Expecting one of: (' +
                  FuncPtrAdapter.bindScopes.join(', ') +
                  ')',
              );
            }
            this.isTransient = 'transient' === this.bindScope;
            this.isContext = 'context' === this.bindScope;
            this.isPermanent = 'permanent' === this.bindScope;
            this.singleton = 'singleton' === this.bindScope ? [] : undefined;

            this.callProxy =
              opt.callProxy instanceof Function ? opt.callProxy : undefined;
          }

          contextKey(argv, argIndex) {
            return this;
          }

          contextMap(key) {
            const cm = this.__cmap || (this.__cmap = new Map());
            let rc = cm.get(key);
            if (undefined === rc) cm.set(key, (rc = []));
            return rc;
          }

          convertArg(v, argv, argIndex) {
            let pair = this.singleton;
            if (!pair && this.isContext) {
              pair = this.contextMap(this.contextKey(argv, argIndex));
            }
            if (pair && pair[0] === v) return pair[1];
            if (v instanceof Function) {
              if (this.callProxy) v = this.callProxy(v);
              const fp = __installFunction(v, this.signature, this.isTransient);
              if (FuncPtrAdapter.debugFuncInstall) {
                FuncPtrAdapter.debugOut(
                  'FuncPtrAdapter installed',
                  this,
                  this.contextKey(argv, argIndex),
                  '@' + fp,
                  v,
                );
              }
              if (pair) {
                if (pair[1]) {
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      'FuncPtrAdapter uninstalling',
                      this,
                      this.contextKey(argv, argIndex),
                      '@' + pair[1],
                      v,
                    );
                  }
                  try {
                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                      pair[1],
                    );
                  } catch (e) {}
                }
                pair[0] = v;
                pair[1] = fp;
              }
              return fp;
            } else if (target.isPtr(v) || null === v || undefined === v) {
              if (pair && pair[1] && pair[1] !== v) {
                if (FuncPtrAdapter.debugFuncInstall) {
                  FuncPtrAdapter.debugOut(
                    'FuncPtrAdapter uninstalling',
                    this,
                    this.contextKey(argv, argIndex),
                    '@' + pair[1],
                    v,
                  );
                }
                try {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                } catch (e) {}
                pair[0] = pair[1] = v | 0;
              }
              return v || 0;
            } else {
              throw new TypeError(
                'Invalid FuncPtrAdapter argument type. ' +
                  'Expecting a function pointer or a ' +
                  (this.name ? this.name + ' ' : '') +
                  'function matching signature ' +
                  this.signature +
                  '.',
              );
            }
          }
        };

        xArg.FuncPtrAdapter.warnOnUse = false;

        xArg.FuncPtrAdapter.debugFuncInstall = false;

        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);

        xArg.FuncPtrAdapter.bindScopes = [
          'transient',
          'context',
          'singleton',
          'permanent',
        ];

        const __xArgAdapterCheck = (t) =>
          xArg.get(t) || toss('Argument adapter not found:', t);

        const __xResultAdapterCheck = (t) =>
          xResult.get(t) || toss('Result adapter not found:', t);

        cache.xWrap.convertArg = (t, ...args) => __xArgAdapterCheck(t)(...args);
        cache.xWrap.convertArgNoCheck = (t, ...args) => xArg.get(t)(...args);

        cache.xWrap.convertResult = (t, v) =>
          null === t ? v : t ? __xResultAdapterCheck(t)(v) : undefined;
        cache.xWrap.convertResultNoCheck = (t, v) =>
          null === t ? v : t ? xResult.get(t)(v) : undefined;

        target.xWrap = function (fArg, resultType, ...argTypes) {
          if (3 === arguments.length && Array.isArray(arguments[2])) {
            argTypes = arguments[2];
          }
          if (target.isPtr(fArg)) {
            fArg =
              target.functionEntry(fArg) ||
              toss('Function pointer not found in WASM function table.');
          }
          const fIsFunc = fArg instanceof Function;
          const xf = fIsFunc ? fArg : target.xGet(fArg);
          if (fIsFunc) fArg = xf.name || 'unnamed function';
          if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);
          if (null === resultType && 0 === xf.length) {
            return xf;
          }
          if (undefined !== resultType && null !== resultType)
            __xResultAdapterCheck(resultType);
          for (const t of argTypes) {
            if (t instanceof AbstractArgAdapter)
              xArg.set(t, (...args) => t.convertArg(...args));
            else __xArgAdapterCheck(t);
          }
          const cxw = cache.xWrap;
          if (0 === xf.length) {
            return (...args) =>
              args.length
                ? __argcMismatch(fArg, xf.length)
                : cxw.convertResult(resultType, xf.call(null));
          }
          return function (...args) {
            if (args.length !== xf.length) __argcMismatch(fArg, xf.length);
            const scope = target.scopedAllocPush();
            try {
              for (const i in args)
                args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);
              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
            } finally {
              target.scopedAllocPop(scope);
            }
          };
        };

        const __xAdapter = function (
          func,
          argc,
          typeName,
          adapter,
          modeName,
          xcvPart,
        ) {
          if ('string' === typeof typeName) {
            if (1 === argc) return xcvPart.get(typeName);
            else if (2 === argc) {
              if (!adapter) {
                delete xcvPart.get(typeName);
                return func;
              } else if (!(adapter instanceof Function)) {
                toss(modeName, 'requires a function argument.');
              }
              xcvPart.set(typeName, adapter);
              return func;
            }
          }
          toss('Invalid arguments to', modeName);
        };

        target.xWrap.resultAdapter = function f(typeName, adapter) {
          return __xAdapter(
            f,
            arguments.length,
            typeName,
            adapter,
            'resultAdapter()',
            xResult,
          );
        };

        target.xWrap.argAdapter = function f(typeName, adapter) {
          return __xAdapter(
            f,
            arguments.length,
            typeName,
            adapter,
            'argAdapter()',
            xArg,
          );
        };

        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;

        target.xCallWrapped = function (fArg, resultType, argTypes, ...args) {
          if (Array.isArray(arguments[3])) args = arguments[3];
          return target
            .xWrap(fArg, resultType, argTypes || [])
            .apply(null, args || []);
        };

        target.xWrap.testConvertArg = cache.xWrap.convertArg;

        target.xWrap.testConvertResult = cache.xWrap.convertResult;

        return target;
      };

      globalThis.WhWasmUtilInstaller.yawl = function (config) {
        const wfetch = () => fetch(config.uri, { credentials: 'same-origin' });
        const wui = this;
        const finalThen = function (arg) {
          if (config.wasmUtilTarget) {
            const toss = (...args) => {
              throw new Error(args.join(' '));
            };
            const tgt = config.wasmUtilTarget;
            tgt.module = arg.module;
            tgt.instance = arg.instance;

            if (!tgt.instance.exports.memory) {
              tgt.memory =
                (config.imports &&
                  config.imports.env &&
                  config.imports.env.memory) ||
                toss("Missing 'memory' object!");
            }
            if (!tgt.alloc && arg.instance.exports.malloc) {
              const exports = arg.instance.exports;
              tgt.alloc = function (n) {
                return (
                  exports.malloc(n) || toss('Allocation of', n, 'bytes failed.')
                );
              };
              tgt.dealloc = function (m) {
                exports.free(m);
              };
            }
            wui(tgt);
          }
          if (config.onload) config.onload(arg, config);
          return arg;
        };
        const loadWasm = WebAssembly.instantiateStreaming
          ? function loadWasmStreaming() {
              return WebAssembly.instantiateStreaming(
                wfetch(),
                config.imports || {},
              ).then(finalThen);
            }
          : function loadWasmOldSchool() {
              return wfetch()
                .then((response) => response.arrayBuffer())
                .then((bytes) =>
                  WebAssembly.instantiate(bytes, config.imports || {}),
                )
                .then(finalThen);
            };
        return loadWasm;
      }.bind(globalThis.WhWasmUtilInstaller);

      ('use strict');
      globalThis.Jaccwabyt = function StructBinderFactory(config) {
        const toss = (...args) => {
          throw new Error(args.join(' '));
        };

        if (
          !(config.heap instanceof WebAssembly.Memory) &&
          !(config.heap instanceof Function)
        ) {
          toss(
            'config.heap must be WebAssembly.Memory instance or a function.',
          );
        }
        ['alloc', 'dealloc'].forEach(function (k) {
          config[k] instanceof Function ||
            toss("Config option '" + k + "' must be a function.");
        });
        const SBF = StructBinderFactory;
        const heap =
            config.heap instanceof Function
              ? config.heap
              : () => new Uint8Array(config.heap.buffer),
          alloc = config.alloc,
          dealloc = config.dealloc,
          log = config.log || console.log.bind(console),
          memberPrefix = config.memberPrefix || '',
          memberSuffix = config.memberSuffix || '',
          bigIntEnabled =
            undefined === config.bigIntEnabled
              ? !!globalThis['BigInt64Array']
              : !!config.bigIntEnabled,
          BigInt = globalThis['BigInt'],
          BigInt64Array = globalThis['BigInt64Array'],
          ptrSizeof = config.ptrSizeof || 4,
          ptrIR = config.ptrIR || 'i32';
        if (!SBF.debugFlags) {
          SBF.__makeDebugFlags = function (deriveFrom = null) {
            if (deriveFrom && deriveFrom.__flags)
              deriveFrom = deriveFrom.__flags;
            const f = function f(flags) {
              if (0 === arguments.length) {
                return f.__flags;
              }
              if (flags < 0) {
                delete f.__flags.getter;
                delete f.__flags.setter;
                delete f.__flags.alloc;
                delete f.__flags.dealloc;
              } else {
                f.__flags.getter = 0 !== (0x01 & flags);
                f.__flags.setter = 0 !== (0x02 & flags);
                f.__flags.alloc = 0 !== (0x04 & flags);
                f.__flags.dealloc = 0 !== (0x08 & flags);
              }
              return f._flags;
            };
            Object.defineProperty(f, '__flags', {
              iterable: false,
              writable: false,
              value: Object.create(deriveFrom),
            });
            if (!deriveFrom) f(0);
            return f;
          };
          SBF.debugFlags = SBF.__makeDebugFlags();
        }

        const isLittleEndian = (function () {
          const buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);

          return new Int16Array(buffer)[0] === 256;
        })();

        const isFuncSig = (s) => '(' === s[1];

        const isPtrSig = (s) => 'p' === s || 'P' === s;
        const isAutoPtrSig = (s) => 'P' === s;
        const sigLetter = (s) => (isFuncSig(s) ? 'p' : s[0]);

        const sigIR = function (s) {
          switch (sigLetter(s)) {
            case 'c':
            case 'C':
              return 'i8';
            case 'i':
              return 'i32';
            case 'p':
            case 'P':
            case 's':
              return ptrIR;
            case 'j':
              return 'i64';
            case 'f':
              return 'float';
            case 'd':
              return 'double';
          }
          toss('Unhandled signature IR:', s);
        };

        const affirmBigIntArray = BigInt64Array
          ? () => true
          : () => toss('BigInt64Array is not available.');

        const sigDVGetter = function (s) {
          switch (sigLetter(s)) {
            case 'p':
            case 'P':
            case 's': {
              switch (ptrSizeof) {
                case 4:
                  return 'getInt32';
                case 8:
                  return affirmBigIntArray() && 'getBigInt64';
              }
              break;
            }
            case 'i':
              return 'getInt32';
            case 'c':
              return 'getInt8';
            case 'C':
              return 'getUint8';
            case 'j':
              return affirmBigIntArray() && 'getBigInt64';
            case 'f':
              return 'getFloat32';
            case 'd':
              return 'getFloat64';
          }
          toss('Unhandled DataView getter for signature:', s);
        };

        const sigDVSetter = function (s) {
          switch (sigLetter(s)) {
            case 'p':
            case 'P':
            case 's': {
              switch (ptrSizeof) {
                case 4:
                  return 'setInt32';
                case 8:
                  return affirmBigIntArray() && 'setBigInt64';
              }
              break;
            }
            case 'i':
              return 'setInt32';
            case 'c':
              return 'setInt8';
            case 'C':
              return 'setUint8';
            case 'j':
              return affirmBigIntArray() && 'setBigInt64';
            case 'f':
              return 'setFloat32';
            case 'd':
              return 'setFloat64';
          }
          toss('Unhandled DataView setter for signature:', s);
        };

        const sigDVSetWrapper = function (s) {
          switch (sigLetter(s)) {
            case 'i':
            case 'f':
            case 'c':
            case 'C':
            case 'd':
              return Number;
            case 'j':
              return affirmBigIntArray() && BigInt;
            case 'p':
            case 'P':
            case 's':
              switch (ptrSizeof) {
                case 4:
                  return Number;
                case 8:
                  return affirmBigIntArray() && BigInt;
              }
              break;
          }
          toss('Unhandled DataView set wrapper for signature:', s);
        };

        const sPropName = (s, k) => s + '::' + k;

        const __propThrowOnSet = function (structName, propName) {
          return () => toss(sPropName(structName, propName), 'is read-only.');
        };

        const __instancePointerMap = new WeakMap();

        const xPtrPropName = '(pointer-is-external)';

        const __freeStruct = function (ctor, obj, m) {
          if (!m) m = __instancePointerMap.get(obj);
          if (m) {
            __instancePointerMap.delete(obj);
            if (Array.isArray(obj.ondispose)) {
              let x;
              while ((x = obj.ondispose.shift())) {
                try {
                  if (x instanceof Function) x.call(obj);
                  else if (x instanceof StructType) x.dispose();
                  else if ('number' === typeof x) dealloc(x);
                } catch (e) {
                  console.warn(
                    'ondispose() for',
                    ctor.structName,
                    '@',
                    m,
                    'threw. NOT propagating it.',
                    e,
                  );
                }
              }
            } else if (obj.ondispose instanceof Function) {
              try {
                obj.ondispose();
              } catch (e) {
                console.warn(
                  'ondispose() for',
                  ctor.structName,
                  '@',
                  m,
                  'threw. NOT propagating it.',
                  e,
                );
              }
            }
            delete obj.ondispose;
            if (ctor.debugFlags.__flags.dealloc) {
              log(
                'debug.dealloc:',
                obj[xPtrPropName] ? 'EXTERNAL' : '',
                ctor.structName,
                'instance:',
                ctor.structInfo.sizeof,
                'bytes @' + m,
              );
            }
            if (!obj[xPtrPropName]) dealloc(m);
          }
        };

        const rop = (v) => {
          return {
            configurable: false,
            writable: false,
            iterable: false,
            value: v,
          };
        };

        const __allocStruct = function (ctor, obj, m) {
          let fill = !m;
          if (m) Object.defineProperty(obj, xPtrPropName, rop(m));
          else {
            m = alloc(ctor.structInfo.sizeof);
            if (!m) toss('Allocation of', ctor.structName, 'structure failed.');
          }
          try {
            if (ctor.debugFlags.__flags.alloc) {
              log(
                'debug.alloc:',
                fill ? '' : 'EXTERNAL',
                ctor.structName,
                'instance:',
                ctor.structInfo.sizeof,
                'bytes @' + m,
              );
            }
            if (fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
            __instancePointerMap.set(obj, m);
          } catch (e) {
            __freeStruct(ctor, obj, m);
            throw e;
          }
        };

        const __memoryDump = function () {
          const p = this.pointer;
          return p
            ? new Uint8Array(heap().slice(p, p + this.structInfo.sizeof))
            : null;
        };

        const __memberKey = (k) => memberPrefix + k + memberSuffix;
        const __memberKeyProp = rop(__memberKey);

        const __lookupMember = function (
          structInfo,
          memberName,
          tossIfNotFound = true,
        ) {
          let m = structInfo.members[memberName];
          if (!m && (memberPrefix || memberSuffix)) {
            for (const v of Object.values(structInfo.members)) {
              if (v.key === memberName) {
                m = v;
                break;
              }
            }
            if (!m && tossIfNotFound) {
              toss(
                sPropName(structInfo.name, memberName),
                'is not a mapped struct member.',
              );
            }
          }
          return m;
        };

        const __memberSignature = function f(
          obj,
          memberName,
          emscriptenFormat = false,
        ) {
          if (!f._)
            f._ = (x) =>
              x.replace(/[^vipPsjrdcC]/g, '').replace(/[pPscC]/g, 'i');
          const m = __lookupMember(obj.structInfo, memberName, true);
          return emscriptenFormat ? f._(m.signature) : m.signature;
        };

        const __ptrPropDescriptor = {
          configurable: false,
          enumerable: false,
          get: function () {
            return __instancePointerMap.get(this);
          },
          set: () => toss("Cannot assign the 'pointer' property of a struct."),
        };

        const __structMemberKeys = rop(function () {
          const a = [];
          for (const k of Object.keys(this.structInfo.members)) {
            a.push(this.memberKey(k));
          }
          return a;
        });

        const __utf8Decoder = new TextDecoder('utf-8');
        const __utf8Encoder = new TextEncoder();

        const __SAB =
          'undefined' === typeof SharedArrayBuffer
            ? function () {}
            : SharedArrayBuffer;
        const __utf8Decode = function (arrayBuffer, begin, end) {
          return __utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB
              ? arrayBuffer.slice(begin, end)
              : arrayBuffer.subarray(begin, end),
          );
        };

        const __memberIsString = function (
          obj,
          memberName,
          tossIfNotFound = false,
        ) {
          const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
          return m && 1 === m.signature.length && 's' === m.signature[0]
            ? m
            : false;
        };

        const __affirmCStringSignature = function (member) {
          if ('s' === member.signature) return;
          toss(
            'Invalid member type signature for C-string value:',
            JSON.stringify(member),
          );
        };

        const __memberToJsString = function f(obj, memberName) {
          const m = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m);
          const addr = obj[m.key];

          if (!addr) return null;
          let pos = addr;
          const mem = heap();
          for (; mem[pos] !== 0; ++pos) {}

          return addr === pos ? '' : __utf8Decode(mem, addr, pos);
        };

        const __addOnDispose = function (obj, ...v) {
          if (obj.ondispose) {
            if (!Array.isArray(obj.ondispose)) {
              obj.ondispose = [obj.ondispose];
            }
          } else {
            obj.ondispose = [];
          }
          obj.ondispose.push(...v);
        };

        const __allocCString = function (str) {
          const u = __utf8Encoder.encode(str);
          const mem = alloc(u.length + 1);
          if (!mem) toss('Allocation error while duplicating string:', str);
          const h = heap();

          h.set(u, mem);
          h[mem + u.length] = 0;

          return mem;
        };

        const __setMemberCString = function (obj, memberName, str) {
          const m = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m);

          const mem = __allocCString(str);
          obj[m.key] = mem;
          __addOnDispose(obj, mem);
          return obj;
        };

        const StructType = function ctor(structName, structInfo) {
          if (arguments[2] !== rop) {
            toss(
              'Do not call the StructType constructor',
              'from client-level code.',
            );
          }
          Object.defineProperties(this, {
            structName: rop(structName),
            structInfo: rop(structInfo),
          });
        };

        StructType.prototype = Object.create(null, {
          dispose: rop(function () {
            __freeStruct(this.constructor, this);
          }),
          lookupMember: rop(function (memberName, tossIfNotFound = true) {
            return __lookupMember(this.structInfo, memberName, tossIfNotFound);
          }),
          memberToJsString: rop(function (memberName) {
            return __memberToJsString(this, memberName);
          }),
          memberIsString: rop(function (memberName, tossIfNotFound = true) {
            return __memberIsString(this, memberName, tossIfNotFound);
          }),
          memberKey: __memberKeyProp,
          memberKeys: __structMemberKeys,
          memberSignature: rop(function (memberName, emscriptenFormat = false) {
            return __memberSignature(this, memberName, emscriptenFormat);
          }),
          memoryDump: rop(__memoryDump),
          pointer: __ptrPropDescriptor,
          setMemberCString: rop(function (memberName, str) {
            return __setMemberCString(this, memberName, str);
          }),
        });

        Object.assign(StructType.prototype, {
          addOnDispose: function (...v) {
            __addOnDispose(this, ...v);
            return this;
          },
        });

        Object.defineProperties(StructType, {
          allocCString: rop(__allocCString),
          isA: rop((v) => v instanceof StructType),
          hasExternalPointer: rop(
            (v) => v instanceof StructType && !!v[xPtrPropName],
          ),
          memberKey: __memberKeyProp,
        });

        const isNumericValue = (v) =>
          Number.isFinite(v) || v instanceof (BigInt || Number);

        const makeMemberWrapper = function f(ctor, name, descr) {
          if (!f._) {
            f._ = { getters: {}, setters: {}, sw: {} };
            const a = ['i', 'c', 'C', 'p', 'P', 's', 'f', 'd', 'v()'];
            if (bigIntEnabled) a.push('j');
            a.forEach(function (v) {
              f._.getters[v] = sigDVGetter(v);
              f._.setters[v] = sigDVSetter(v);
              f._.sw[v] = sigDVSetWrapper(v);
            });
            const rxSig1 = /^[ipPsjfdcC]$/,
              rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
            f.sigCheck = function (obj, name, key, sig) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                toss(obj.structName, 'already has a property named', key + '.');
              }
              rxSig1.test(sig) ||
                rxSig2.test(sig) ||
                toss(
                  'Malformed signature for',
                  sPropName(obj.structName, name) + ':',
                  sig,
                );
            };
          }
          const key = ctor.memberKey(name);
          f.sigCheck(ctor.prototype, name, key, descr.signature);
          descr.key = key;
          descr.name = name;
          const sigGlyph = sigLetter(descr.signature);
          const xPropName = sPropName(ctor.prototype.structName, key);
          const dbg = ctor.prototype.debugFlags.__flags;

          const prop = Object.create(null);
          prop.configurable = false;
          prop.enumerable = false;
          prop.get = function () {
            if (dbg.getter) {
              log(
                'debug.getter:',
                f._.getters[sigGlyph],
                'for',
                sigIR(sigGlyph),
                xPropName,
                '@',
                this.pointer,
                '+',
                descr.offset,
                'sz',
                descr.sizeof,
              );
            }
            let rc = new DataView(
              heap().buffer,
              this.pointer + descr.offset,
              descr.sizeof,
            )[f._.getters[sigGlyph]](0, isLittleEndian);
            if (dbg.getter) log('debug.getter:', xPropName, 'result =', rc);
            return rc;
          };
          if (descr.readOnly) {
            prop.set = __propThrowOnSet(ctor.prototype.structName, key);
          } else {
            prop.set = function (v) {
              if (dbg.setter) {
                log(
                  'debug.setter:',
                  f._.setters[sigGlyph],
                  'for',
                  sigIR(sigGlyph),
                  xPropName,
                  '@',
                  this.pointer,
                  '+',
                  descr.offset,
                  'sz',
                  descr.sizeof,
                  v,
                );
              }
              if (!this.pointer) {
                toss('Cannot set struct property on disposed instance.');
              }
              if (null === v) v = 0;
              else
                while (!isNumericValue(v)) {
                  if (
                    isAutoPtrSig(descr.signature) &&
                    v instanceof StructType
                  ) {
                    v = v.pointer || 0;
                    if (dbg.setter)
                      log('debug.setter:', xPropName, 'resolved to', v);
                    break;
                  }
                  toss('Invalid value for pointer-type', xPropName + '.');
                }
              new DataView(
                heap().buffer,
                this.pointer + descr.offset,
                descr.sizeof,
              )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);
            };
          }
          Object.defineProperty(ctor.prototype, key, prop);
        };

        const StructBinder = function StructBinder(structName, structInfo) {
          if (1 === arguments.length) {
            structInfo = structName;
            structName = structInfo.name;
          } else if (!structInfo.name) {
            structInfo.name = structName;
          }
          if (!structName) toss('Struct name is required.');
          let lastMember = false;
          Object.keys(structInfo.members).forEach((k) => {
            const m = structInfo.members[k];
            if (!m.sizeof) toss(structName, 'member', k, 'is missing sizeof.');
            else if (m.sizeof === 1) {
              m.signature === 'c' ||
                m.signature === 'C' ||
                toss(
                  'Unexpected sizeof==1 member',
                  sPropName(structInfo.name, k),
                  'with signature',
                  m.signature,
                );
            } else {
              if (0 !== m.sizeof % 4) {
                console.warn(
                  'Invalid struct member description =',
                  m,
                  'from',
                  structInfo,
                );
                toss(
                  structName,
                  'member',
                  k,
                  'sizeof is not aligned. sizeof=' + m.sizeof,
                );
              }
              if (0 !== m.offset % 4) {
                console.warn(
                  'Invalid struct member description =',
                  m,
                  'from',
                  structInfo,
                );
                toss(
                  structName,
                  'member',
                  k,
                  'offset is not aligned. offset=' + m.offset,
                );
              }
            }
            if (!lastMember || lastMember.offset < m.offset) lastMember = m;
          });
          if (!lastMember) toss('No member property descriptions found.');
          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
            toss(
              'Invalid struct config:',
              structName,
              'max member offset (' + lastMember.offset + ') ',
              'extends past end of struct (sizeof=' + structInfo.sizeof + ').',
            );
          }
          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));

          const StructCtor = function StructCtor(externalMemory) {
            if (!(this instanceof StructCtor)) {
              toss(
                'The',
                structName,
                "constructor may only be called via 'new'.",
              );
            } else if (arguments.length) {
              if (
                externalMemory !== (externalMemory | 0) ||
                externalMemory <= 0
              ) {
                toss('Invalid pointer value for', structName, 'constructor.');
              }
              __allocStruct(StructCtor, this, externalMemory);
            } else {
              __allocStruct(StructCtor, this);
            }
          };
          Object.defineProperties(StructCtor, {
            debugFlags: debugFlags,
            isA: rop((v) => v instanceof StructCtor),
            memberKey: __memberKeyProp,
            memberKeys: __structMemberKeys,
            methodInfoForKey: rop(function (mKey) {}),
            structInfo: rop(structInfo),
            structName: rop(structName),
          });
          StructCtor.prototype = new StructType(structName, structInfo, rop);
          Object.defineProperties(StructCtor.prototype, {
            debugFlags: debugFlags,
            constructor: rop(StructCtor),
          });
          Object.keys(structInfo.members).forEach((name) =>
            makeMemberWrapper(StructCtor, name, structInfo.members[name]),
          );
          return StructCtor;
        };
        StructBinder.StructType = StructType;
        StructBinder.config = config;
        StructBinder.allocCString = __allocCString;
        if (!StructBinder.debugFlags) {
          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
        }
        return StructBinder;
      };

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        'use strict';
        const toss = (...args) => {
          throw new Error(args.join(' '));
        };
        const toss3 = sqlite3.SQLite3Error.toss;
        const capi = sqlite3.capi,
          wasm = sqlite3.wasm,
          util = sqlite3.util;
        globalThis.WhWasmUtilInstaller(wasm);
        delete globalThis.WhWasmUtilInstaller;

        if (false) {}

        wasm.bindingSignatures = [
          ['sqlite3_aggregate_context', 'void*', 'sqlite3_context*', 'int'],

          ['sqlite3_bind_double', 'int', 'sqlite3_stmt*', 'int', 'f64'],
          ['sqlite3_bind_int', 'int', 'sqlite3_stmt*', 'int', 'int'],
          ['sqlite3_bind_null', undefined, 'sqlite3_stmt*', 'int'],
          ['sqlite3_bind_parameter_count', 'int', 'sqlite3_stmt*'],
          ['sqlite3_bind_parameter_index', 'int', 'sqlite3_stmt*', 'string'],
          [
            'sqlite3_bind_pointer',
            'int',
            'sqlite3_stmt*',
            'int',
            '*',
            'string:static',
            '*',
          ],
          [
            'sqlite3_busy_handler',
            'int',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                signature: 'i(pi)',
                contextKey: (argv, argIndex) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_busy_timeout', 'int', 'sqlite3*', 'int'],

          ['sqlite3_changes', 'int', 'sqlite3*'],
          ['sqlite3_clear_bindings', 'int', 'sqlite3_stmt*'],
          ['sqlite3_collation_needed', 'int', 'sqlite3*', '*', '*'],
          ['sqlite3_column_blob', '*', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_bytes', 'int', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_count', 'int', 'sqlite3_stmt*'],
          ['sqlite3_column_double', 'f64', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_int', 'int', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_name', 'string', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_text', 'string', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_type', 'int', 'sqlite3_stmt*', 'int'],
          ['sqlite3_column_value', 'sqlite3_value*', 'sqlite3_stmt*', 'int'],
          [
            'sqlite3_commit_hook',
            'void*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_commit_hook',
                signature: 'i(p)',
                contextKey: (argv) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_compileoption_get', 'string', 'int'],
          ['sqlite3_compileoption_used', 'int', 'string'],
          ['sqlite3_complete', 'int', 'string:flexible'],
          ['sqlite3_context_db_handle', 'sqlite3*', 'sqlite3_context*'],

          ['sqlite3_data_count', 'int', 'sqlite3_stmt*'],
          ['sqlite3_db_filename', 'string', 'sqlite3*', 'string'],
          ['sqlite3_db_handle', 'sqlite3*', 'sqlite3_stmt*'],
          ['sqlite3_db_name', 'string', 'sqlite3*', 'int'],
          ['sqlite3_db_status', 'int', 'sqlite3*', 'int', '*', '*', 'int'],
          ['sqlite3_errcode', 'int', 'sqlite3*'],
          ['sqlite3_errmsg', 'string', 'sqlite3*'],
          ['sqlite3_error_offset', 'int', 'sqlite3*'],
          ['sqlite3_errstr', 'string', 'int'],
          [
            'sqlite3_exec',
            'int',
            [
              'sqlite3*',
              'string:flexible',
              new wasm.xWrap.FuncPtrAdapter({
                signature: 'i(pipp)',
                bindScope: 'transient',
                callProxy: (callback) => {
                  let aNames;
                  return (pVoid, nCols, pColVals, pColNames) => {
                    try {
                      const aVals = wasm.cArgvToJs(nCols, pColVals);
                      if (!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);
                      return callback(aVals, aNames) | 0;
                    } catch (e) {
                      return e.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                },
              }),
              '*',
              '**',
            ],
          ],
          ['sqlite3_expanded_sql', 'string', 'sqlite3_stmt*'],
          ['sqlite3_extended_errcode', 'int', 'sqlite3*'],
          ['sqlite3_extended_result_codes', 'int', 'sqlite3*', 'int'],
          ['sqlite3_file_control', 'int', 'sqlite3*', 'string', 'int', '*'],
          ['sqlite3_finalize', 'int', 'sqlite3_stmt*'],
          ['sqlite3_free', undefined, '*'],
          ['sqlite3_get_autocommit', 'int', 'sqlite3*'],
          ['sqlite3_get_auxdata', '*', 'sqlite3_context*', 'int'],
          ['sqlite3_initialize', undefined],

          ['sqlite3_keyword_count', 'int'],
          ['sqlite3_keyword_name', 'int', ['int', '**', '*']],
          ['sqlite3_keyword_check', 'int', ['string', 'int']],
          ['sqlite3_libversion', 'string'],
          ['sqlite3_libversion_number', 'int'],
          ['sqlite3_limit', 'int', ['sqlite3*', 'int', 'int']],
          ['sqlite3_malloc', '*', 'int'],
          ['sqlite3_open', 'int', 'string', '*'],
          ['sqlite3_open_v2', 'int', 'string', '*', 'int', 'string'],

          [
            'sqlite3_progress_handler',
            undefined,
            [
              'sqlite3*',
              'int',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xProgressHandler',
                signature: 'i(p)',
                bindScope: 'context',
                contextKey: (argv, argIndex) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_realloc', '*', '*', 'int'],
          ['sqlite3_reset', 'int', 'sqlite3_stmt*'],

          [
            'sqlite3_result_blob',
            undefined,
            'sqlite3_context*',
            '*',
            'int',
            '*',
          ],
          ['sqlite3_result_double', undefined, 'sqlite3_context*', 'f64'],
          [
            'sqlite3_result_error',
            undefined,
            'sqlite3_context*',
            'string',
            'int',
          ],
          ['sqlite3_result_error_code', undefined, 'sqlite3_context*', 'int'],
          ['sqlite3_result_error_nomem', undefined, 'sqlite3_context*'],
          ['sqlite3_result_error_toobig', undefined, 'sqlite3_context*'],
          ['sqlite3_result_int', undefined, 'sqlite3_context*', 'int'],
          ['sqlite3_result_null', undefined, 'sqlite3_context*'],
          [
            'sqlite3_result_pointer',
            undefined,
            'sqlite3_context*',
            '*',
            'string:static',
            '*',
          ],
          ['sqlite3_result_subtype', undefined, 'sqlite3_value*', 'int'],
          [
            'sqlite3_result_text',
            undefined,
            'sqlite3_context*',
            'string',
            'int',
            '*',
          ],
          ['sqlite3_result_zeroblob', undefined, 'sqlite3_context*', 'int'],
          [
            'sqlite3_rollback_hook',
            'void*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_rollback_hook',
                signature: 'v(p)',
                contextKey: (argv) => argv[0],
              }),
              '*',
            ],
          ],
          [
            'sqlite3_set_authorizer',
            'int',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_set_authorizer::xAuth',
                signature: 'i(pi' + 'ssss)',
                contextKey: (argv, argIndex) => argv[0],
                callProxy: (callback) => {
                  return (pV, iCode, s0, s1, s2, s3) => {
                    try {
                      s0 = s0 && wasm.cstrToJs(s0);
                      s1 = s1 && wasm.cstrToJs(s1);
                      s2 = s2 && wasm.cstrToJs(s2);
                      s3 = s3 && wasm.cstrToJs(s3);
                      return callback(pV, iCode, s0, s1, s2, s3) || 0;
                    } catch (e) {
                      return e.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                },
              }),
              '*',
            ],
          ],
          [
            'sqlite3_set_auxdata',
            undefined,
            [
              'sqlite3_context*',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroyAuxData',
                signature: 'v(*)',
                contextKey: (argv, argIndex) => argv[0],
              }),
            ],
          ],
          ['sqlite3_shutdown', undefined],
          ['sqlite3_sourceid', 'string'],
          ['sqlite3_sql', 'string', 'sqlite3_stmt*'],
          ['sqlite3_status', 'int', 'int', '*', '*', 'int'],
          ['sqlite3_step', 'int', 'sqlite3_stmt*'],
          ['sqlite3_stmt_isexplain', 'int', ['sqlite3_stmt*']],
          ['sqlite3_stmt_readonly', 'int', ['sqlite3_stmt*']],
          ['sqlite3_stmt_status', 'int', 'sqlite3_stmt*', 'int', 'int'],
          ['sqlite3_strglob', 'int', 'string', 'string'],
          ['sqlite3_stricmp', 'int', 'string', 'string'],
          ['sqlite3_strlike', 'int', 'string', 'string', 'int'],
          ['sqlite3_strnicmp', 'int', 'string', 'string', 'int'],
          [
            'sqlite3_table_column_metadata',
            'int',
            'sqlite3*',
            'string',
            'string',
            'string',
            '**',
            '**',
            '*',
            '*',
            '*',
          ],
          ['sqlite3_total_changes', 'int', 'sqlite3*'],
          [
            'sqlite3_trace_v2',
            'int',
            [
              'sqlite3*',
              'int',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_trace_v2::callback',
                signature: 'i(ippp)',
                contextKey: (argv, argIndex) => argv[0],
              }),
              '*',
            ],
          ],
          ['sqlite3_txn_state', 'int', ['sqlite3*', 'string']],

          ['sqlite3_uri_boolean', 'int', 'sqlite3_filename', 'string', 'int'],
          ['sqlite3_uri_key', 'string', 'sqlite3_filename', 'int'],
          ['sqlite3_uri_parameter', 'string', 'sqlite3_filename', 'string'],
          ['sqlite3_user_data', 'void*', 'sqlite3_context*'],
          ['sqlite3_value_blob', '*', 'sqlite3_value*'],
          ['sqlite3_value_bytes', 'int', 'sqlite3_value*'],
          ['sqlite3_value_double', 'f64', 'sqlite3_value*'],
          ['sqlite3_value_dup', 'sqlite3_value*', 'sqlite3_value*'],
          ['sqlite3_value_free', undefined, 'sqlite3_value*'],
          ['sqlite3_value_frombind', 'int', 'sqlite3_value*'],
          ['sqlite3_value_int', 'int', 'sqlite3_value*'],
          ['sqlite3_value_nochange', 'int', 'sqlite3_value*'],
          ['sqlite3_value_numeric_type', 'int', 'sqlite3_value*'],
          ['sqlite3_value_pointer', '*', 'sqlite3_value*', 'string:static'],
          ['sqlite3_value_subtype', 'int', 'sqlite3_value*'],
          ['sqlite3_value_text', 'string', 'sqlite3_value*'],
          ['sqlite3_value_type', 'int', 'sqlite3_value*'],
          ['sqlite3_vfs_find', '*', 'string'],
          ['sqlite3_vfs_register', 'int', 'sqlite3_vfs*', 'int'],
          ['sqlite3_vfs_unregister', 'int', 'sqlite3_vfs*'],
        ];

        if (false) {}

        if (wasm.exports.sqlite3_activate_see instanceof Function) {
          wasm.bindingSignatures.push(
            ['sqlite3_key', 'int', 'sqlite3*', 'string', 'int'],
            ['sqlite3_key_v2', 'int', 'sqlite3*', 'string', '*', 'int'],
            ['sqlite3_rekey', 'int', 'sqlite3*', 'string', 'int'],
            ['sqlite3_rekey_v2', 'int', 'sqlite3*', 'string', '*', 'int'],
            ['sqlite3_activate_see', undefined, 'string'],
          );
        }

        wasm.bindingSignatures.int64 = [
          ['sqlite3_bind_int64', 'int', ['sqlite3_stmt*', 'int', 'i64']],
          ['sqlite3_changes64', 'i64', ['sqlite3*']],
          ['sqlite3_column_int64', 'i64', ['sqlite3_stmt*', 'int']],
          [
            'sqlite3_create_module',
            'int',
            ['sqlite3*', 'string', 'sqlite3_module*', '*'],
          ],
          [
            'sqlite3_create_module_v2',
            'int',
            ['sqlite3*', 'string', 'sqlite3_module*', '*', '*'],
          ],
          ['sqlite3_declare_vtab', 'int', ['sqlite3*', 'string:flexible']],
          [
            'sqlite3_deserialize',
            'int',
            'sqlite3*',
            'string',
            '*',
            'i64',
            'i64',
            'int',
          ],
          ['sqlite3_drop_modules', 'int', ['sqlite3*', '**']],
          ['sqlite3_last_insert_rowid', 'i64', ['sqlite3*']],
          ['sqlite3_malloc64', '*', 'i64'],
          ['sqlite3_msize', 'i64', '*'],
          ['sqlite3_overload_function', 'int', ['sqlite3*', 'string', 'int']],
          ['sqlite3_preupdate_blobwrite', 'int', 'sqlite3*'],
          ['sqlite3_preupdate_count', 'int', 'sqlite3*'],
          ['sqlite3_preupdate_depth', 'int', 'sqlite3*'],
          [
            'sqlite3_preupdate_hook',
            '*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_preupdate_hook',
                signature: 'v(ppippjj)',
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p, db, op, zDb, zTbl, iKey1, iKey2) => {
                    callback(
                      p,
                      db,
                      op,
                      wasm.cstrToJs(zDb),
                      wasm.cstrToJs(zTbl),
                      iKey1,
                      iKey2,
                    );
                  };
                },
              }),
              '*',
            ],
          ],
          ['sqlite3_preupdate_new', 'int', ['sqlite3*', 'int', '**']],
          ['sqlite3_preupdate_old', 'int', ['sqlite3*', 'int', '**']],
          ['sqlite3_realloc64', '*', '*', 'i64'],
          ['sqlite3_result_int64', undefined, '*', 'i64'],
          ['sqlite3_result_zeroblob64', 'int', '*', 'i64'],
          ['sqlite3_serialize', '*', 'sqlite3*', 'string', '*', 'int'],
          ['sqlite3_set_last_insert_rowid', undefined, ['sqlite3*', 'i64']],
          ['sqlite3_status64', 'int', 'int', '*', '*', 'int'],
          ['sqlite3_total_changes64', 'i64', ['sqlite3*']],
          [
            'sqlite3_update_hook',
            '*',
            [
              'sqlite3*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'sqlite3_update_hook',
                signature: 'v(iippj)',
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p, op, z0, z1, rowid) => {
                    callback(
                      p,
                      op,
                      wasm.cstrToJs(z0),
                      wasm.cstrToJs(z1),
                      rowid,
                    );
                  };
                },
              }),
              '*',
            ],
          ],
          ['sqlite3_uri_int64', 'i64', ['sqlite3_filename', 'string', 'i64']],
          ['sqlite3_value_int64', 'i64', 'sqlite3_value*'],
          ['sqlite3_vtab_collation', 'string', 'sqlite3_index_info*', 'int'],
          ['sqlite3_vtab_distinct', 'int', 'sqlite3_index_info*'],
          ['sqlite3_vtab_in', 'int', 'sqlite3_index_info*', 'int', 'int'],
          ['sqlite3_vtab_in_first', 'int', 'sqlite3_value*', '**'],
          ['sqlite3_vtab_in_next', 'int', 'sqlite3_value*', '**'],

          ['sqlite3_vtab_nochange', 'int', 'sqlite3_context*'],
          ['sqlite3_vtab_on_conflict', 'int', 'sqlite3*'],
          ['sqlite3_vtab_rhs_value', 'int', 'sqlite3_index_info*', 'int', '**'],
        ];

        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add) {
          const __ipsProxy = {
            signature: 'i(ps)',
            callProxy: (callback) => {
              return (p, s) => {
                try {
                  return callback(p, wasm.cstrToJs(s)) | 0;
                } catch (e) {
                  return e.resultCode || capi.SQLITE_ERROR;
                }
              };
            },
          };

          wasm.bindingSignatures.int64.push(
            ...[
              [
                'sqlite3changegroup_add',
                'int',
                ['sqlite3_changegroup*', 'int', 'void*'],
              ],
              [
                'sqlite3changegroup_add_strm',
                'int',
                [
                  'sqlite3_changegroup*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changegroup_delete',
                undefined,
                ['sqlite3_changegroup*'],
              ],
              ['sqlite3changegroup_new', 'int', ['**']],
              [
                'sqlite3changegroup_output',
                'int',
                ['sqlite3_changegroup*', 'int*', '**'],
              ],
              [
                'sqlite3changegroup_output_strm',
                'int',
                [
                  'sqlite3_changegroup*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppi)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_apply',
                'int',
                [
                  'sqlite3*',
                  'int',
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_apply_strm',
                'int',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_apply_v2',
                'int',
                [
                  'sqlite3*',
                  'int',
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  '**',
                  'int*',
                  'int',
                ],
              ],
              [
                'sqlite3changeset_apply_v2_strm',
                'int',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    bindScope: 'transient',
                    ...__ipsProxy,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xConflict',
                    signature: 'i(pip)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  '**',
                  'int*',
                  'int',
                ],
              ],
              [
                'sqlite3changeset_concat',
                'int',
                ['int', 'void*', 'int', 'void*', 'int*', '**'],
              ],
              [
                'sqlite3changeset_concat_strm',
                'int',
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInputA',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInputB',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppi)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_conflict',
                'int',
                ['sqlite3_changeset_iter*', 'int', '**'],
              ],
              ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],
              [
                'sqlite3changeset_fk_conflicts',
                'int',
                ['sqlite3_changeset_iter*', 'int*'],
              ],
              [
                'sqlite3changeset_invert',
                'int',
                ['int', 'void*', 'int*', '**'],
              ],
              [
                'sqlite3changeset_invert_strm',
                'int',
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppi)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3changeset_new',
                'int',
                ['sqlite3_changeset_iter*', 'int', '**'],
              ],
              ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],
              [
                'sqlite3changeset_old',
                'int',
                ['sqlite3_changeset_iter*', 'int', '**'],
              ],
              [
                'sqlite3changeset_op',
                'int',
                ['sqlite3_changeset_iter*', '**', 'int*', 'int*', 'int*'],
              ],
              [
                'sqlite3changeset_pk',
                'int',
                ['sqlite3_changeset_iter*', '**', 'int*'],
              ],
              ['sqlite3changeset_start', 'int', ['**', 'int', '*']],
              [
                'sqlite3changeset_start_strm',
                'int',
                [
                  '**',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],
              [
                'sqlite3changeset_start_v2_strm',
                'int',
                [
                  '**',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                  'int',
                ],
              ],
              ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],
              [
                'sqlite3session_changeset',
                'int',
                ['sqlite3_session*', 'int*', '**'],
              ],
              ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],
              [
                'sqlite3session_changeset_strm',
                'int',
                [
                  'sqlite3_session*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              ['sqlite3session_config', 'int', ['int', 'void*']],
              ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],

              [
                'sqlite3session_diff',
                'int',
                ['sqlite3_session*', 'string', 'string', '**'],
              ],
              ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],
              ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],
              ['sqlite3session_isempty', 'int', ['sqlite3_session*']],
              ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],
              [
                'sqlite3session_object_config',
                'int',
                ['sqlite3_session*', 'int', 'void*'],
              ],
              [
                'sqlite3session_patchset',
                'int',
                ['sqlite3_session*', '*', '**'],
              ],
              [
                'sqlite3session_patchset_strm',
                'int',
                [
                  'sqlite3_session*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xOutput',
                    signature: 'i(ppp)',
                    bindScope: 'transient',
                  }),
                  'void*',
                ],
              ],
              [
                'sqlite3session_table_filter',
                undefined,
                [
                  'sqlite3_session*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFilter',
                    ...__ipsProxy,
                    contextKey: (argv, argIndex) => argv[0],
                  }),
                  '*',
                ],
              ],
            ],
          );
        }

        wasm.bindingSignatures.wasm = [
          ['sqlite3_wasm_db_reset', 'int', 'sqlite3*'],
          ['sqlite3_wasm_db_vfs', 'sqlite3_vfs*', 'sqlite3*', 'string'],
          [
            'sqlite3_wasm_vfs_create_file',
            'int',
            'sqlite3_vfs*',
            'string',
            '*',
            'int',
          ],
          ['sqlite3_wasm_posix_create_file', 'int', 'string', '*', 'int'],
          ['sqlite3_wasm_vfs_unlink', 'int', 'sqlite3_vfs*', 'string'],
        ];

        sqlite3.StructBinder = globalThis.Jaccwabyt({
          heap:  false ? 0 : wasm.heap8u,
          alloc: wasm.alloc,
          dealloc: wasm.dealloc,
          bigIntEnabled: wasm.bigIntEnabled,
          memberPrefix: '$',
        });
        delete globalThis.Jaccwabyt;

        {
          const __xString = wasm.xWrap.argAdapter('string');
          wasm.xWrap.argAdapter('string:flexible', (v) =>
            __xString(util.flexibleString(v)),
          );

          wasm.xWrap.argAdapter(
            'string:static',
            function (v) {
              if (wasm.isPtr(v)) return v;
              v = '' + v;
              let rc = this[v];
              return rc || (this[v] = wasm.allocCString(v));
            }.bind(Object.create(null)),
          );

          const __xArgPtr = wasm.xWrap.argAdapter('*');
          const nilType = function () {};
          wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)(
            'sqlite3_context*',
            __xArgPtr,
          )('sqlite3_value*', __xArgPtr)('void*', __xArgPtr)(
            'sqlite3_changegroup*',
            __xArgPtr,
          )('sqlite3_changeset_iter*', __xArgPtr)(
            'sqlite3_session*',
            __xArgPtr,
          )('sqlite3_stmt*', (v) =>
            __xArgPtr(
              v instanceof (sqlite3?.oo1?.Stmt || nilType) ? v.pointer : v,
            ),
          )('sqlite3*', (v) =>
            __xArgPtr(
              v instanceof (sqlite3?.oo1?.DB || nilType) ? v.pointer : v,
            ),
          )('sqlite3_index_info*', (v) =>
            __xArgPtr(
              v instanceof (capi.sqlite3_index_info || nilType) ? v.pointer : v,
            ),
          )('sqlite3_module*', (v) =>
            __xArgPtr(
              v instanceof (capi.sqlite3_module || nilType) ? v.pointer : v,
            ),
          )('sqlite3_vfs*', (v) => {
            if ('string' === typeof v) {
              return (
                capi.sqlite3_vfs_find(v) ||
                sqlite3.SQLite3Error.toss(
                  capi.SQLITE_NOTFOUND,
                  'Unknown sqlite3_vfs name:',
                  v,
                )
              );
            }
            return __xArgPtr(
              v instanceof (capi.sqlite3_vfs || nilType) ? v.pointer : v,
            );
          });

          const __xRcPtr = wasm.xWrap.resultAdapter('*');
          wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)(
            'sqlite3_context*',
            __xRcPtr,
          )('sqlite3_stmt*', __xRcPtr)('sqlite3_value*', __xRcPtr)(
            'sqlite3_vfs*',
            __xRcPtr,
          )('void*', __xRcPtr);

          if (0 === wasm.exports.sqlite3_step.length) {
            wasm.xWrap.doArgcCheck = false;
            sqlite3.config.warn(
              'Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks.',
            );
          }
          for (const e of wasm.bindingSignatures) {
            capi[e[0]] = wasm.xWrap.apply(null, e);
          }
          for (const e of wasm.bindingSignatures.wasm) {
            wasm[e[0]] = wasm.xWrap.apply(null, e);
          }

          const fI64Disabled = function (fname) {
            return () =>
              toss(
                fname + '() is unavailable due to lack',
                'of BigInt support in this build.',
              );
          };
          for (const e of wasm.bindingSignatures.int64) {
            capi[e[0]] = wasm.bigIntEnabled
              ? wasm.xWrap.apply(null, e)
              : fI64Disabled(e[0]);
          }

          delete wasm.bindingSignatures;

          if (wasm.exports.sqlite3_wasm_db_error) {
            const __db_err = wasm.xWrap(
              'sqlite3_wasm_db_error',
              'int',
              'sqlite3*',
              'int',
              'string',
            );

            util.sqlite3_wasm_db_error = function (pDb, resultCode, message) {
              if (resultCode instanceof sqlite3.WasmAllocError) {
                resultCode = capi.SQLITE_NOMEM;
                message = 0;
              } else if (resultCode instanceof Error) {
                message = message || '' + resultCode;
                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
              }
              return pDb ? __db_err(pDb, resultCode, message) : resultCode;
            };
          } else {
            util.sqlite3_wasm_db_error = function (pDb, errCode, msg) {
              console.warn(
                'sqlite3_wasm_db_error() is not exported.',
                arguments,
              );
              return errCode;
            };
          }
        }

        {
          const cJson = wasm.xCall('sqlite3_wasm_enum_json');
          if (!cJson) {
            toss(
              "Maintenance required: increase sqlite3_wasm_enum_json()'s",
              'static buffer size!',
            );
          }

          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));

          const defineGroups = [
            'access',
            'authorizer',
            'blobFinalizers',
            'changeset',
            'config',
            'dataTypes',
            'dbConfig',
            'dbStatus',
            'encodings',
            'fcntl',
            'flock',
            'ioCap',
            'limits',
            'openFlags',
            'prepareFlags',
            'resultCodes',
            'sqlite3Status',
            'stmtStatus',
            'syncFlags',
            'trace',
            'txnState',
            'udfFlags',
            'version',
          ];
          if (wasm.bigIntEnabled) {
            defineGroups.push('serialize', 'session', 'vtab');
          }
          for (const t of defineGroups) {
            for (const e of Object.entries(wasm.ctype[t])) {
              capi[e[0]] = e[1];
            }
          }
          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              'Internal error: cannot resolve exported function',
              'entry SQLITE_WASM_DEALLOC (==' + capi.SQLITE_WASM_DEALLOC + ').',
            );
          }
          const __rcMap = Object.create(null);
          for (const t of ['resultCodes']) {
            for (const e of Object.entries(wasm.ctype[t])) {
              __rcMap[e[1]] = e[0];
            }
          }

          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];

          const notThese = Object.assign(Object.create(null), {
            WasmTestStruct: true,

            sqlite3_kvvfs_methods: !util.isUIThread(),

            sqlite3_index_info: !wasm.bigIntEnabled,
            sqlite3_index_constraint: !wasm.bigIntEnabled,
            sqlite3_index_orderby: !wasm.bigIntEnabled,
            sqlite3_index_constraint_usage: !wasm.bigIntEnabled,
          });
          for (const s of wasm.ctype.structs) {
            if (!notThese[s.name]) {
              capi[s.name] = sqlite3.StructBinder(s);
            }
          }
          if (capi.sqlite3_index_info) {
            for (const k of [
              'sqlite3_index_constraint',
              'sqlite3_index_orderby',
              'sqlite3_index_constraint_usage',
            ]) {
              capi.sqlite3_index_info[k] = capi[k];
              delete capi[k];
            }
            capi.sqlite3_vtab_config = wasm.xWrap(
              'sqlite3_wasm_vtab_config',
              'int',
              ['sqlite3*', 'int', 'int'],
            );
          }
        }

        const __dbArgcMismatch = (pDb, f, n) => {
          return util.sqlite3_wasm_db_error(
            pDb,
            capi.SQLITE_MISUSE,
            f + '() requires ' + n + ' argument' + (1 === n ? '' : 's') + '.',
          );
        };

        const __errEncoding = (pDb) => {
          return util.sqlite3_wasm_db_error(
            pDb,
            capi.SQLITE_FORMAT,
            'SQLITE_UTF8 is the only supported encoding.',
          );
        };

        const __argPDb = (pDb) => wasm.xWrap.argAdapter('sqlite3*')(pDb);
        const __argStr = (str) => (wasm.isPtr(str) ? wasm.cstrToJs(str) : str);
        const __dbCleanupMap = function (pDb, mode) {
          pDb = __argPDb(pDb);
          let m = this.dbMap.get(pDb);
          if (!mode) {
            this.dbMap.delete(pDb);
            return m;
          } else if (!m && mode > 0) {
            this.dbMap.set(pDb, (m = Object.create(null)));
          }
          return m;
        }.bind(
          Object.assign(Object.create(null), {
            dbMap: new Map(),
          }),
        );

        __dbCleanupMap.addCollation = function (pDb, name) {
          const m = __dbCleanupMap(pDb, 1);
          if (!m.collation) m.collation = new Set();
          m.collation.add(__argStr(name).toLowerCase());
        };

        __dbCleanupMap._addUDF = function (pDb, name, arity, map) {
          name = __argStr(name).toLowerCase();
          let u = map.get(name);
          if (!u) map.set(name, (u = new Set()));
          u.add(arity < 0 ? -1 : arity);
        };

        __dbCleanupMap.addFunction = function (pDb, name, arity) {
          const m = __dbCleanupMap(pDb, 1);
          if (!m.udf) m.udf = new Map();
          this._addUDF(pDb, name, arity, m.udf);
        };

        __dbCleanupMap.addWindowFunc = function (pDb, name, arity) {
          const m = __dbCleanupMap(pDb, 1);
          if (!m.wudf) m.wudf = new Map();
          this._addUDF(pDb, name, arity, m.wudf);
        };

        __dbCleanupMap.cleanup = function (pDb) {
          pDb = __argPDb(pDb);

          const closeArgs = [pDb];
          for (const name of [
            'sqlite3_busy_handler',
            'sqlite3_commit_hook',
            'sqlite3_preupdate_hook',
            'sqlite3_progress_handler',
            'sqlite3_rollback_hook',
            'sqlite3_set_authorizer',
            'sqlite3_trace_v2',
            'sqlite3_update_hook',
          ]) {
            const x = wasm.exports[name];
            closeArgs.length = x.length;
            try {
              capi[name](...closeArgs);
            } catch (e) {
              console.warn(
                'close-time call of',
                name + '(',
                closeArgs,
                ') threw:',
                e,
              );
            }
          }
          const m = __dbCleanupMap(pDb, 0);
          if (!m) return;
          if (m.collation) {
            for (const name of m.collation) {
              try {
                capi.sqlite3_create_collation_v2(
                  pDb,
                  name,
                  capi.SQLITE_UTF8,
                  0,
                  0,
                  0,
                );
              } catch (e) {}
            }
            delete m.collation;
          }
          let i;
          for (i = 0; i < 2; ++i) {
            const fmap = i ? m.wudf : m.udf;
            if (!fmap) continue;
            const func = i
              ? capi.sqlite3_create_window_function
              : capi.sqlite3_create_function_v2;
            for (const e of fmap) {
              const name = e[0],
                arities = e[1];
              const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
              if (i) fargs.push(0);
              for (const arity of arities) {
                try {
                  fargs[2] = arity;
                  func.apply(null, fargs);
                } catch (e) {}
              }
              arities.clear();
            }
            fmap.clear();
          }
          delete m.udf;
          delete m.wudf;
        };

        {
          const __sqlite3CloseV2 = wasm.xWrap(
            'sqlite3_close_v2',
            'int',
            'sqlite3*',
          );
          capi.sqlite3_close_v2 = function (pDb) {
            if (1 !== arguments.length)
              return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);
            if (pDb) {
              try {
                __dbCleanupMap.cleanup(pDb);
              } catch (e) {}
            }
            return __sqlite3CloseV2(pDb);
          };
        }

        if (capi.sqlite3session_table_filter) {
          const __sqlite3SessionDelete = wasm.xWrap(
            'sqlite3session_delete',
            undefined,
            ['sqlite3_session*'],
          );
          capi.sqlite3session_delete = function (pSession) {
            if (1 !== arguments.length) {
              return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);
            } else if (pSession) {
              capi.sqlite3session_table_filter(pSession, 0, 0);
            }
            __sqlite3SessionDelete(pSession);
          };
        }

        {
          const contextKey = (argv, argIndex) => {
            return (
              'argv[' +
              argIndex +
              ']:' +
              argv[0] +
              ':' +
              wasm.cstrToJs(argv[1]).toLowerCase()
            );
          };
          const __sqlite3CreateCollationV2 = wasm.xWrap(
            'sqlite3_create_collation_v2',
            'int',
            [
              'sqlite3*',
              'string',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xCompare',
                signature: 'i(pipip)',
                contextKey,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroy',
                signature: 'v(p)',
                contextKey,
              }),
            ],
          );

          capi.sqlite3_create_collation_v2 = function (
            pDb,
            zName,
            eTextRep,
            pArg,
            xCompare,
            xDestroy,
          ) {
            if (6 !== arguments.length)
              return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);
            else if (0 === (eTextRep & 0xf)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
              return __errEncoding(pDb);
            }
            try {
              const rc = __sqlite3CreateCollationV2(
                pDb,
                zName,
                eTextRep,
                pArg,
                xCompare,
                xDestroy,
              );
              if (0 === rc && xCompare instanceof Function) {
                __dbCleanupMap.addCollation(pDb, zName);
              }
              return rc;
            } catch (e) {
              return util.sqlite3_wasm_db_error(pDb, e);
            }
          };

          capi.sqlite3_create_collation = (
            pDb,
            zName,
            eTextRep,
            pArg,
            xCompare,
          ) => {
            return 5 === arguments.length
              ? capi.sqlite3_create_collation_v2(
                  pDb,
                  zName,
                  eTextRep,
                  pArg,
                  xCompare,
                  0,
                )
              : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);
          };
        }

        {
          const contextKey = function (argv, argIndex) {
            return (
              argv[0] +
              ':' +
              (argv[2] < 0 ? -1 : argv[2]) +
              ':' +
              argIndex +
              ':' +
              wasm.cstrToJs(argv[1]).toLowerCase()
            );
          };

          const __cfProxy = Object.assign(Object.create(null), {
            xInverseAndStep: {
              signature: 'v(pip)',
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              },
            },
            xFinalAndValue: {
              signature: 'v(p)',
              contextKey,
              callProxy: (callback) => {
                return (pCtx) => {
                  try {
                    capi.sqlite3_result_js(pCtx, callback(pCtx));
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              },
            },
            xFunc: {
              signature: 'v(pip)',
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    capi.sqlite3_result_js(
                      pCtx,
                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)),
                    );
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              },
            },
            xDestroy: {
              signature: 'v(p)',
              contextKey,

              callProxy: (callback) => {
                return (pVoid) => {
                  try {
                    callback(pVoid);
                  } catch (e) {
                    console.error('UDF xDestroy method threw:', e);
                  }
                };
              },
            },
          });

          const __sqlite3CreateFunction = wasm.xWrap(
            'sqlite3_create_function_v2',
            'int',
            [
              'sqlite3*',
              'string',
              'int',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xFunc',
                ...__cfProxy.xFunc,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xStep',
                ...__cfProxy.xInverseAndStep,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xFinal',
                ...__cfProxy.xFinalAndValue,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroy',
                ...__cfProxy.xDestroy,
              }),
            ],
          );

          const __sqlite3CreateWindowFunction = wasm.xWrap(
            'sqlite3_create_window_function',
            'int',
            [
              'sqlite3*',
              'string',
              'int',
              'int',
              '*',
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xStep',
                ...__cfProxy.xInverseAndStep,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xFinal',
                ...__cfProxy.xFinalAndValue,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xValue',
                ...__cfProxy.xFinalAndValue,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xInverse',
                ...__cfProxy.xInverseAndStep,
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: 'xDestroy',
                ...__cfProxy.xDestroy,
              }),
            ],
          );

          capi.sqlite3_create_function_v2 = function f(
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb,
                'sqlite3_create_function_v2',
                f.length,
              );
            } else if (0 === (eTextRep & 0xf)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
              return __errEncoding(pDb);
            }
            try {
              const rc = __sqlite3CreateFunction(
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy,
              );
              if (
                0 === rc &&
                (xFunc instanceof Function ||
                  xStep instanceof Function ||
                  xFinal instanceof Function ||
                  xDestroy instanceof Function)
              ) {
                __dbCleanupMap.addFunction(pDb, funcName, nArg);
              }
              return rc;
            } catch (e) {
              console.error('sqlite3_create_function_v2() setup threw:', e);
              return util.sqlite3_wasm_db_error(
                pDb,
                e,
                'Creation of UDF threw: ' + e,
              );
            }
          };

          capi.sqlite3_create_function = function f(
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xFunc,
            xStep,
            xFinal,
          ) {
            return f.length === arguments.length
              ? capi.sqlite3_create_function_v2(
                  pDb,
                  funcName,
                  nArg,
                  eTextRep,
                  pApp,
                  xFunc,
                  xStep,
                  xFinal,
                  0,
                )
              : __dbArgcMismatch(pDb, 'sqlite3_create_function', f.length);
          };

          capi.sqlite3_create_window_function = function f(
            pDb,
            funcName,
            nArg,
            eTextRep,
            pApp,
            xStep,
            xFinal,
            xValue,
            xInverse,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb,
                'sqlite3_create_window_function',
                f.length,
              );
            } else if (0 === (eTextRep & 0xf)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
              return __errEncoding(pDb);
            }
            try {
              const rc = __sqlite3CreateWindowFunction(
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy,
              );
              if (
                0 === rc &&
                (xStep instanceof Function ||
                  xFinal instanceof Function ||
                  xValue instanceof Function ||
                  xInverse instanceof Function ||
                  xDestroy instanceof Function)
              ) {
                __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);
              }
              return rc;
            } catch (e) {
              console.error('sqlite3_create_window_function() setup threw:', e);
              return util.sqlite3_wasm_db_error(
                pDb,
                e,
                'Creation of UDF threw: ' + e,
              );
            }
          };

          capi.sqlite3_create_function_v2.udfSetResult =
            capi.sqlite3_create_function.udfSetResult =
            capi.sqlite3_create_window_function.udfSetResult =
              capi.sqlite3_result_js;

          capi.sqlite3_create_function_v2.udfConvertArgs =
            capi.sqlite3_create_function.udfConvertArgs =
            capi.sqlite3_create_window_function.udfConvertArgs =
              capi.sqlite3_values_to_js;

          capi.sqlite3_create_function_v2.udfSetError =
            capi.sqlite3_create_function.udfSetError =
            capi.sqlite3_create_window_function.udfSetError =
              capi.sqlite3_result_error_js;
        }

        {
          const __flexiString = (v, n) => {
            if ('string' === typeof v) {
              n = -1;
            } else if (util.isSQLableTypedArray(v)) {
              n = v.byteLength;
              v = util.typedArrayToString(
                v instanceof ArrayBuffer ? new Uint8Array(v) : v,
              );
            } else if (Array.isArray(v)) {
              v = v.join('');
              n = -1;
            }
            return [v, n];
          };

          const __prepare = {
            basic: wasm.xWrap('sqlite3_prepare_v3', 'int', [
              'sqlite3*',
              'string',
              'int',
              'int',
              '**',
              '**',
            ]),

            full: wasm.xWrap('sqlite3_prepare_v3', 'int', [
              'sqlite3*',
              '*',
              'int',
              'int',
              '**',
              '**',
            ]),
          };

          capi.sqlite3_prepare_v3 = function f(
            pDb,
            sql,
            sqlLen,
            prepFlags,
            ppStmt,
            pzTail,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(pDb, 'sqlite3_prepare_v3', f.length);
            }
            const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
            switch (typeof xSql) {
              case 'string':
                return __prepare.basic(
                  pDb,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  null,
                );
              case 'number':
                return __prepare.full(
                  pDb,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  pzTail,
                );
              default:
                return util.sqlite3_wasm_db_error(
                  pDb,
                  capi.SQLITE_MISUSE,
                  'Invalid SQL argument type for sqlite3_prepare_v2/v3().',
                );
            }
          };

          capi.sqlite3_prepare_v2 = function f(
            pDb,
            sql,
            sqlLen,
            ppStmt,
            pzTail,
          ) {
            return f.length === arguments.length
              ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)
              : __dbArgcMismatch(pDb, 'sqlite3_prepare_v2', f.length);
          };
        }

        {
          const __bindText = wasm.xWrap('sqlite3_bind_text', 'int', [
            'sqlite3_stmt*',
            'int',
            'string',
            'int',
            '*',
          ]);
          const __bindBlob = wasm.xWrap('sqlite3_bind_blob', 'int', [
            'sqlite3_stmt*',
            'int',
            '*',
            'int',
            '*',
          ]);

          capi.sqlite3_bind_text = function f(
            pStmt,
            iCol,
            text,
            nText,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                'sqlite3_bind_text',
                f.length,
              );
            } else if (wasm.isPtr(text) || null === text) {
              return __bindText(pStmt, iCol, text, nText, xDestroy);
            } else if (text instanceof ArrayBuffer) {
              text = new Uint8Array(text);
            } else if (Array.isArray(pMem)) {
              text = pMem.join('');
            }
            let p, n;
            try {
              if (util.isSQLableTypedArray(text)) {
                p = wasm.allocFromTypedArray(text);
                n = text.byteLength;
              } else if ('string' === typeof text) {
                [p, n] = wasm.allocCString(text);
              } else {
                return util.sqlite3_wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  'Invalid 3rd argument type for sqlite3_bind_text().',
                );
              }
              return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
            } catch (e) {
              wasm.dealloc(p);
              return util.sqlite3_wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e,
              );
            }
          };

          capi.sqlite3_bind_blob = function f(
            pStmt,
            iCol,
            pMem,
            nMem,
            xDestroy,
          ) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                'sqlite3_bind_blob',
                f.length,
              );
            } else if (wasm.isPtr(pMem) || null === pMem) {
              return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);
            } else if (pMem instanceof ArrayBuffer) {
              pMem = new Uint8Array(pMem);
            } else if (Array.isArray(pMem)) {
              pMem = pMem.join('');
            }
            let p, n;
            try {
              if (util.isBindableTypedArray(pMem)) {
                p = wasm.allocFromTypedArray(pMem);
                n = nMem >= 0 ? nMem : pMem.byteLength;
              } else if ('string' === typeof pMem) {
                [p, n] = wasm.allocCString(pMem);
              } else {
                return util.sqlite3_wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  'Invalid 3rd argument type for sqlite3_bind_blob().',
                );
              }
              return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
            } catch (e) {
              wasm.dealloc(p);
              return util.sqlite3_wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e,
              );
            }
          };
        }

        {
          capi.sqlite3_config = function (op, ...args) {
            if (arguments.length < 2) return capi.SQLITE_MISUSE;
            switch (op) {
              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
              case capi.SQLITE_CONFIG_MEMSTATUS:
              case capi.SQLITE_CONFIG_SMALL_MALLOC:
              case capi.SQLITE_CONFIG_SORTERREF_SIZE:
              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
              case capi.SQLITE_CONFIG_URI:
                return wasm.exports.sqlite3_wasm_config_i(op, args[0]);
              case capi.SQLITE_CONFIG_LOOKASIDE:
                return wasm.exports.sqlite3_wasm_config_ii(
                  op,
                  args[0],
                  args[1],
                );
              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                return wasm.exports.sqlite3_wasm_config_j(op, args[0]);
              case capi.SQLITE_CONFIG_GETMALLOC:
              case capi.SQLITE_CONFIG_GETMUTEX:
              case capi.SQLITE_CONFIG_GETPCACHE2:
              case capi.SQLITE_CONFIG_GETPCACHE:
              case capi.SQLITE_CONFIG_HEAP:
              case capi.SQLITE_CONFIG_LOG:
              case capi.SQLITE_CONFIG_MALLOC:
              case capi.SQLITE_CONFIG_MMAP_SIZE:
              case capi.SQLITE_CONFIG_MULTITHREAD:
              case capi.SQLITE_CONFIG_MUTEX:
              case capi.SQLITE_CONFIG_PAGECACHE:
              case capi.SQLITE_CONFIG_PCACHE2:
              case capi.SQLITE_CONFIG_PCACHE:
              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
              case capi.SQLITE_CONFIG_PMASZ:
              case capi.SQLITE_CONFIG_SERIALIZED:
              case capi.SQLITE_CONFIG_SINGLETHREAD:
              case capi.SQLITE_CONFIG_SQLLOG:
              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
              default:
                return capi.SQLITE_NOTFOUND;
            }
          };
        }

        {
          const __autoExtFptr = new Set();

          capi.sqlite3_auto_extension = function (fPtr) {
            if (fPtr instanceof Function) {
              fPtr = wasm.installFunction('i(ppp)', fPtr);
            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {
              return capi.SQLITE_MISUSE;
            }
            const rc = wasm.exports.sqlite3_auto_extension(fPtr);
            if (fPtr !== arguments[0]) {
              if (0 === rc) __autoExtFptr.add(fPtr);
              else wasm.uninstallFunction(fPtr);
            }
            return rc;
          };

          capi.sqlite3_cancel_auto_extension = function (fPtr) {
            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr)) return 0;
            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
          };

          capi.sqlite3_reset_auto_extension = function () {
            wasm.exports.sqlite3_reset_auto_extension();
            for (const fp of __autoExtFptr) wasm.uninstallFunction(fp);
            __autoExtFptr.clear();
          };
        }

        const pKvvfs = capi.sqlite3_vfs_find('kvvfs');
        if (pKvvfs) {
          if (util.isUIThread()) {
            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
              wasm.exports.sqlite3_wasm_kvvfs_methods(),
            );
            delete capi.sqlite3_kvvfs_methods;

            const kvvfsMakeKey = wasm.exports.sqlite3_wasm_kvvfsMakeKeyOnPstack,
              pstack = wasm.pstack;

            const kvvfsStorage = (zClass) =>
              115 === wasm.peek(zClass) ? sessionStorage : localStorage;

            const kvvfsImpls = {
              xRead: (zClass, zKey, zBuf, nBuf) => {
                const stack = pstack.pointer,
                  astack = wasm.scopedAllocPush();
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return -3;
                  const jKey = wasm.cstrToJs(zXKey);
                  const jV = kvvfsStorage(zClass).getItem(jKey);
                  if (!jV) return -1;
                  const nV = jV.length;
                  if (nBuf <= 0) return nV;
                  else if (1 === nBuf) {
                    wasm.poke(zBuf, 0);
                    return nV;
                  }
                  const zV = wasm.scopedAllocCString(jV);
                  if (nBuf > nV + 1) nBuf = nV + 1;
                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                  wasm.poke(zBuf + nBuf - 1, 0);
                  return nBuf - 1;
                } catch (e) {
                  console.error('kvstorageRead()', e);
                  return -2;
                } finally {
                  pstack.restore(stack);
                  wasm.scopedAllocPop(astack);
                }
              },
              xWrite: (zClass, zKey, zData) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return 1;
                  const jKey = wasm.cstrToJs(zXKey);
                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
                  return 0;
                } catch (e) {
                  console.error('kvstorageWrite()', e);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
              xDelete: (zClass, zKey) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return 1;
                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
                  return 0;
                } catch (e) {
                  console.error('kvstorageDelete()', e);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
            };
            for (const k of Object.keys(kvvfsImpls)) {
              kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm.installFunction(
                kvvfsMethods.memberSignature(k),
                kvvfsImpls[k],
              );
            }
          } else {
            capi.sqlite3_vfs_unregister(pKvvfs);
          }
        }

        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        sqlite3.version = {
          libVersion: '3.45.3',
          libVersionNumber: 3045003,
          sourceId:
            '2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355',
          downloadVersion: 3450300,
        };
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        const toss = (...args) => {
          throw new Error(args.join(' '));
        };
        const toss3 = (...args) => {
          throw new sqlite3.SQLite3Error(...args);
        };

        const capi = sqlite3.capi,
          wasm = sqlite3.wasm,
          util = sqlite3.util;

        const __ptrMap = new WeakMap();

        const __stmtMap = new WeakMap();

        const getOwnOption = (opts, p, dflt) => {
          const d = Object.getOwnPropertyDescriptor(opts, p);
          return d ? d.value : dflt;
        };

        const checkSqlite3Rc = function (dbPtr, sqliteResultCode) {
          if (sqliteResultCode) {
            if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;
            toss3(
              sqliteResultCode,
              'sqlite3 result code',
              sqliteResultCode + ':',
              dbPtr
                ? capi.sqlite3_errmsg(dbPtr)
                : capi.sqlite3_errstr(sqliteResultCode),
            );
          }
          return arguments[0];
        };

        const __dbTraceToConsole = wasm.installFunction(
          'i(ippp)',
          function (t, c, p, x) {
            if (capi.SQLITE_TRACE_STMT === t) {
              console.log(
                'SQL TRACE #' + ++this.counter + ' via sqlite3@' + c + ':',
                wasm.cstrToJs(x),
              );
            }
          }.bind({ counter: 0 }),
        );

        const __vfsPostOpenSql = Object.create(null);

        const dbCtorHelper = function ctor(...args) {
          if (!ctor._name2vfs) {
            ctor._name2vfs = Object.create(null);
            const isWorkerThread =
              'function' === typeof importScripts
                ? (n) =>
                    toss3(
                      'The VFS for',
                      n,
                      'is only available in the main window thread.',
                    )
                : false;
            ctor._name2vfs[':localStorage:'] = {
              vfs: 'kvvfs',
              filename: isWorkerThread || (() => 'local'),
            };
            ctor._name2vfs[':sessionStorage:'] = {
              vfs: 'kvvfs',
              filename: isWorkerThread || (() => 'session'),
            };
          }
          const opt = ctor.normalizeArgs(...args);
          let fn = opt.filename,
            vfsName = opt.vfs,
            flagsStr = opt.flags;
          if (
            ('string' !== typeof fn && 'number' !== typeof fn) ||
            'string' !== typeof flagsStr ||
            (vfsName &&
              'string' !== typeof vfsName &&
              'number' !== typeof vfsName)
          ) {
            sqlite3.config.error('Invalid DB ctor args', opt, arguments);
            toss3('Invalid arguments for DB constructor.');
          }
          let fnJs = 'number' === typeof fn ? wasm.cstrToJs(fn) : fn;
          const vfsCheck = ctor._name2vfs[fnJs];
          if (vfsCheck) {
            vfsName = vfsCheck.vfs;
            fn = fnJs = vfsCheck.filename(fnJs);
          }
          let pDb,
            oflags = 0;
          if (flagsStr.indexOf('c') >= 0) {
            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
          }
          if (flagsStr.indexOf('w') >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;
          if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;
          oflags |= capi.SQLITE_OPEN_EXRESCODE;
          const stack = wasm.pstack.pointer;
          try {
            const pPtr = wasm.pstack.allocPtr();
            let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
            pDb = wasm.peekPtr(pPtr);
            checkSqlite3Rc(pDb, rc);
            capi.sqlite3_extended_result_codes(pDb, 1);
            if (flagsStr.indexOf('t') >= 0) {
              capi.sqlite3_trace_v2(
                pDb,
                capi.SQLITE_TRACE_STMT,
                __dbTraceToConsole,
                pDb,
              );
            }
          } catch (e) {
            if (pDb) capi.sqlite3_close_v2(pDb);
            throw e;
          } finally {
            wasm.pstack.restore(stack);
          }
          this.filename = fnJs;
          __ptrMap.set(this, pDb);
          __stmtMap.set(this, Object.create(null));
          try {
            const pVfs = capi.sqlite3_js_db_vfs(pDb);
            if (!pVfs)
              toss3('Internal error: cannot get VFS for new db handle.');
            const postInitSql = __vfsPostOpenSql[pVfs];
            if (postInitSql instanceof Function) {
              postInitSql(this, sqlite3);
            } else if (postInitSql) {
              checkSqlite3Rc(pDb, capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0));
            }
          } catch (e) {
            this.close();
            throw e;
          }
        };

        dbCtorHelper.setVfsPostOpenSql = function (pVfs, sql) {
          __vfsPostOpenSql[pVfs] = sql;
        };

        dbCtorHelper.normalizeArgs = function (
          filename = ':memory:',
          flags = 'c',
          vfs = null,
        ) {
          const arg = {};
          if (
            1 === arguments.length &&
            arguments[0] &&
            'object' === typeof arguments[0]
          ) {
            Object.assign(arg, arguments[0]);
            if (undefined === arg.flags) arg.flags = 'c';
            if (undefined === arg.vfs) arg.vfs = null;
            if (undefined === arg.filename) arg.filename = ':memory:';
          } else {
            arg.filename = filename;
            arg.flags = flags;
            arg.vfs = vfs;
          }
          return arg;
        };

        const DB = function (...args) {
          dbCtorHelper.apply(this, args);
        };
        DB.dbCtorHelper = dbCtorHelper;

        const BindTypes = {
          null: 1,
          number: 2,
          string: 3,
          boolean: 4,
          blob: 5,
        };
        BindTypes['undefined'] == BindTypes.null;
        if (wasm.bigIntEnabled) {
          BindTypes.bigint = BindTypes.number;
        }

        const Stmt = function () {
          if (BindTypes !== arguments[2]) {
            toss3(
              capi.SQLITE_MISUSE,
              'Do not call the Stmt constructor directly. Use DB.prepare().',
            );
          }
          this.db = arguments[0];
          __ptrMap.set(this, arguments[1]);
          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
        };

        const affirmDbOpen = function (db) {
          if (!db.pointer) toss3('DB has been closed.');
          return db;
        };

        const affirmColIndex = function (stmt, ndx) {
          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
            toss3('Column index', ndx, 'is out of range.');
          }
          return stmt;
        };

        const parseExecArgs = function (db, args) {
          const out = Object.create(null);
          out.opt = Object.create(null);
          switch (args.length) {
            case 1:
              if (
                'string' === typeof args[0] ||
                util.isSQLableTypedArray(args[0])
              ) {
                out.sql = args[0];
              } else if (Array.isArray(args[0])) {
                out.sql = args[0];
              } else if (args[0] && 'object' === typeof args[0]) {
                out.opt = args[0];
                out.sql = out.opt.sql;
              }
              break;
            case 2:
              out.sql = args[0];
              out.opt = args[1];
              break;
            default:
              toss3('Invalid argument count for exec().');
          }
          out.sql = util.flexibleString(out.sql);
          if ('string' !== typeof out.sql) {
            toss3('Missing SQL argument or unsupported SQL value type.');
          }
          const opt = out.opt;
          switch (opt.returnValue) {
            case 'resultRows':
              if (!opt.resultRows) opt.resultRows = [];
              out.returnVal = () => opt.resultRows;
              break;
            case 'saveSql':
              if (!opt.saveSql) opt.saveSql = [];
              out.returnVal = () => opt.saveSql;
              break;
            case undefined:
            case 'this':
              out.returnVal = () => db;
              break;
            default:
              toss3('Invalid returnValue value:', opt.returnValue);
          }
          if (!opt.callback && !opt.returnValue && undefined !== opt.rowMode) {
            if (!opt.resultRows) opt.resultRows = [];
            out.returnVal = () => opt.resultRows;
          }
          if (opt.callback || opt.resultRows) {
            switch (undefined === opt.rowMode ? 'array' : opt.rowMode) {
              case 'object':
                out.cbArg = (stmt) => stmt.get(Object.create(null));
                break;
              case 'array':
                out.cbArg = (stmt) => stmt.get([]);
                break;
              case 'stmt':
                if (Array.isArray(opt.resultRows)) {
                  toss3(
                    'exec(): invalid rowMode for a resultRows array: must',
                    "be one of 'array', 'object',",
                    'a result column number, or column name reference.',
                  );
                }
                out.cbArg = (stmt) => stmt;
                break;
              default:
                if (util.isInt32(opt.rowMode)) {
                  out.cbArg = (stmt) => stmt.get(opt.rowMode);
                  break;
                } else if (
                  'string' === typeof opt.rowMode &&
                  opt.rowMode.length > 1 &&
                  '$' === opt.rowMode[0]
                ) {
                  const $colName = opt.rowMode.substr(1);
                  out.cbArg = (stmt) => {
                    const rc = stmt.get(Object.create(null))[$colName];
                    return undefined === rc
                      ? toss3(
                          capi.SQLITE_NOTFOUND,
                          'exec(): unknown result column:',
                          $colName,
                        )
                      : rc;
                  };
                  break;
                }
                toss3('Invalid rowMode:', opt.rowMode);
            }
          }
          return out;
        };

        const __selectFirstRow = (db, sql, bind, ...getArgs) => {
          const stmt = db.prepare(sql);
          try {
            const rc = stmt.bind(bind).step()
              ? stmt.get(...getArgs)
              : undefined;
            stmt.reset();
            return rc;
          } finally {
            stmt.finalize();
          }
        };

        const __selectAll = (db, sql, bind, rowMode) =>
          db.exec({
            sql,
            bind,
            rowMode,
            returnValue: 'resultRows',
          });

        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);

        DB.prototype = {
          isOpen: function () {
            return !!this.pointer;
          },

          affirmOpen: function () {
            return affirmDbOpen(this);
          },

          close: function () {
            if (this.pointer) {
              if (this.onclose && this.onclose.before instanceof Function) {
                try {
                  this.onclose.before(this);
                } catch (e) {}
              }
              const pDb = this.pointer;
              Object.keys(__stmtMap.get(this)).forEach((k, s) => {
                if (s && s.pointer) {
                  try {
                    s.finalize();
                  } catch (e) {}
                }
              });
              __ptrMap.delete(this);
              __stmtMap.delete(this);
              capi.sqlite3_close_v2(pDb);
              if (this.onclose && this.onclose.after instanceof Function) {
                try {
                  this.onclose.after(this);
                } catch (e) {}
              }
              delete this.filename;
            }
          },

          changes: function (total = false, sixtyFour = false) {
            const p = affirmDbOpen(this).pointer;
            if (total) {
              return sixtyFour
                ? capi.sqlite3_total_changes64(p)
                : capi.sqlite3_total_changes(p);
            } else {
              return sixtyFour
                ? capi.sqlite3_changes64(p)
                : capi.sqlite3_changes(p);
            }
          },

          dbFilename: function (dbName = 'main') {
            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
          },

          dbName: function (dbNumber = 0) {
            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
          },

          dbVfsName: function (dbName = 0) {
            let rc;
            const pVfs = capi.sqlite3_js_db_vfs(
              affirmDbOpen(this).pointer,
              dbName,
            );
            if (pVfs) {
              const v = new capi.sqlite3_vfs(pVfs);
              try {
                rc = wasm.cstrToJs(v.$zName);
              } finally {
                v.dispose();
              }
            }
            return rc;
          },

          prepare: function (sql) {
            affirmDbOpen(this);
            const stack = wasm.pstack.pointer;
            let ppStmt, pStmt;
            try {
              ppStmt = wasm.pstack.alloc(8);
              DB.checkRc(
                this,
                capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null),
              );
              pStmt = wasm.peekPtr(ppStmt);
            } finally {
              wasm.pstack.restore(stack);
            }
            if (!pStmt) toss3('Cannot prepare empty SQL.');
            const stmt = new Stmt(this, pStmt, BindTypes);
            __stmtMap.get(this)[pStmt] = stmt;
            return stmt;
          },

          exec: function () {
            affirmDbOpen(this);
            const arg = parseExecArgs(this, arguments);
            if (!arg.sql) {
              return toss3('exec() requires an SQL string.');
            }
            const opt = arg.opt;
            const callback = opt.callback;
            const resultRows = Array.isArray(opt.resultRows)
              ? opt.resultRows
              : undefined;
            let stmt;
            let bind = opt.bind;
            let evalFirstResult = !!(
              arg.cbArg ||
              opt.columnNames ||
              resultRows
            );
            const stack = wasm.scopedAllocPush();
            const saveSql = Array.isArray(opt.saveSql)
              ? opt.saveSql
              : undefined;
            try {
              const isTA = util.isSQLableTypedArray(arg.sql);
              let sqlByteLen = isTA
                ? arg.sql.byteLength
                : wasm.jstrlen(arg.sql);
              const ppStmt = wasm.scopedAlloc(
                2 * wasm.ptrSizeof + (sqlByteLen + 1),
              );
              const pzTail = ppStmt + wasm.ptrSizeof;
              let pSql = pzTail + wasm.ptrSizeof;
              const pSqlEnd = pSql + sqlByteLen;
              if (isTA) wasm.heap8().set(arg.sql, pSql);
              else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
              wasm.poke(pSql + sqlByteLen, 0);
              while (pSql && wasm.peek(pSql, 'i8')) {
                wasm.pokePtr([ppStmt, pzTail], 0);
                DB.checkRc(
                  this,
                  capi.sqlite3_prepare_v3(
                    this.pointer,
                    pSql,
                    sqlByteLen,
                    0,
                    ppStmt,
                    pzTail,
                  ),
                );
                const pStmt = wasm.peekPtr(ppStmt);
                pSql = wasm.peekPtr(pzTail);
                sqlByteLen = pSqlEnd - pSql;
                if (!pStmt) continue;
                if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
                stmt = new Stmt(this, pStmt, BindTypes);
                if (bind && stmt.parameterCount) {
                  stmt.bind(bind);
                  bind = null;
                }
                if (evalFirstResult && stmt.columnCount) {
                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                  evalFirstResult = false;
                  if (arg.cbArg || resultRows) {
                    for (; stmt.step(); stmt._lockedByExec = false) {
                      if (0 === gotColNames++)
                        stmt.getColumnNames(opt.columnNames);
                      stmt._lockedByExec = true;
                      const row = arg.cbArg(stmt);
                      if (resultRows) resultRows.push(row);
                      if (callback && false === callback.call(opt, row, stmt)) {
                        break;
                      }
                    }
                    stmt._lockedByExec = false;
                  }
                  if (0 === gotColNames) {
                    stmt.getColumnNames(opt.columnNames);
                  }
                } else {
                  stmt.step();
                }
                stmt.reset().finalize();
                stmt = null;
              }
            } finally {
              wasm.scopedAllocPop(stack);
              if (stmt) {
                delete stmt._lockedByExec;
                stmt.finalize();
              }
            }
            return arg.returnVal();
          },

          createFunction: function f(name, xFunc, opt) {
            const isFunc = (f) => f instanceof Function;
            switch (arguments.length) {
              case 1:
                opt = name;
                name = opt.name;
                xFunc = opt.xFunc || 0;
                break;
              case 2:
                if (!isFunc(xFunc)) {
                  opt = xFunc;
                  xFunc = opt.xFunc || 0;
                }
                break;
              case 3:
                break;
              default:
                break;
            }
            if (!opt) opt = {};
            if ('string' !== typeof name) {
              toss3('Invalid arguments: missing function name.');
            }
            let xStep = opt.xStep || 0;
            let xFinal = opt.xFinal || 0;
            const xValue = opt.xValue || 0;
            const xInverse = opt.xInverse || 0;
            let isWindow = undefined;
            if (isFunc(xFunc)) {
              isWindow = false;
              if (isFunc(xStep) || isFunc(xFinal)) {
                toss3('Ambiguous arguments: scalar or aggregate?');
              }
              xStep = xFinal = null;
            } else if (isFunc(xStep)) {
              if (!isFunc(xFinal)) {
                toss3('Missing xFinal() callback for aggregate or window UDF.');
              }
              xFunc = null;
            } else if (isFunc(xFinal)) {
              toss3('Missing xStep() callback for aggregate or window UDF.');
            } else {
              toss3('Missing function-type properties.');
            }
            if (false === isWindow) {
              if (isFunc(xValue) || isFunc(xInverse)) {
                toss3(
                  'xValue and xInverse are not permitted for non-window UDFs.',
                );
              }
            } else if (isFunc(xValue)) {
              if (!isFunc(xInverse)) {
                toss3('xInverse must be provided if xValue is.');
              }
              isWindow = true;
            } else if (isFunc(xInverse)) {
              toss3('xValue must be provided if xInverse is.');
            }
            const pApp = opt.pApp;
            if (
              undefined !== pApp &&
              null !== pApp &&
              ('number' !== typeof pApp || !util.isInt32(pApp))
            ) {
              toss3(
                'Invalid value for pApp property. Must be a legal WASM pointer value.',
              );
            }
            const xDestroy = opt.xDestroy || 0;
            if (xDestroy && !isFunc(xDestroy)) {
              toss3('xDestroy property must be a function.');
            }
            let fFlags = 0;
            if (getOwnOption(opt, 'deterministic'))
              fFlags |= capi.SQLITE_DETERMINISTIC;
            if (getOwnOption(opt, 'directOnly'))
              fFlags |= capi.SQLITE_DIRECTONLY;
            if (getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;
            name = name.toLowerCase();
            const xArity = xFunc || xStep;
            const arity = getOwnOption(opt, 'arity');
            const arityArg =
              'number' === typeof arity
                ? arity
                : xArity.length
                  ? xArity.length - 1
                  : 0;
            let rc;
            if (isWindow) {
              rc = capi.sqlite3_create_window_function(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy,
              );
            } else {
              rc = capi.sqlite3_create_function_v2(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xFunc,
                xStep,
                xFinal,
                xDestroy,
              );
            }
            DB.checkRc(this, rc);
            return this;
          },

          selectValue: function (sql, bind, asType) {
            return __selectFirstRow(this, sql, bind, 0, asType);
          },

          selectValues: function (sql, bind, asType) {
            const stmt = this.prepare(sql),
              rc = [];
            try {
              stmt.bind(bind);
              while (stmt.step()) rc.push(stmt.get(0, asType));
              stmt.reset();
            } finally {
              stmt.finalize();
            }
            return rc;
          },

          selectArray: function (sql, bind) {
            return __selectFirstRow(this, sql, bind, []);
          },

          selectObject: function (sql, bind) {
            return __selectFirstRow(this, sql, bind, {});
          },

          selectArrays: function (sql, bind) {
            return __selectAll(this, sql, bind, 'array');
          },

          selectObjects: function (sql, bind) {
            return __selectAll(this, sql, bind, 'object');
          },

          openStatementCount: function () {
            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
          },

          transaction: function (callback) {
            let opener = 'BEGIN';
            if (arguments.length > 1) {
              if (/[^a-zA-Z]/.test(arguments[0])) {
                toss3(
                  capi.SQLITE_MISUSE,
                  'Invalid argument for BEGIN qualifier.',
                );
              }
              opener += ' ' + arguments[0];
              callback = arguments[1];
            }
            affirmDbOpen(this).exec(opener);
            try {
              const rc = callback(this);
              this.exec('COMMIT');
              return rc;
            } catch (e) {
              this.exec('ROLLBACK');
              throw e;
            }
          },

          savepoint: function (callback) {
            affirmDbOpen(this).exec('SAVEPOINT oo1');
            try {
              const rc = callback(this);
              this.exec('RELEASE oo1');
              return rc;
            } catch (e) {
              this.exec('ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1');
              throw e;
            }
          },

          checkRc: function (resultCode) {
            return checkSqlite3Rc(this, resultCode);
          },
        };

        const affirmStmtOpen = function (stmt) {
          if (!stmt.pointer) toss3('Stmt has been closed.');
          return stmt;
        };

        const isSupportedBindType = function (v) {
          let t = BindTypes[null === v || undefined === v ? 'null' : typeof v];
          switch (t) {
            case BindTypes.boolean:
            case BindTypes.null:
            case BindTypes.number:
            case BindTypes.string:
              return t;
            case BindTypes.bigint:
              if (wasm.bigIntEnabled) return t;

            default:
              return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;
          }
        };

        const affirmSupportedBindType = function (v) {
          return (
            isSupportedBindType(v) ||
            toss3('Unsupported bind() argument type:', typeof v)
          );
        };

        const affirmParamIndex = function (stmt, key) {
          const n =
            'number' === typeof key
              ? key
              : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
          if (0 === n || !util.isInt32(n)) {
            toss3('Invalid bind() parameter name: ' + key);
          } else if (n < 1 || n > stmt.parameterCount)
            toss3('Bind index', key, 'is out of range.');
          return n;
        };

        const affirmNotLockedByExec = function (stmt, currentOpName) {
          if (stmt._lockedByExec) {
            toss3(
              'Operation is illegal when statement is locked:',
              currentOpName,
            );
          }
          return stmt;
        };

        const bindOne = function f(stmt, ndx, bindType, val) {
          affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');
          if (!f._) {
            f._tooBigInt = (v) =>
              toss3(
                'BigInt value is too big to store without precision loss:',
                v,
              );
            f._ = {
              string: function (stmt, ndx, val, asBlob) {
                const [pStr, n] = wasm.allocCString(val, true);
                const f = asBlob
                  ? capi.sqlite3_bind_blob
                  : capi.sqlite3_bind_text;
                return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);
              },
            };
          }
          affirmSupportedBindType(val);
          ndx = affirmParamIndex(stmt, ndx);
          let rc = 0;
          switch (
            null === val || undefined === val ? BindTypes.null : bindType
          ) {
            case BindTypes.null:
              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
              break;
            case BindTypes.string:
              rc = f._.string(stmt, ndx, val, false);
              break;
            case BindTypes.number: {
              let m;
              if (util.isInt32(val)) m = capi.sqlite3_bind_int;
              else if ('bigint' === typeof val) {
                if (!util.bigIntFits64(val)) {
                  f._tooBigInt(val);
                } else if (wasm.bigIntEnabled) {
                  m = capi.sqlite3_bind_int64;
                } else if (util.bigIntFitsDouble(val)) {
                  val = Number(val);
                  m = capi.sqlite3_bind_double;
                } else {
                  f._tooBigInt(val);
                }
              } else {
                val = Number(val);
                if (wasm.bigIntEnabled && Number.isInteger(val)) {
                  m = capi.sqlite3_bind_int64;
                } else {
                  m = capi.sqlite3_bind_double;
                }
              }
              rc = m(stmt.pointer, ndx, val);
              break;
            }
            case BindTypes.boolean:
              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
              break;
            case BindTypes.blob: {
              if ('string' === typeof val) {
                rc = f._.string(stmt, ndx, val, true);
                break;
              } else if (val instanceof ArrayBuffer) {
                val = new Uint8Array(val);
              } else if (!util.isBindableTypedArray(val)) {
                toss3(
                  'Binding a value as a blob requires',
                  'that it be a string, Uint8Array, Int8Array, or ArrayBuffer.',
                );
              }
              const pBlob = wasm.alloc(val.byteLength || 1);
              wasm.heap8().set(val.byteLength ? val : [0], pBlob);
              rc = capi.sqlite3_bind_blob(
                stmt.pointer,
                ndx,
                pBlob,
                val.byteLength,
                capi.SQLITE_WASM_DEALLOC,
              );
              break;
            }
            default:
              sqlite3.config.warn('Unsupported bind() argument type:', val);
              toss3('Unsupported bind() argument type: ' + typeof val);
          }
          if (rc) DB.checkRc(stmt.db.pointer, rc);
          stmt._mayGet = false;
          return stmt;
        };

        Stmt.prototype = {
          finalize: function () {
            if (this.pointer) {
              affirmNotLockedByExec(this, 'finalize()');
              const rc = capi.sqlite3_finalize(this.pointer);
              delete __stmtMap.get(this.db)[this.pointer];
              __ptrMap.delete(this);
              delete this._mayGet;
              delete this.parameterCount;
              delete this._lockedByExec;
              delete this.db;
              return rc;
            }
          },

          clearBindings: function () {
            affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()');
            capi.sqlite3_clear_bindings(this.pointer);
            this._mayGet = false;
            return this;
          },

          reset: function (alsoClearBinds) {
            affirmNotLockedByExec(this, 'reset()');
            if (alsoClearBinds) this.clearBindings();
            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
            this._mayGet = false;
            checkSqlite3Rc(this.db, rc);
            return this;
          },

          bind: function () {
            affirmStmtOpen(this);
            let ndx, arg;
            switch (arguments.length) {
              case 1:
                ndx = 1;
                arg = arguments[0];
                break;
              case 2:
                ndx = arguments[0];
                arg = arguments[1];
                break;
              default:
                toss3('Invalid bind() arguments.');
            }
            if (undefined === arg) {
              return this;
            } else if (!this.parameterCount) {
              toss3('This statement has no bindable parameters.');
            }
            this._mayGet = false;
            if (null === arg) {
              return bindOne(this, ndx, BindTypes.null, arg);
            } else if (Array.isArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  'When binding an array, an index argument is not permitted.',
                );
              }
              arg.forEach((v, i) =>
                bindOne(this, i + 1, affirmSupportedBindType(v), v),
              );
              return this;
            } else if (arg instanceof ArrayBuffer) {
              arg = new Uint8Array(arg);
            }
            if ('object' === typeof arg && !util.isBindableTypedArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  'When binding an object, an index argument is not permitted.',
                );
              }
              Object.keys(arg).forEach((k) =>
                bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k]),
              );
              return this;
            } else {
              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
            }
            toss3('Should not reach this point.');
          },

          bindAsBlob: function (ndx, arg) {
            affirmStmtOpen(this);
            if (1 === arguments.length) {
              arg = ndx;
              ndx = 1;
            }
            const t = affirmSupportedBindType(arg);
            if (
              BindTypes.string !== t &&
              BindTypes.blob !== t &&
              BindTypes.null !== t
            ) {
              toss3('Invalid value type for bindAsBlob()');
            }
            return bindOne(this, ndx, BindTypes.blob, arg);
          },

          step: function () {
            affirmNotLockedByExec(this, 'step()');
            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
            switch (rc) {
              case capi.SQLITE_DONE:
                return (this._mayGet = false);
              case capi.SQLITE_ROW:
                return (this._mayGet = true);
              default:
                this._mayGet = false;
                sqlite3.config.warn(
                  'sqlite3_step() rc=',
                  rc,
                  capi.sqlite3_js_rc_str(rc),
                  'SQL =',
                  capi.sqlite3_sql(this.pointer),
                );
                DB.checkRc(this.db.pointer, rc);
            }
          },

          stepReset: function () {
            this.step();
            return this.reset();
          },

          stepFinalize: function () {
            try {
              const rc = this.step();
              this.reset();
              return rc;
            } finally {
              try {
                this.finalize();
              } catch (e) {}
            }
          },

          get: function (ndx, asType) {
            if (!affirmStmtOpen(this)._mayGet) {
              toss3('Stmt.step() has not (recently) returned true.');
            }
            if (Array.isArray(ndx)) {
              let i = 0;
              const n = this.columnCount;
              while (i < n) {
                ndx[i] = this.get(i++);
              }
              return ndx;
            } else if (ndx && 'object' === typeof ndx) {
              let i = 0;
              const n = this.columnCount;
              while (i < n) {
                ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);
              }
              return ndx;
            }
            affirmColIndex(this, ndx);
            switch (
              undefined === asType
                ? capi.sqlite3_column_type(this.pointer, ndx)
                : asType
            ) {
              case capi.SQLITE_NULL:
                return null;
              case capi.SQLITE_INTEGER: {
                if (wasm.bigIntEnabled) {
                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                  if (
                    rc >= Number.MIN_SAFE_INTEGER &&
                    rc <= Number.MAX_SAFE_INTEGER
                  ) {
                    return Number(rc).valueOf();
                  }
                  return rc;
                } else {
                  const rc = capi.sqlite3_column_double(this.pointer, ndx);
                  if (
                    rc > Number.MAX_SAFE_INTEGER ||
                    rc < Number.MIN_SAFE_INTEGER
                  ) {
                    toss3(
                      'Integer is out of range for JS integer range: ' + rc,
                    );
                  }

                  return util.isInt32(rc) ? rc | 0 : rc;
                }
              }
              case capi.SQLITE_FLOAT:
                return capi.sqlite3_column_double(this.pointer, ndx);
              case capi.SQLITE_TEXT:
                return capi.sqlite3_column_text(this.pointer, ndx);
              case capi.SQLITE_BLOB: {
                const n = capi.sqlite3_column_bytes(this.pointer, ndx),
                  ptr = capi.sqlite3_column_blob(this.pointer, ndx),
                  rc = new Uint8Array(n);

                if (n) rc.set(wasm.heap8u().slice(ptr, ptr + n), 0);

                if (n && this.db._blobXfer instanceof Array) {
                  this.db._blobXfer.push(rc.buffer);
                }
                return rc;
              }
              default:
                toss3(
                  "Don't know how to translate",
                  'type of result column #' + ndx + '.',
                );
            }
            toss3('Not reached.');
          },

          getInt: function (ndx) {
            return this.get(ndx, capi.SQLITE_INTEGER);
          },

          getFloat: function (ndx) {
            return this.get(ndx, capi.SQLITE_FLOAT);
          },

          getString: function (ndx) {
            return this.get(ndx, capi.SQLITE_TEXT);
          },

          getBlob: function (ndx) {
            return this.get(ndx, capi.SQLITE_BLOB);
          },

          getJSON: function (ndx) {
            const s = this.get(ndx, capi.SQLITE_STRING);
            return null === s ? s : JSON.parse(s);
          },

          getColumnName: function (ndx) {
            return capi.sqlite3_column_name(
              affirmColIndex(affirmStmtOpen(this), ndx).pointer,
              ndx,
            );
          },

          getColumnNames: function (tgt = []) {
            affirmColIndex(affirmStmtOpen(this), 0);
            const n = this.columnCount;
            for (let i = 0; i < n; ++i) {
              tgt.push(capi.sqlite3_column_name(this.pointer, i));
            }
            return tgt;
          },

          getParamIndex: function (name) {
            return affirmStmtOpen(this).parameterCount
              ? capi.sqlite3_bind_parameter_index(this.pointer, name)
              : undefined;
          },
        };

        {
          const prop = {
            enumerable: true,
            get: function () {
              return __ptrMap.get(this);
            },
            set: () => toss3('The pointer property is read-only.'),
          };
          Object.defineProperty(Stmt.prototype, 'pointer', prop);
          Object.defineProperty(DB.prototype, 'pointer', prop);
        }

        Object.defineProperty(Stmt.prototype, 'columnCount', {
          enumerable: false,
          get: function () {
            return capi.sqlite3_column_count(this.pointer);
          },
          set: () => toss3('The columnCount property is read-only.'),
        });

        sqlite3.oo1 = {
          DB,
          Stmt,
        };

        if (util.isUIThread()) {
          sqlite3.oo1.JsStorageDb = function (storageName = 'session') {
            if ('session' !== storageName && 'local' !== storageName) {
              toss3("JsStorageDb db name must be one of 'session' or 'local'.");
            }
            dbCtorHelper.call(this, {
              filename: storageName,
              flags: 'c',
              vfs: 'kvvfs',
            });
          };
          const jdb = sqlite3.oo1.JsStorageDb;
          jdb.prototype = Object.create(DB.prototype);

          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;

          jdb.prototype.clearStorage = function () {
            return jdb.clearStorage(affirmDbOpen(this).filename);
          };

          jdb.storageSize = capi.sqlite3_js_kvvfs_size;

          jdb.prototype.storageSize = function () {
            return jdb.storageSize(affirmDbOpen(this).filename);
          };
        }
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        sqlite3.initWorker1API = function () {
          'use strict';
          const toss = (...args) => {
            throw new Error(args.join(' '));
          };
          if (!(globalThis.WorkerGlobalScope instanceof Function)) {
            toss('initWorker1API() must be run from a Worker thread.');
          }
          const sqlite3 = this.sqlite3 || toss('Missing this.sqlite3 object.');
          const DB = sqlite3.oo1.DB;

          const getDbId = function (db) {
            let id = wState.idMap.get(db);
            if (id) return id;
            id = 'db#' + ++wState.idSeq + '@' + db.pointer;

            wState.idMap.set(db, id);
            return id;
          };

          const wState = {
            dbList: [],

            idSeq: 0,

            idMap: new WeakMap(),

            xfer: [],
            open: function (opt) {
              const db = new DB(opt);
              this.dbs[getDbId(db)] = db;
              if (this.dbList.indexOf(db) < 0) this.dbList.push(db);
              return db;
            },
            close: function (db, alsoUnlink) {
              if (db) {
                delete this.dbs[getDbId(db)];
                const filename = db.filename;
                const pVfs = sqlite3.wasm.sqlite3_wasm_db_vfs(db.pointer, 0);
                db.close();
                const ddNdx = this.dbList.indexOf(db);
                if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);
                if (alsoUnlink && filename && pVfs) {
                  sqlite3.wasm.sqlite3_wasm_vfs_unlink(pVfs, filename);
                }
              }
            },

            post: function (msg, xferList) {
              if (xferList && xferList.length) {
                globalThis.postMessage(msg, Array.from(xferList));
                xferList.length = 0;
              } else {
                globalThis.postMessage(msg);
              }
            },

            dbs: Object.create(null),

            getDb: function (id, require = true) {
              return (
                this.dbs[id] ||
                (require ? toss('Unknown (or closed) DB ID:', id) : undefined)
              );
            },
          };

          const affirmDbOpen = function (db = wState.dbList[0]) {
            return db && db.pointer ? db : toss('DB is not opened.');
          };

          const getMsgDb = function (msgData, affirmExists = true) {
            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
            return affirmExists ? affirmDbOpen(db) : db;
          };

          const getDefaultDbId = function () {
            return wState.dbList[0] && getDbId(wState.dbList[0]);
          };

          const guessVfs = function (filename) {
            const m = /^file:.+(vfs=(\w+))/.exec(filename);
            return sqlite3.capi.sqlite3_vfs_find(m ? m[2] : 0);
          };

          const isSpecialDbFilename = (n) => {
            return '' === n || ':' === n[0];
          };

          const wMsgHandler = {
            open: function (ev) {
              const oargs = Object.create(null),
                args = ev.args || Object.create(null);
              if (args.simulateError) {
                toss('Throwing because of simulateError flag.');
              }
              const rc = Object.create(null);
              let byteArray, pVfs;
              oargs.vfs = args.vfs;
              if (isSpecialDbFilename(args.filename)) {
                oargs.filename = args.filename || '';
              } else {
                oargs.filename = args.filename;
                byteArray = args.byteArray;
                if (byteArray) pVfs = guessVfs(args.filename);
              }
              if (pVfs) {
                let pMem;
                try {
                  pMem = sqlite3.wasm.allocFromTypedArray(byteArray);
                  const rc = sqlite3.wasm.sqlite3_wasm_vfs_create_file(
                    pVfs,
                    oargs.filename,
                    pMem,
                    byteArray.byteLength,
                  );
                  if (rc) sqlite3.SQLite3Error.toss(rc);
                } catch (e) {
                  throw new sqlite3.SQLite3Error(
                    e.name + ' creating ' + args.filename + ': ' + e.message,
                    {
                      cause: e,
                    },
                  );
                } finally {
                  if (pMem) sqlite3.wasm.dealloc(pMem);
                }
              }
              const db = wState.open(oargs);
              rc.filename = db.filename;
              rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(
                db.pointer,
                'opfs',
              );
              rc.dbId = getDbId(db);
              rc.vfs = db.dbVfsName();
              return rc;
            },

            close: function (ev) {
              const db = getMsgDb(ev, false);
              const response = {
                filename: db && db.filename,
              };
              if (db) {
                const doUnlink =
                  ev.args && 'object' === typeof ev.args
                    ? !!ev.args.unlink
                    : false;
                wState.close(db, doUnlink);
              }
              return response;
            },

            exec: function (ev) {
              const rc =
                'string' === typeof ev.args
                  ? { sql: ev.args }
                  : ev.args || Object.create(null);
              if ('stmt' === rc.rowMode) {
                toss(
                  "Invalid rowMode for 'exec': stmt mode",
                  'does not work in the Worker API.',
                );
              } else if (!rc.sql) {
                toss("'exec' requires input SQL.");
              }
              const db = getMsgDb(ev);
              if (rc.callback || Array.isArray(rc.resultRows)) {
                db._blobXfer = wState.xfer;
              }
              const theCallback = rc.callback;
              let rowNumber = 0;
              const hadColNames = !!rc.columnNames;
              if ('string' === typeof theCallback) {
                if (!hadColNames) rc.columnNames = [];

                rc.callback = function (row, stmt) {
                  wState.post(
                    {
                      type: theCallback,
                      columnNames: rc.columnNames,
                      rowNumber: ++rowNumber,
                      row: row,
                    },
                    wState.xfer,
                  );
                };
              }
              try {
                const changeCount = !!rc.countChanges
                  ? db.changes(true, 64 === rc.countChanges)
                  : undefined;
                db.exec(rc);
                if (undefined !== changeCount) {
                  rc.changeCount =
                    db.changes(true, 64 === rc.countChanges) - changeCount;
                }
                if (rc.callback instanceof Function) {
                  rc.callback = theCallback;

                  wState.post({
                    type: theCallback,
                    columnNames: rc.columnNames,
                    rowNumber: null,
                    row: undefined,
                  });
                }
              } finally {
                delete db._blobXfer;
                if (rc.callback) rc.callback = theCallback;
              }
              return rc;
            },

            'config-get': function () {
              const rc = Object.create(null),
                src = sqlite3.config;
              ['bigIntEnabled'].forEach(function (k) {
                if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
              });
              rc.version = sqlite3.version;
              rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();
              rc.opfsEnabled = !!sqlite3.opfs;
              return rc;
            },

            export: function (ev) {
              const db = getMsgDb(ev);
              const response = {
                byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),
                filename: db.filename,
                mimetype: 'application/x-sqlite3',
              };
              wState.xfer.push(response.byteArray.buffer);
              return response;
            },

            toss: function (ev) {
              toss('Testing worker exception');
            },

            'opfs-tree': async function (ev) {
              if (!sqlite3.opfs) toss('OPFS support is unavailable.');
              const response = await sqlite3.opfs.treeList();
              return response;
            },
          };

          globalThis.onmessage = async function (ev) {
            ev = ev.data;
            let result,
              dbId = ev.dbId,
              evType = ev.type;
            const arrivalTime = performance.now();
            try {
              if (
                wMsgHandler.hasOwnProperty(evType) &&
                wMsgHandler[evType] instanceof Function
              ) {
                result = await wMsgHandler[evType](ev);
              } else {
                toss('Unknown db worker message type:', ev.type);
              }
            } catch (err) {
              evType = 'error';
              result = {
                operation: ev.type,
                message: err.message,
                errorClass: err.name,
                input: ev,
              };
              if (err.stack) {
                result.stack =
                  'string' === typeof err.stack
                    ? err.stack.split(/\n\s*/)
                    : err.stack;
              }
              if (false)
                {}
            }
            if (!dbId) {
              dbId = result.dbId || getDefaultDbId();
            }

            wState.post(
              {
                type: evType,
                dbId: dbId,
                messageId: ev.messageId,
                workerReceivedTime: arrivalTime,
                workerRespondTime: performance.now(),
                departureTime: ev.departureTime,

                result: result,
              },
              wState.xfer,
            );
          };
          globalThis.postMessage({
            type: 'sqlite3-api',
            result: 'worker1-ready',
          });
        }.bind({ sqlite3 });
      });

      ('use strict');
      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        const wasm = sqlite3.wasm,
          capi = sqlite3.capi,
          toss = sqlite3.util.toss3;
        const vfs = Object.create(null),
          vtab = Object.create(null);

        const StructBinder = sqlite3.StructBinder;
        sqlite3.vfs = vfs;
        sqlite3.vtab = vtab;

        const sii = capi.sqlite3_index_info;

        sii.prototype.nthConstraint = function (n, asPtr = false) {
          if (n < 0 || n >= this.$nConstraint) return false;
          const ptr =
            this.$aConstraint +
            sii.sqlite3_index_constraint.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
        };

        sii.prototype.nthConstraintUsage = function (n, asPtr = false) {
          if (n < 0 || n >= this.$nConstraint) return false;
          const ptr =
            this.$aConstraintUsage +
            sii.sqlite3_index_constraint_usage.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
        };

        sii.prototype.nthOrderBy = function (n, asPtr = false) {
          if (n < 0 || n >= this.$nOrderBy) return false;
          const ptr =
            this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
        };

        const installMethod = function callee(
          tgt,
          name,
          func,
          applyArgcCheck = callee.installMethodArgcCheck,
        ) {
          if (!(tgt instanceof StructBinder.StructType)) {
            toss('Usage error: target object is-not-a StructType.');
          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {
            toss('Usage errror: expecting a Function or WASM pointer to one.');
          }
          if (1 === arguments.length) {
            return (n, f) => callee(tgt, n, f, applyArgcCheck);
          }
          if (!callee.argcProxy) {
            callee.argcProxy = function (tgt, funcName, func, sig) {
              return function (...args) {
                if (func.length !== arguments.length) {
                  toss(
                    'Argument mismatch for',
                    tgt.structInfo.name +
                      '::' +
                      funcName +
                      ': Native signature is:',
                    sig,
                  );
                }
                return func.apply(this, args);
              };
            };

            callee.removeFuncList = function () {
              if (this.ondispose.__removeFuncList) {
                this.ondispose.__removeFuncList.forEach((v, ndx) => {
                  if ('number' === typeof v) {
                    try {
                      wasm.uninstallFunction(v);
                    } catch (e) {}
                  }
                });
                delete this.ondispose.__removeFuncList;
              }
            };
          }
          const sigN = tgt.memberSignature(name);
          if (sigN.length < 2) {
            toss(
              'Member',
              name,
              'does not have a function pointer signature:',
              sigN,
            );
          }
          const memKey = tgt.memberKey(name);
          const fProxy =
            applyArgcCheck && !wasm.isPtr(func)
              ? callee.argcProxy(tgt, memKey, func, sigN)
              : func;
          if (wasm.isPtr(fProxy)) {
            if (fProxy && !wasm.functionEntry(fProxy)) {
              toss('Pointer', fProxy, 'is not a WASM function table entry.');
            }
            tgt[memKey] = fProxy;
          } else {
            const pFunc = wasm.installFunction(
              fProxy,
              tgt.memberSignature(name, true),
            );
            tgt[memKey] = pFunc;
            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
              tgt.addOnDispose(
                'ondispose.__removeFuncList handler',
                callee.removeFuncList,
              );
              tgt.ondispose.__removeFuncList = [];
            }
            tgt.ondispose.__removeFuncList.push(memKey, pFunc);
          }
          return (n, f) => callee(tgt, n, f, applyArgcCheck);
        };
        installMethod.installMethodArgcCheck = false;

        const installMethods = function (
          structInstance,
          methods,
          applyArgcCheck = installMethod.installMethodArgcCheck,
        ) {
          const seen = new Map();
          for (const k of Object.keys(methods)) {
            const m = methods[k];
            const prior = seen.get(m);
            if (prior) {
              const mkey = structInstance.memberKey(k);
              structInstance[mkey] =
                structInstance[structInstance.memberKey(prior)];
            } else {
              installMethod(structInstance, k, m, applyArgcCheck);
              seen.set(m, k);
            }
          }
          return structInstance;
        };

        StructBinder.StructType.prototype.installMethod = function callee(
          name,
          func,
          applyArgcCheck = installMethod.installMethodArgcCheck,
        ) {
          return arguments.length < 3 && name && 'object' === typeof name
            ? installMethods(this, ...arguments)
            : installMethod(this, ...arguments);
        };

        StructBinder.StructType.prototype.installMethods = function (
          methods,
          applyArgcCheck = installMethod.installMethodArgcCheck,
        ) {
          return installMethods(this, methods, applyArgcCheck);
        };

        capi.sqlite3_vfs.prototype.registerVfs = function (asDefault = false) {
          if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {
            toss('Expecting a sqlite3_vfs-type argument.');
          }
          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
          if (rc) {
            toss('sqlite3_vfs_register(', this, ') failed with rc', rc);
          }
          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
            toss(
              'BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS',
              this,
            );
          }
          return this;
        };

        vfs.installVfs = function (opt) {
          let count = 0;
          const propList = ['io', 'vfs'];
          for (const key of propList) {
            const o = opt[key];
            if (o) {
              ++count;
              installMethods(o.struct, o.methods, !!o.applyArgcCheck);
              if ('vfs' === key) {
                if (!o.struct.$zName && 'string' === typeof o.name) {
                  o.struct.addOnDispose(
                    (o.struct.$zName = wasm.allocCString(o.name)),
                  );
                }
                o.struct.registerVfs(!!o.asDefault);
              }
            }
          }
          if (!count)
            toss(
              'Misuse: installVfs() options object requires at least',
              'one of:',
              propList,
            );
          return this;
        };

        const __xWrapFactory = function (methodName, StructType) {
          return function (ptr, removeMapping = false) {
            if (0 === arguments.length) ptr = new StructType();
            if (ptr instanceof StructType) {
              this.set(ptr.pointer, ptr);
              return ptr;
            } else if (!wasm.isPtr(ptr)) {
              sqlite3.SQLite3Error.toss(
                'Invalid argument to',
                methodName + '()',
              );
            }
            let rc = this.get(ptr);
            if (removeMapping) this.delete(ptr);
            return rc;
          }.bind(new Map());
        };

        const StructPtrMapper = function (name, StructType) {
          const __xWrap = __xWrapFactory(name, StructType);

          return Object.assign(Object.create(null), {
            StructType,

            create: (ppOut) => {
              const rc = __xWrap();
              wasm.pokePtr(ppOut, rc.pointer);
              return rc;
            },

            get: (pCObj) => __xWrap(pCObj),

            unget: (pCObj) => __xWrap(pCObj, true),

            dispose: (pCObj) => {
              const o = __xWrap(pCObj, true);
              if (o) o.dispose();
            },
          });
        };

        vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);

        vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);

        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);

        vtab.xError = function f(methodName, err, defaultRc) {
          if (f.errorReporter instanceof Function) {
            try {
              f.errorReporter(
                'sqlite3_module::' + methodName + '(): ' + err.message,
              );
            } catch (e) {}
          }
          let rc;
          if (err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;
          else if (arguments.length > 2) rc = defaultRc;
          else if (err instanceof sqlite3.SQLite3Error) rc = err.resultCode;
          return rc || capi.SQLITE_ERROR;
        };
        vtab.xError.errorReporter =  true ? console.error.bind(console) : 0;

        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, 'i64');

        vtab.setupModule = function (opt) {
          let createdMod = false;
          const mod =
            this instanceof capi.sqlite3_module
              ? this
              : opt.struct || (createdMod = new capi.sqlite3_module());
          try {
            const methods = opt.methods || toss("Missing 'methods' object.");
            for (const e of Object.entries({
              xConnect: 'xCreate',
              xDisconnect: 'xDestroy',
            })) {
              const k = e[0],
                v = e[1];
              if (true === methods[k]) methods[k] = methods[v];
              else if (true === methods[v]) methods[v] = methods[k];
            }
            if (opt.catchExceptions) {
              const fwrap = function (methodName, func) {
                if (['xConnect', 'xCreate'].indexOf(methodName) >= 0) {
                  return function (pDb, pAux, argc, argv, ppVtab, pzErr) {
                    try {
                      return func(...arguments) || 0;
                    } catch (e) {
                      if (!(e instanceof sqlite3.WasmAllocError)) {
                        wasm.dealloc(wasm.peekPtr(pzErr));
                        wasm.pokePtr(pzErr, wasm.allocCString(e.message));
                      }
                      return vtab.xError(methodName, e);
                    }
                  };
                } else {
                  return function (...args) {
                    try {
                      return func(...args) || 0;
                    } catch (e) {
                      return vtab.xError(methodName, e);
                    }
                  };
                }
              };
              const mnames = [
                'xCreate',
                'xConnect',
                'xBestIndex',
                'xDisconnect',
                'xDestroy',
                'xOpen',
                'xClose',
                'xFilter',
                'xNext',
                'xEof',
                'xColumn',
                'xRowid',
                'xUpdate',
                'xBegin',
                'xSync',
                'xCommit',
                'xRollback',
                'xFindFunction',
                'xRename',
                'xSavepoint',
                'xRelease',
                'xRollbackTo',
                'xShadowName',
              ];
              const remethods = Object.create(null);
              for (const k of mnames) {
                const m = methods[k];
                if (!(m instanceof Function)) continue;
                else if ('xConnect' === k && methods.xCreate === m) {
                  remethods[k] = methods.xCreate;
                } else if ('xCreate' === k && methods.xConnect === m) {
                  remethods[k] = methods.xConnect;
                } else {
                  remethods[k] = fwrap(k, m);
                }
              }
              installMethods(mod, remethods, false);
            } else {
              installMethods(mod, methods, !!opt.applyArgcCheck);
            }
            if (0 === mod.$iVersion) {
              let v;
              if ('number' === typeof opt.iVersion) v = opt.iVersion;
              else if (mod.$xShadowName) v = 3;
              else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)
                v = 2;
              else v = 1;
              mod.$iVersion = v;
            }
          } catch (e) {
            if (createdMod) createdMod.dispose();
            throw e;
          }
          return mod;
        };

        capi.sqlite3_module.prototype.setupModule = function (opt) {
          return vtab.setupModule.call(this, opt);
        };
      });

      ('use strict');
      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        const installOpfsVfs = function callee(options) {
          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
            return Promise.reject(
              new Error(
                'Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. ' +
                  'The server must emit the COOP/COEP response headers to enable those. ' +
                  'See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep',
              ),
            );
          } else if ('undefined' === typeof WorkerGlobalScope) {
            return Promise.reject(
              new Error(
                'The OPFS sqlite3_vfs cannot run in the main thread ' +
                  'because it requires Atomics.wait().',
              ),
            );
          } else if (
            !globalThis.FileSystemHandle ||
            !globalThis.FileSystemDirectoryHandle ||
            !globalThis.FileSystemFileHandle ||
            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
            !navigator?.storage?.getDirectory
          ) {
            return Promise.reject(new Error('Missing required OPFS APIs.'));
          }
          if (!options || 'object' !== typeof options) {
            options = Object.create(null);
          }
          const urlParams = new URL(globalThis.location.href).searchParams;
          if (urlParams.has('opfs-disable')) {
            return Promise.resolve(sqlite3);
          }
          if (undefined === options.verbose) {
            options.verbose = urlParams.has('opfs-verbose')
              ? +urlParams.get('opfs-verbose') || 2
              : 1;
          }
          if (undefined === options.sanityChecks) {
            options.sanityChecks = urlParams.has('opfs-sanity-check');
          }
          if (undefined === options.proxyUri) {
            options.proxyUri = callee.defaultProxyUri;
          }

          if ('function' === typeof options.proxyUri) {
            options.proxyUri = options.proxyUri();
          }
          const thePromise = new Promise(function (
            promiseResolve_,
            promiseReject_,
          ) {
            const loggers = [
              sqlite3.config.error,
              sqlite3.config.warn,
              sqlite3.config.log,
            ];
            const logImpl = (level, ...args) => {
              if (options.verbose > level)
                loggers[level]('OPFS syncer:', ...args);
            };
            const log = (...args) => logImpl(2, ...args);
            const warn = (...args) => logImpl(1, ...args);
            const error = (...args) => logImpl(0, ...args);
            const toss = sqlite3.util.toss;
            const capi = sqlite3.capi;
            const util = sqlite3.util;
            const wasm = sqlite3.wasm;
            const sqlite3_vfs = capi.sqlite3_vfs;
            const sqlite3_file = capi.sqlite3_file;
            const sqlite3_io_methods = capi.sqlite3_io_methods;

            const opfsUtil = Object.create(null);

            const thisThreadHasOPFS = () => {
              return (
                globalThis.FileSystemHandle &&
                globalThis.FileSystemDirectoryHandle &&
                globalThis.FileSystemFileHandle &&
                globalThis.FileSystemFileHandle.prototype
                  .createSyncAccessHandle &&
                navigator?.storage?.getDirectory
              );
            };

            opfsUtil.metrics = {
              dump: function () {
                let k,
                  n = 0,
                  t = 0,
                  w = 0;
                for (k in state.opIds) {
                  const m = metrics[k];
                  n += m.count;
                  t += m.time;
                  w += m.wait;
                  m.avgTime = m.count && m.time ? m.time / m.count : 0;
                  m.avgWait = m.count && m.wait ? m.wait / m.count : 0;
                }
                sqlite3.config.log(
                  globalThis.location.href,
                  'metrics for',
                  globalThis.location.href,
                  ':',
                  metrics,
                  '\nTotal of',
                  n,
                  'op(s) for',
                  t,
                  'ms (incl. ' + w + ' ms of waiting on the async side)',
                );
                sqlite3.config.log('Serialization metrics:', metrics.s11n);
                W.postMessage({ type: 'opfs-async-metrics' });
              },
              reset: function () {
                let k;
                const r = (m) => (m.count = m.time = m.wait = 0);
                for (k in state.opIds) {
                  r((metrics[k] = Object.create(null)));
                }
                let s = (metrics.s11n = Object.create(null));
                s = s.serialize = Object.create(null);
                s.count = s.time = 0;
                s = metrics.s11n.deserialize = Object.create(null);
                s.count = s.time = 0;
              },
            };
            const opfsIoMethods = new sqlite3_io_methods();
            const opfsVfs = new sqlite3_vfs().addOnDispose(() =>
              opfsIoMethods.dispose(),
            );
            let promiseWasRejected = undefined;
            const promiseReject = (err) => {
              promiseWasRejected = true;
              opfsVfs.dispose();
              return promiseReject_(err);
            };
            const promiseResolve = () => {
              promiseWasRejected = false;
              return promiseResolve_(sqlite3);
            };
            const W = new Worker(
              new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("vendors-node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-opfs-async-proxy_js"), __webpack_require__.b),
            );
            setTimeout(() => {
              if (undefined === promiseWasRejected) {
                promiseReject(
                  new Error(
                    'Timeout while waiting for OPFS async proxy worker.',
                  ),
                );
              }
            }, 4000);
            W._originalOnError = W.onerror;
            W.onerror = function (err) {
              error('Error initializing OPFS asyncer:', err);
              promiseReject(
                new Error(
                  'Loading OPFS async Worker failed for unknown reasons.',
                ),
              );
            };
            const pDVfs = capi.sqlite3_vfs_find(null);
            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
            opfsIoMethods.$iVersion = 1;
            opfsVfs.$iVersion = 2;
            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
            opfsVfs.$mxPathname = 1024;
            opfsVfs.$zName = wasm.allocCString('opfs');

            opfsVfs.$xDlOpen =
              opfsVfs.$xDlError =
              opfsVfs.$xDlSym =
              opfsVfs.$xDlClose =
                null;
            opfsVfs.addOnDispose(
              '$zName',
              opfsVfs.$zName,
              'cleanup default VFS wrapper',
              () => (dVfs ? dVfs.dispose() : null),
            );

            const state = Object.create(null);
            state.verbose = options.verbose;
            state.littleEndian = (() => {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);

              return new Int16Array(buffer)[0] === 256;
            })();

            state.asyncIdleWaitTime = 150;

            state.asyncS11nExceptions = 1;

            state.fileBufferSize = 1024 * 64;
            state.sabS11nOffset = state.fileBufferSize;

            state.sabS11nSize = opfsVfs.$mxPathname * 2;

            state.sabIO = new SharedArrayBuffer(
              state.fileBufferSize + state.sabS11nSize,
            );
            state.opIds = Object.create(null);
            const metrics = Object.create(null);
            {
              let i = 0;

              state.opIds.whichOp = i++;

              state.opIds.rc = i++;

              state.opIds.xAccess = i++;
              state.opIds.xClose = i++;
              state.opIds.xDelete = i++;
              state.opIds.xDeleteNoWait = i++;
              state.opIds.xFileSize = i++;
              state.opIds.xLock = i++;
              state.opIds.xOpen = i++;
              state.opIds.xRead = i++;
              state.opIds.xSleep = i++;
              state.opIds.xSync = i++;
              state.opIds.xTruncate = i++;
              state.opIds.xUnlock = i++;
              state.opIds.xWrite = i++;
              state.opIds.mkdir = i++;
              state.opIds['opfs-async-metrics'] = i++;
              state.opIds['opfs-async-shutdown'] = i++;

              state.opIds.retry = i++;
              state.sabOP = new SharedArrayBuffer(i * 4);
              opfsUtil.metrics.reset();
            }

            state.sq3Codes = Object.create(null);
            [
              'SQLITE_ACCESS_EXISTS',
              'SQLITE_ACCESS_READWRITE',
              'SQLITE_BUSY',
              'SQLITE_ERROR',
              'SQLITE_IOERR',
              'SQLITE_IOERR_ACCESS',
              'SQLITE_IOERR_CLOSE',
              'SQLITE_IOERR_DELETE',
              'SQLITE_IOERR_FSYNC',
              'SQLITE_IOERR_LOCK',
              'SQLITE_IOERR_READ',
              'SQLITE_IOERR_SHORT_READ',
              'SQLITE_IOERR_TRUNCATE',
              'SQLITE_IOERR_UNLOCK',
              'SQLITE_IOERR_WRITE',
              'SQLITE_LOCK_EXCLUSIVE',
              'SQLITE_LOCK_NONE',
              'SQLITE_LOCK_PENDING',
              'SQLITE_LOCK_RESERVED',
              'SQLITE_LOCK_SHARED',
              'SQLITE_LOCKED',
              'SQLITE_MISUSE',
              'SQLITE_NOTFOUND',
              'SQLITE_OPEN_CREATE',
              'SQLITE_OPEN_DELETEONCLOSE',
              'SQLITE_OPEN_MAIN_DB',
              'SQLITE_OPEN_READONLY',
            ].forEach((k) => {
              if (undefined === (state.sq3Codes[k] = capi[k])) {
                toss('Maintenance required: not found:', k);
              }
            });
            state.opfsFlags = Object.assign(Object.create(null), {
              OPFS_UNLOCK_ASAP: 0x01,

              defaultUnlockAsap: false,
            });

            const opRun = (op, ...args) => {
              const opNdx = state.opIds[op] || toss('Invalid op ID:', op);
              state.s11n.serialize(...args);
              Atomics.store(state.sabOPView, state.opIds.rc, -1);
              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
              Atomics.notify(state.sabOPView, state.opIds.whichOp);
              const t = performance.now();
              Atomics.wait(state.sabOPView, state.opIds.rc, -1);
              const rc = Atomics.load(state.sabOPView, state.opIds.rc);
              metrics[op].wait += performance.now() - t;
              if (rc && state.asyncS11nExceptions) {
                const err = state.s11n.deserialize();
                if (err) error(op + '() async error:', ...err);
              }
              return rc;
            };

            opfsUtil.debug = {
              asyncShutdown: () => {
                warn(
                  'Shutting down OPFS async listener. The OPFS VFS will no longer work.',
                );
                opRun('opfs-async-shutdown');
              },
              asyncRestart: () => {
                warn(
                  'Attempting to restart OPFS VFS async listener. Might work, might not.',
                );
                W.postMessage({ type: 'opfs-async-restart' });
              },
            };

            const initS11n = () => {
              if (state.s11n) return state.s11n;
              const textDecoder = new TextDecoder(),
                textEncoder = new TextEncoder('utf-8'),
                viewU8 = new Uint8Array(
                  state.sabIO,
                  state.sabS11nOffset,
                  state.sabS11nSize,
                ),
                viewDV = new DataView(
                  state.sabIO,
                  state.sabS11nOffset,
                  state.sabS11nSize,
                );
              state.s11n = Object.create(null);

              const TypeIds = Object.create(null);
              TypeIds.number = {
                id: 1,
                size: 8,
                getter: 'getFloat64',
                setter: 'setFloat64',
              };
              TypeIds.bigint = {
                id: 2,
                size: 8,
                getter: 'getBigInt64',
                setter: 'setBigInt64',
              };
              TypeIds.boolean = {
                id: 3,
                size: 4,
                getter: 'getInt32',
                setter: 'setInt32',
              };
              TypeIds.string = { id: 4 };

              const getTypeId = (v) =>
                TypeIds[typeof v] ||
                toss(
                  'Maintenance required: this value type cannot be serialized.',
                  v,
                );
              const getTypeIdById = (tid) => {
                switch (tid) {
                  case TypeIds.number.id:
                    return TypeIds.number;
                  case TypeIds.bigint.id:
                    return TypeIds.bigint;
                  case TypeIds.boolean.id:
                    return TypeIds.boolean;
                  case TypeIds.string.id:
                    return TypeIds.string;
                  default:
                    toss('Invalid type ID:', tid);
                }
              };

              state.s11n.deserialize = function (clear = false) {
                ++metrics.s11n.deserialize.count;
                const t = performance.now();
                const argc = viewU8[0];
                const rc = argc ? [] : null;
                if (argc) {
                  const typeIds = [];
                  let offset = 1,
                    i,
                    n,
                    v;
                  for (i = 0; i < argc; ++i, ++offset) {
                    typeIds.push(getTypeIdById(viewU8[offset]));
                  }
                  for (i = 0; i < argc; ++i) {
                    const t = typeIds[i];
                    if (t.getter) {
                      v = viewDV[t.getter](offset, state.littleEndian);
                      offset += t.size;
                    } else {
                      n = viewDV.getInt32(offset, state.littleEndian);
                      offset += 4;
                      v = textDecoder.decode(viewU8.slice(offset, offset + n));
                      offset += n;
                    }
                    rc.push(v);
                  }
                }
                if (clear) viewU8[0] = 0;

                metrics.s11n.deserialize.time += performance.now() - t;
                return rc;
              };

              state.s11n.serialize = function (...args) {
                const t = performance.now();
                ++metrics.s11n.serialize.count;
                if (args.length) {
                  const typeIds = [];
                  let i = 0,
                    offset = 1;
                  viewU8[0] = args.length & 0xff;
                  for (; i < args.length; ++i, ++offset) {
                    typeIds.push(getTypeId(args[i]));
                    viewU8[offset] = typeIds[i].id;
                  }
                  for (i = 0; i < args.length; ++i) {
                    const t = typeIds[i];
                    if (t.setter) {
                      viewDV[t.setter](offset, args[i], state.littleEndian);
                      offset += t.size;
                    } else {
                      const s = textEncoder.encode(args[i]);
                      viewDV.setInt32(offset, s.byteLength, state.littleEndian);
                      offset += 4;
                      viewU8.set(s, offset);
                      offset += s.byteLength;
                    }
                  }
                } else {
                  viewU8[0] = 0;
                }
                metrics.s11n.serialize.time += performance.now() - t;
              };
              return state.s11n;
            };

            const randomFilename = function f(len = 16) {
              if (!f._chars) {
                f._chars =
                  'abcdefghijklmnopqrstuvwxyz' +
                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
                  '012346789';
                f._n = f._chars.length;
              }
              const a = [];
              let i = 0;
              for (; i < len; ++i) {
                const ndx = (Math.random() * (f._n * 64)) % f._n | 0;
                a[i] = f._chars[ndx];
              }
              return a.join('');
            };

            const __openFiles = Object.create(null);

            const opTimer = Object.create(null);
            opTimer.op = undefined;
            opTimer.start = undefined;
            const mTimeStart = (op) => {
              opTimer.start = performance.now();
              opTimer.op = op;
              ++metrics[op].count;
            };
            const mTimeEnd = () =>
              (metrics[opTimer.op].time += performance.now() - opTimer.start);

            const ioSyncWrappers = {
              xCheckReservedLock: function (pFile, pOut) {
                const f = __openFiles[pFile];
                wasm.poke(pOut, f.lockType ? 1 : 0, 'i32');
                return 0;
              },
              xClose: function (pFile) {
                mTimeStart('xClose');
                let rc = 0;
                const f = __openFiles[pFile];
                if (f) {
                  delete __openFiles[pFile];
                  rc = opRun('xClose', pFile);
                  if (f.sq3File) f.sq3File.dispose();
                }
                mTimeEnd();
                return rc;
              },
              xDeviceCharacteristics: function (pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              },
              xFileControl: function (pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              },
              xFileSize: function (pFile, pSz64) {
                mTimeStart('xFileSize');
                let rc = opRun('xFileSize', pFile);
                if (0 == rc) {
                  try {
                    const sz = state.s11n.deserialize()[0];
                    wasm.poke(pSz64, sz, 'i64');
                  } catch (e) {
                    error('Unexpected error reading xFileSize() result:', e);
                    rc = state.sq3Codes.SQLITE_IOERR;
                  }
                }
                mTimeEnd();
                return rc;
              },
              xLock: function (pFile, lockType) {
                mTimeStart('xLock');
                const f = __openFiles[pFile];
                let rc = 0;

                if (!f.lockType) {
                  rc = opRun('xLock', pFile, lockType);
                  if (0 === rc) f.lockType = lockType;
                } else {
                  f.lockType = lockType;
                }
                mTimeEnd();
                return rc;
              },
              xRead: function (pFile, pDest, n, offset64) {
                mTimeStart('xRead');
                const f = __openFiles[pFile];
                let rc;
                try {
                  rc = opRun('xRead', pFile, n, Number(offset64));
                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                    wasm.heap8u().set(f.sabView.subarray(0, n), pDest);
                  }
                } catch (e) {
                  error('xRead(', arguments, ') failed:', e, f);
                  rc = capi.SQLITE_IOERR_READ;
                }
                mTimeEnd();
                return rc;
              },
              xSync: function (pFile, flags) {
                mTimeStart('xSync');
                ++metrics.xSync.count;
                const rc = opRun('xSync', pFile, flags);
                mTimeEnd();
                return rc;
              },
              xTruncate: function (pFile, sz64) {
                mTimeStart('xTruncate');
                const rc = opRun('xTruncate', pFile, Number(sz64));
                mTimeEnd();
                return rc;
              },
              xUnlock: function (pFile, lockType) {
                mTimeStart('xUnlock');
                const f = __openFiles[pFile];
                let rc = 0;
                if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {
                  rc = opRun('xUnlock', pFile, lockType);
                }
                if (0 === rc) f.lockType = lockType;
                mTimeEnd();
                return rc;
              },
              xWrite: function (pFile, pSrc, n, offset64) {
                mTimeStart('xWrite');
                const f = __openFiles[pFile];
                let rc;
                try {
                  f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n));
                  rc = opRun('xWrite', pFile, n, Number(offset64));
                } catch (e) {
                  error('xWrite(', arguments, ') failed:', e, f);
                  rc = capi.SQLITE_IOERR_WRITE;
                }
                mTimeEnd();
                return rc;
              },
            };

            const vfsSyncWrappers = {
              xAccess: function (pVfs, zName, flags, pOut) {
                mTimeStart('xAccess');
                const rc = opRun('xAccess', wasm.cstrToJs(zName));
                wasm.poke(pOut, rc ? 0 : 1, 'i32');
                mTimeEnd();
                return 0;
              },
              xCurrentTime: function (pVfs, pOut) {
                wasm.poke(
                  pOut,
                  2440587.5 + new Date().getTime() / 86400000,
                  'double',
                );
                return 0;
              },
              xCurrentTimeInt64: function (pVfs, pOut) {
                wasm.poke(
                  pOut,
                  2440587.5 * 86400000 + new Date().getTime(),
                  'i64',
                );
                return 0;
              },
              xDelete: function (pVfs, zName, doSyncDir) {
                mTimeStart('xDelete');
                const rc = opRun(
                  'xDelete',
                  wasm.cstrToJs(zName),
                  doSyncDir,
                  false,
                );
                mTimeEnd();
                return rc;
              },
              xFullPathname: function (pVfs, zName, nOut, pOut) {
                const i = wasm.cstrncpy(pOut, zName, nOut);
                return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
              },
              xGetLastError: function (pVfs, nOut, pOut) {
                warn('OPFS xGetLastError() has nothing sensible to return.');
                return 0;
              },

              xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
                mTimeStart('xOpen');
                let opfsFlags = 0;
                if (0 === zName) {
                  zName = randomFilename();
                } else if ('number' === typeof zName) {
                  if (capi.sqlite3_uri_boolean(zName, 'opfs-unlock-asap', 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
                  }
                  zName = wasm.cstrToJs(zName);
                }
                const fh = Object.create(null);
                fh.fid = pFile;
                fh.filename = zName;
                fh.sab = new SharedArrayBuffer(state.fileBufferSize);
                fh.flags = flags;
                const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);
                if (!rc) {
                  if (fh.readOnly) {
                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');
                  }
                  __openFiles[pFile] = fh;
                  fh.sabView = state.sabFileBufView;
                  fh.sq3File = new sqlite3_file(pFile);
                  fh.sq3File.$pMethods = opfsIoMethods.pointer;
                  fh.lockType = capi.SQLITE_LOCK_NONE;
                }
                mTimeEnd();
                return rc;
              },
            };

            if (dVfs) {
              opfsVfs.$xRandomness = dVfs.$xRandomness;
              opfsVfs.$xSleep = dVfs.$xSleep;
            }
            if (!opfsVfs.$xRandomness) {
              vfsSyncWrappers.xRandomness = function (pVfs, nOut, pOut) {
                const heap = wasm.heap8u();
                let i = 0;
                for (; i < nOut; ++i)
                  heap[pOut + i] = (Math.random() * 255000) & 0xff;
                return i;
              };
            }
            if (!opfsVfs.$xSleep) {
              vfsSyncWrappers.xSleep = function (pVfs, ms) {
                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
                return 0;
              };
            }

            opfsUtil.getResolvedPath = function (filename, splitIt) {
              const p = new URL(filename, 'file://irrelevant').pathname;
              return splitIt ? p.split('/').filter((v) => !!v) : p;
            };

            opfsUtil.getDirForFilename = async function f(
              absFilename,
              createDirs = false,
            ) {
              const path = opfsUtil.getResolvedPath(absFilename, true);
              const filename = path.pop();
              let dh = opfsUtil.rootDirectory;
              for (const dirName of path) {
                if (dirName) {
                  dh = await dh.getDirectoryHandle(dirName, {
                    create: !!createDirs,
                  });
                }
              }
              return [dh, filename];
            };

            opfsUtil.mkdir = async function (absDirName) {
              try {
                await opfsUtil.getDirForFilename(
                  absDirName + '/filepart',
                  true,
                );
                return true;
              } catch (e) {
                return false;
              }
            };

            opfsUtil.entryExists = async function (fsEntryName) {
              try {
                const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
                await dh.getFileHandle(fn);
                return true;
              } catch (e) {
                return false;
              }
            };

            opfsUtil.randomFilename = randomFilename;

            opfsUtil.registerVfs = (asDefault = false) => {
              return wasm.exports.sqlite3_vfs_register(
                opfsVfs.pointer,
                asDefault ? 1 : 0,
              );
            };

            opfsUtil.treeList = async function () {
              const doDir = async function callee(dirHandle, tgt) {
                tgt.name = dirHandle.name;
                tgt.dirs = [];
                tgt.files = [];
                for await (const handle of dirHandle.values()) {
                  if ('directory' === handle.kind) {
                    const subDir = Object.create(null);
                    tgt.dirs.push(subDir);
                    await callee(handle, subDir);
                  } else {
                    tgt.files.push(handle.name);
                  }
                }
              };
              const root = Object.create(null);
              await doDir(opfsUtil.rootDirectory, root);
              return root;
            };

            opfsUtil.rmfr = async function () {
              const dir = opfsUtil.rootDirectory,
                opt = { recurse: true };
              for await (const handle of dir.values()) {
                dir.removeEntry(handle.name, opt);
              }
            };

            opfsUtil.unlink = async function (
              fsEntryName,
              recursive = false,
              throwOnError = false,
            ) {
              try {
                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                  fsEntryName,
                  false,
                );
                await hDir.removeEntry(filenamePart, { recursive });
                return true;
              } catch (e) {
                if (throwOnError) {
                  throw new Error(
                    'unlink(',
                    arguments[0],
                    ') failed: ' + e.message,
                    {
                      cause: e,
                    },
                  );
                }
                return false;
              }
            };

            opfsUtil.traverse = async function (opt) {
              const defaultOpt = {
                recursive: true,
                directory: opfsUtil.rootDirectory,
              };
              if ('function' === typeof opt) {
                opt = { callback: opt };
              }
              opt = Object.assign(defaultOpt, opt || {});
              const doDir = async function callee(dirHandle, depth) {
                for await (const handle of dirHandle.values()) {
                  if (false === opt.callback(handle, dirHandle, depth))
                    return false;
                  else if (opt.recursive && 'directory' === handle.kind) {
                    if (false === (await callee(handle, depth + 1))) break;
                  }
                }
              };
              doDir(opt.directory, 0);
            };

            const importDbChunked = async function (filename, callback) {
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true,
              );
              const hFile = await hDir.getFileHandle(fnamePart, {
                create: true,
              });
              let sah = await hFile.createSyncAccessHandle();
              let nWrote = 0,
                chunk,
                checkedHeader = false,
                err = false;
              try {
                sah.truncate(0);
                while (undefined !== (chunk = await callback())) {
                  if (chunk instanceof ArrayBuffer)
                    chunk = new Uint8Array(chunk);
                  if (0 === nWrote && chunk.byteLength >= 15) {
                    util.affirmDbHeader(chunk);
                    checkedHeader = true;
                  }
                  sah.write(chunk, { at: nWrote });
                  nWrote += chunk.byteLength;
                }
                if (nWrote < 512 || 0 !== nWrote % 512) {
                  toss(
                    'Input size',
                    nWrote,
                    'is not correct for an SQLite database.',
                  );
                }
                if (!checkedHeader) {
                  const header = new Uint8Array(20);
                  sah.read(header, { at: 0 });
                  util.affirmDbHeader(header);
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e) {
                await sah.close();
                sah = undefined;
                await hDir.removeEntry(fnamePart).catch(() => {});
                throw e;
              } finally {
                if (sah) await sah.close();
              }
            };

            opfsUtil.importDb = async function (filename, bytes) {
              if (bytes instanceof Function) {
                return importDbChunked(filename, bytes);
              }
              if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
              util.affirmIsDb(bytes);
              const n = bytes.byteLength;
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true,
              );
              let sah,
                err,
                nWrote = 0;
              try {
                const hFile = await hDir.getFileHandle(fnamePart, {
                  create: true,
                });
                sah = await hFile.createSyncAccessHandle();
                sah.truncate(0);
                nWrote = sah.write(bytes, { at: 0 });
                if (nWrote != n) {
                  toss(
                    'Expected to write ' +
                      n +
                      ' bytes but wrote ' +
                      nWrote +
                      '.',
                  );
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e) {
                if (sah) {
                  await sah.close();
                  sah = undefined;
                }
                await hDir.removeEntry(fnamePart).catch(() => {});
                throw e;
              } finally {
                if (sah) await sah.close();
              }
            };

            if (sqlite3.oo1) {
              const OpfsDb = function (...args) {
                const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                opt.vfs = opfsVfs.$zName;
                sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
              };
              OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
              sqlite3.oo1.OpfsDb = OpfsDb;
              OpfsDb.importDb = opfsUtil.importDb;
              sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                opfsVfs.pointer,
                function (oo1Db, sqlite3) {
                  sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);
                  sqlite3.capi.sqlite3_exec(
                    oo1Db,
                    [
                      'pragma journal_mode=DELETE;',

                      'pragma cache_size=-16384;',
                    ],
                    0,
                    0,
                    0,
                  );
                },
              );
            }

            const sanityCheck = function () {
              const scope = wasm.scopedAllocPush();
              const sq3File = new sqlite3_file();
              try {
                const fid = sq3File.pointer;
                const openFlags =
                  capi.SQLITE_OPEN_CREATE |
                  capi.SQLITE_OPEN_READWRITE |
                  capi.SQLITE_OPEN_MAIN_DB;
                const pOut = wasm.scopedAlloc(8);
                const dbFile = '/sanity/check/file' + randomFilename(8);
                const zDbFile = wasm.scopedAllocCString(dbFile);
                let rc;
                state.s11n.serialize('This is  string.');
                rc = state.s11n.deserialize();
                log('deserialize() says:', rc);
                if ('This is  string.' !== rc[0]) toss('String d13n error.');
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, 'i32');
                log('xAccess(', dbFile, ') exists ?=', rc);
                rc = vfsSyncWrappers.xOpen(
                  opfsVfs.pointer,
                  zDbFile,
                  fid,
                  openFlags,
                  pOut,
                );
                log(
                  'open rc =',
                  rc,
                  'state.sabOPView[xOpen] =',
                  state.sabOPView[state.opIds.xOpen],
                );
                if (0 !== rc) {
                  error('open failed with code', rc);
                  return;
                }
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, 'i32');
                if (!rc) toss('xAccess() failed to detect file.');
                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                if (rc) toss('sync failed w/ rc', rc);
                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                if (rc) toss('truncate failed w/ rc', rc);
                wasm.poke(pOut, 0, 'i64');
                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                if (rc) toss('xFileSize failed w/ rc', rc);
                log('xFileSize says:', wasm.peek(pOut, 'i64'));
                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                if (rc) toss('xWrite() failed!');
                const readBuf = wasm.scopedAlloc(16);
                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                wasm.poke(readBuf + 6, 0);
                let jRead = wasm.cstrToJs(readBuf);
                log('xRead() got:', jRead);
                if ('sanity' !== jRead) toss('Unexpected xRead() value.');
                if (vfsSyncWrappers.xSleep) {
                  log('xSleep()ing before close()ing...');
                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2000);
                  log('waking up from xSleep()');
                }
                rc = ioSyncWrappers.xClose(fid);
                log('xClose rc =', rc, 'sabOPView =', state.sabOPView);
                log('Deleting file:', dbFile);
                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, 'i32');
                if (rc)
                  toss(
                    'Expecting 0 from xAccess(',
                    dbFile,
                    ') after xDelete().',
                  );
                warn('End of OPFS sanity checks.');
              } finally {
                sq3File.dispose();
                wasm.scopedAllocPop(scope);
              }
            };

            W.onmessage = function ({ data }) {
              switch (data.type) {
                case 'opfs-unavailable':
                  promiseReject(new Error(data.payload.join(' ')));
                  break;
                case 'opfs-async-loaded':
                  W.postMessage({ type: 'opfs-async-init', args: state });
                  break;
                case 'opfs-async-inited': {
                  if (true === promiseWasRejected) {
                    break;
                  }
                  try {
                    sqlite3.vfs.installVfs({
                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers },
                    });
                    state.sabOPView = new Int32Array(state.sabOP);
                    state.sabFileBufView = new Uint8Array(
                      state.sabIO,
                      0,
                      state.fileBufferSize,
                    );
                    state.sabS11nView = new Uint8Array(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize,
                    );
                    initS11n();
                    if (options.sanityChecks) {
                      warn(
                        'Running sanity checks because of opfs-sanity-check URL arg...',
                      );
                      sanityCheck();
                    }
                    if (thisThreadHasOPFS()) {
                      navigator.storage
                        .getDirectory()
                        .then((d) => {
                          W.onerror = W._originalOnError;
                          delete W._originalOnError;
                          sqlite3.opfs = opfsUtil;
                          opfsUtil.rootDirectory = d;
                          log('End of OPFS sqlite3_vfs setup.', opfsVfs);
                          promiseResolve();
                        })
                        .catch(promiseReject);
                    } else {
                      promiseResolve();
                    }
                  } catch (e) {
                    error(e);
                    promiseReject(e);
                  }
                  break;
                }
                default: {
                  const errMsg =
                    'Unexpected message from the OPFS async worker: ' +
                    JSON.stringify(data);
                  error(errMsg);
                  promiseReject(new Error(errMsg));
                  break;
                }
              }
            };
          });
          return thePromise;
        };
        installOpfsVfs.defaultProxyUri = 'sqlite3-opfs-async-proxy.js';
        globalThis.sqlite3ApiBootstrap.initializersAsync.push(
          async (sqlite3) => {
            try {
              let proxyJs = installOpfsVfs.defaultProxyUri;
              if (sqlite3.scriptInfo.sqlite3Dir) {
                installOpfsVfs.defaultProxyUri =
                  sqlite3.scriptInfo.sqlite3Dir + proxyJs;
              }
              return installOpfsVfs().catch((e) => {
                sqlite3.config.warn(
                  'Ignoring inability to install OPFS sqlite3_vfs:',
                  e.message,
                );
              });
            } catch (e) {
              sqlite3.config.error('installOpfsVfs() exception:', e);
              return Promise.reject(e);
            }
          },
        );
      });

      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
        'use strict';
        const toss = sqlite3.util.toss;
        const toss3 = sqlite3.util.toss3;
        const initPromises = Object.create(null);
        const capi = sqlite3.capi;
        const util = sqlite3.util;
        const wasm = sqlite3.wasm;

        const SECTOR_SIZE = 4096;
        const HEADER_MAX_PATH_SIZE = 512;
        const HEADER_FLAGS_SIZE = 4;
        const HEADER_DIGEST_SIZE = 8;
        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
        const HEADER_OFFSET_DATA = SECTOR_SIZE;

        const PERSISTENT_FILE_TYPES =
          capi.SQLITE_OPEN_MAIN_DB |
          capi.SQLITE_OPEN_MAIN_JOURNAL |
          capi.SQLITE_OPEN_SUPER_JOURNAL |
          capi.SQLITE_OPEN_WAL;

        const OPAQUE_DIR_NAME = '.opaque';

        const getRandomName = () => Math.random().toString(36).slice(2);

        const textDecoder = new TextDecoder();
        const textEncoder = new TextEncoder();

        const optionDefaults = Object.assign(Object.create(null), {
          name: 'opfs-sahpool',
          directory: undefined,
          initialCapacity: 6,
          clearOnInit: false,

          verbosity: 2,
        });

        const loggers = [
          sqlite3.config.error,
          sqlite3.config.warn,
          sqlite3.config.log,
        ];
        const log = sqlite3.config.log;
        const warn = sqlite3.config.warn;
        const error = sqlite3.config.error;

        const __mapVfsToPool = new Map();
        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);
        const setPoolForVfs = (pVfs, pool) => {
          if (pool) __mapVfsToPool.set(pVfs, pool);
          else __mapVfsToPool.delete(pVfs);
        };

        const __mapSqlite3File = new Map();
        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);
        const setPoolForPFile = (pFile, pool) => {
          if (pool) __mapSqlite3File.set(pFile, pool);
          else __mapSqlite3File.delete(pFile);
        };

        const ioMethods = {
          xCheckReservedLock: function (pFile, pOut) {
            const pool = getPoolForPFile(pFile);
            pool.log('xCheckReservedLock');
            pool.storeErr();
            wasm.poke32(pOut, 1);
            return 0;
          },
          xClose: function (pFile) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            if (file) {
              try {
                pool.log(`xClose ${file.path}`);
                pool.mapS3FileToOFile(pFile, false);
                file.sah.flush();
                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                  pool.deletePath(file.path);
                }
              } catch (e) {
                return pool.storeErr(e, capi.SQLITE_IOERR);
              }
            }
            return 0;
          },
          xDeviceCharacteristics: function (pFile) {
            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
          },
          xFileControl: function (pFile, opId, pArg) {
            return capi.SQLITE_NOTFOUND;
          },
          xFileSize: function (pFile, pSz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xFileSize`);
            const file = pool.getOFileForS3File(pFile);
            const size = file.sah.getSize() - HEADER_OFFSET_DATA;

            wasm.poke64(pSz64, BigInt(size));
            return 0;
          },
          xLock: function (pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xLock ${lockType}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xRead: function (pFile, pDest, n, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xRead ${file.path} ${n} @ ${offset64}`);
            try {
              const nRead = file.sah.read(
                wasm.heap8u().subarray(pDest, pDest + n),
                { at: HEADER_OFFSET_DATA + Number(offset64) },
              );
              if (nRead < n) {
                wasm.heap8u().fill(0, pDest + nRead, pDest + n);
                return capi.SQLITE_IOERR_SHORT_READ;
              }
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xSectorSize: function (pFile) {
            return SECTOR_SIZE;
          },
          xSync: function (pFile, flags) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xSync ${flags}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);

            try {
              file.sah.flush();
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xTruncate: function (pFile, sz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xTruncate ${sz64}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);

            try {
              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xUnlock: function (pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log('xUnlock');
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xWrite: function (pFile, pSrc, n, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xWrite ${file.path} ${n} ${offset64}`);
            try {
              const nBytes = file.sah.write(
                wasm.heap8u().subarray(pSrc, pSrc + n),
                { at: HEADER_OFFSET_DATA + Number(offset64) },
              );
              return n === nBytes ? 0 : toss('Unknown write() failure.');
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
        };

        const opfsIoMethods = new capi.sqlite3_io_methods();
        opfsIoMethods.$iVersion = 1;
        sqlite3.vfs.installVfs({
          io: { struct: opfsIoMethods, methods: ioMethods },
        });

        const vfsMethods = {
          xAccess: function (pVfs, zName, flags, pOut) {
            const pool = getPoolForVfs(pVfs);
            pool.storeErr();
            try {
              const name = pool.getPath(zName);
              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
            } catch (e) {
              wasm.poke32(pOut, 0);
            }
            return 0;
          },
          xCurrentTime: function (pVfs, pOut) {
            wasm.poke(
              pOut,
              2440587.5 + new Date().getTime() / 86400000,
              'double',
            );
            return 0;
          },
          xCurrentTimeInt64: function (pVfs, pOut) {
            wasm.poke(pOut, 2440587.5 * 86400000 + new Date().getTime(), 'i64');
            return 0;
          },
          xDelete: function (pVfs, zName, doSyncDir) {
            const pool = getPoolForVfs(pVfs);
            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
            pool.storeErr();
            try {
              pool.deletePath(pool.getPath(zName));
              return 0;
            } catch (e) {
              pool.storeErr(e);
              return capi.SQLITE_IOERR_DELETE;
            }
          },
          xFullPathname: function (pVfs, zName, nOut, pOut) {
            const i = wasm.cstrncpy(pOut, zName, nOut);
            return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
          },
          xGetLastError: function (pVfs, nOut, pOut) {
            const pool = getPoolForVfs(pVfs);
            const e = pool.popErr();
            pool.log(`xGetLastError ${nOut} e =`, e);
            if (e) {
              const scope = wasm.scopedAllocPush();
              try {
                const [cMsg, n] = wasm.scopedAllocCString(e.message, true);
                wasm.cstrncpy(pOut, cMsg, nOut);
                if (n > nOut) wasm.poke8(pOut + nOut - 1, 0);
              } catch (e) {
                return capi.SQLITE_NOMEM;
              } finally {
                wasm.scopedAllocPop(scope);
              }
            }
            return e ? e.sqlite3Rc || capi.SQLITE_IOERR : 0;
          },

          xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
            const pool = getPoolForVfs(pVfs);
            try {
              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);

              const path =
                zName && wasm.peek8(zName)
                  ? pool.getPath(zName)
                  : getRandomName();
              let sah = pool.getSAHForPath(path);
              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {
                if (pool.getFileCount() < pool.getCapacity()) {
                  sah = pool.nextAvailableSAH();
                  pool.setAssociatedPath(sah, path, flags);
                } else {
                  toss('SAH pool is full. Cannot create file', path);
                }
              }
              if (!sah) {
                toss('file not found:', path);
              }

              const file = { path, flags, sah };
              pool.mapS3FileToOFile(pFile, file);
              file.lockType = capi.SQLITE_LOCK_NONE;
              const sq3File = new capi.sqlite3_file(pFile);
              sq3File.$pMethods = opfsIoMethods.pointer;
              sq3File.dispose();
              wasm.poke32(pOutFlags, flags);
              return 0;
            } catch (e) {
              pool.storeErr(e);
              return capi.SQLITE_CANTOPEN;
            }
          },
        };

        const createOpfsVfs = function (vfsName) {
          if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {
            toss3('VFS name is already registered:', vfsName);
          }
          const opfsVfs = new capi.sqlite3_vfs();

          const pDVfs = capi.sqlite3_vfs_find(null);
          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
          opfsVfs.$iVersion = 2;
          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
          opfsVfs.addOnDispose(
            (opfsVfs.$zName = wasm.allocCString(vfsName)),
            () => setPoolForVfs(opfsVfs.pointer, 0),
          );

          if (dVfs) {
            opfsVfs.$xRandomness = dVfs.$xRandomness;
            opfsVfs.$xSleep = dVfs.$xSleep;
            dVfs.dispose();
          }
          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
            vfsMethods.xRandomness = function (pVfs, nOut, pOut) {
              const heap = wasm.heap8u();
              let i = 0;
              for (; i < nOut; ++i)
                heap[pOut + i] = (Math.random() * 255000) & 0xff;
              return i;
            };
          }
          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
            vfsMethods.xSleep = (pVfs, ms) => 0;
          }
          sqlite3.vfs.installVfs({
            vfs: { struct: opfsVfs, methods: vfsMethods },
          });
          return opfsVfs;
        };

        class OpfsSAHPool {
          vfsDir;

          #dhVfsRoot;

          #dhOpaque;

          #dhVfsParent;

          #mapSAHToName = new Map();

          #mapFilenameToSAH = new Map();

          #availableSAH = new Set();

          #mapS3FileToOFile_ = new Map();

          #apBody = new Uint8Array(HEADER_CORPUS_SIZE);

          #dvBody;

          #cVfs;

          #verbosity;

          constructor(options = Object.create(null)) {
            this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
            this.vfsName = options.name || optionDefaults.name;
            this.#cVfs = createOpfsVfs(this.vfsName);
            setPoolForVfs(this.#cVfs.pointer, this);
            this.vfsDir = options.directory || '.' + this.vfsName;
            this.#dvBody = new DataView(
              this.#apBody.buffer,
              this.#apBody.byteOffset,
            );
            this.isReady = this.reset(
              !!(options.clearOnInit ?? optionDefaults.clearOnInit),
            ).then(() => {
              if (this.$error) throw this.$error;
              return this.getCapacity()
                ? Promise.resolve(undefined)
                : this.addCapacity(
                    options.initialCapacity || optionDefaults.initialCapacity,
                  );
            });
          }

          #logImpl(level, ...args) {
            if (this.#verbosity > level)
              loggers[level](this.vfsName + ':', ...args);
          }
          log(...args) {
            this.#logImpl(2, ...args);
          }
          warn(...args) {
            this.#logImpl(1, ...args);
          }
          error(...args) {
            this.#logImpl(0, ...args);
          }

          getVfs() {
            return this.#cVfs;
          }

          getCapacity() {
            return this.#mapSAHToName.size;
          }

          getFileCount() {
            return this.#mapFilenameToSAH.size;
          }

          getFileNames() {
            const rc = [];
            const iter = this.#mapFilenameToSAH.keys();
            for (const n of iter) rc.push(n);
            return rc;
          }

          async addCapacity(n) {
            for (let i = 0; i < n; ++i) {
              const name = getRandomName();
              const h = await this.#dhOpaque.getFileHandle(name, {
                create: true,
              });
              const ah = await h.createSyncAccessHandle();
              this.#mapSAHToName.set(ah, name);
              this.setAssociatedPath(ah, '', 0);
            }
            return this.getCapacity();
          }

          async reduceCapacity(n) {
            let nRm = 0;
            for (const ah of Array.from(this.#availableSAH)) {
              if (nRm === n || this.getFileCount() === this.getCapacity()) {
                break;
              }
              const name = this.#mapSAHToName.get(ah);

              ah.close();
              await this.#dhOpaque.removeEntry(name);
              this.#mapSAHToName.delete(ah);
              this.#availableSAH.delete(ah);
              ++nRm;
            }
            return nRm;
          }

          releaseAccessHandles() {
            for (const ah of this.#mapSAHToName.keys()) ah.close();
            this.#mapSAHToName.clear();
            this.#mapFilenameToSAH.clear();
            this.#availableSAH.clear();
          }

          async acquireAccessHandles(clearFiles) {
            const files = [];
            for await (const [name, h] of this.#dhOpaque) {
              if ('file' === h.kind) {
                files.push([name, h]);
              }
            }
            return Promise.all(
              files.map(async ([name, h]) => {
                try {
                  const ah = await h.createSyncAccessHandle();
                  this.#mapSAHToName.set(ah, name);
                  if (clearFiles) {
                    ah.truncate(HEADER_OFFSET_DATA);
                    this.setAssociatedPath(ah, '', 0);
                  } else {
                    const path = this.getAssociatedPath(ah);
                    if (path) {
                      this.#mapFilenameToSAH.set(path, ah);
                    } else {
                      this.#availableSAH.add(ah);
                    }
                  }
                } catch (e) {
                  this.storeErr(e);
                  this.releaseAccessHandles();
                  throw e;
                }
              }),
            );
          }

          getAssociatedPath(sah) {
            sah.read(this.#apBody, { at: 0 });

            const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
            if (
              this.#apBody[0] &&
              (flags & capi.SQLITE_OPEN_DELETEONCLOSE ||
                (flags & PERSISTENT_FILE_TYPES) === 0)
            ) {
              warn(
                `Removing file with unexpected flags ${flags.toString(16)}`,
                this.#apBody,
              );
              this.setAssociatedPath(sah, '', 0);
              return '';
            }

            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
            const compDigest = this.computeDigest(this.#apBody);
            if (fileDigest.every((v, i) => v === compDigest[i])) {
              const pathBytes = this.#apBody.findIndex((v) => 0 === v);
              if (0 === pathBytes) {
                sah.truncate(HEADER_OFFSET_DATA);
              }
              return pathBytes
                ? textDecoder.decode(this.#apBody.subarray(0, pathBytes))
                : '';
            } else {
              warn('Disassociating file with bad digest.');
              this.setAssociatedPath(sah, '', 0);
              return '';
            }
          }

          setAssociatedPath(sah, path, flags) {
            const enc = textEncoder.encodeInto(path, this.#apBody);
            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
              toss('Path too long:', path);
            }
            this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
            this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);

            const digest = this.computeDigest(this.#apBody);
            sah.write(this.#apBody, { at: 0 });
            sah.write(digest, { at: HEADER_OFFSET_DIGEST });
            sah.flush();

            if (path) {
              this.#mapFilenameToSAH.set(path, sah);
              this.#availableSAH.delete(sah);
            } else {
              sah.truncate(HEADER_OFFSET_DATA);
              this.#availableSAH.add(sah);
            }
          }

          computeDigest(byteArray) {
            let h1 = 0xdeadbeef;
            let h2 = 0x41c6ce57;
            for (const v of byteArray) {
              h1 = 31 * h1 + v * 307;
              h2 = 31 * h2 + v * 307;
            }
            return new Uint32Array([h1 >>> 0, h2 >>> 0]);
          }

          async reset(clearFiles) {
            await this.isReady;
            let h = await navigator.storage.getDirectory();
            let prev, prevName;
            for (const d of this.vfsDir.split('/')) {
              if (d) {
                prev = h;
                h = await h.getDirectoryHandle(d, { create: true });
              }
            }
            this.#dhVfsRoot = h;
            this.#dhVfsParent = prev;
            this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
              OPAQUE_DIR_NAME,
              { create: true },
            );
            this.releaseAccessHandles();
            return this.acquireAccessHandles(clearFiles);
          }

          getPath(arg) {
            if (wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);
            return (
              arg instanceof URL ? arg : new URL(arg, 'file://localhost/')
            ).pathname;
          }

          deletePath(path) {
            const sah = this.#mapFilenameToSAH.get(path);
            if (sah) {
              this.#mapFilenameToSAH.delete(path);
              this.setAssociatedPath(sah, '', 0);
            }
            return !!sah;
          }

          storeErr(e, code) {
            if (e) {
              e.sqlite3Rc = code || capi.SQLITE_IOERR;
              this.error(e);
            }
            this.$error = e;
            return code;
          }

          popErr() {
            const rc = this.$error;
            this.$error = undefined;
            return rc;
          }

          nextAvailableSAH() {
            const [rc] = this.#availableSAH.keys();
            return rc;
          }

          getOFileForS3File(pFile) {
            return this.#mapS3FileToOFile_.get(pFile);
          }

          mapS3FileToOFile(pFile, file) {
            if (file) {
              this.#mapS3FileToOFile_.set(pFile, file);
              setPoolForPFile(pFile, this);
            } else {
              this.#mapS3FileToOFile_.delete(pFile);
              setPoolForPFile(pFile, false);
            }
          }

          hasFilename(name) {
            return this.#mapFilenameToSAH.has(name);
          }

          getSAHForPath(path) {
            return this.#mapFilenameToSAH.get(path);
          }

          async removeVfs() {
            if (!this.#cVfs.pointer || !this.#dhOpaque) return false;
            capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
            this.#cVfs.dispose();
            try {
              this.releaseAccessHandles();
              await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {
                recursive: true,
              });
              this.#dhOpaque = undefined;
              await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {
                recursive: true,
              });
              this.#dhVfsRoot = this.#dhVfsParent = undefined;
            } catch (e) {
              sqlite3.config.error(this.vfsName, 'removeVfs() failed:', e);
            }
            return true;
          }

          exportFile(name) {
            const sah =
              this.#mapFilenameToSAH.get(name) || toss('File not found:', name);
            const n = sah.getSize() - HEADER_OFFSET_DATA;
            const b = new Uint8Array(n > 0 ? n : 0);
            if (n > 0) {
              const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });
              if (nRead != n) {
                toss(
                  'Expected to read ' + n + ' bytes but read ' + nRead + '.',
                );
              }
            }
            return b;
          }

          async importDbChunked(name, callback) {
            const sah =
              this.#mapFilenameToSAH.get(name) ||
              this.nextAvailableSAH() ||
              toss('No available handles to import to.');
            sah.truncate(0);
            let nWrote = 0,
              chunk,
              checkedHeader = false,
              err = false;
            try {
              while (undefined !== (chunk = await callback())) {
                if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
                if (0 === nWrote && chunk.byteLength >= 15) {
                  util.affirmDbHeader(chunk);
                  checkedHeader = true;
                }
                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                nWrote += chunk.byteLength;
              }
              if (nWrote < 512 || 0 !== nWrote % 512) {
                toss(
                  'Input size',
                  nWrote,
                  'is not correct for an SQLite database.',
                );
              }
              if (!checkedHeader) {
                const header = new Uint8Array(20);
                sah.read(header, { at: 0 });
                util.affirmDbHeader(header);
              }
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18,
              });
            } catch (e) {
              this.setAssociatedPath(sah, '', 0);
              throw e;
            }
            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            return nWrote;
          }

          importDb(name, bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            else if (bytes instanceof Function)
              return this.importDbChunked(name, bytes);
            const sah =
              this.#mapFilenameToSAH.get(name) ||
              this.nextAvailableSAH() ||
              toss('No available handles to import to.');
            const n = bytes.byteLength;
            if (n < 512 || n % 512 != 0) {
              toss('Byte array size is invalid for an SQLite db.');
            }
            const header = 'SQLite format 3';
            for (let i = 0; i < header.length; ++i) {
              if (header.charCodeAt(i) !== bytes[i]) {
                toss('Input does not contain an SQLite database header.');
              }
            }
            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
            if (nWrote != n) {
              this.setAssociatedPath(sah, '', 0);
              toss(
                'Expected to write ' + n + ' bytes but wrote ' + nWrote + '.',
              );
            } else {
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18,
              });
              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            }
            return nWrote;
          }
        }

        class OpfsSAHPoolUtil {
          #p;

          constructor(sahPool) {
            this.#p = sahPool;
            this.vfsName = sahPool.vfsName;
          }

          async addCapacity(n) {
            return this.#p.addCapacity(n);
          }

          async reduceCapacity(n) {
            return this.#p.reduceCapacity(n);
          }

          getCapacity() {
            return this.#p.getCapacity(this.#p);
          }

          getFileCount() {
            return this.#p.getFileCount();
          }
          getFileNames() {
            return this.#p.getFileNames();
          }

          async reserveMinimumCapacity(min) {
            const c = this.#p.getCapacity();
            return c < min ? this.#p.addCapacity(min - c) : c;
          }

          exportFile(name) {
            return this.#p.exportFile(name);
          }

          importDb(name, bytes) {
            return this.#p.importDb(name, bytes);
          }

          async wipeFiles() {
            return this.#p.reset(true);
          }

          unlink(filename) {
            return this.#p.deletePath(filename);
          }

          async removeVfs() {
            return this.#p.removeVfs();
          }
        }

        const apiVersionCheck = async () => {
          const dh = await navigator.storage.getDirectory();
          const fn = '.opfs-sahpool-sync-check-' + getRandomName();
          const fh = await dh.getFileHandle(fn, { create: true });
          const ah = await fh.createSyncAccessHandle();
          const close = ah.close();
          await close;
          await dh.removeEntry(fn);
          if (close?.then) {
            toss(
              'The local OPFS API is too old for opfs-sahpool:',
              'it has an async FileSystemSyncAccessHandle.close() method.',
            );
          }
          return true;
        };

        let instanceCounter = 0;

        sqlite3.installOpfsSAHPoolVfs = async function (
          options = Object.create(null),
        ) {
          const vfsName = options.name || optionDefaults.name;
          if (false) {}
          if (initPromises[vfsName]) {
            return initPromises[vfsName];
          }
          if (
            !globalThis.FileSystemHandle ||
            !globalThis.FileSystemDirectoryHandle ||
            !globalThis.FileSystemFileHandle ||
            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
            !navigator?.storage?.getDirectory
          ) {
            return (initPromises[vfsName] = Promise.reject(
              new Error('Missing required OPFS APIs.'),
            ));
          }

          return (initPromises[vfsName] = apiVersionCheck()
            .then(async function () {
              if (options.$testThrowInInit) {
                throw options.$testThrowInInit;
              }
              const thePool = new OpfsSAHPool(options);
              return thePool.isReady
                .then(async () => {
                  const poolUtil = new OpfsSAHPoolUtil(thePool);
                  if (sqlite3.oo1) {
                    const oo1 = sqlite3.oo1;
                    const theVfs = thePool.getVfs();
                    const OpfsSAHPoolDb = function (...args) {
                      const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                      opt.vfs = theVfs.$zName;
                      oo1.DB.dbCtorHelper.call(this, opt);
                    };
                    OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);

                    poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
                    oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                      theVfs.pointer,
                      function (oo1Db, sqlite3) {
                        sqlite3.capi.sqlite3_exec(
                          oo1Db,
                          [
                            'pragma journal_mode=DELETE;',
                            'pragma cache_size=-16384;',
                          ],
                          0,
                          0,
                          0,
                        );
                      },
                    );
                  }
                  thePool.log('VFS initialized.');
                  return poolUtil;
                })
                .catch(async (e) => {
                  await thePool.removeVfs().catch(() => {});
                  throw e;
                });
            })
            .catch((err) => {
              return (initPromises[vfsName] = Promise.reject(err));
            }));
        };
      });

      ('use strict');
      if ('undefined' !== typeof Module) {
        const SABC = Object.assign(
          Object.create(null),
          {
            exports:
              'undefined' === typeof wasmExports ? Module['asm'] : wasmExports,
            memory: Module.wasmMemory,
          },
          globalThis.sqlite3ApiConfig || {},
        );

        globalThis.sqlite3ApiConfig = SABC;
        let sqlite3;
        try {
          sqlite3 = globalThis.sqlite3ApiBootstrap();
        } catch (e) {
          console.error('sqlite3ApiBootstrap() error:', e);
          throw e;
        } finally {
          delete globalThis.sqlite3ApiBootstrap;
          delete globalThis.sqlite3ApiConfig;
        }

        Module.sqlite3 = sqlite3;
      } else {
        console.warn(
          'This is not running in an Emscripten module context, so',
          'globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack',
          'of config info for the WASM environment.',
          'It must be called manually.',
        );
      }
    });

    return sqlite3InitModule.ready;
  };
})();

const toExportForESM = (function () {
  const originalInit = sqlite3InitModule;
  if (!originalInit) {
    throw new Error(
      'Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.',
    );
  }

  const initModuleState = (globalThis.sqlite3InitModuleState = Object.assign(
    Object.create(null),
    {
      moduleScript: globalThis?.document?.currentScript,
      isWorker: 'undefined' !== typeof WorkerGlobalScope,
      location: globalThis.location,
      urlParams: globalThis?.location?.href
        ? new URL(globalThis.location.href).searchParams
        : new URLSearchParams(),
    },
  ));
  initModuleState.debugModule = initModuleState.urlParams.has(
    'sqlite3.debugModule',
  )
    ? (...args) => console.warn('sqlite3.debugModule:', ...args)
    : () => {};

  if (initModuleState.urlParams.has('sqlite3.dir')) {
    initModuleState.sqlite3Dir =
      initModuleState.urlParams.get('sqlite3.dir') + '/';
  } else if (initModuleState.moduleScript) {
    const li = initModuleState.moduleScript.src.split('/');
    li.pop();
    initModuleState.sqlite3Dir = li.join('/') + '/';
  }

  globalThis.sqlite3InitModule = function ff(...args) {
    return originalInit(...args)
      .then((EmscriptenModule) => {
        const s = EmscriptenModule.sqlite3;
        s.scriptInfo = initModuleState;

        if (ff.__isUnderTest) s.__isUnderTest = true;
        const f = s.asyncPostInit;
        delete s.asyncPostInit;
        return f();
      })
      .catch((e) => {
        console.error('Exception loading sqlite3 module:', e);
        throw e;
      });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;

  if (globalThis.sqlite3InitModuleState.moduleScript) {
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split('/');
    src.pop();
    sim.scriptDir = src.join('/') + '/';
  }
  initModuleState.debugModule('sqlite3InitModuleState =', initModuleState);
  if (false) {}
  return globalThis.sqlite3InitModule;
})();
sqlite3InitModule = toExportForESM;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sqlite3InitModule);


/***/ }),

/***/ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm":
/*!******************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "b4d6efa36bdb8259647a.wasm";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "./chunk/" + chunkId + "." + "624040443756e43f7d99" + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "/../../";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"vendors-node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-worker1-bundler-friendly_mjs": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!******************************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-bundler-friendly.mjs ***!
  \******************************************************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite3-bundler-friendly.mjs */ "./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs");
/*
  2022-05-23

  The author disclaims copyright to this source code.  In place of a
  legal notice, here is a blessing:

  *   May you do good and not evil.
  *   May you find forgiveness for yourself and forgive others.
  *   May you share freely, never taking more than you give.

  ***********************************************************************

  This is a JS Worker file for the main sqlite3 api. It loads
  sqlite3.js, initializes the module, and postMessage()'s a message
  after the module is initialized:

  {type: 'sqlite3-api', result: 'worker1-ready'}

  This seemingly superfluous level of indirection is necessary when
  loading sqlite3.js via a Worker. Instantiating a worker with new
  Worker("sqlite.js") will not (cannot) call sqlite3InitModule() to
  initialize the module due to a timing/order-of-operations conflict
  (and that symbol is not exported in a way that a Worker loading it
  that way can see it).  Thus JS code wanting to load the sqlite3
  Worker-specific API needs to pass _this_ file (or equivalent) to the
  Worker constructor and then listen for an event in the form shown
  above in order to know when the module has completed initialization.

  This file accepts a URL arguments to adjust how it loads sqlite3.js:

  - `sqlite3.dir`, if set, treats the given directory name as the
    directory from which `sqlite3.js` will be loaded.
*/

(0,_sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])().then((sqlite3) => sqlite3.initWorker1API());

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jaHVuay92ZW5kb3JzLW5vZGVfbW9kdWxlc19zcWxpdGVfb3JnX3NxbGl0ZS13YXNtX3NxbGl0ZS13YXNtX2pzd2FzbV9zcWxpdGUzLXdvcmtlcjEtYnVuZGxlci1mcmllbmRseV9tanMuMzJiYWViOTdjZTM3YzRkYmQxYTQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUpBQWU7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxNQUFLO0FBQ3hDLFFBQVEsQ0FBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0JBQStCLDJKQUErQjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0QkFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0QkFBNEI7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUIsdURBQXVEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELHFCQUFxQjs7QUFFeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaURBQWlELHFCQUFxQjs7QUFFdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXOztBQUVYLDZCQUE2QjtBQUM3QixVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakIsa0VBQWtFOztBQUVsRSwrQ0FBK0M7QUFDL0MsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFDLEVBQUUsRUFLTixDQUFDO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELDRCQUE0QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxLQUFDLEVBQUUsRUFnQk47O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLEtBQTBELEVBQUUsRUFNL0Q7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFDLEdBQUcsQ0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsWUFBWTtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSx1REFBdUQ7QUFDdkQsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBQztBQUNuQixnQkFBZ0IsRUFLRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTLFFBQVEsU0FBUztBQUMxQixPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBQyxpQ0FBaUMsQ0FBSzs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0xBQThDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFLDZCQUE2QiwyQ0FBMkM7QUFDeEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxFQUFFLEdBQUcsSUFBSSxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxFQUFFLEdBQUcsRUFBRSxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCLEVBQUUsTUFBTTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0NBQXNDO0FBQ3pELFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDLGdDQUFnQywwQkFBMEI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdCQUF3QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUE0QixFQUFFLEVBRWpDO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFDLEVBQUUsRUFTTjtBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUVBQWUsaUJBQWlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDNW5jakM7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ2xCQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7O1dBRUE7O1dBRUE7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUM4RTtBQUM5RSx5RUFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TUUxpdGUtV2ViQ2xpZW50L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9TUUxpdGUtV2ViQ2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLWJ1bmRsZXItZnJpZW5kbHkubWpzIiwid2VicGFjazovL1NRTGl0ZS1XZWJDbGllbnQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vU1FMaXRlLVdlYkNsaWVudC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vU1FMaXRlLVdlYkNsaWVudC93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vU1FMaXRlLVdlYkNsaWVudC93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL1NRTGl0ZS1XZWJDbGllbnQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9TUUxpdGUtV2ViQ2xpZW50L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vU1FMaXRlLVdlYkNsaWVudC93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9TUUxpdGUtV2ViQ2xpZW50L3dlYnBhY2svcnVudGltZS9pbXBvcnRTY3JpcHRzIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vU1FMaXRlLVdlYkNsaWVudC8uL25vZGVfbW9kdWxlcy9Ac3FsaXRlLm9yZy9zcWxpdGUtd2FzbS9zcWxpdGUtd2FzbS9qc3dhc20vc3FsaXRlMy13b3JrZXIxLWJ1bmRsZXItZnJpZW5kbHkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gIiwiLypcbiAqKiBMSUNFTlNFIGZvciB0aGUgc3FsaXRlMyBXZWJBc3NlbWJseS9KYXZhU2NyaXB0IEFQSXMuXG4gKipcbiAqKiBUaGlzIGJ1bmRsZSAodHlwaWNhbGx5IHJlbGVhc2VkIGFzIHNxbGl0ZTMuanMgb3Igc3FsaXRlMy5tanMpXG4gKiogaXMgYW4gYW1hbGdhbWF0aW9uIG9mIEphdmFTY3JpcHQgc291cmNlIGNvZGUgZnJvbSB0d28gcHJvamVjdHM6XG4gKipcbiAqKiAxKSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnOiB0aGUgRW1zY3JpcHRlbiBcImdsdWUgY29kZVwiIGlzIGNvdmVyZWQgYnlcbiAqKiAgICB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlIGFuZCBVbml2ZXJzaXR5IG9mIElsbGlub2lzL05DU0FcbiAqKiAgICBPcGVuIFNvdXJjZSBMaWNlbnNlLCBhcyBkZXNjcmliZWQgYXQ6XG4gKipcbiAqKiAgICBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvaW50cm9kdWNpbmdfZW1zY3JpcHRlbi9lbXNjcmlwdGVuX2xpY2Vuc2UuaHRtbFxuICoqXG4gKiogMikgaHR0cHM6Ly9zcWxpdGUub3JnOiBhbGwgY29kZSBhbmQgZG9jdW1lbnRhdGlvbiBsYWJlbGVkIGFzIGJlaW5nXG4gKiogICAgZnJvbSB0aGlzIHNvdXJjZSBhcmUgcmVsZWFzZWQgdW5kZXIgdGhlIHNhbWUgdGVybXMgYXMgdGhlIHNxbGl0ZTNcbiAqKiAgICBDIGxpYnJhcnk6XG4gKipcbiAqKiAyMDIyLTEwLTE2XG4gKipcbiAqKiBUaGUgYXV0aG9yIGRpc2NsYWltcyBjb3B5cmlnaHQgdG8gdGhpcyBzb3VyY2UgY29kZS4gIEluIHBsYWNlIG9mIGFcbiAqKiBsZWdhbCBub3RpY2UsIGhlcmUgaXMgYSBibGVzc2luZzpcbiAqKlxuICoqICogICBNYXkgeW91IGRvIGdvb2QgYW5kIG5vdCBldmlsLlxuICoqICogICBNYXkgeW91IGZpbmQgZm9yZ2l2ZW5lc3MgZm9yIHlvdXJzZWxmIGFuZCBmb3JnaXZlIG90aGVycy5cbiAqKiAqICAgTWF5IHlvdSBzaGFyZSBmcmVlbHksIG5ldmVyIHRha2luZyBtb3JlIHRoYW4geW91IGdpdmUuXG4gKi9cbi8qXG4gKiogVGhpcyBjb2RlIHdhcyBidWlsdCBmcm9tIHNxbGl0ZTMgdmVyc2lvbi4uLlxuICoqXG4gKiogU1FMSVRFX1ZFUlNJT04gXCIzLjQ1LjNcIlxuICoqIFNRTElURV9WRVJTSU9OX05VTUJFUiAzMDQ1MDAzXG4gKiogU1FMSVRFX1NPVVJDRV9JRCBcIjIwMjQtMDQtMTUgMTM6MzQ6MDUgODY1M2I3NTg4NzBlNmVmMGM5OGQ0NmIzYWNlMjc4NDkwNTRhZjg1ZGE4OTFlYjEyMWU5YWFhNTM3ZjFlODM1NVwiXG4gKipcbiAqKiBVc2luZyB0aGUgRW1zY3JpcHRlbiBTREsgdmVyc2lvbiAzLjEuMzAuXG4gKi9cblxudmFyIHNxbGl0ZTNJbml0TW9kdWxlID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHREaXIgPSBpbXBvcnQubWV0YS51cmw7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB2YXIgc3FsaXRlM0luaXRNb2R1bGUgPSBjb25maWcgfHwge307XG5cbiAgICB2YXIgTW9kdWxlID1cbiAgICAgIHR5cGVvZiBzcWxpdGUzSW5pdE1vZHVsZSAhPSAndW5kZWZpbmVkJyA/IHNxbGl0ZTNJbml0TW9kdWxlIDoge307XG5cbiAgICB2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSwgcmVhZHlQcm9taXNlUmVqZWN0O1xuICAgIE1vZHVsZVsncmVhZHknXSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcmVhZHlQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUgfHxcbiAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICBkZWJ1Z01vZHVsZTogKCkgPT4ge30sXG4gICAgICB9KTtcbiAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlO1xuICAgIHNxbGl0ZTNJbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoXG4gICAgICAnZ2xvYmFsVGhpcy5sb2NhdGlvbiA9JyxcbiAgICAgIGdsb2JhbFRoaXMubG9jYXRpb24sXG4gICAgKTtcblxuICAgIGNvbnN0IHhOYW1lT2ZJbnN0YW50aWF0ZVdhc20gPSBmYWxzZVxuICAgICAgPyAnaW5zdGFudGlhdGVXYXNtJ1xuICAgICAgOiAnZW1zY3JpcHRlbi1idWctMTc5NTEnO1xuICAgIE1vZHVsZVt4TmFtZU9mSW5zdGFudGlhdGVXYXNtXSA9IGZ1bmN0aW9uIGNhbGxlZShpbXBvcnRzLCBvblN1Y2Nlc3MpIHtcbiAgICAgIGltcG9ydHMuZW52LmZvbyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgY29uc3QgdXJpID0gTW9kdWxlLmxvY2F0ZUZpbGUoXG4gICAgICAgIGNhbGxlZS51cmksXG4gICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2Ygc2NyaXB0RGlyZWN0b3J5ID8gJycgOiBzY3JpcHREaXJlY3RvcnksXG4gICAgICApO1xuICAgICAgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZSgnaW5zdGFudGlhdGVXYXNtKCkgdXJpID0nLCB1cmkpO1xuICAgICAgY29uc3Qgd2ZldGNoID0gKCkgPT4gZmV0Y2godXJpLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pO1xuICAgICAgY29uc3QgbG9hZFdhc20gPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ1xuICAgICAgICA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh3ZmV0Y2goKSwgaW1wb3J0cykudGhlbihcbiAgICAgICAgICAgICAgKGFyZykgPT4gb25TdWNjZXNzKGFyZy5pbnN0YW5jZSwgYXJnLm1vZHVsZSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gd2ZldGNoKClcbiAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgICAgICAudGhlbigoYnl0ZXMpID0+IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKSlcbiAgICAgICAgICAgICAgLnRoZW4oKGFyZykgPT4gb25TdWNjZXNzKGFyZy5pbnN0YW5jZSwgYXJnLm1vZHVsZSkpO1xuICAgICAgICAgIH07XG4gICAgICBsb2FkV2FzbSgpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG5cbiAgICBNb2R1bGVbeE5hbWVPZkluc3RhbnRpYXRlV2FzbV0udXJpID0gJ3NxbGl0ZTMud2FzbSc7XG5cbiAgICB2YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcblxuICAgIHZhciBhcmd1bWVudHNfID0gW107XG4gICAgdmFyIHRoaXNQcm9ncmFtID0gJy4vdGhpcy5wcm9ncmFtJztcbiAgICB2YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gICAgICB0aHJvdyB0b1Rocm93O1xuICAgIH07XG5cbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfV0VCID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JztcbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gJ2Z1bmN0aW9uJztcblxuICAgIHZhciBFTlZJUk9OTUVOVF9JU19OT0RFID1cbiAgICAgIHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSAnc3RyaW5nJztcbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPVxuICAgICAgIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG4gICAgdmFyIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICAgIGZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xuICAgICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICAgIHJldHVybiBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG4gICAgfVxuXG4gICAgdmFyIHJlYWRfLCByZWFkQXN5bmMsIHJlYWRCaW5hcnksIHNldFdpbmRvd1RpdGxlO1xuXG4gICAgaWYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgICAgIH1cblxuICAgICAgaWYgKF9zY3JpcHREaXIpIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKCdibG9iOicpICE9PSAwKSB7XG4gICAgICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywgJycpLmxhc3RJbmRleE9mKCcvJykgKyAxLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVhZF8gPSAodXJsKSA9PiB7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICAgICAgICAgcmVhZEJpbmFyeSA9ICh1cmwpID0+IHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZEFzeW5jID0gKHVybCwgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB4aHIub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNldFdpbmRvd1RpdGxlID0gKHRpdGxlKSA9PiAoZG9jdW1lbnQudGl0bGUgPSB0aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gTW9kdWxlWydwcmludCddIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgdmFyIGVyciA9IE1vZHVsZVsncHJpbnRFcnInXSB8fCBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcblxuICAgIE9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuXG4gICAgbW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcblxuICAgIGlmIChNb2R1bGVbJ2FyZ3VtZW50cyddKSBhcmd1bWVudHNfID0gTW9kdWxlWydhcmd1bWVudHMnXTtcblxuICAgIGlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO1xuXG4gICAgaWYgKE1vZHVsZVsncXVpdCddKSBxdWl0XyA9IE1vZHVsZVsncXVpdCddO1xuXG4gICAgdmFyIFNUQUNLX0FMSUdOID0gMTY7XG4gICAgdmFyIFBPSU5URVJfU0laRSA9IDQ7XG5cbiAgICBmdW5jdGlvbiBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgIGNhc2UgJ3U4JzpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgY2FzZSAndTE2JzpcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgY2FzZSAndTMyJzpcbiAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgY2FzZSAndTY0JzpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICAgICAgICByZXR1cm4gUE9JTlRFUl9TSVpFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZVswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gTnVtYmVyKHR5cGUuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgICAgYml0cyAlIDggPT09IDAsXG4gICAgICAgICAgICAgICdnZXROYXRpdmVUeXBlU2l6ZSBpbnZhbGlkIGJpdHMgJyArIGJpdHMgKyAnLCB0eXBlICcgKyB0eXBlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBiaXRzIC8gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2FzbUJpbmFyeTtcbiAgICBpZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHdhc21CaW5hcnkgPSBNb2R1bGVbJ3dhc21CaW5hcnknXTtcbiAgICB2YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVsnbm9FeGl0UnVudGltZSddIHx8IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9ICdvYmplY3QnKSB7XG4gICAgICBhYm9ydCgnbm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIHZhciB3YXNtTWVtb3J5O1xuXG4gICAgdmFyIEFCT1JUID0gZmFsc2U7XG5cbiAgICB2YXIgRVhJVFNUQVRVUztcblxuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGFib3J0KHRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBVVEY4RGVjb2RlciA9XG4gICAgICB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuICAgIGZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXBPckFycmF5LCBpZHgsIG1heEJ5dGVzVG9SZWFkKSB7XG4gICAgICB2YXIgZW5kSWR4ID0gaWR4ICsgbWF4Qnl0ZXNUb1JlYWQ7XG4gICAgICB2YXIgZW5kUHRyID0gaWR4O1xuXG4gICAgICB3aGlsZSAoaGVhcE9yQXJyYXlbZW5kUHRyXSAmJiAhKGVuZFB0ciA+PSBlbmRJZHgpKSArK2VuZFB0cjtcblxuICAgICAgaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIGhlYXBPckFycmF5LmJ1ZmZlciAmJiBVVEY4RGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgICAgICAgdmFyIHUwID0gaGVhcE9yQXJyYXlbaWR4KytdO1xuICAgICAgICBpZiAoISh1MCAmIDB4ODApKSB7XG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1MSA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgICBpZiAoKHUwICYgMHhlMCkgPT0gMHhjMCkge1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgodTAgJiAzMSkgPDwgNikgfCB1MSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICAgIGlmICgodTAgJiAweGYwKSA9PSAweGUwKSB7XG4gICAgICAgICAgdTAgPSAoKHUwICYgMTUpIDw8IDEyKSB8ICh1MSA8PCA2KSB8IHUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHUwID1cbiAgICAgICAgICAgICgodTAgJiA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgKHUxIDw8IDEyKSB8XG4gICAgICAgICAgICAodTIgPDwgNikgfFxuICAgICAgICAgICAgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1MCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoID0gdTAgLSAweDEwMDAwO1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgMHhkODAwIHwgKGNoID4+IDEwKSxcbiAgICAgICAgICAgIDB4ZGMwMCB8IChjaCAmIDB4M2ZmKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7XG4gICAgICByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgICAgIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKSByZXR1cm4gMDtcblxuICAgICAgdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xuICAgICAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAodSA+PSAweGQ4MDAgJiYgdSA8PSAweGRmZmYpIHtcbiAgICAgICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgICAgIHUgPSAoMHgxMDAwMCArICgodSAmIDB4M2ZmKSA8PCAxMCkpIHwgKHUxICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1IDw9IDB4N2YpIHtcbiAgICAgICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSB1O1xuICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMHg3ZmYpIHtcbiAgICAgICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhjMCB8ICh1ID4+IDYpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgaWYgKG91dElkeCArIDIgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ZTAgfCAodSA+PiAxMik7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvdXRJZHggKyAzID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweGYwIHwgKHUgPj4gMTgpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhlYXBbb3V0SWR4XSA9IDA7XG4gICAgICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgICAgIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHtcbiAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMHg3Zikge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPD0gMHg3ZmYpIHtcbiAgICAgICAgICBsZW4gKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGZmZikge1xuICAgICAgICAgIGxlbiArPSA0O1xuICAgICAgICAgICsraTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW4gKz0gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9XG5cbiAgICB2YXIgSEVBUCxcbiAgICAgIEhFQVA4LFxuICAgICAgSEVBUFU4LFxuICAgICAgSEVBUDE2LFxuICAgICAgSEVBUFUxNixcbiAgICAgIEhFQVAzMixcbiAgICAgIEhFQVBVMzIsXG4gICAgICBIRUFQRjMyLFxuICAgICAgSEVBUDY0LFxuICAgICAgSEVBUFU2NCxcbiAgICAgIEhFQVBGNjQ7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpIHtcbiAgICAgIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gICAgICBNb2R1bGVbJ0hFQVA4J10gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVAxNiddID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBVMTYnXSA9IEhFQVBVMTYgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBGMzInXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQRjY0J10gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUDY0J10gPSBIRUFQNjQgPSBuZXcgQmlnSW50NjRBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUFU2NCddID0gSEVBUFU2NCA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbiAgICB9XG5cbiAgICB2YXIgU1RBQ0tfU0laRSA9IDUyNDI4ODtcblxuICAgIHZhciBJTklUSUFMX01FTU9SWSA9IE1vZHVsZVsnSU5JVElBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjtcblxuICAgIGlmIChNb2R1bGVbJ3dhc21NZW1vcnknXSkge1xuICAgICAgd2FzbU1lbW9yeSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXNtTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAgIGluaXRpYWw6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzYsXG5cbiAgICAgICAgbWF4aW11bTogMjE0NzQ4MzY0OCAvIDY1NTM2LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcblxuICAgIElOSVRJQUxfTUVNT1JZID0gd2FzbU1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aDtcblxuICAgIHZhciB3YXNtVGFibGU7XG5cbiAgICB2YXIgX19BVFBSRVJVTl9fID0gW107XG4gICAgdmFyIF9fQVRJTklUX18gPSBbXTtcbiAgICB2YXIgX19BVEVYSVRfXyA9IFtdO1xuICAgIHZhciBfX0FUUE9TVFJVTl9fID0gW107XG5cbiAgICB2YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuICAgICAgcmV0dXJuIG5vRXhpdFJ1bnRpbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUnVuKCkge1xuICAgICAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZVJ1biddID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICAgICAgd2hpbGUgKE1vZHVsZVsncHJlUnVuJ10ubGVuZ3RoKSB7XG4gICAgICAgICAgYWRkT25QcmVSdW4oTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuICAgICAgcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgaWYgKCFNb2R1bGVbJ25vRlNJbml0J10gJiYgIUZTLmluaXQuaW5pdGlhbGl6ZWQpIEZTLmluaXQoKTtcbiAgICAgIEZTLmlnbm9yZVBlcm1pc3Npb25zID0gZmFsc2U7XG5cbiAgICAgIFRUWS5pbml0KCk7XG4gICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3N0UnVuKCkge1xuICAgICAgaWYgKE1vZHVsZVsncG9zdFJ1biddKSB7XG4gICAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtNb2R1bGVbJ3Bvc3RSdW4nXV07XG4gICAgICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgICAgICBhZGRPblBvc3RSdW4oTW9kdWxlWydwb3N0UnVuJ10uc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgICAgIF9fQVRJTklUX18udW5zaGlmdChjYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT25FeGl0KGNiKSB7fVxuXG4gICAgZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gICAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xuICAgIH1cblxuICAgIHZhciBydW5EZXBlbmRlbmNpZXMgPSAwO1xuICAgIHZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG4gICAgdmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICAgICAgcnVuRGVwZW5kZW5jaWVzKys7XG5cbiAgICAgIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgICAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgICAgIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gICAgICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICAgICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gICAgICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xuICAgICAgICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcbiAgICAgIGlmIChNb2R1bGVbJ29uQWJvcnQnXSkge1xuICAgICAgICBNb2R1bGVbJ29uQWJvcnQnXSh3aGF0KTtcbiAgICAgIH1cblxuICAgICAgd2hhdCA9ICdBYm9ydGVkKCcgKyB3aGF0ICsgJyknO1xuXG4gICAgICBlcnIod2hhdCk7XG5cbiAgICAgIEFCT1JUID0gdHJ1ZTtcbiAgICAgIEVYSVRTVEFUVVMgPSAxO1xuXG4gICAgICB3aGF0ICs9ICcuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uJztcblxuICAgICAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuXG4gICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cbiAgICBmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRmlsZVVSSShmaWxlbmFtZSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcbiAgICB9XG5cbiAgICB2YXIgd2FzbUJpbmFyeUZpbGU7XG4gICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICB3YXNtQmluYXJ5RmlsZSA9ICdzcWxpdGUzLndhc20nO1xuICAgICAgaWYgKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICAgICAgIHdhc21CaW5hcnlGaWxlID0gbG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhc21CaW5hcnlGaWxlID0gbmV3IFVSTCgnc3FsaXRlMy53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkQmluYXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgJ2JvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkJztcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhYm9ydChlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKSB7XG4gICAgICBpZiAoIXdhc21CaW5hcnkgJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgICBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgd2FzbUJpbmFyeUZpbGUgKyBcIidcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICBlbnY6IGFzbUxpYnJhcnlBcmcsXG4gICAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IGFzbUxpYnJhcnlBcmcsXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgICAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG5cbiAgICAgICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7XG5cbiAgICAgICAgd2FzbVRhYmxlID0gTW9kdWxlWydhc20nXVsnX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZSddO1xuXG4gICAgICAgIGFkZE9uSW5pdChNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKTtcblxuICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICAgICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKClcbiAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4ocmVjZWl2ZXIsIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIGVycignZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJyArIHJlYXNvbik7XG5cbiAgICAgICAgICAgIGFib3J0KHJlYXNvbik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2FzbUJpbmFyeSAmJlxuICAgICAgICAgIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkgJiZcbiAgICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSkudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGluZm8pO1xuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGVycignd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICcgKyByZWFzb24pO1xuICAgICAgICAgICAgICAgIGVycignZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBleHBvcnRzID0gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyKCdNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZSk7XG5cbiAgICAgICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5zdGFudGlhdGVBc3luYygpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBEb3VibGU7XG4gICAgdmFyIHRlbXBJNjQ7XG5cbiAgICB2YXIgQVNNX0NPTlNUUyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHRoaXMubmFtZSA9ICdFeGl0U3RhdHVzJztcbiAgICAgIHRoaXMubWVzc2FnZSA9ICdQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCcgKyBzdGF0dXMgKyAnKSc7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSAnKic7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgIHJldHVybiBIRUFQOFtwdHIgPj4gMF07XG4gICAgICAgIGNhc2UgJ2k4JzpcbiAgICAgICAgICByZXR1cm4gSEVBUDhbcHRyID4+IDBdO1xuICAgICAgICBjYXNlICdpMTYnOlxuICAgICAgICAgIHJldHVybiBIRUFQMTZbcHRyID4+IDFdO1xuICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgIHJldHVybiBIRUFQMzJbcHRyID4+IDJdO1xuICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgIHJldHVybiBIRUFQNjRbcHRyID4+IDNdO1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgcmV0dXJuIEhFQVBGMzJbcHRyID4+IDJdO1xuICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgIHJldHVybiBIRUFQRjY0W3B0ciA+PiAzXTtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmV0dXJuIEhFQVBVMzJbcHRyID4+IDJdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAnICsgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gJ2k4Jykge1xuICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9ICcqJztcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpMSc6XG4gICAgICAgICAgSEVBUDhbcHRyID4+IDBdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2k4JzpcbiAgICAgICAgICBIRUFQOFtwdHIgPj4gMF0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICBIRUFQMTZbcHRyID4+IDFdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2kzMic6XG4gICAgICAgICAgSEVBUDMyW3B0ciA+PiAyXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgICAgdmFsdWUgPj4+IDAsXG4gICAgICAgICAgICAoKHRlbXBEb3VibGUgPSB2YWx1ZSksXG4gICAgICAgICAgICArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMS4wXG4gICAgICAgICAgICAgID8gdGVtcERvdWJsZSA+IDAuMFxuICAgICAgICAgICAgICAgID8gKE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5Ni4wKSxcbiAgICAgICAgICAgICAgICAgICAgNDI5NDk2NzI5NS4wLFxuICAgICAgICAgICAgICAgICAgKSB8XG4gICAgICAgICAgICAgICAgICAgIDApID4+PlxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIDogfn4rTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICAodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2LjAsXG4gICAgICAgICAgICAgICAgICApID4+PiAwXG4gICAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgICAoSEVBUDMyW3B0ciA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgICAgKEhFQVAzMlsocHRyICsgNCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgIEhFQVBGMzJbcHRyID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgSEVBUEY2NFtwdHIgPj4gM10gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgSEVBUFUzMltwdHIgPj4gMl0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhYm9ydCgnaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJyArIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQQVRIID0ge1xuICAgICAgaXNBYnM6IChwYXRoKSA9PiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgICAgc3BsaXRQYXRoOiAoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID1cbiAgICAgICAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZUFycmF5OiAocGFydHMsIGFsbG93QWJvdmVSb290KSA9PiB7XG4gICAgICAgIHZhciB1cCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGZvciAoOyB1cDsgdXAtLSkge1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZTogKHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBQQVRILmlzQWJzKHBhdGgpLFxuICAgICAgICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnN1YnN0cigtMSkgPT09ICcvJztcblxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShcbiAgICAgICAgICBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApLFxuICAgICAgICAgICFpc0Fic29sdXRlLFxuICAgICAgICApLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgICAgICAgcGF0aCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbiAgICAgIH0sXG4gICAgICBkaXJuYW1lOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgcmVzdWx0ID0gUEFUSC5zcGxpdFBhdGgocGF0aCksXG4gICAgICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgICAgICBkaXIgPSByZXN1bHRbMV07XG4gICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QgKyBkaXI7XG4gICAgICB9LFxuICAgICAgYmFzZW5hbWU6IChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gLTEpIHJldHVybiBwYXRoO1xuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoICsgMSk7XG4gICAgICB9LFxuICAgICAgam9pbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbignLycpKTtcbiAgICAgIH0sXG4gICAgICBqb2luMjogKGwsIHIpID0+IHtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFJhbmRvbURldmljZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGNyeXB0byA9PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvWydnZXRSYW5kb21WYWx1ZXMnXSA9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdmFyIHJhbmRvbUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnVmZmVyKTtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tQnVmZmVyWzBdO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHJldHVybiAoKSA9PiBhYm9ydCgncmFuZG9tRGV2aWNlJyk7XG4gICAgfVxuXG4gICAgdmFyIFBBVEhfRlMgPSB7XG4gICAgICByZXNvbHZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSBpID49IDAgPyBhcmd1bWVudHNbaV0gOiBGUy5jd2QoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IFBBVEguaXNBYnMocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlZFBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KFxuICAgICAgICAgIHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKSxcbiAgICAgICAgICAhcmVzb2x2ZWRBYnNvbHV0ZSxcbiAgICAgICAgKS5qb2luKCcvJyk7XG4gICAgICAgIHJldHVybiAocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCB8fCAnLic7XG4gICAgICB9LFxuICAgICAgcmVsYXRpdmU6IChmcm9tLCB0bykgPT4ge1xuICAgICAgICBmcm9tID0gUEFUSF9GUy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgICAgICAgdG8gPSBQQVRIX0ZTLnJlc29sdmUodG8pLnN1YnN0cigxKTtcbiAgICAgICAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICAgICAgICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksIGRvbnRBZGROdWxsLCBsZW5ndGgpIHtcbiAgICAgIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpICsgMTtcbiAgICAgIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gICAgICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoXG4gICAgICAgIHN0cmluZ3ksXG4gICAgICAgIHU4YXJyYXksXG4gICAgICAgIDAsXG4gICAgICAgIHU4YXJyYXkubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XG4gICAgICByZXR1cm4gdThhcnJheTtcbiAgICB9XG4gICAgdmFyIFRUWSA9IHtcbiAgICAgIHR0eXM6IFtdLFxuICAgICAgaW5pdDogZnVuY3Rpb24gKCkge30sXG4gICAgICBzaHV0ZG93bjogZnVuY3Rpb24gKCkge30sXG4gICAgICByZWdpc3RlcjogZnVuY3Rpb24gKGRldiwgb3BzKSB7XG4gICAgICAgIFRUWS50dHlzW2Rldl0gPSB7IGlucHV0OiBbXSwgb3V0cHV0OiBbXSwgb3BzOiBvcHMgfTtcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCBUVFkuc3RyZWFtX29wcyk7XG4gICAgICB9LFxuICAgICAgc3RyZWFtX29wczoge1xuICAgICAgICBvcGVuOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO1xuICAgICAgICAgIGlmICghdHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS50dHkgPSB0dHk7XG4gICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZzeW5jOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICBieXRlc1JlYWQrKztcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIoc3RyZWFtLnR0eSwgYnVmZmVyW29mZnNldCArIGldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRfdHR5X29wczoge1xuICAgICAgICBnZXRfY2hhcjogZnVuY3Rpb24gKHR0eSkge1xuICAgICAgICAgIGlmICghdHR5LmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdy5wcm9tcHQgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoJ0lucHV0OiAnKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGxpbmUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZWFkbGluZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR0eS5pbnB1dCA9IGludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHR5LmlucHV0LnNoaWZ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1dF9jaGFyOiBmdW5jdGlvbiAodHR5LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHtcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmc3luYzogZnVuY3Rpb24gKHR0eSkge1xuICAgICAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZGVmYXVsdF90dHkxX29wczoge1xuICAgICAgICBwdXRfY2hhcjogZnVuY3Rpb24gKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnN5bmM6IGZ1bmN0aW9uICh0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gemVyb01lbW9yeShhZGRyZXNzLCBzaXplKSB7XG4gICAgICBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLCBhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoc2l6ZSAvIGFsaWdubWVudCkgKiBhbGlnbm1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1tYXBBbGxvYyhzaXplKSB7XG4gICAgICBzaXplID0gYWxpZ25NZW1vcnkoc2l6ZSwgNjU1MzYpO1xuICAgICAgdmFyIHB0ciA9IF9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24oNjU1MzYsIHNpemUpO1xuICAgICAgaWYgKCFwdHIpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHplcm9NZW1vcnkocHRyLCBzaXplKTtcbiAgICB9XG4gICAgdmFyIE1FTUZTID0ge1xuICAgICAgb3BzX3RhYmxlOiBudWxsLFxuICAgICAgbW91bnQ6IGZ1bmN0aW9uIChtb3VudCkge1xuICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShudWxsLCAnLycsIDE2Mzg0IHwgNTExLCAwKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU1FTUZTLm9wc190YWJsZSkge1xuICAgICAgICAgIE1FTUZTLm9wc190YWJsZSA9IHtcbiAgICAgICAgICAgIGRpcjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgICAgIGxvb2t1cDogTUVNRlMubm9kZV9vcHMubG9va3VwLFxuICAgICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCxcbiAgICAgICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSxcbiAgICAgICAgICAgICAgICB1bmxpbms6IE1FTUZTLm5vZGVfb3BzLnVubGluayxcbiAgICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsXG4gICAgICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpcixcbiAgICAgICAgICAgICAgICBzeW1saW5rOiBNRU1GUy5ub2RlX29wcy5zeW1saW5rLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayxcbiAgICAgICAgICAgICAgICByZWFkOiBNRU1GUy5zdHJlYW1fb3BzLnJlYWQsXG4gICAgICAgICAgICAgICAgd3JpdGU6IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUsXG4gICAgICAgICAgICAgICAgYWxsb2NhdGU6IE1FTUZTLnN0cmVhbV9vcHMuYWxsb2NhdGUsXG4gICAgICAgICAgICAgICAgbW1hcDogTUVNRlMuc3RyZWFtX29wcy5tbWFwLFxuICAgICAgICAgICAgICAgIG1zeW5jOiBNRU1GUy5zdHJlYW1fb3BzLm1zeW5jLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgICByZWFkbGluazogTUVNRlMubm9kZV9vcHMucmVhZGxpbmssXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbToge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hyZGV2OiB7XG4gICAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIuc3RyZWFtO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLnN0cmVhbTtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG5cbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUubGluay5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLnN0cmVhbTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5jb250ZW50c1tuYW1lXSA9IG5vZGU7XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IG5vZGUudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGdldEZpbGVEYXRhQXNUeXBlZEFycmF5OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpXG4gICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobm9kZS5jb250ZW50cyk7XG4gICAgICB9LFxuICAgICAgZXhwYW5kRmlsZVN0b3JhZ2U6IGZ1bmN0aW9uIChub2RlLCBuZXdDYXBhY2l0eSkge1xuICAgICAgICB2YXIgcHJldkNhcGFjaXR5ID0gbm9kZS5jb250ZW50cyA/IG5vZGUuY29udGVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSA+PSBuZXdDYXBhY2l0eSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBDQVBBQ0lUWV9ET1VCTElOR19NQVggPSAxMDI0ICogMTAyNDtcbiAgICAgICAgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChcbiAgICAgICAgICBuZXdDYXBhY2l0eSxcbiAgICAgICAgICAocHJldkNhcGFjaXR5ICpcbiAgICAgICAgICAgIChwcmV2Q2FwYWNpdHkgPCBDQVBBQ0lUWV9ET1VCTElOR19NQVggPyAyLjAgOiAxLjEyNSkpID4+PlxuICAgICAgICAgICAgMCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSAhPSAwKSBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAyNTYpO1xuICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO1xuICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPiAwKVxuICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKSwgMCk7XG4gICAgICB9LFxuICAgICAgcmVzaXplRmlsZVN0b3JhZ2U6IGZ1bmN0aW9uIChub2RlLCBuZXdTaXplKSB7XG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA9PSBuZXdTaXplKSByZXR1cm47XG4gICAgICAgIGlmIChuZXdTaXplID09IDApIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50cztcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7XG4gICAgICAgICAgaWYgKG9sZENvbnRlbnRzKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChcbiAgICAgICAgICAgICAgb2xkQ29udGVudHMuc3ViYXJyYXkoMCwgTWF0aC5taW4obmV3U2l6ZSwgbm9kZS51c2VkQnl0ZXMpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbmV3U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vZGVfb3BzOiB7XG4gICAgICAgIGdldGF0dHI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSB7fTtcblxuICAgICAgICAgIGF0dHIuZGV2ID0gRlMuaXNDaHJkZXYobm9kZS5tb2RlKSA/IG5vZGUuaWQgOiAxO1xuICAgICAgICAgIGF0dHIuaW5vID0gbm9kZS5pZDtcbiAgICAgICAgICBhdHRyLm1vZGUgPSBub2RlLm1vZGU7XG4gICAgICAgICAgYXR0ci5ubGluayA9IDE7XG4gICAgICAgICAgYXR0ci51aWQgPSAwO1xuICAgICAgICAgIGF0dHIuZ2lkID0gMDtcbiAgICAgICAgICBhdHRyLnJkZXYgPSBub2RlLnJkZXY7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDQwOTY7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS5saW5rLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0ci5hdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBhdHRyLm10aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG5cbiAgICAgICAgICBhdHRyLmJsa3NpemUgPSA0MDk2O1xuICAgICAgICAgIGF0dHIuYmxvY2tzID0gTWF0aC5jZWlsKGF0dHIuc2l6ZSAvIGF0dHIuYmxrc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldGF0dHI6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgICAgaWYgKGF0dHIubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnRpbWVzdGFtcCA9IGF0dHIudGltZXN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE1FTUZTLnJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsIGF0dHIuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBGUy5nZW5lcmljRXJyb3JzWzQ0XTtcbiAgICAgICAgfSxcbiAgICAgICAgbWtub2Q6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikge1xuICAgICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKSB7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbmV3X25vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIGlmIChuZXdfbm9kZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG5ld19ub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIG9sZF9ub2RlLnBhcmVudC5jb250ZW50c1tvbGRfbm9kZS5uYW1lXTtcbiAgICAgICAgICBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBvbGRfbm9kZS5uYW1lID0gbmV3X25hbWU7XG4gICAgICAgICAgbmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV0gPSBvbGRfbm9kZTtcbiAgICAgICAgICBuZXdfZGlyLnRpbWVzdGFtcCA9IG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgb2xkX25vZGUucGFyZW50ID0gbmV3X2RpcjtcbiAgICAgICAgfSxcbiAgICAgICAgdW5saW5rOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm1kaXI6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG5vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGRpcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IFsnLicsICcuLiddO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAgc3ltbGluazogZnVuY3Rpb24gKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCkge1xuICAgICAgICAgIHZhciBub2RlID0gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5ld25hbWUsIDUxMSB8IDQwOTYwLCAwKTtcbiAgICAgICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuICAgICAgICByZWFkbGluazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmxpbms7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgc3RyZWFtX29wczoge1xuICAgICAgICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBzdHJlYW0ubm9kZS51c2VkQnl0ZXMpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKHNpemUgPiA4ICYmIGNvbnRlbnRzLnN1YmFycmF5KSB7XG4gICAgICAgICAgICBidWZmZXIuc2V0KGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIHNpemUpLCBvZmZzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xuICAgICAgICAgICAgY2FuT3duID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBub2RlID0gc3RyZWFtLm5vZGU7XG4gICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHtcbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnVzZWRCeXRlcyA9PT0gMCAmJiBwb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uICsgbGVuZ3RoIDw9IG5vZGUudXNlZEJ5dGVzKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KFxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5ICYmIGJ1ZmZlci5zdWJhcnJheSkge1xuICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoXG4gICAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzW3Bvc2l0aW9uICsgaV0gPSBidWZmZXJbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBsbHNlZWs6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBhbGxvY2F0ZTogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShzdHJlYW0ubm9kZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnVzZWRCeXRlcyxcbiAgICAgICAgICAgIG9mZnNldCArIGxlbmd0aCxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBtbWFwOiBmdW5jdGlvbiAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykge1xuICAgICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwdHI7XG4gICAgICAgICAgdmFyIGFsbG9jYXRlZDtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcblxuICAgICAgICAgIGlmICghKGZsYWdzICYgMikgJiYgY29udGVudHMuYnVmZmVyID09PSBIRUFQOC5idWZmZXIpIHtcbiAgICAgICAgICAgIGFsbG9jYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcHRyID0gY29udGVudHMuYnl0ZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMCB8fCBwb3NpdGlvbiArIGxlbmd0aCA8IGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoY29udGVudHMuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiArIGxlbmd0aCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQOC5zZXQoY29udGVudHMsIHB0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IGFsbG9jYXRlZCB9O1xuICAgICAgICB9LFxuICAgICAgICBtc3luYzogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgICAgTUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgMCwgbGVuZ3RoLCBvZmZzZXQsIGZhbHNlKTtcblxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYXN5bmNMb2FkKHVybCwgb25sb2FkLCBvbmVycm9yLCBub1J1bkRlcCkge1xuICAgICAgdmFyIGRlcCA9ICFub1J1bkRlcCA/IGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koJ2FsICcgKyB1cmwpIDogJyc7XG4gICAgICByZWFkQXN5bmMoXG4gICAgICAgIHVybCxcbiAgICAgICAgKGFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgYXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAnTG9hZGluZyBkYXRhIGZpbGUgXCInICsgdXJsICsgJ1wiIGZhaWxlZCAobm8gYXJyYXlCdWZmZXIpLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvbmxvYWQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgICBpZiAoZGVwKSByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgIH0sXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChvbmVycm9yKSB7XG4gICAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdMb2FkaW5nIGRhdGEgZmlsZSBcIicgKyB1cmwgKyAnXCIgZmFpbGVkLic7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIGlmIChkZXApIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICB9XG5cbiAgICB2YXIgRlMgPSB7XG4gICAgICByb290OiBudWxsLFxuICAgICAgbW91bnRzOiBbXSxcbiAgICAgIGRldmljZXM6IHt9LFxuICAgICAgc3RyZWFtczogW10sXG4gICAgICBuZXh0SW5vZGU6IDEsXG4gICAgICBuYW1lVGFibGU6IG51bGwsXG4gICAgICBjdXJyZW50UGF0aDogJy8nLFxuICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgaWdub3JlUGVybWlzc2lvbnM6IHRydWUsXG4gICAgICBFcnJub0Vycm9yOiBudWxsLFxuICAgICAgZ2VuZXJpY0Vycm9yczoge30sXG4gICAgICBmaWxlc3lzdGVtczogbnVsbCxcbiAgICAgIHN5bmNGU1JlcXVlc3RzOiAwLFxuICAgICAgbG9va3VwUGF0aDogKHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBwYXRoID0gUEFUSF9GUy5yZXNvbHZlKHBhdGgpO1xuXG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIHsgcGF0aDogJycsIG5vZGU6IG51bGwgfTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgZm9sbG93X21vdW50OiB0cnVlLFxuICAgICAgICAgIHJlY3Vyc2VfY291bnQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcblxuICAgICAgICBpZiAob3B0cy5yZWN1cnNlX2NvdW50ID4gOCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5yb290O1xuICAgICAgICB2YXIgY3VycmVudF9wYXRoID0gJy8nO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNsYXN0ID0gaSA9PT0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTtcblxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQoY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmICghaXNsYXN0IHx8IChpc2xhc3QgJiYgb3B0cy5mb2xsb3dfbW91bnQpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1vdW50ZWQucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvdykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbGluayA9IEZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG5cbiAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoY3VycmVudF9wYXRoLCB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZV9jb3VudDogb3B0cy5yZWN1cnNlX2NvdW50ICsgMSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBsb29rdXAubm9kZTtcblxuICAgICAgICAgICAgICBpZiAoY291bnQrKyA+IDQwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGF0aDogY3VycmVudF9wYXRoLCBub2RlOiBjdXJyZW50IH07XG4gICAgICB9LFxuICAgICAgZ2V0UGF0aDogKG5vZGUpID0+IHtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSkge1xuICAgICAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudC5tb3VudHBvaW50O1xuICAgICAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbW91bnQ7XG4gICAgICAgICAgICByZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoIC0gMV0gIT09ICcvJ1xuICAgICAgICAgICAgICA/IG1vdW50ICsgJy8nICsgcGF0aFxuICAgICAgICAgICAgICA6IG1vdW50ICsgcGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IHBhdGggPyBub2RlLm5hbWUgKyAnLycgKyBwYXRoIDogbm9kZS5uYW1lO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc2hOYW1lOiAocGFyZW50aWQsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZS5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgocGFyZW50aWQgKyBoYXNoKSA+Pj4gMCkgJSBGUy5uYW1lVGFibGUubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGhhc2hBZGROb2RlOiAobm9kZSkgPT4ge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBub2RlLm5hbWVfbmV4dCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZTtcbiAgICAgIH0sXG4gICAgICBoYXNoUmVtb3ZlTm9kZTogKG5vZGUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKEZTLm5hbWVUYWJsZVtoYXNoXSA9PT0gbm9kZSkge1xuICAgICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5uYW1lX25leHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5uYW1lX25leHQgPSBub2RlLm5hbWVfbmV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uYW1lX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbG9va3VwTm9kZTogKHBhcmVudCwgbmFtZSkgPT4ge1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUxvb2t1cChwYXJlbnQpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShwYXJlbnQuaWQsIG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBub2RlID0gRlMubmFtZVRhYmxlW2hhc2hdOyBub2RlOyBub2RlID0gbm9kZS5uYW1lX25leHQpIHtcbiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50LmlkID09PSBwYXJlbnQuaWQgJiYgbm9kZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGUy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlOiAocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSA9PiB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IEZTLkZTTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpO1xuXG4gICAgICAgIEZTLmhhc2hBZGROb2RlKG5vZGUpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lOb2RlOiAobm9kZSkgPT4ge1xuICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShub2RlKTtcbiAgICAgIH0sXG4gICAgICBpc1Jvb3Q6IChub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBub2RlLnBhcmVudDtcbiAgICAgIH0sXG4gICAgICBpc01vdW50cG9pbnQ6IChub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAhIW5vZGUubW91bnRlZDtcbiAgICAgIH0sXG4gICAgICBpc0ZpbGU6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMzI3Njg7XG4gICAgICB9LFxuICAgICAgaXNEaXI6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMTYzODQ7XG4gICAgICB9LFxuICAgICAgaXNMaW5rOiAobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTYwO1xuICAgICAgfSxcbiAgICAgIGlzQ2hyZGV2OiAobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDgxOTI7XG4gICAgICB9LFxuICAgICAgaXNCbGtkZXY6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMjQ1NzY7XG4gICAgICB9LFxuICAgICAgaXNGSUZPOiAobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTY7XG4gICAgICB9LFxuICAgICAgaXNTb2NrZXQ6IChtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDQ5MTUyKSA9PT0gNDkxNTI7XG4gICAgICB9LFxuICAgICAgZmxhZ01vZGVzOiB7IHI6IDAsICdyKyc6IDIsIHc6IDU3NywgJ3crJzogNTc4LCBhOiAxMDg5LCAnYSsnOiAxMDkwIH0sXG4gICAgICBtb2RlU3RyaW5nVG9GbGFnczogKHN0cikgPT4ge1xuICAgICAgICB2YXIgZmxhZ3MgPSBGUy5mbGFnTW9kZXNbc3RyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJyArIHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfSxcbiAgICAgIGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nOiAoZmxhZykgPT4ge1xuICAgICAgICB2YXIgcGVybXMgPSBbJ3InLCAndycsICdydyddW2ZsYWcgJiAzXTtcbiAgICAgICAgaWYgKGZsYWcgJiA1MTIpIHtcbiAgICAgICAgICBwZXJtcyArPSAndyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlcm1zO1xuICAgICAgfSxcbiAgICAgIG5vZGVQZXJtaXNzaW9uczogKG5vZGUsIHBlcm1zKSA9PiB7XG4gICAgICAgIGlmIChGUy5pZ25vcmVQZXJtaXNzaW9ucykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlcm1zLmluY2x1ZGVzKCdyJykgJiYgIShub2RlLm1vZGUgJiAyOTIpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3cnKSAmJiAhKG5vZGUubW9kZSAmIDE0NikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygneCcpICYmICEobm9kZS5tb2RlICYgNzMpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgbWF5TG9va3VwOiAoZGlyKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHJldHVybiBlcnJDb2RlO1xuICAgICAgICBpZiAoIWRpci5ub2RlX29wcy5sb29rdXApIHJldHVybiAyO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBtYXlDcmVhdGU6IChkaXIsIG5hbWUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm4gMjA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKTtcbiAgICAgIH0sXG4gICAgICBtYXlEZWxldGU6IChkaXIsIG5hbWUsIGlzZGlyKSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHJldHVybiBlcnJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc2Rpcikge1xuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDU0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpIHx8IEZTLmdldFBhdGgobm9kZSkgPT09IEZTLmN3ZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gMzE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIG1heU9wZW46IChub2RlLCBmbGFncykgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gNDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBpZiAoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpICE9PSAncicgfHwgZmxhZ3MgJiA1MTIpIHtcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpO1xuICAgICAgfSxcbiAgICAgIE1BWF9PUEVOX0ZEUzogNDA5NixcbiAgICAgIG5leHRmZDogKGZkX3N0YXJ0ID0gMCwgZmRfZW5kID0gRlMuTUFYX09QRU5fRkRTKSA9PiB7XG4gICAgICAgIGZvciAodmFyIGZkID0gZmRfc3RhcnQ7IGZkIDw9IGZkX2VuZDsgZmQrKykge1xuICAgICAgICAgIGlmICghRlMuc3RyZWFtc1tmZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzMpO1xuICAgICAgfSxcbiAgICAgIGdldFN0cmVhbTogKGZkKSA9PiBGUy5zdHJlYW1zW2ZkXSxcbiAgICAgIGNyZWF0ZVN0cmVhbTogKHN0cmVhbSwgZmRfc3RhcnQsIGZkX2VuZCkgPT4ge1xuICAgICAgICBpZiAoIUZTLkZTU3RyZWFtKSB7XG4gICAgICAgICAgRlMuRlNTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZCA9IHt9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgRlMuRlNTdHJlYW0ucHJvdG90eXBlID0ge307XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlMuRlNTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUgPSB2YWw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZWFkOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAxO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzV3JpdGU6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBcHBlbmQ6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxMDI0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYXJlZC5mbGFncztcbiAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZC5mbGFncyA9IHZhbDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWQucG9zaXRpb247XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZWQucG9zaXRpb24gPSB2YWw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtID0gT2JqZWN0LmFzc2lnbihuZXcgRlMuRlNTdHJlYW0oKSwgc3RyZWFtKTtcbiAgICAgICAgdmFyIGZkID0gRlMubmV4dGZkKGZkX3N0YXJ0LCBmZF9lbmQpO1xuICAgICAgICBzdHJlYW0uZmQgPSBmZDtcbiAgICAgICAgRlMuc3RyZWFtc1tmZF0gPSBzdHJlYW07XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgY2xvc2VTdHJlYW06IChmZCkgPT4ge1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7XG4gICAgICB9LFxuICAgICAgY2hyZGV2X3N0cmVhbV9vcHM6IHtcbiAgICAgICAgb3BlbjogKHN0cmVhbSkgPT4ge1xuICAgICAgICAgIHZhciBkZXZpY2UgPSBGUy5nZXREZXZpY2Uoc3RyZWFtLm5vZGUucmRldik7XG5cbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcyA9IGRldmljZS5zdHJlYW1fb3BzO1xuXG4gICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pIHtcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxsc2VlazogKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBtYWpvcjogKGRldikgPT4gZGV2ID4+IDgsXG4gICAgICBtaW5vcjogKGRldikgPT4gZGV2ICYgMHhmZixcbiAgICAgIG1ha2VkZXY6IChtYSwgbWkpID0+IChtYSA8PCA4KSB8IG1pLFxuICAgICAgcmVnaXN0ZXJEZXZpY2U6IChkZXYsIG9wcykgPT4ge1xuICAgICAgICBGUy5kZXZpY2VzW2Rldl0gPSB7IHN0cmVhbV9vcHM6IG9wcyB9O1xuICAgICAgfSxcbiAgICAgIGdldERldmljZTogKGRldikgPT4gRlMuZGV2aWNlc1tkZXZdLFxuICAgICAgZ2V0TW91bnRzOiAobW91bnQpID0+IHtcbiAgICAgICAgdmFyIG1vdW50cyA9IFtdO1xuICAgICAgICB2YXIgY2hlY2sgPSBbbW91bnRdO1xuXG4gICAgICAgIHdoaWxlIChjaGVjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbSA9IGNoZWNrLnBvcCgpO1xuXG4gICAgICAgICAgbW91bnRzLnB1c2gobSk7XG5cbiAgICAgICAgICBjaGVjay5wdXNoLmFwcGx5KGNoZWNrLCBtLm1vdW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW91bnRzO1xuICAgICAgfSxcbiAgICAgIHN5bmNmczogKHBvcHVsYXRlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBvcHVsYXRlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IHBvcHVsYXRlO1xuICAgICAgICAgIHBvcHVsYXRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cysrO1xuXG4gICAgICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHtcbiAgICAgICAgICBlcnIoXG4gICAgICAgICAgICAnd2FybmluZzogJyArXG4gICAgICAgICAgICAgIEZTLnN5bmNGU1JlcXVlc3RzICtcbiAgICAgICAgICAgICAgJyBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhGUy5yb290Lm1vdW50KTtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9DYWxsYmFjayhlcnJDb2RlKSB7XG4gICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyckNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgaWYgKCFkb25lLmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgZG9uZS5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvQ2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2NvbXBsZXRlZCA+PSBtb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb0NhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50cy5mb3JFYWNoKChtb3VudCkgPT4ge1xuICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBtb3VudDogKHR5cGUsIG9wdHMsIG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgdmFyIHJvb3QgPSBtb3VudHBvaW50ID09PSAnLyc7XG4gICAgICAgIHZhciBwc2V1ZG8gPSAhbW91bnRwb2ludDtcbiAgICAgICAgdmFyIG5vZGU7XG5cbiAgICAgICAgaWYgKHJvb3QgJiYgRlMucm9vdCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm9vdCAmJiAhcHNldWRvKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuXG4gICAgICAgICAgbW91bnRwb2ludCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcblxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91bnQgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBvcHRzOiBvcHRzLFxuICAgICAgICAgIG1vdW50cG9pbnQ6IG1vdW50cG9pbnQsXG4gICAgICAgICAgbW91bnRzOiBbXSxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbW91bnRSb290ID0gdHlwZS5tb3VudChtb3VudCk7XG4gICAgICAgIG1vdW50Um9vdC5tb3VudCA9IG1vdW50O1xuICAgICAgICBtb3VudC5yb290ID0gbW91bnRSb290O1xuXG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgRlMucm9vdCA9IG1vdW50Um9vdDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICAgICAgbm9kZS5tb3VudGVkID0gbW91bnQ7XG5cbiAgICAgICAgICBpZiAobm9kZS5tb3VudCkge1xuICAgICAgICAgICAgbm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdW50Um9vdDtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50OiAobW91bnRwb2ludCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG5cbiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudGVkO1xuICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTtcblxuICAgICAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goKGhhc2gpID0+IHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcblxuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnQubmFtZV9uZXh0O1xuXG4gICAgICAgICAgICBpZiAobW91bnRzLmluY2x1ZGVzKGN1cnJlbnQubW91bnQpKSB7XG4gICAgICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGUubW91bnRlZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO1xuICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH0sXG4gICAgICBsb29rdXA6IChwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBta25vZDogKHBhdGgsIG1vZGUsIGRldikgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lID09PSAnLicgfHwgbmFtZSA9PT0gJy4uJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLm1rbm9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubWtub2QocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZTogKHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA0Mzg7XG4gICAgICAgIG1vZGUgJj0gNDA5NTtcbiAgICAgICAgbW9kZSB8PSAzMjc2ODtcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgfSxcbiAgICAgIG1rZGlyOiAocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDUxMTtcbiAgICAgICAgbW9kZSAmPSA1MTEgfCA1MTI7XG4gICAgICAgIG1vZGUgfD0gMTYzODQ7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgIH0sXG4gICAgICBta2RpclRyZWU6IChwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIHZhciBkaXJzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWRpcnNbaV0pIGNvbnRpbnVlO1xuICAgICAgICAgIGQgKz0gJy8nICsgZGlyc1tpXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRlMubWtkaXIoZCwgbW9kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuZXJybm8gIT0gMjApIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWtkZXY6IChwYXRoLCBtb2RlLCBkZXYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZXYgPSBtb2RlO1xuICAgICAgICAgIG1vZGUgPSA0Mzg7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSB8PSA4MTkyO1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sXG4gICAgICBzeW1saW5rOiAob2xkcGF0aCwgbmV3cGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVBBVEhfRlMucmVzb2x2ZShvbGRwYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3bmFtZSA9IFBBVEguYmFzZW5hbWUobmV3cGF0aCk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmV3bmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMuc3ltbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKTtcbiAgICAgIH0sXG4gICAgICByZW5hbWU6IChvbGRfcGF0aCwgbmV3X3BhdGgpID0+IHtcbiAgICAgICAgdmFyIG9sZF9kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG9sZF9wYXRoKTtcbiAgICAgICAgdmFyIG5ld19kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG5ld19wYXRoKTtcbiAgICAgICAgdmFyIG9sZF9uYW1lID0gUEFUSC5iYXNlbmFtZShvbGRfcGF0aCk7XG4gICAgICAgIHZhciBuZXdfbmFtZSA9IFBBVEguYmFzZW5hbWUobmV3X3BhdGgpO1xuXG4gICAgICAgIHZhciBsb29rdXAsIG9sZF9kaXIsIG5ld19kaXI7XG5cbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChvbGRfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG9sZF9kaXIgPSBsb29rdXAubm9kZTtcbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG5ld19kaXIgPSBsb29rdXAubm9kZTtcblxuICAgICAgICBpZiAoIW9sZF9kaXIgfHwgIW5ld19kaXIpIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcblxuICAgICAgICBpZiAob2xkX2Rpci5tb3VudCAhPT0gbmV3X2Rpci5tb3VudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDc1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGRfbm9kZSA9IEZTLmxvb2t1cE5vZGUob2xkX2Rpciwgb2xkX25hbWUpO1xuXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUob2xkX3BhdGgsIG5ld19kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVsYXRpdmUgPSBQQVRIX0ZTLnJlbGF0aXZlKG5ld19wYXRoLCBvbGRfZGlybmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfbm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIGlmIChvbGRfbm9kZSA9PT0gbmV3X25vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNkaXIgPSBGUy5pc0RpcihvbGRfbm9kZS5tb2RlKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUob2xkX2Rpciwgb2xkX25hbWUsIGlzZGlyKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVyckNvZGUgPSBuZXdfbm9kZVxuICAgICAgICAgID8gRlMubWF5RGVsZXRlKG5ld19kaXIsIG5ld19uYW1lLCBpc2RpcilcbiAgICAgICAgICA6IEZTLm1heUNyZWF0ZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgRlMuaXNNb3VudHBvaW50KG9sZF9ub2RlKSB8fFxuICAgICAgICAgIChuZXdfbm9kZSAmJiBGUy5pc01vdW50cG9pbnQobmV3X25vZGUpKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3X2RpciAhPT0gb2xkX2Rpcikge1xuICAgICAgICAgIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMob2xkX2RpciwgJ3cnKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUob2xkX25vZGUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRlMuaGFzaEFkZE5vZGUob2xkX25vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcm1kaXI6IChwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMucm1kaXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMucm1kaXIocGFyZW50LCBuYW1lKTtcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XG4gICAgICB9LFxuICAgICAgcmVhZGRpcjogKHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5yZWFkZGlyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSk7XG4gICAgICB9LFxuICAgICAgdW5saW5rOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy51bmxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIHJlYWRsaW5rOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcbiAgICAgICAgdmFyIGxpbmsgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluay5ub2RlX29wcy5yZWFkbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSF9GUy5yZXNvbHZlKFxuICAgICAgICAgIEZTLmdldFBhdGgobGluay5wYXJlbnQpLFxuICAgICAgICAgIGxpbmsubm9kZV9vcHMucmVhZGxpbmsobGluayksXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc3RhdDogKHBhdGgsIGRvbnRGb2xsb3cpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLmdldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZV9vcHMuZ2V0YXR0cihub2RlKTtcbiAgICAgIH0sXG4gICAgICBsc3RhdDogKHBhdGgpID0+IHtcbiAgICAgICAgcmV0dXJuIEZTLnN0YXQocGF0aCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgY2htb2Q6IChwYXRoLCBtb2RlLCBkb250Rm9sbG93KSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsY2htb2Q6IChwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIEZTLmNobW9kKHBhdGgsIG1vZGUsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGZjaG1vZDogKGZkLCBtb2RlKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNobW9kKHN0cmVhbS5ub2RlLCBtb2RlKTtcbiAgICAgIH0sXG4gICAgICBjaG93bjogKHBhdGgsIHVpZCwgZ2lkLCBkb250Rm9sbG93KSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsY2hvd246IChwYXRoLCB1aWQsIGdpZCkgPT4ge1xuICAgICAgICBGUy5jaG93bihwYXRoLCB1aWQsIGdpZCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZmNob3duOiAoZmQsIHVpZCwgZ2lkKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNob3duKHN0cmVhbS5ub2RlLCB1aWQsIGdpZCk7XG4gICAgICB9LFxuICAgICAgdHJ1bmNhdGU6IChwYXRoLCBsZW4pID0+IHtcbiAgICAgICAgaWYgKGxlbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsICd3Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICBzaXplOiBsZW4sXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmdHJ1bmNhdGU6IChmZCwgbGVuKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgRlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsIGxlbik7XG4gICAgICB9LFxuICAgICAgdXRpbWU6IChwYXRoLCBhdGltZSwgbXRpbWUpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBNYXRoLm1heChhdGltZSwgbXRpbWUpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvcGVuOiAocGF0aCwgZmxhZ3MsIG1vZGUpID0+IHtcbiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGZsYWdzID0gdHlwZW9mIGZsYWdzID09ICdzdHJpbmcnID8gRlMubW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpIDogZmxhZ3M7XG4gICAgICAgIG1vZGUgPSB0eXBlb2YgbW9kZSA9PSAndW5kZWZpbmVkJyA/IDQzOCA6IG1vZGU7XG4gICAgICAgIGlmIChmbGFncyAmIDY0KSB7XG4gICAgICAgICAgbW9kZSA9IChtb2RlICYgNDA5NSkgfCAzMjc2ODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7XG4gICAgICAgICAgICAgIGZvbGxvdzogIShmbGFncyAmIDEzMTA3MiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZsYWdzICYgNjQpIHtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgMTI4KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgZmxhZ3MgJj0gfjUxMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIDY1NTM2ICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjcmVhdGVkKSB7XG4gICAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlPcGVuKG5vZGUsIGZsYWdzKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgNTEyICYmICFjcmVhdGVkKSB7XG4gICAgICAgICAgRlMudHJ1bmNhdGUobm9kZSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbGFncyAmPSB+KDEyOCB8IDUxMiB8IDEzMTA3Mik7XG5cbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbSh7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBwYXRoOiBGUy5nZXRQYXRoKG5vZGUpLFxuICAgICAgICAgIGZsYWdzOiBmbGFncyxcbiAgICAgICAgICBzZWVrYWJsZTogdHJ1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICBzdHJlYW1fb3BzOiBub2RlLnN0cmVhbV9vcHMsXG5cbiAgICAgICAgICB1bmdvdHRlbjogW10sXG4gICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydsb2dSZWFkRmlsZXMnXSAmJiAhKGZsYWdzICYgMSkpIHtcbiAgICAgICAgICBpZiAoIUZTLnJlYWRGaWxlcykgRlMucmVhZEZpbGVzID0ge307XG4gICAgICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7XG4gICAgICAgICAgICBGUy5yZWFkRmlsZXNbcGF0aF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiAoc3RyZWFtKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cykgc3RyZWFtLmdldGRlbnRzID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2UpIHtcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5mZCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgaXNDbG9zZWQ6IChzdHJlYW0pID0+IHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5mZCA9PT0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBsbHNlZWs6IChzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc2Vla2FibGUgfHwgIXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlbmNlICE9IDAgJiYgd2hlbmNlICE9IDEgJiYgd2hlbmNlICE9IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvc2l0aW9uID0gc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgICBzdHJlYW0udW5nb3R0ZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICByZWFkOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMucmVhZCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNSZWFkID0gc3RyZWFtLnN0cmVhbV9vcHMucmVhZChcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5zZWVrYWJsZSAmJiBzdHJlYW0uZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgMCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBjYW5Pd24sXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICAgIH0sXG4gICAgICBhbGxvY2F0ZTogKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBsZW5ndGggPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMzgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIG1tYXA6IChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAocHJvdCAmIDIpICE9PSAwICYmXG4gICAgICAgICAgKGZsYWdzICYgMikgPT09IDAgJiZcbiAgICAgICAgICAoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgIT09IDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubW1hcCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKTtcbiAgICAgIH0sXG4gICAgICBtc3luYzogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSA9PiB7XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgIG1tYXBGbGFncyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBtdW5tYXA6IChzdHJlYW0pID0+IDAsXG4gICAgICBpb2N0bDogKHN0cmVhbSwgY21kLCBhcmcpID0+IHtcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwoc3RyZWFtLCBjbWQsIGFyZyk7XG4gICAgICB9LFxuICAgICAgcmVhZEZpbGU6IChwYXRoLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgMDtcbiAgICAgICAgb3B0cy5lbmNvZGluZyA9IG9wdHMuZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nICE9PSAndXRmOCcgJiYgb3B0cy5lbmNvZGluZyAhPT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSBcIicgKyBvcHRzLmVuY29kaW5nICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncyk7XG4gICAgICAgIHZhciBzdGF0ID0gRlMuc3RhdChwYXRoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIEZTLnJlYWQoc3RyZWFtLCBidWYsIDAsIGxlbmd0aCwgMCk7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICByZXQgPSBVVEY4QXJyYXlUb1N0cmluZyhidWYsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgcmV0ID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgd3JpdGVGaWxlOiAocGF0aCwgZGF0YSwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDU3NztcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncywgb3B0cy5tb2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSArIDEpO1xuICAgICAgICAgIHZhciBhY3R1YWxOdW1CeXRlcyA9IHN0cmluZ1RvVVRGOEFycmF5KGRhdGEsIGJ1ZiwgMCwgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBidWYsIDAsIGFjdHVhbE51bUJ5dGVzLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCwgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgfSxcbiAgICAgIGN3ZDogKCkgPT4gRlMuY3VycmVudFBhdGgsXG4gICAgICBjaGRpcjogKHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIGlmIChsb29rdXAubm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRGlyKGxvb2t1cC5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLCAneCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzOiAoKSA9PiB7XG4gICAgICAgIEZTLm1rZGlyKCcvdG1wJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZScpO1xuICAgICAgICBGUy5ta2RpcignL2hvbWUvd2ViX3VzZXInKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVEZWZhdWx0RGV2aWNlczogKCkgPT4ge1xuICAgICAgICBGUy5ta2RpcignL2RldicpO1xuXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKEZTLm1ha2VkZXYoMSwgMyksIHtcbiAgICAgICAgICByZWFkOiAoKSA9PiAwLFxuICAgICAgICAgIHdyaXRlOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpID0+IGxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L251bGwnLCBGUy5tYWtlZGV2KDEsIDMpKTtcblxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7XG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDYsIDApLCBUVFkuZGVmYXVsdF90dHkxX29wcyk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eScsIEZTLm1ha2VkZXYoNSwgMCkpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHkxJywgRlMubWFrZWRldig2LCAwKSk7XG5cbiAgICAgICAgdmFyIHJhbmRvbV9kZXZpY2UgPSBnZXRSYW5kb21EZXZpY2UoKTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3JhbmRvbScsIHJhbmRvbV9kZXZpY2UpO1xuICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAndXJhbmRvbScsIHJhbmRvbV9kZXZpY2UpO1xuXG4gICAgICAgIEZTLm1rZGlyKCcvZGV2L3NobScpO1xuICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0vdG1wJyk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOiAoKSA9PiB7XG4gICAgICAgIEZTLm1rZGlyKCcvcHJvYycpO1xuICAgICAgICB2YXIgcHJvY19zZWxmID0gRlMubWtkaXIoJy9wcm9jL3NlbGYnKTtcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jL3NlbGYvZmQnKTtcbiAgICAgICAgRlMubW91bnQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW91bnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHByb2Nfc2VsZiwgJ2ZkJywgMTYzODQgfCA1MTEsIDczKTtcbiAgICAgICAgICAgICAgbm9kZS5ub2RlX29wcyA9IHtcbiAgICAgICAgICAgICAgICBsb29rdXA6IChwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBmZCA9ICtuYW1lO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXN0cmVhbSkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1vdW50OiB7IG1vdW50cG9pbnQ6ICdmYWtlJyB9LFxuICAgICAgICAgICAgICAgICAgICBub2RlX29wczogeyByZWFkbGluazogKCkgPT4gc3RyZWFtLnBhdGggfSxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXQucGFyZW50ID0gcmV0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAnL3Byb2Mvc2VsZi9mZCcsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU3RhbmRhcmRTdHJlYW1zOiAoKSA9PiB7XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGluJ10pIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkaW4nLCBNb2R1bGVbJ3N0ZGluJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3RkaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydzdGRvdXQnXSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRvdXQnLCBudWxsLCBNb2R1bGVbJ3N0ZG91dCddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZG91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGVyciddKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIE1vZHVsZVsnc3RkZXJyJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0ZGluID0gRlMub3BlbignL2Rldi9zdGRpbicsIDApO1xuICAgICAgICB2YXIgc3Rkb3V0ID0gRlMub3BlbignL2Rldi9zdGRvdXQnLCAxKTtcbiAgICAgICAgdmFyIHN0ZGVyciA9IEZTLm9wZW4oJy9kZXYvc3RkZXJyJywgMSk7XG4gICAgICB9LFxuICAgICAgZW5zdXJlRXJybm9FcnJvcjogKCkgPT4ge1xuICAgICAgICBpZiAoRlMuRXJybm9FcnJvcikgcmV0dXJuO1xuICAgICAgICBGUy5FcnJub0Vycm9yID0gZnVuY3Rpb24gRXJybm9FcnJvcihlcnJubywgbm9kZSkge1xuICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyA9IGZ1bmN0aW9uIChlcnJubykge1xuICAgICAgICAgICAgdGhpcy5lcnJubyA9IGVycm5vO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyhlcnJubyk7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlID0gJ0ZTIGVycm9yJztcbiAgICAgICAgfTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGUy5FcnJub0Vycm9yO1xuXG4gICAgICAgIFs0NF0uZm9yRWFjaCgoY29kZSkgPT4ge1xuICAgICAgICAgIEZTLmdlbmVyaWNFcnJvcnNbY29kZV0gPSBuZXcgRlMuRXJybm9FcnJvcihjb2RlKTtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdLnN0YWNrID0gJzxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4nO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzdGF0aWNJbml0OiAoKSA9PiB7XG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcblxuICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7XG5cbiAgICAgICAgRlMubW91bnQoTUVNRlMsIHt9LCAnLycpO1xuXG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO1xuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGV2aWNlcygpO1xuICAgICAgICBGUy5jcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKTtcblxuICAgICAgICBGUy5maWxlc3lzdGVtcyA9IHtcbiAgICAgICAgICBNRU1GUzogTUVNRlMsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaW5pdDogKGlucHV0LCBvdXRwdXQsIGVycm9yKSA9PiB7XG4gICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcblxuICAgICAgICBNb2R1bGVbJ3N0ZGluJ10gPSBpbnB1dCB8fCBNb2R1bGVbJ3N0ZGluJ107XG4gICAgICAgIE1vZHVsZVsnc3Rkb3V0J10gPSBvdXRwdXQgfHwgTW9kdWxlWydzdGRvdXQnXTtcbiAgICAgICAgTW9kdWxlWydzdGRlcnInXSA9IGVycm9yIHx8IE1vZHVsZVsnc3RkZXJyJ107XG5cbiAgICAgICAgRlMuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCk7XG4gICAgICB9LFxuICAgICAgcXVpdDogKCkgPT4ge1xuICAgICAgICBGUy5pbml0LmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLnN0cmVhbXNbaV07XG4gICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0TW9kZTogKGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBtb2RlID0gMDtcbiAgICAgICAgaWYgKGNhblJlYWQpIG1vZGUgfD0gMjkyIHwgNzM7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfSxcbiAgICAgIGZpbmRPYmplY3Q6IChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICAgICAgaWYgKCFyZXQuZXhpc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5vYmplY3Q7XG4gICAgICB9LFxuICAgICAgYW5hbHl6ZVBhdGg6IChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgICAgIHBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLFxuICAgICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IDAsXG4gICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICAgIG9iamVjdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG51bGwsXG4gICAgICAgICAgcGFyZW50T2JqZWN0OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICAgIHJldC5wYXJlbnRFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIHJldC5wYXJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgICAgcmV0LnBhcmVudE9iamVjdCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIHJldC5uYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgICAgICByZXQuZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5vYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IGxvb2t1cC5ub2RlLm5hbWU7XG4gICAgICAgICAgcmV0LmlzUm9vdCA9IGxvb2t1cC5wYXRoID09PSAnLyc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXQuZXJyb3IgPSBlLmVycm5vO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgY3JlYXRlUGF0aDogKHBhcmVudCwgcGF0aCwgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLnJldmVyc2UoKTtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IFBBVEguam9pbjIocGFyZW50LCBwYXJ0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRlMubWtkaXIoY3VycmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICBwYXJlbnQgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUZpbGU6IChwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihcbiAgICAgICAgICB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIHJldHVybiBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGF0YUZpbGU6IChwYXJlbnQsIG5hbWUsIGRhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pID0+IHtcbiAgICAgICAgdmFyIHBhdGggPSBuYW1lO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgICBwYXRoID0gbmFtZSA/IFBBVEguam9pbjIocGFyZW50LCBuYW1lKSA6IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgICAgIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGRhdGEgPSBhcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSB8IDE0Nik7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4obm9kZSwgNTc3KTtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGV2aWNlOiAocGFyZW50LCBuYW1lLCBpbnB1dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihcbiAgICAgICAgICB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZSghIWlucHV0LCAhIW91dHB1dCk7XG4gICAgICAgIGlmICghRlMuY3JlYXRlRGV2aWNlLm1ham9yKSBGUy5jcmVhdGVEZXZpY2UubWFqb3IgPSA2NDtcbiAgICAgICAgdmFyIGRldiA9IEZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssIDApO1xuXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwge1xuICAgICAgICAgIG9wZW46IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2U6IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgb3V0cHV0LmJ1ZmZlciAmJiBvdXRwdXQuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBvdXRwdXQoMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVhZDogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlc1JlYWQpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0KGJ1ZmZlcltvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRlMubWtkZXYocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sXG4gICAgICBmb3JjZUxvYWRGaWxlOiAob2JqKSA9PiB7XG4gICAgICAgIGlmIChvYmouaXNEZXZpY2UgfHwgb2JqLmlzRm9sZGVyIHx8IG9iai5saW5rIHx8IG9iai5jb250ZW50cylcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhZF8pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqLmNvbnRlbnRzID0gaW50QXJyYXlGcm9tU3RyaW5nKHJlYWRfKG9iai51cmwpLCB0cnVlKTtcbiAgICAgICAgICAgIG9iai51c2VkQnl0ZXMgPSBvYmouY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUxhenlGaWxlOiAocGFyZW50LCBuYW1lLCB1cmwsIGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5KCkge1xuICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KSB7XG4gICAgICAgICAgaWYgKGlkeCA+IHRoaXMubGVuZ3RoIC0gMSB8fCBpZHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSB0aGlzLmNodW5rU2l6ZTtcbiAgICAgICAgICB2YXIgY2h1bmtOdW0gPSAoaWR4IC8gdGhpcy5jaHVua1NpemUpIHwgMDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoY2h1bmtOdW0pW2NodW5rT2Zmc2V0XTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLnNldERhdGFHZXR0ZXIgPVxuICAgICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjtcbiAgICAgICAgICB9O1xuICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuY2FjaGVMZW5ndGggPVxuICAgICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoKCkge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGRhdGFsZW5ndGggPSBOdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LWxlbmd0aCcpKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPVxuICAgICAgICAgICAgICAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdBY2NlcHQtUmFuZ2VzJykpICYmXG4gICAgICAgICAgICAgIGhlYWRlciA9PT0gJ2J5dGVzJztcbiAgICAgICAgICAgIHZhciB1c2VzR3ppcCA9XG4gICAgICAgICAgICAgIChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtRW5jb2RpbmcnKSkgJiZcbiAgICAgICAgICAgICAgaGVhZGVyID09PSAnZ3ppcCc7XG5cbiAgICAgICAgICAgIHZhciBjaHVua1NpemUgPSAxMDI0ICogMTAyNDtcblxuICAgICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGRvWEhSID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChmcm9tID4gdG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgcmFuZ2UgKCcgK1xuICAgICAgICAgICAgICAgICAgICBmcm9tICtcbiAgICAgICAgICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIHRvICtcbiAgICAgICAgICAgICAgICAgICAgJykgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkIScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHRvID4gZGF0YWxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ29ubHkgJyArIGRhdGFsZW5ndGggKyAnIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciEnLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmIChkYXRhbGVuZ3RoICE9PSBjaHVua1NpemUpXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBmcm9tICsgJy0nICsgdG8pO1xuXG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICBpZiAoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UgfHwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCB8fCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGxhenlBcnJheSA9IHRoaXM7XG4gICAgICAgICAgICBsYXp5QXJyYXkuc2V0RGF0YUdldHRlcigoY2h1bmtOdW0pID0+IHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtOdW0gKiBjaHVua1NpemU7XG4gICAgICAgICAgICAgIHZhciBlbmQgPSAoY2h1bmtOdW0gKyAxKSAqIGNodW5rU2l6ZSAtIDE7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgZGF0YWxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPSBkb1hIUihzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9YSFIgZmFpbGVkIScpO1xuICAgICAgICAgICAgICByZXR1cm4gbGF6eUFycmF5LmNodW5rc1tjaHVua051bV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHVzZXNHemlwIHx8ICFkYXRhbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGggPSAxO1xuICAgICAgICAgICAgICBkYXRhbGVuZ3RoID0gdGhpcy5nZXR0ZXIoMCkubGVuZ3RoO1xuICAgICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgICAgICBvdXQoXG4gICAgICAgICAgICAgICAgJ0xhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZCcsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKCFFTlZJUk9OTUVOVF9JU19XT1JLRVIpXG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyc7XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSwge1xuICAgICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNodW5rU2l6ZToge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU2l6ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgdXJsOiB1cmwgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKTtcblxuICAgICAgICBpZiAocHJvcGVydGllcy5jb250ZW50cykge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBwcm9wZXJ0aWVzLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMudXJsKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgbm9kZS51cmwgPSBwcm9wZXJ0aWVzLnVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIHtcbiAgICAgICAgICB1c2VkQnl0ZXM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdHJlYW1fb3BzID0ge307XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICB2YXIgZm4gPSBub2RlLnN0cmVhbV9vcHNba2V5XTtcbiAgICAgICAgICBzdHJlYW1fb3BzW2tleV0gPSBmdW5jdGlvbiBmb3JjZUxvYWRMYXp5RmlsZSgpIHtcbiAgICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDaHVua3Moc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjb250ZW50cy5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oY29udGVudHMubGVuZ3RoIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKGNvbnRlbnRzLnNsaWNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50cy5nZXQocG9zaXRpb24gKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW1fb3BzLnJlYWQgPSAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtzKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmVhbV9vcHMubW1hcCA9IChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICB2YXIgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3JpdGVDaHVua3Moc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICByZXR1cm4geyBwdHI6IHB0ciwgYWxsb2NhdGVkOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IHN0cmVhbV9vcHM7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVByZWxvYWRlZEZpbGU6IChcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuYW1lLFxuICAgICAgICB1cmwsXG4gICAgICAgIGNhblJlYWQsXG4gICAgICAgIGNhbldyaXRlLFxuICAgICAgICBvbmxvYWQsXG4gICAgICAgIG9uZXJyb3IsXG4gICAgICAgIGRvbnRDcmVhdGVGaWxlLFxuICAgICAgICBjYW5Pd24sXG4gICAgICAgIHByZUZpbmlzaCxcbiAgICAgICkgPT4ge1xuICAgICAgICB2YXIgZnVsbG5hbWUgPSBuYW1lXG4gICAgICAgICAgPyBQQVRIX0ZTLnJlc29sdmUoUEFUSC5qb2luMihwYXJlbnQsIG5hbWUpKVxuICAgICAgICAgIDogcGFyZW50O1xuICAgICAgICB2YXIgZGVwID0gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeSgnY3AgJyArIGZ1bGxuYW1lKTtcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KSB7XG4gICAgICAgICAgZnVuY3Rpb24gZmluaXNoKGJ5dGVBcnJheSkge1xuICAgICAgICAgICAgaWYgKHByZUZpbmlzaCkgcHJlRmluaXNoKCk7XG4gICAgICAgICAgICBpZiAoIWRvbnRDcmVhdGVGaWxlKSB7XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFxuICAgICAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGJ5dGVBcnJheSxcbiAgICAgICAgICAgICAgICBjYW5SZWFkLFxuICAgICAgICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgICAgICAgIGNhbk93bixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbmxvYWQpIG9ubG9hZCgpO1xuICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBCcm93c2VyLmhhbmRsZWRCeVByZWxvYWRQbHVnaW4oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChvbmVycm9yKSBvbmVycm9yKCk7XG4gICAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaChieXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhc3luY0xvYWQodXJsLCAoYnl0ZUFycmF5KSA9PiBwcm9jZXNzRGF0YShieXRlQXJyYXkpLCBvbmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzRGF0YSh1cmwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kZXhlZERCOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgd2luZG93LmluZGV4ZWREQiB8fFxuICAgICAgICAgIHdpbmRvdy5tb3pJbmRleGVkREIgfHxcbiAgICAgICAgICB3aW5kb3cud2Via2l0SW5kZXhlZERCIHx8XG4gICAgICAgICAgd2luZG93Lm1zSW5kZXhlZERCXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgREJfTkFNRTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gJ0VNX0ZTXycgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB9LFxuICAgICAgREJfVkVSU0lPTjogMjAsXG4gICAgICBEQl9TVE9SRV9OQU1FOiAnRklMRV9EQVRBJyxcbiAgICAgIHNhdmVGaWxlc1RvREI6IChwYXRocywgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgICAgIG9ubG9hZCA9IG9ubG9hZCB8fCAoKCkgPT4ge30pO1xuICAgICAgICBvbmVycm9yID0gb25lcnJvciB8fCAoKCkgPT4ge30pO1xuICAgICAgICB2YXIgaW5kZXhlZERCID0gRlMuaW5kZXhlZERCKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBvbmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcbiAgICAgICAgICBvdXQoJ2NyZWF0aW5nIGRiJyk7XG4gICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgIHZhciBmaWxlcyA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgICAgIHZhciBvayA9IDAsXG4gICAgICAgICAgICBmYWlsID0gMCxcbiAgICAgICAgICAgIHRvdGFsID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpO1xuICAgICAgICAgICAgZWxzZSBvbmVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHZhciBwdXRSZXF1ZXN0ID0gZmlsZXMucHV0KFxuICAgICAgICAgICAgICBGUy5hbmFseXplUGF0aChwYXRoKS5vYmplY3QuY29udGVudHMsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIG9rKys7XG4gICAgICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHB1dFJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZmFpbCsrO1xuICAgICAgICAgICAgICBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgfSxcbiAgICAgIGxvYWRGaWxlc0Zyb21EQjogKHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gb25lcnJvcjtcbiAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZG9ubHknKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvbmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgICAgICB2YXIgb2sgPSAwLFxuICAgICAgICAgICAgZmFpbCA9IDAsXG4gICAgICAgICAgICB0b3RhbCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgICAgICBpZiAoZmFpbCA9PSAwKSBvbmxvYWQoKTtcbiAgICAgICAgICAgIGVsc2Ugb25lcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IGZpbGVzLmdldChwYXRoKTtcbiAgICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoRlMuYW5hbHl6ZVBhdGgocGF0aCkuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFxuICAgICAgICAgICAgICAgIFBBVEguZGlybmFtZShwYXRoKSxcbiAgICAgICAgICAgICAgICBQQVRILmJhc2VuYW1lKHBhdGgpLFxuICAgICAgICAgICAgICAgIGdldFJlcXVlc3QucmVzdWx0LFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBvaysrO1xuICAgICAgICAgICAgICBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGZhaWwrKztcbiAgICAgICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgU1lTQ0FMTFMgPSB7XG4gICAgICBERUZBVUxUX1BPTExNQVNLOiA1LFxuICAgICAgY2FsY3VsYXRlQXQ6IGZ1bmN0aW9uIChkaXJmZCwgcGF0aCwgYWxsb3dFbXB0eSkge1xuICAgICAgICBpZiAoUEFUSC5pc0FicyhwYXRoKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpcjtcbiAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7XG4gICAgICAgICAgZGlyID0gRlMuY3dkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChkaXJmZCk7XG4gICAgICAgICAgZGlyID0gZGlyc3RyZWFtLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSC5qb2luMihkaXIsIHBhdGgpO1xuICAgICAgfSxcbiAgICAgIGRvU3RhdDogZnVuY3Rpb24gKGZ1bmMsIHBhdGgsIGJ1Zikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzdGF0ID0gZnVuYyhwYXRoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGUgJiZcbiAgICAgICAgICAgIGUubm9kZSAmJlxuICAgICAgICAgICAgUEFUSC5ub3JtYWxpemUocGF0aCkgIT09IFBBVEgubm9ybWFsaXplKEZTLmdldFBhdGgoZS5ub2RlKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAtNTQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyW2J1ZiA+PiAyXSA9IHN0YXQuZGV2O1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDgpID4+IDJdID0gc3RhdC5pbm87XG4gICAgICAgIEhFQVAzMlsoYnVmICsgMTIpID4+IDJdID0gc3RhdC5tb2RlO1xuICAgICAgICBIRUFQVTMyWyhidWYgKyAxNikgPj4gMl0gPSBzdGF0Lm5saW5rO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDIwKSA+PiAyXSA9IHN0YXQudWlkO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDI0KSA+PiAyXSA9IHN0YXQuZ2lkO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDI4KSA+PiAyXSA9IHN0YXQucmRldjtcbiAgICAgICAgKHRlbXBJNjQgPSBbXG4gICAgICAgICAgc3RhdC5zaXplID4+PiAwLFxuICAgICAgICAgICgodGVtcERvdWJsZSA9IHN0YXQuc2l6ZSksXG4gICAgICAgICAgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDEuMFxuICAgICAgICAgICAgPyB0ZW1wRG91YmxlID4gMC4wXG4gICAgICAgICAgICAgID8gKE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgK01hdGguZmxvb3IodGVtcERvdWJsZSAvIDQyOTQ5NjcyOTYuMCksXG4gICAgICAgICAgICAgICAgICA0Mjk0OTY3Mjk1LjAsXG4gICAgICAgICAgICAgICAgKSB8XG4gICAgICAgICAgICAgICAgICAwKSA+Pj5cbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgIDogfn4rTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5Ni4wLFxuICAgICAgICAgICAgICAgICkgPj4+IDBcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgIF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDQwKSA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDQ0KSA+PiAyXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQMzJbKGJ1ZiArIDQ4KSA+PiAyXSA9IDQwOTY7XG4gICAgICAgIEhFQVAzMlsoYnVmICsgNTIpID4+IDJdID0gc3RhdC5ibG9ja3M7XG4gICAgICAgIHZhciBhdGltZSA9IHN0YXQuYXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgbXRpbWUgPSBzdGF0Lm10aW1lLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XG4gICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgIE1hdGguZmxvb3IoYXRpbWUgLyAxMDAwKSA+Pj4gMCxcbiAgICAgICAgICAoKHRlbXBEb3VibGUgPSBNYXRoLmZsb29yKGF0aW1lIC8gMTAwMCkpLFxuICAgICAgICAgICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxLjBcbiAgICAgICAgICAgID8gdGVtcERvdWJsZSA+IDAuMFxuICAgICAgICAgICAgICA/IChNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2LjApLFxuICAgICAgICAgICAgICAgICAgNDI5NDk2NzI5NS4wLFxuICAgICAgICAgICAgICAgICkgfFxuICAgICAgICAgICAgICAgICAgMCkgPj4+XG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICA6IH5+K01hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYuMCxcbiAgICAgICAgICAgICAgICApID4+PiAwXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICBdKSxcbiAgICAgICAgICAoSEVBUDMyWyhidWYgKyA1NikgPj4gMl0gPSB0ZW1wSTY0WzBdKSxcbiAgICAgICAgICAoSEVBUDMyWyhidWYgKyA2MCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUFUzMlsoYnVmICsgNjQpID4+IDJdID0gKGF0aW1lICUgMTAwMCkgKiAxMDAwO1xuICAgICAgICAodGVtcEk2NCA9IFtcbiAgICAgICAgICBNYXRoLmZsb29yKG10aW1lIC8gMTAwMCkgPj4+IDAsXG4gICAgICAgICAgKCh0ZW1wRG91YmxlID0gTWF0aC5mbG9vcihtdGltZSAvIDEwMDApKSxcbiAgICAgICAgICArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMS4wXG4gICAgICAgICAgICA/IHRlbXBEb3VibGUgPiAwLjBcbiAgICAgICAgICAgICAgPyAoTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5Ni4wKSxcbiAgICAgICAgICAgICAgICAgIDQyOTQ5NjcyOTUuMCxcbiAgICAgICAgICAgICAgICApIHxcbiAgICAgICAgICAgICAgICAgIDApID4+PlxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgOiB+fitNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2LjAsXG4gICAgICAgICAgICAgICAgKSA+Pj4gMFxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgXSksXG4gICAgICAgICAgKEhFQVAzMlsoYnVmICsgNzIpID4+IDJdID0gdGVtcEk2NFswXSksXG4gICAgICAgICAgKEhFQVAzMlsoYnVmICsgNzYpID4+IDJdID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIEhFQVBVMzJbKGJ1ZiArIDgwKSA+PiAyXSA9IChtdGltZSAlIDEwMDApICogMTAwMDtcbiAgICAgICAgKHRlbXBJNjQgPSBbXG4gICAgICAgICAgTWF0aC5mbG9vcihjdGltZSAvIDEwMDApID4+PiAwLFxuICAgICAgICAgICgodGVtcERvdWJsZSA9IE1hdGguZmxvb3IoY3RpbWUgLyAxMDAwKSksXG4gICAgICAgICAgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDEuMFxuICAgICAgICAgICAgPyB0ZW1wRG91YmxlID4gMC4wXG4gICAgICAgICAgICAgID8gKE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgK01hdGguZmxvb3IodGVtcERvdWJsZSAvIDQyOTQ5NjcyOTYuMCksXG4gICAgICAgICAgICAgICAgICA0Mjk0OTY3Mjk1LjAsXG4gICAgICAgICAgICAgICAgKSB8XG4gICAgICAgICAgICAgICAgICAwKSA+Pj5cbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgIDogfn4rTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5Ni4wLFxuICAgICAgICAgICAgICAgICkgPj4+IDBcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgIF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDg4KSA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDkyKSA+PiAyXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQVTMyWyhidWYgKyA5NikgPj4gMl0gPSAoY3RpbWUgJSAxMDAwKSAqIDEwMDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgIHN0YXQuaW5vID4+PiAwLFxuICAgICAgICAgICgodGVtcERvdWJsZSA9IHN0YXQuaW5vKSxcbiAgICAgICAgICArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMS4wXG4gICAgICAgICAgICA/IHRlbXBEb3VibGUgPiAwLjBcbiAgICAgICAgICAgICAgPyAoTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5Ni4wKSxcbiAgICAgICAgICAgICAgICAgIDQyOTQ5NjcyOTUuMCxcbiAgICAgICAgICAgICAgICApIHxcbiAgICAgICAgICAgICAgICAgIDApID4+PlxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgOiB+fitNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2LjAsXG4gICAgICAgICAgICAgICAgKSA+Pj4gMFxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgXSksXG4gICAgICAgICAgKEhFQVAzMlsoYnVmICsgMTA0KSA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKGJ1ZiArIDEwOCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgZG9Nc3luYzogZnVuY3Rpb24gKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KSB7XG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gSEVBUFU4LnNsaWNlKGFkZHIsIGFkZHIgKyBsZW4pO1xuICAgICAgICBGUy5tc3luYyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW4sIGZsYWdzKTtcbiAgICAgIH0sXG4gICAgICB2YXJhcmdzOiB1bmRlZmluZWQsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xuICAgICAgICB2YXIgcmV0ID0gSEVBUDMyWyhTWVNDQUxMUy52YXJhcmdzIC0gNCkgPj4gMl07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgZ2V0U3RyOiBmdW5jdGlvbiAocHRyKSB7XG4gICAgICAgIHZhciByZXQgPSBVVEY4VG9TdHJpbmcocHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICBnZXRTdHJlYW1Gcm9tRkQ6IGZ1bmN0aW9uIChmZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfY2htb2QocGF0aCwgbW9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mYWNjZXNzYXQoZGlyZmQsIHBhdGgsIGFtb2RlLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgaWYgKGFtb2RlICYgfjcpIHtcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gLTQ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJtcyA9ICcnO1xuICAgICAgICBpZiAoYW1vZGUgJiA0KSBwZXJtcyArPSAncic7XG4gICAgICAgIGlmIChhbW9kZSAmIDIpIHBlcm1zICs9ICd3JztcbiAgICAgICAgaWYgKGFtb2RlICYgMSkgcGVybXMgKz0gJ3gnO1xuICAgICAgICBpZiAocGVybXMgJiYgRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSkge1xuICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNobW9kKGZkLCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBGUy5mY2htb2QoZmQsIG1vZGUpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNob3duMzIoZmQsIG93bmVyLCBncm91cCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgRlMuZmNob3duKGZkLCBvd25lciwgZ3JvdXApO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEVyck5vKHZhbHVlKSB7XG4gICAgICBIRUFQMzJbX19fZXJybm9fbG9jYXRpb24oKSA+PiAyXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNudGw2NChmZCwgY21kLCB2YXJhcmdzKSB7XG4gICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgICAgaWYgKGFyZyA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdTdHJlYW07XG4gICAgICAgICAgICBuZXdTdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oc3RyZWFtLCBhcmcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0cmVhbS5mZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0uZmxhZ3M7XG4gICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICB2YXIgYXJnID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgICBzdHJlYW0uZmxhZ3MgfD0gYXJnO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIEhFQVAxNlsoYXJnICsgb2Zmc2V0KSA+PiAxXSA9IDI7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBzZXRFcnJObygyOCk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZnN0YXQ2NChmZCwgYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBzdHJlYW0ucGF0aCwgYnVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBNQVhfSU5UNTMgPSA5MDA3MTk5MjU0NzQwOTkyO1xuXG4gICAgdmFyIE1JTl9JTlQ1MyA9IC05MDA3MTk5MjU0NzQwOTkyO1xuICAgIGZ1bmN0aW9uIGJpZ2ludFRvSTUzQ2hlY2tlZChudW0pIHtcbiAgICAgIHJldHVybiBudW0gPCBNSU5fSU5UNTMgfHwgbnVtID4gTUFYX0lOVDUzID8gTmFOIDogTnVtYmVyKG51bSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mdHJ1bmNhdGU2NChmZCwgbGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZW5ndGggPSBiaWdpbnRUb0k1M0NoZWNrZWQobGVuZ3RoKTtcbiAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkpIHJldHVybiAtNjE7XG4gICAgICAgIEZTLmZ0cnVuY2F0ZShmZCwgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2dldGN3ZChidWYsIHNpemUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gLTI4O1xuICAgICAgICB2YXIgY3dkID0gRlMuY3dkKCk7XG4gICAgICAgIHZhciBjd2RMZW5ndGhJbkJ5dGVzID0gbGVuZ3RoQnl0ZXNVVEY4KGN3ZCkgKyAxO1xuICAgICAgICBpZiAoc2l6ZSA8IGN3ZExlbmd0aEluQnl0ZXMpIHJldHVybiAtNjg7XG4gICAgICAgIHN0cmluZ1RvVVRGOChjd2QsIGJ1Ziwgc2l6ZSk7XG4gICAgICAgIHJldHVybiBjd2RMZW5ndGhJbkJ5dGVzO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9pb2N0bChmZCwgb3AsIHZhcmFyZ3MpIHtcbiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICBjYXNlIDIxNTA5OlxuICAgICAgICAgIGNhc2UgMjE1MDU6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTEwOlxuICAgICAgICAgIGNhc2UgMjE1MTE6XG4gICAgICAgICAgY2FzZSAyMTUxMjpcbiAgICAgICAgICBjYXNlIDIxNTA2OlxuICAgICAgICAgIGNhc2UgMjE1MDc6XG4gICAgICAgICAgY2FzZSAyMTUwODoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MTk6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHZhciBhcmdwID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgICBIRUFQMzJbYXJncCA+PiAyXSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUyMDoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUzMToge1xuICAgICAgICAgICAgdmFyIGFyZ3AgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBGUy5pb2N0bChzdHJlYW0sIG9wLCBhcmdwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUyMzoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MjQ6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9sc3RhdDY0KHBhdGgsIGJ1Zikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5sc3RhdCwgcGF0aCwgYnVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtkaXJhdChkaXJmZCwgcGF0aCwgbW9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcblxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJylcbiAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgRlMubWtkaXIocGF0aCwgbW9kZSwgMCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9uZXdmc3RhdGF0KGRpcmZkLCBwYXRoLCBidWYsIGZsYWdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICB2YXIgbm9mb2xsb3cgPSBmbGFncyAmIDI1NjtcbiAgICAgICAgdmFyIGFsbG93RW1wdHkgPSBmbGFncyAmIDQwOTY7XG4gICAgICAgIGZsYWdzID0gZmxhZ3MgJiB+NjQwMDtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCBhbGxvd0VtcHR5KTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChub2ZvbGxvdyA/IEZTLmxzdGF0IDogRlMuc3RhdCwgcGF0aCwgYnVmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfb3BlbmF0KGRpcmZkLCBwYXRoLCBmbGFncywgdmFyYXJncykge1xuICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgICB2YXIgbW9kZSA9IHZhcmFyZ3MgPyBTWVNDQUxMUy5nZXQoKSA6IDA7XG4gICAgICAgIHJldHVybiBGUy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlKS5mZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcmVhZGxpbmthdChkaXJmZCwgcGF0aCwgYnVmLCBidWZzaXplKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgICBpZiAoYnVmc2l6ZSA8PSAwKSByZXR1cm4gLTI4O1xuICAgICAgICB2YXIgcmV0ID0gRlMucmVhZGxpbmsocGF0aCk7XG5cbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGJ1ZnNpemUsIGxlbmd0aEJ5dGVzVVRGOChyZXQpKTtcbiAgICAgICAgdmFyIGVuZENoYXIgPSBIRUFQOFtidWYgKyBsZW5dO1xuICAgICAgICBzdHJpbmdUb1VURjgocmV0LCBidWYsIGJ1ZnNpemUgKyAxKTtcblxuICAgICAgICBIRUFQOFtidWYgKyBsZW5dID0gZW5kQ2hhcjtcbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9zdGF0NjQocGF0aCwgYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX3VubGlua2F0KGRpcmZkLCBwYXRoLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgaWYgKGZsYWdzID09PSAwKSB7XG4gICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzID09PSA1MTIpIHtcbiAgICAgICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhYm9ydCgnSW52YWxpZCBmbGFncyBwYXNzZWQgdG8gdW5saW5rYXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRJNTNGcm9tSTY0KHB0cikge1xuICAgICAgcmV0dXJuIEhFQVBVMzJbcHRyID4+IDJdICsgSEVBUDMyWyhwdHIgKyA0KSA+PiAyXSAqIDQyOTQ5NjcyOTY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF91dGltZW5zYXQoZGlyZmQsIHBhdGgsIHRpbWVzLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCB0cnVlKTtcbiAgICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICAgIHZhciBhdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgdmFyIG10aW1lID0gYXRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlY29uZHMgPSByZWFkSTUzRnJvbUk2NCh0aW1lcyk7XG4gICAgICAgICAgdmFyIG5hbm9zZWNvbmRzID0gSEVBUDMyWyh0aW1lcyArIDgpID4+IDJdO1xuICAgICAgICAgIGF0aW1lID0gc2Vjb25kcyAqIDEwMDAgKyBuYW5vc2Vjb25kcyAvICgxMDAwICogMTAwMCk7XG4gICAgICAgICAgdGltZXMgKz0gMTY7XG4gICAgICAgICAgc2Vjb25kcyA9IHJlYWRJNTNGcm9tSTY0KHRpbWVzKTtcbiAgICAgICAgICBuYW5vc2Vjb25kcyA9IEhFQVAzMlsodGltZXMgKyA4KSA+PiAyXTtcbiAgICAgICAgICBtdGltZSA9IHNlY29uZHMgKiAxMDAwICsgbmFub3NlY29uZHMgLyAoMTAwMCAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIEZTLnV0aW1lKHBhdGgsIGF0aW1lLCBtdGltZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vd0lzTW9ub3RvbmljID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMoKSB7XG4gICAgICByZXR1cm4gbm93SXNNb25vdG9uaWM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19pc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbiAgICB9XG5cbiAgICB2YXIgX19NT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA9IFtcbiAgICAgIDAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1LFxuICAgIF07XG5cbiAgICB2YXIgX19NT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRSA9IFtcbiAgICAgIDAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0LFxuICAgIF07XG4gICAgZnVuY3Rpb24gX195ZGF5X2Zyb21fZGF0ZShkYXRlKSB7XG4gICAgICB2YXIgaXNMZWFwWWVhciA9IF9faXNMZWFwWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgdmFyIG1vbnRoRGF5c0N1bXVsYXRpdmUgPSBpc0xlYXBZZWFyXG4gICAgICAgID8gX19NT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRVxuICAgICAgICA6IF9fTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkU7XG4gICAgICB2YXIgeWRheSA9IG1vbnRoRGF5c0N1bXVsYXRpdmVbZGF0ZS5nZXRNb250aCgpXSArIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcblxuICAgICAgcmV0dXJuIHlkYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHJlYWRJNTNGcm9tSTY0KHRpbWUpICogMTAwMCk7XG4gICAgICBIRUFQMzJbdG1QdHIgPj4gMl0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyA0KSA+PiAyXSA9IGRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDgpID4+IDJdID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDEyKSA+PiAyXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDE2KSA+PiAyXSA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAyMCkgPj4gMl0gPSBkYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTAwO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDI0KSA+PiAyXSA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgIHZhciB5ZGF5ID0gX195ZGF5X2Zyb21fZGF0ZShkYXRlKSB8IDA7XG4gICAgICBIRUFQMzJbKHRtUHRyICsgMjgpID4+IDJdID0geWRheTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAzNikgPj4gMl0gPSAtKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDYsIDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBkc3QgPVxuICAgICAgICAoc3VtbWVyT2Zmc2V0ICE9IHdpbnRlck9mZnNldCAmJlxuICAgICAgICAgIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PSBNYXRoLm1pbih3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCkpIHwgMDtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAzMikgPj4gMl0gPSBkc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19tbWFwX2pzKGxlbiwgcHJvdCwgZmxhZ3MsIGZkLCBvZmYsIGFsbG9jYXRlZCwgYWRkcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHZhciByZXMgPSBGUy5tbWFwKHN0cmVhbSwgbGVuLCBvZmYsIHByb3QsIGZsYWdzKTtcbiAgICAgICAgdmFyIHB0ciA9IHJlcy5wdHI7XG4gICAgICAgIEhFQVAzMlthbGxvY2F0ZWQgPj4gMl0gPSByZXMuYWxsb2NhdGVkO1xuICAgICAgICBIRUFQVTMyW2FkZHIgPj4gMl0gPSBwdHI7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19tdW5tYXBfanMoYWRkciwgbGVuLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIGlmIChwcm90ICYgMikge1xuICAgICAgICAgIFNZU0NBTExTLmRvTXN5bmMoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIEZTLm11bm1hcChzdHJlYW0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVVVEY4KHN0cikge1xuICAgICAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gICAgICB2YXIgcmV0ID0gX21hbGxvYyhzaXplKTtcbiAgICAgIGlmIChyZXQpIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUDgsIHJldCwgc2l6ZSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfX3R6c2V0X2pzKHRpbWV6b25lLCBkYXlsaWdodCwgdHpuYW1lKSB7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgd2ludGVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDAsIDEpO1xuICAgICAgdmFyIHN1bW1lciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCA2LCAxKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSB3aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgICAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgod2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpO1xuXG4gICAgICBIRUFQVTMyW3RpbWV6b25lID4+IDJdID0gc3RkVGltZXpvbmVPZmZzZXQgKiA2MDtcblxuICAgICAgSEVBUDMyW2RheWxpZ2h0ID4+IDJdID0gTnVtYmVyKHdpbnRlck9mZnNldCAhPSBzdW1tZXJPZmZzZXQpO1xuXG4gICAgICBmdW5jdGlvbiBleHRyYWN0Wm9uZShkYXRlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRhdGUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnR01UJztcbiAgICAgIH1cbiAgICAgIHZhciB3aW50ZXJOYW1lID0gZXh0cmFjdFpvbmUod2ludGVyKTtcbiAgICAgIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyKTtcbiAgICAgIHZhciB3aW50ZXJOYW1lUHRyID0gYWxsb2NhdGVVVEY4KHdpbnRlck5hbWUpO1xuICAgICAgdmFyIHN1bW1lck5hbWVQdHIgPSBhbGxvY2F0ZVVURjgoc3VtbWVyTmFtZSk7XG4gICAgICBpZiAoc3VtbWVyT2Zmc2V0IDwgd2ludGVyT2Zmc2V0KSB7XG4gICAgICAgIEhFQVBVMzJbdHpuYW1lID4+IDJdID0gd2ludGVyTmFtZVB0cjtcbiAgICAgICAgSEVBUFUzMlsodHpuYW1lICsgNCkgPj4gMl0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSEVBUFUzMlt0em5hbWUgPj4gMl0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgICBIRUFQVTMyWyh0em5hbWUgKyA0KSA+PiAyXSA9IHdpbnRlck5hbWVQdHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZGF0ZV9ub3coKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztcbiAgICBfZW1zY3JpcHRlbl9nZXRfbm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiAgICAgIHJldHVybiAyMTQ3NDgzNjQ4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIoc2l6ZSkge1xuICAgICAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdhc21NZW1vcnkuZ3Jvdygoc2l6ZSAtIGIuYnl0ZUxlbmd0aCArIDY1NTM1KSA+Pj4gMTYpO1xuICAgICAgICB1cGRhdGVNZW1vcnlWaWV3cygpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpIHtcbiAgICAgIHZhciBvbGRTaXplID0gSEVBUFU4Lmxlbmd0aDtcbiAgICAgIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuXG4gICAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFsaWduVXAgPSAoeCwgbXVsdGlwbGUpID0+XG4gICAgICAgIHggKyAoKG11bHRpcGxlIC0gKHggJSBtdWx0aXBsZSkpICUgbXVsdGlwbGUpO1xuXG4gICAgICBmb3IgKHZhciBjdXREb3duID0gMTsgY3V0RG93biA8PSA0OyBjdXREb3duICo9IDIpIHtcbiAgICAgICAgdmFyIG92ZXJHcm93bkhlYXBTaXplID0gb2xkU2l6ZSAqICgxICsgMC4yIC8gY3V0RG93bik7XG5cbiAgICAgICAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihcbiAgICAgICAgICBvdmVyR3Jvd25IZWFwU2l6ZSxcbiAgICAgICAgICByZXF1ZXN0ZWRTaXplICsgMTAwNjYzMjk2LFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4oXG4gICAgICAgICAgbWF4SGVhcFNpemUsXG4gICAgICAgICAgYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLCBvdmVyR3Jvd25IZWFwU2l6ZSksIDY1NTM2KSxcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKG5ld1NpemUpO1xuICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBFTlYgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVOYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXNQcm9ncmFtIHx8ICcuL3RoaXMucHJvZ3JhbSc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gICAgICBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICAgICAgICB2YXIgbGFuZyA9XG4gICAgICAgICAgKFxuICAgICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJlxuICAgICAgICAgICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fFxuICAgICAgICAgICAgJ0MnXG4gICAgICAgICAgKS5yZXBsYWNlKCctJywgJ18nKSArICcuVVRGLTgnO1xuICAgICAgICB2YXIgZW52ID0ge1xuICAgICAgICAgIFVTRVI6ICd3ZWJfdXNlcicsXG4gICAgICAgICAgTE9HTkFNRTogJ3dlYl91c2VyJyxcbiAgICAgICAgICBQQVRIOiAnLycsXG4gICAgICAgICAgUFdEOiAnLycsXG4gICAgICAgICAgSE9NRTogJy9ob21lL3dlYl91c2VyJyxcbiAgICAgICAgICBMQU5HOiBsYW5nLFxuICAgICAgICAgIF86IGdldEV4ZWN1dGFibGVOYW1lKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgeCBpbiBFTlYpIHtcbiAgICAgICAgICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07XG4gICAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goeCArICc9JyArIGVudlt4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0ciwgYnVmZmVyLCBkb250QWRkTnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgSEVBUDhbYnVmZmVyKysgPj4gMF0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb250QWRkTnVsbCkgSEVBUDhbYnVmZmVyID4+IDBdID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW52aXJvbl9nZXQoX19lbnZpcm9uLCBlbnZpcm9uX2J1Zikge1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKHN0cmluZywgaSkge1xuICAgICAgICB2YXIgcHRyID0gZW52aXJvbl9idWYgKyBidWZTaXplO1xuICAgICAgICBIRUFQVTMyWyhfX2Vudmlyb24gKyBpICogNCkgPj4gMl0gPSBwdHI7XG4gICAgICAgIHdyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcsIHB0cik7XG4gICAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiAgICAgIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuICAgICAgSEVBUFUzMltwZW52aXJvbl9jb3VudCA+PiAyXSA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgSEVBUFUzMltwZW52aXJvbl9idWZfc2l6ZSA+PiAyXSA9IGJ1ZlNpemU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQsIHBidWYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuXG4gICAgICAgIHZhciB0eXBlID0gc3RyZWFtLnR0eVxuICAgICAgICAgID8gMlxuICAgICAgICAgIDogRlMuaXNEaXIoc3RyZWFtLm1vZGUpXG4gICAgICAgICAgICA/IDNcbiAgICAgICAgICAgIDogRlMuaXNMaW5rKHN0cmVhbS5tb2RlKVxuICAgICAgICAgICAgICA/IDdcbiAgICAgICAgICAgICAgOiA0O1xuICAgICAgICBIRUFQOFtwYnVmID4+IDBdID0gdHlwZTtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgICB2YXIgcHRyID0gSEVBUFUzMltpb3YgPj4gMl07XG4gICAgICAgIHZhciBsZW4gPSBIRUFQVTMyWyhpb3YgKyA0KSA+PiAyXTtcbiAgICAgICAgaW92ICs9IDg7XG4gICAgICAgIHZhciBjdXJyID0gRlMucmVhZChzdHJlYW0sIEhFQVA4LCBwdHIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGN1cnIgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIHJldCArPSBjdXJyO1xuICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWs7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mZF9yZWFkKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHZhciBudW0gPSBkb1JlYWR2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgICAgICBIRUFQVTMyW3BudW0gPj4gMl0gPSBudW07XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmRfc2VlayhmZCwgb2Zmc2V0LCB3aGVuY2UsIG5ld09mZnNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2Zmc2V0ID0gYmlnaW50VG9JNTNDaGVja2VkKG9mZnNldCk7XG4gICAgICAgIGlmIChpc05hTihvZmZzZXQpKSByZXR1cm4gNjE7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBGUy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7XG4gICAgICAgICh0ZW1wSTY0ID0gW1xuICAgICAgICAgIHN0cmVhbS5wb3NpdGlvbiA+Pj4gMCxcbiAgICAgICAgICAoKHRlbXBEb3VibGUgPSBzdHJlYW0ucG9zaXRpb24pLFxuICAgICAgICAgICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxLjBcbiAgICAgICAgICAgID8gdGVtcERvdWJsZSA+IDAuMFxuICAgICAgICAgICAgICA/IChNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2LjApLFxuICAgICAgICAgICAgICAgICAgNDI5NDk2NzI5NS4wLFxuICAgICAgICAgICAgICAgICkgfFxuICAgICAgICAgICAgICAgICAgMCkgPj4+XG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICA6IH5+K01hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYuMCxcbiAgICAgICAgICAgICAgICApID4+PiAwXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICBdKSxcbiAgICAgICAgICAoSEVBUDMyW25ld09mZnNldCA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgICAgIChIRUFQMzJbKG5ld09mZnNldCArIDQpID4+IDJdID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMgJiYgb2Zmc2V0ID09PSAwICYmIHdoZW5jZSA9PT0gMClcbiAgICAgICAgICBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZkX3N5bmMoZmQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMgJiYgc3RyZWFtLnN0cmVhbV9vcHMuZnN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuZnN5bmMoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgcmV0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+IDJdO1xuICAgICAgICB2YXIgbGVuID0gSEVBUFUzMlsoaW92ICsgNCkgPj4gMl07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICB2YXIgY3VyciA9IEZTLndyaXRlKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgcmV0ICs9IGN1cnI7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mZF93cml0ZShmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICB2YXIgbnVtID0gZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCk7XG4gICAgICAgIEhFQVBVMzJbcG51bSA+PiAyXSA9IG51bTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBGU05vZGUgPSBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLm1vdW50ID0gcGFyZW50Lm1vdW50O1xuICAgICAgdGhpcy5tb3VudGVkID0gbnVsbDtcbiAgICAgIHRoaXMuaWQgPSBGUy5uZXh0SW5vZGUrKztcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5ub2RlX29wcyA9IHt9O1xuICAgICAgdGhpcy5zdHJlYW1fb3BzID0ge307XG4gICAgICB0aGlzLnJkZXYgPSByZGV2O1xuICAgIH07XG4gICAgdmFyIHJlYWRNb2RlID0gMjkyIHwgNzM7XG4gICAgdmFyIHdyaXRlTW9kZSA9IDE0NjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGU05vZGUucHJvdG90eXBlLCB7XG4gICAgICByZWFkOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgcmVhZE1vZGUpID09PSByZWFkTW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgdmFsID8gKHRoaXMubW9kZSB8PSByZWFkTW9kZSkgOiAodGhpcy5tb2RlICY9IH5yZWFkTW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgd3JpdGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiB3cml0ZU1vZGUpID09PSB3cml0ZU1vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHZhbCA/ICh0aGlzLm1vZGUgfD0gd3JpdGVNb2RlKSA6ICh0aGlzLm1vZGUgJj0gfndyaXRlTW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgaXNGb2xkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgaXNEZXZpY2U6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEZTLmlzQ2hyZGV2KHRoaXMubW9kZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIEZTLkZTTm9kZSA9IEZTTm9kZTtcbiAgICBGUy5zdGF0aWNJbml0KCk7XG4gICAgdmFyIEFTU0VSVElPTlMgPSBmYWxzZTtcblxuICAgIHZhciBhc21MaWJyYXJ5QXJnID0ge1xuICAgICAgX19zeXNjYWxsX2NobW9kOiBfX19zeXNjYWxsX2NobW9kLFxuICAgICAgX19zeXNjYWxsX2ZhY2Nlc3NhdDogX19fc3lzY2FsbF9mYWNjZXNzYXQsXG4gICAgICBfX3N5c2NhbGxfZmNobW9kOiBfX19zeXNjYWxsX2ZjaG1vZCxcbiAgICAgIF9fc3lzY2FsbF9mY2hvd24zMjogX19fc3lzY2FsbF9mY2hvd24zMixcbiAgICAgIF9fc3lzY2FsbF9mY250bDY0OiBfX19zeXNjYWxsX2ZjbnRsNjQsXG4gICAgICBfX3N5c2NhbGxfZnN0YXQ2NDogX19fc3lzY2FsbF9mc3RhdDY0LFxuICAgICAgX19zeXNjYWxsX2Z0cnVuY2F0ZTY0OiBfX19zeXNjYWxsX2Z0cnVuY2F0ZTY0LFxuICAgICAgX19zeXNjYWxsX2dldGN3ZDogX19fc3lzY2FsbF9nZXRjd2QsXG4gICAgICBfX3N5c2NhbGxfaW9jdGw6IF9fX3N5c2NhbGxfaW9jdGwsXG4gICAgICBfX3N5c2NhbGxfbHN0YXQ2NDogX19fc3lzY2FsbF9sc3RhdDY0LFxuICAgICAgX19zeXNjYWxsX21rZGlyYXQ6IF9fX3N5c2NhbGxfbWtkaXJhdCxcbiAgICAgIF9fc3lzY2FsbF9uZXdmc3RhdGF0OiBfX19zeXNjYWxsX25ld2ZzdGF0YXQsXG4gICAgICBfX3N5c2NhbGxfb3BlbmF0OiBfX19zeXNjYWxsX29wZW5hdCxcbiAgICAgIF9fc3lzY2FsbF9yZWFkbGlua2F0OiBfX19zeXNjYWxsX3JlYWRsaW5rYXQsXG4gICAgICBfX3N5c2NhbGxfcm1kaXI6IF9fX3N5c2NhbGxfcm1kaXIsXG4gICAgICBfX3N5c2NhbGxfc3RhdDY0OiBfX19zeXNjYWxsX3N0YXQ2NCxcbiAgICAgIF9fc3lzY2FsbF91bmxpbmthdDogX19fc3lzY2FsbF91bmxpbmthdCxcbiAgICAgIF9fc3lzY2FsbF91dGltZW5zYXQ6IF9fX3N5c2NhbGxfdXRpbWVuc2F0LFxuICAgICAgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWM6IF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyxcbiAgICAgIF9sb2NhbHRpbWVfanM6IF9fbG9jYWx0aW1lX2pzLFxuICAgICAgX21tYXBfanM6IF9fbW1hcF9qcyxcbiAgICAgIF9tdW5tYXBfanM6IF9fbXVubWFwX2pzLFxuICAgICAgX3R6c2V0X2pzOiBfX3R6c2V0X2pzLFxuICAgICAgZW1zY3JpcHRlbl9kYXRlX25vdzogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gICAgICBlbXNjcmlwdGVuX2dldF9ub3c6IF9lbXNjcmlwdGVuX2dldF9ub3csXG4gICAgICBlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgICAgIGVudmlyb25fZ2V0OiBfZW52aXJvbl9nZXQsXG4gICAgICBlbnZpcm9uX3NpemVzX2dldDogX2Vudmlyb25fc2l6ZXNfZ2V0LFxuICAgICAgZmRfY2xvc2U6IF9mZF9jbG9zZSxcbiAgICAgIGZkX2Zkc3RhdF9nZXQ6IF9mZF9mZHN0YXRfZ2V0LFxuICAgICAgZmRfcmVhZDogX2ZkX3JlYWQsXG4gICAgICBmZF9zZWVrOiBfZmRfc2VlayxcbiAgICAgIGZkX3N5bmM6IF9mZF9zeW5jLFxuICAgICAgZmRfd3JpdGU6IF9mZF93cml0ZSxcbiAgICAgIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgICB9O1xuICAgIHZhciBhc20gPSBjcmVhdGVXYXNtKCk7XG5cbiAgICB2YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gKE1vZHVsZVsnX19fd2FzbV9jYWxsX2N0b3JzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9fX3dhc21fY2FsbF9jdG9ycyA9IE1vZHVsZVsnX19fd2FzbV9jYWxsX2N0b3JzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3N0YXR1czY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzNjQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfc3RhdHVzNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3N0YXR1czY0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0YXR1czY0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfc3RhdHVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0YXR1cyA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RhdHVzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0YXR1cyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2RiX3N0YXR1cyA9IChNb2R1bGVbJ19zcWxpdGUzX2RiX3N0YXR1cyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19kYl9zdGF0dXMgPSBNb2R1bGVbJ19zcWxpdGUzX2RiX3N0YXR1cyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kYl9zdGF0dXMnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19tc2l6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX21zaXplJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX21zaXplID0gTW9kdWxlWydfc3FsaXRlM19tc2l6ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19tc2l6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Zmc19maW5kID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmZzX2ZpbmQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmZzX2ZpbmQgPSBNb2R1bGVbJ19zcWxpdGUzX3Zmc19maW5kJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Zmc19maW5kJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2luaXRpYWxpemUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfaW5pdGlhbGl6ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19pbml0aWFsaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfbWFsbG9jID0gKE1vZHVsZVsnX3NxbGl0ZTNfbWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX21hbGxvYyA9IE1vZHVsZVsnX3NxbGl0ZTNfbWFsbG9jJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX21hbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2ZyZWUgPSAoTW9kdWxlWydfc3FsaXRlM19mcmVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2ZyZWUgPSBNb2R1bGVbJ19zcWxpdGUzX2ZyZWUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZnJlZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Zmc19yZWdpc3RlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Zmc19yZWdpc3RlciddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM192ZnNfcmVnaXN0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Zmc19yZWdpc3RlciddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192ZnNfcmVnaXN0ZXInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192ZnNfdW5yZWdpc3RlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Zmc191bnJlZ2lzdGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Zmc191bnJlZ2lzdGVyID0gTW9kdWxlWydfc3FsaXRlM192ZnNfdW5yZWdpc3RlciddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Zmc191bnJlZ2lzdGVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19tYWxsb2M2NCA9IChNb2R1bGVbJ19zcWxpdGUzX21hbGxvYzY0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX21hbGxvYzY0ID0gTW9kdWxlWydfc3FsaXRlM19tYWxsb2M2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19tYWxsb2M2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3JlYWxsb2MgPSAoTW9kdWxlWydfc3FsaXRlM19yZWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3JlYWxsb2MgPSBNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2MnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVhbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3JlYWxsb2M2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2M2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19yZWFsbG9jNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3JlYWxsb2M2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZWFsbG9jNjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfdGV4dCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV90ZXh0ID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV90ZXh0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX3RleHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yYW5kb21uZXNzID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmFuZG9tbmVzcyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19yYW5kb21uZXNzID0gTW9kdWxlWydfc3FsaXRlM19yYW5kb21uZXNzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3JhbmRvbW5lc3MnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJpY21wID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RyaWNtcCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zdHJpY21wID0gTW9kdWxlWydfc3FsaXRlM19zdHJpY21wJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0cmljbXAnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJuaWNtcCA9IChNb2R1bGVbJ19zcWxpdGUzX3N0cm5pY21wJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0cm5pY21wID0gTW9kdWxlWydfc3FsaXRlM19zdHJuaWNtcCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zdHJuaWNtcCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSAoTW9kdWxlWydfc3FsaXRlM191cmlfcGFyYW1ldGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9wYXJhbWV0ZXInXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM191cmlfcGFyYW1ldGVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfX19lcnJub19sb2NhdGlvbiA9IChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9fX2Vycm5vX2xvY2F0aW9uID0gTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnX19lcnJub19sb2NhdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9ib29sZWFuID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXJpX2Jvb2xlYW4nXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdXJpX2Jvb2xlYW4gPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9ib29sZWFuJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3VyaV9ib29sZWFuJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfc2VyaWFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfc2VyaWFsaXplJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3NlcmlhbGl6ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfc2VyaWFsaXplJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3NlcmlhbGl6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXBhcmVfdjIgPSAoTW9kdWxlWydfc3FsaXRlM19wcmVwYXJlX3YyJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ByZXBhcmVfdjIgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXBhcmVfdjInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJlcGFyZV92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3N0ZXAgPSAoTW9kdWxlWydfc3FsaXRlM19zdGVwJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0ZXAgPSBNb2R1bGVbJ19zcWxpdGUzX3N0ZXAnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfc3RlcCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQ2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5faW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb2x1bW5faW50NjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXNldCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc2V0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc2V0ID0gTW9kdWxlWydfc3FsaXRlM19yZXNldCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXNldCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2V4ZWMgPSAoTW9kdWxlWydfc3FsaXRlM19leGVjJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2V4ZWMgPSBNb2R1bGVbJ19zcWxpdGUzX2V4ZWMnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZXhlYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5faW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2ludCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2ZpbmFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfZmluYWxpemUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZmluYWxpemUgPSBNb2R1bGVbJ19zcWxpdGUzX2ZpbmFsaXplJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2ZpbmFsaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZmlsZV9jb250cm9sID0gKE1vZHVsZVsnX3NxbGl0ZTNfZmlsZV9jb250cm9sJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2ZpbGVfY29udHJvbCA9IE1vZHVsZVsnX3NxbGl0ZTNfZmlsZV9jb250cm9sJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2ZpbGVfY29udHJvbCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9uYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX25hbWUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX25hbWUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9uYW1lJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbHVtbl9uYW1lJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX3RleHQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fdGV4dCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fdGV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX3RleHQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX3RleHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fdHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl90eXBlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl90eXBlID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fdHlwZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb2x1bW5fdHlwZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2Vycm1zZyA9IChNb2R1bGVbJ19zcWxpdGUzX2Vycm1zZyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJtc2cgPSBNb2R1bGVbJ19zcWxpdGUzX2Vycm1zZyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19lcnJtc2cnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19kZXNlcmlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2Rlc2VyaWFsaXplJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2Rlc2VyaWFsaXplID0gTW9kdWxlWydfc3FsaXRlM19kZXNlcmlhbGl6ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kZXNlcmlhbGl6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MgPSBNb2R1bGVbJ19zcWxpdGUzX2NsZWFyX2JpbmRpbmdzJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ibG9iJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2Jsb2InXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfYmxvYiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2J5dGVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfYnl0ZXMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfYnl0ZXMgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2J5dGVzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX2J5dGVzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZG91YmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZG91YmxlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZG91YmxlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX2RvdWJsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2ludCA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9pbnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludDY0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2ludDY0ID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9pbnQ2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX3N1YnR5cGUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9zdWJ0eXBlJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX3N1YnR5cGUgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3N1YnR5cGUnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9zdWJ0eXBlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfcG9pbnRlciddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9wb2ludGVyJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfcG9pbnRlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfdHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3R5cGUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfdHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfdHlwZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV90eXBlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9ub2NoYW5nZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9mcm9tYmluZCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9mcm9tYmluZCA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192YWx1ZV9mcm9tYmluZCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZHVwID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZHVwJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2R1cCA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZHVwJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ZhbHVlX2R1cCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9mcmVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ZyZWUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfZnJlZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9ibG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Jsb2InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9ibG9iJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc3VsdF9ibG9iJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0gPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZG91YmxlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2RvdWJsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9lcnJvciA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc3VsdF9lcnJvciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfaW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2ludCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQ2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfaW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfaW50NjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfbnVsbCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9udWxsJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9udWxsID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfbnVsbCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfbnVsbCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9wb2ludGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9wb2ludGVyJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3RleHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3RleHQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF90ZXh0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc3VsdF90ZXh0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0ID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VzZXJfZGF0YSA9IChNb2R1bGVbJ19zcWxpdGUzX3VzZXJfZGF0YSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM191c2VyX2RhdGEgPSBNb2R1bGVbJ19zcWxpdGUzX3VzZXJfZGF0YSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM191c2VyX2RhdGEnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luX2ZpcnN0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW5fZmlyc3QnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192dGFiX2luX2ZpcnN0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192dGFiX2luX25leHQgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luX25leHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9pbl9uZXh0ID0gTW9kdWxlWydfc3FsaXRlM192dGFiX2luX25leHQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9pbl9uZXh0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQgPSAoTW9kdWxlWydfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2dldF9hdXhkYXRhID0gKE1vZHVsZVsnX3NxbGl0ZTNfZ2V0X2F1eGRhdGEnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZ2V0X2F1eGRhdGEgPSBNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXhkYXRhJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2dldF9hdXhkYXRhJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfc2V0X2F1eGRhdGEgPSAoTW9kdWxlWydfc3FsaXRlM19zZXRfYXV4ZGF0YSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zZXRfYXV4ZGF0YSA9IE1vZHVsZVsnX3NxbGl0ZTNfc2V0X2F1eGRhdGEnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfc2V0X2F1eGRhdGEnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fY291bnQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fY291bnQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2NvdW50ID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fY291bnQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2NvdW50J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZGF0YV9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX2RhdGFfY291bnQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZGF0YV9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfZGF0YV9jb3VudCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kYXRhX2NvdW50J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYmxvYiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fYmxvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2Jsb2InXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2Jsb2InXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fYnl0ZXMgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYnl0ZXMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2J5dGVzID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fYnl0ZXMnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY29sdW1uX2J5dGVzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9kb3VibGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbHVtbl9kb3VibGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl92YWx1ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl92YWx1ZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fdmFsdWUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl92YWx1ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb2x1bW5fdmFsdWUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2Jsb2InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfYmluZF9ibG9iID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX2Jsb2InXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9ibG9iJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9kb3VibGUgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2RvdWJsZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19iaW5kX2RvdWJsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9kb3VibGUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9kb3VibGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX2ludCA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfaW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfaW50ID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19iaW5kX2ludCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfaW50NjQgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludDY0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfaW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfaW50NjQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9pbnQ2NCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfbnVsbCA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfbnVsbCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19iaW5kX251bGwgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfbnVsbCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19iaW5kX251bGwnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX3BvaW50ZXIgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX3BvaW50ZXInXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfYmluZF9wb2ludGVyID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX3BvaW50ZXInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9wb2ludGVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYmluZF90ZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF90ZXh0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfdGV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF90ZXh0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2JpbmRfdGV4dCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50ID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50J1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXggPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZGJfaGFuZGxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfaGFuZGxlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2RiX2hhbmRsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfZGJfaGFuZGxlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2RiX2hhbmRsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3N0bXRfcmVhZG9ubHkgPSAoTW9kdWxlWydfc3FsaXRlM19zdG10X3JlYWRvbmx5J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfcmVhZG9ubHkgPSBNb2R1bGVbJ19zcWxpdGUzX3N0bXRfcmVhZG9ubHknXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zdG10X3JlYWRvbmx5J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdG10X2lzZXhwbGFpbiA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfaXNleHBsYWluJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfaXNleHBsYWluID0gTW9kdWxlWydfc3FsaXRlM19zdG10X2lzZXhwbGFpbiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0bXRfaXNleHBsYWluJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdG10X3N0YXR1cyA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfc3RhdHVzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfc3RhdHVzID0gTW9kdWxlWydfc3FsaXRlM19zdG10X3N0YXR1cyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zdG10X3N0YXR1cyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3NxbCA9IChNb2R1bGVbJ19zcWxpdGUzX3NxbCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zcWwgPSBNb2R1bGVbJ19zcWxpdGUzX3NxbCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zcWwnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19leHBhbmRlZF9zcWwgPSAoTW9kdWxlWydfc3FsaXRlM19leHBhbmRlZF9zcWwnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfZXhwYW5kZWRfc3FsID0gTW9kdWxlWydfc3FsaXRlM19leHBhbmRlZF9zcWwnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZXhwYW5kZWRfc3FsJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9vbGQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX29sZCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfY291bnQgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9uZXcgPSAoTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfbmV3J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9uZXcgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9uZXcnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19wcmV1cGRhdGVfbmV3J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zZXRfYXV0aG9yaXplciA9IChNb2R1bGVbJ19zcWxpdGUzX3NldF9hdXRob3JpemVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3NldF9hdXRob3JpemVyID0gTW9kdWxlWydfc3FsaXRlM19zZXRfYXV0aG9yaXplciddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3NldF9hdXRob3JpemVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJnbG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RyZ2xvYiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zdHJnbG9iID0gTW9kdWxlWydfc3FsaXRlM19zdHJnbG9iJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0cmdsb2InXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zdHJsaWtlID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RybGlrZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zdHJsaWtlID0gTW9kdWxlWydfc3FsaXRlM19zdHJsaWtlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3N0cmxpa2UnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IChNb2R1bGVbJ19zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlWydfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbidcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24nXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbidcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcHJlcGFyZV92MyA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXBhcmVfdjMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfcHJlcGFyZV92MyA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJlcGFyZV92MyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19wcmVwYXJlX3YzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9tb2R1bGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV9tb2R1bGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIgPSAoTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfZHJvcF9tb2R1bGVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfZHJvcF9tb2R1bGVzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2Ryb3BfbW9kdWxlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfZHJvcF9tb2R1bGVzJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2Ryb3BfbW9kdWxlcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2RlY2xhcmVfdnRhYiA9IChNb2R1bGVbJ19zcWxpdGUzX2RlY2xhcmVfdnRhYiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19kZWNsYXJlX3Z0YWIgPSBNb2R1bGVbJ19zcWxpdGUzX2RlY2xhcmVfdnRhYiddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kZWNsYXJlX3Z0YWInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24gPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfY29sbGF0aW9uJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfaW4gPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfaW4gPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW4nXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9pbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfZGlzdGluY3QgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2Rpc3RpbmN0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfZGlzdGluY3QgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfZGlzdGluY3QnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM192dGFiX2Rpc3RpbmN0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19rZXl3b3JkX25hbWUgPSAoTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX25hbWUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfa2V5d29yZF9uYW1lID0gTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX25hbWUnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfa2V5d29yZF9uYW1lJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfY291bnQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9jb3VudCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2tleXdvcmRfY291bnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2tleXdvcmRfY2hlY2sgPSAoTW9kdWxlWydfc3FsaXRlM19rZXl3b3JkX2NoZWNrJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2tleXdvcmRfY2hlY2sgPSBNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfY2hlY2snXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19rZXl3b3JkX2NoZWNrJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb21wbGV0ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbXBsZXRlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbXBsZXRlID0gTW9kdWxlWydfc3FsaXRlM19jb21wbGV0ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb21wbGV0ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2xpYnZlcnNpb24gPSAoTW9kdWxlWydfc3FsaXRlM19saWJ2ZXJzaW9uJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2xpYnZlcnNpb24gPSBNb2R1bGVbJ19zcWxpdGUzX2xpYnZlcnNpb24nXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfbGlidmVyc2lvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zaHV0ZG93biA9IChNb2R1bGVbJ19zcWxpdGUzX3NodXRkb3duJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3NodXRkb3duID0gTW9kdWxlWydfc3FsaXRlM19zaHV0ZG93biddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zaHV0ZG93biddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkID0gKE1vZHVsZVsnX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jaGFuZ2VzNjQgPSAoTW9kdWxlWydfc3FsaXRlM19jaGFuZ2VzNjQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2hhbmdlczY0ID0gTW9kdWxlWydfc3FsaXRlM19jaGFuZ2VzNjQnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY2hhbmdlczY0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY2hhbmdlcyA9IChNb2R1bGVbJ19zcWxpdGUzX2NoYW5nZXMnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2hhbmdlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfY2hhbmdlcyddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jaGFuZ2VzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM190b3RhbF9jaGFuZ2VzID0gKE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlcyddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM190b3RhbF9jaGFuZ2VzID0gTW9kdWxlWydfc3FsaXRlM190b3RhbF9jaGFuZ2VzJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdG90YWxfY2hhbmdlcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdHhuX3N0YXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdHhuX3N0YXRlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3R4bl9zdGF0ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdHhuX3N0YXRlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3R4bl9zdGF0ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2Nsb3NlX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2xvc2VfdjInXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfY2xvc2VfdjIgPSBNb2R1bGVbJ19zcWxpdGUzX2Nsb3NlX3YyJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2Nsb3NlX3YyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYnVzeV9oYW5kbGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV9oYW5kbGVyJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2J1c3lfaGFuZGxlciA9IE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV9oYW5kbGVyJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2J1c3lfaGFuZGxlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIgPSAoTW9kdWxlWydfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfYnVzeV90aW1lb3V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV90aW1lb3V0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2J1c3lfdGltZW91dCA9IE1vZHVsZVsnX3NxbGl0ZTNfYnVzeV90aW1lb3V0J10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2J1c3lfdGltZW91dCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbidcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbidcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiA9IChNb2R1bGVbJ19zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfdHJhY2VfdjIgPSAoTW9kdWxlWydfc3FsaXRlM190cmFjZV92MiddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM190cmFjZV92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfdHJhY2VfdjInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdHJhY2VfdjInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb21taXRfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbW1pdF9ob29rJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2NvbW1pdF9ob29rID0gTW9kdWxlWydfc3FsaXRlM19jb21taXRfaG9vayddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb21taXRfaG9vayddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VwZGF0ZV9ob29rID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXBkYXRlX2hvb2snXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfdXBkYXRlX2hvb2sgPSBNb2R1bGVbJ19zcWxpdGUzX3VwZGF0ZV9ob29rJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3VwZGF0ZV9ob29rJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX3JvbGxiYWNrX2hvb2snXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IE1vZHVsZVsnX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3JvbGxiYWNrX2hvb2snXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2sgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9ob29rJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2Vycm9yX29mZnNldCA9IChNb2R1bGVbJ19zcWxpdGUzX2Vycm9yX29mZnNldCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJvcl9vZmZzZXQgPSBNb2R1bGVbJ19zcWxpdGUzX2Vycm9yX29mZnNldCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19lcnJvcl9vZmZzZXQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19lcnJjb2RlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXJyY29kZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJjb2RlID0gTW9kdWxlWydfc3FsaXRlM19lcnJjb2RlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2VycmNvZGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2VycnN0ciA9IChNb2R1bGVbJ19zcWxpdGUzX2VycnN0ciddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19lcnJzdHIgPSBNb2R1bGVbJ19zcWxpdGUzX2VycnN0ciddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19lcnJzdHInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19saW1pdCA9IChNb2R1bGVbJ19zcWxpdGUzX2xpbWl0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2xpbWl0ID0gTW9kdWxlWydfc3FsaXRlM19saW1pdCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19saW1pdCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX29wZW4gPSAoTW9kdWxlWydfc3FsaXRlM19vcGVuJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX29wZW4gPSBNb2R1bGVbJ19zcWxpdGUzX29wZW4nXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfb3BlbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX29wZW5fdjIgPSAoTW9kdWxlWydfc3FsaXRlM19vcGVuX3YyJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX29wZW5fdjIgPSBNb2R1bGVbJ19zcWxpdGUzX29wZW5fdjInXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfb3Blbl92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSAoTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24nXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2dldF9hdXRvY29tbWl0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQgPSBNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXRvY29tbWl0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9rZXkgPSAoTW9kdWxlWydfc3FsaXRlM191cmlfa2V5J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3VyaV9rZXkgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9rZXknXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfdXJpX2tleSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3VyaV9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3VyaV9pbnQ2NCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM191cmlfaW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX3VyaV9pbnQ2NCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM191cmlfaW50NjQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19kYl9uYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfbmFtZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM19kYl9uYW1lID0gTW9kdWxlWydfc3FsaXRlM19kYl9uYW1lJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2RiX25hbWUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19kYl9maWxlbmFtZSA9IChNb2R1bGVbJ19zcWxpdGUzX2RiX2ZpbGVuYW1lJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX2RiX2ZpbGVuYW1lID0gTW9kdWxlWydfc3FsaXRlM19kYl9maWxlbmFtZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19kYl9maWxlbmFtZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fZGlmZiA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kaWZmJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9kaWZmID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fZGlmZiddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fZGlmZiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fYXR0YWNoJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9hdHRhY2gnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fYXR0YWNoJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY3JlYXRlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kZWxldGUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9kZWxldGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0nXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fZW5hYmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fZW5hYmxlID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fZW5hYmxlJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCA9IE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5J10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5ID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9pc2VtcHR5J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9zdGFydCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjIgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0gPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0nXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9uZXh0ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9uZXh0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXh0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfb3AgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9vcCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9vcCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfb3AnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfb3AnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9wayA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3BrJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3BrID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9wayddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9wayddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X29sZCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X29sZCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9vbGQgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X29sZCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9vbGQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9uZXcgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXcnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfbmV3ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXcnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9hcHBseSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9hcHBseSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY29uZmlnJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jb25maWcnXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM3Nlc3Npb25fY29uZmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM19zb3VyY2VpZCA9IChNb2R1bGVbJ19zcWxpdGUzX3NvdXJjZWlkJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3NvdXJjZWlkID0gTW9kdWxlWydfc3FsaXRlM19zb3VyY2VpZCddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM19zb3VyY2VpZCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19wdHIgPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fcHN0YWNrX3B0ciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmUnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3BzdGFja19hbGxvYydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmcnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX3BzdGFja19xdW90YSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19xdW90YSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2RiX2Vycm9yJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfZXJyb3InXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX2Vycm9yJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cnVjdCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0ID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0J1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdGVzdF9zdHJ1Y3QnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fZW51bV9qc29uID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24gPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fZW51bV9qc29uJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fdmZzX3VubGluayA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdmZzX3VubGluayddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Zmc191bmxpbmsgPSBNb2R1bGVbJ19zcWxpdGUzX3dhc21fdmZzX3VubGluayddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdmZzX3VubGluayddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl92ZnMgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2RiX3ZmcyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX3ZmcyA9IE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9kYl92ZnMnXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9kYl92ZnMnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2RiX3Jlc2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9kYl9yZXNldCddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX3Jlc2V0ID0gTW9kdWxlWydfc3FsaXRlM193YXNtX2RiX3Jlc2V0J10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9kYl9yZXNldCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX2V4cG9ydF9jaHVua2VkID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fZGJfZXhwb3J0X2NodW5rZWQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUnXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjayA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjaydcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjaydcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2snXSkuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kcyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdnRhYl9jb25maWcnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Z0YWJfY29uZmlnJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaSA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fZGJfY29uZmlnX3MnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19zJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX2NvbmZpZ19pID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9jb25maWdfaSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2NvbmZpZ19pID0gTW9kdWxlWydfc3FsaXRlM193YXNtX2NvbmZpZ19pJ10gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9jb25maWdfaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9jb25maWdfaWkgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2NvbmZpZ19paSddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX2NvbmZpZ19paSA9IE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9jb25maWdfaWknXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX2NvbmZpZ19paSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV9jb25maWdfaiA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fY29uZmlnX2onXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9jb25maWdfaiA9IE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV9jb25maWdfaiddID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fY29uZmlnX2onXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21faW5pdF93YXNtZnMgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX2luaXRfd2FzbWZzJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21faW5pdF93YXNtZnMgPSBNb2R1bGVbXG4gICAgICAgICAgJ19zcWxpdGUzX3dhc21faW5pdF93YXNtZnMnXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9pbml0X3dhc21mcyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0ciA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF9pbnRwdHInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0ciA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0cidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3RfaW50cHRyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0ciA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyJ10gPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0cidcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0ciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9tYXgnXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCdcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWF4J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluID0gKE1vZHVsZVsnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW4nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczIgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczInXG4gICAgXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X3RpbWVzMiA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczInXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfdGltZXMyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCdcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWlubWF4ID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCdcbiAgICAgIF0gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5tYXgnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHIgPSAoTW9kdWxlWydfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHInXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyID0gTW9kdWxlW1xuICAgICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHInXG4gICAgICAgIF0gPVxuICAgICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdydcbiAgICBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cnXSkuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB2YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbyA9IChNb2R1bGVbJ19zcWxpdGUzX3dhc21fdGVzdF9zdHJfaGVsbG8nXSA9XG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbyA9IE1vZHVsZVtcbiAgICAgICAgICAnX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbydcbiAgICAgICAgXSA9XG4gICAgICAgICAgTW9kdWxlWydhc20nXVsnc3FsaXRlM193YXNtX3Rlc3Rfc3RyX2hlbGxvJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgIHZhciBfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iJ1xuICAgIF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9zcWxpdGUzX3dhc21fU1FMVGVzdGVyX3N0cmdsb2IgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iJ1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ3NxbGl0ZTNfd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9tYWxsb2MgPSAoTW9kdWxlWydfbWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9tYWxsb2MgPSBNb2R1bGVbJ19tYWxsb2MnXSA9IE1vZHVsZVsnYXNtJ11bJ21hbGxvYyddKS5hcHBseShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXJndW1lbnRzLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHZhciBfZnJlZSA9IChNb2R1bGVbJ19mcmVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9mcmVlID0gTW9kdWxlWydfZnJlZSddID0gTW9kdWxlWydhc20nXVsnZnJlZSddKS5hcHBseShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXJndW1lbnRzLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHZhciBfcmVhbGxvYyA9IChNb2R1bGVbJ19yZWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9yZWFsbG9jID0gTW9kdWxlWydfcmVhbGxvYyddID0gTW9kdWxlWydhc20nXVsncmVhbGxvYyddKS5hcHBseShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXJndW1lbnRzLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHZhciBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID0gKE1vZHVsZVsnX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiddID1cbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID0gTW9kdWxlW1xuICAgICAgICAgICdfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduJ1xuICAgICAgICBdID1cbiAgICAgICAgICBNb2R1bGVbJ2FzbSddWydlbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgdmFyIHN0YWNrU2F2ZSA9IChNb2R1bGVbJ3N0YWNrU2F2ZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzdGFja1NhdmUgPSBNb2R1bGVbJ3N0YWNrU2F2ZSddID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnc3RhY2tTYXZlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgc3RhY2tSZXN0b3JlID0gKE1vZHVsZVsnc3RhY2tSZXN0b3JlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHN0YWNrUmVzdG9yZSA9IE1vZHVsZVsnc3RhY2tSZXN0b3JlJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzdGFja1Jlc3RvcmUnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIHZhciBzdGFja0FsbG9jID0gKE1vZHVsZVsnc3RhY2tBbGxvYyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzdGFja0FsbG9jID0gTW9kdWxlWydzdGFja0FsbG9jJ10gPVxuICAgICAgICBNb2R1bGVbJ2FzbSddWydzdGFja0FsbG9jJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICBNb2R1bGVbJ3dhc21NZW1vcnknXSA9IHdhc21NZW1vcnk7XG5cbiAgICB2YXIgY2FsbGVkUnVuO1xuXG4gICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuICAgICAgaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuICAgICAgaWYgKCFjYWxsZWRSdW4pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuKGFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBhcmdzIHx8IGFyZ3VtZW50c187XG5cbiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJlUnVuKCk7XG5cbiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgICAgIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgICAgICAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgICAgICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKEFCT1JUKSByZXR1cm47XG5cbiAgICAgICAgaW5pdFJ1bnRpbWUoKTtcblxuICAgICAgICByZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7XG4gICAgICAgIGlmIChNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10pIE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSgpO1xuXG4gICAgICAgIHBvc3RSdW4oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcbiAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpO1xuICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgIGRvUnVuKCk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9SdW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICAgICAgd2hpbGUgKE1vZHVsZVsncHJlSW5pdCddLmxlbmd0aCA+IDApIHtcbiAgICAgICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBydW4oKTtcblxuICAgIGlmICghTW9kdWxlLnBvc3RSdW4pIE1vZHVsZS5wb3N0UnVuID0gW107XG4gICAgTW9kdWxlLnBvc3RSdW4ucHVzaChmdW5jdGlvbiAoTW9kdWxlKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcCA9IGZ1bmN0aW9uIHNxbGl0ZTNBcGlCb290c3RyYXAoXG4gICAgICAgIGFwaUNvbmZpZyA9IGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fFxuICAgICAgICAgIHNxbGl0ZTNBcGlCb290c3RyYXAuZGVmYXVsdENvbmZpZyxcbiAgICAgICkge1xuICAgICAgICBpZiAoc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ3NxbGl0ZTNBcGlCb290c3RyYXAoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuJyxcbiAgICAgICAgICAgICdDb25maWcgYW5kIGV4dGVybmFsIGluaXRpYWxpemVycyBhcmUgaWdub3JlZCBvbiBjYWxscyBhZnRlciB0aGUgZmlyc3QuJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4cG9ydHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1lbW9yeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmlnSW50RW5hYmxlZDogKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhTW9kdWxlLkhFQVBVNjQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5CaWdJbnQ2NEFycmF5O1xuICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgIGRlYnVnOiBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICB3YXJuOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKSxcbiAgICAgICAgICAgIGVycm9yOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICBsb2c6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICB3YXNtZnNPcGZzRGlyOiAnL29wZnMnLFxuXG4gICAgICAgICAgICB1c2VTdGRBbGxvYzogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcGlDb25maWcgfHwge30sXG4gICAgICAgICk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWxsb2NFeHBvcnROYW1lOiBjb25maWcudXNlU3RkQWxsb2MgPyAnbWFsbG9jJyA6ICdzcWxpdGUzX21hbGxvYycsXG4gICAgICAgICAgICBkZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jID8gJ2ZyZWUnIDogJ3NxbGl0ZTNfZnJlZScsXG4gICAgICAgICAgICByZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jXG4gICAgICAgICAgICAgID8gJ3JlYWxsb2MnXG4gICAgICAgICAgICAgIDogJ3NxbGl0ZTNfcmVhbGxvYycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICk7XG5cbiAgICAgICAgWydleHBvcnRzJywgJ21lbW9yeScsICd3YXNtZnNPcGZzRGlyJ10uZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgY29uZmlnW2tdKSB7XG4gICAgICAgICAgICBjb25maWdba10gPSBjb25maWdba10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNhcGkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IHdhc20gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IF9fcmNTdHIgPSAocmMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGNhcGkuc3FsaXRlM19qc19yY19zdHIgJiYgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYykpIHx8XG4gICAgICAgICAgICAnVW5rbm93biByZXN1bHQgY29kZSAjJyArIHJjXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2lzSW50ID0gKG4pID0+ICdudW1iZXInID09PSB0eXBlb2YgbiAmJiBuID09PSAobiB8IDApO1xuXG4gICAgICAgIGNsYXNzIFNRTGl0ZTNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKF9faXNJbnQoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICByYyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBzdXBlcihfX3JjU3RyKGFyZ3NbMF0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmNTdHIgPSBfX3JjU3RyKHJjKTtcbiAgICAgICAgICAgICAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIocmNTdHIsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHJjU3RyICsgJzonO1xuICAgICAgICAgICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgyID09PSBhcmdzLmxlbmd0aCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdENvZGUgPSByYyB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTUUxpdGUzRXJyb3InO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFNRTGl0ZTNFcnJvci50b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgU1FMaXRlM0Vycm9yKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3NzMyA9IFNRTGl0ZTNFcnJvci50b3NzO1xuXG4gICAgICAgIGlmIChjb25maWcud2FzbWZzT3Bmc0RpciAmJiAhL15cXC9bXi9dKyQvLnRlc3QoY29uZmlnLndhc21mc09wZnNEaXIpKSB7XG4gICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICBcImNvbmZpZy53YXNtZnNPcGZzRGlyIG11c3QgYmUgZmFsc3kgb3IgaW4gdGhlIGZvcm0gJy9kaXItbmFtZScuXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzSW50MzIgPSAobikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnYmlnaW50JyAhPT0gdHlwZW9mIG4gJiZcbiAgICAgICAgICAgICEhKG4gPT09IChuIHwgMCkgJiYgbiA8PSAyMTQ3NDgzNjQ3ICYmIG4gPj0gLTIxNDc0ODM2NDgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaWdJbnRGaXRzNjQgPSBmdW5jdGlvbiBmKGIpIHtcbiAgICAgICAgICBpZiAoIWYuX21heCkge1xuICAgICAgICAgICAgZi5fbWF4ID0gQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICAgICAgICAgIGYuX21pbiA9IH5mLl9tYXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiID49IGYuX21pbiAmJiBiIDw9IGYuX21heDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaWdJbnRGaXRzMzIgPSAoYikgPT4gYiA+PSAtMHg3ZmZmZmZmZm4gLSAxbiAmJiBiIDw9IDB4N2ZmZmZmZmZuO1xuXG4gICAgICAgIGNvbnN0IGJpZ0ludEZpdHNEb3VibGUgPSBmdW5jdGlvbiBmKGIpIHtcbiAgICAgICAgICBpZiAoIWYuX21pbikge1xuICAgICAgICAgICAgZi5fbWluID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBmLl9tYXggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGIgPj0gZi5fbWluICYmIGIgPD0gZi5fbWF4O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlzVHlwZWRBcnJheSA9ICh2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHYgJiYgdi5jb25zdHJ1Y3RvciAmJiBpc0ludDMyKHYuY29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQpXG4gICAgICAgICAgICA/IHZcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19TQUIgPVxuICAgICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIDogU2hhcmVkQXJyYXlCdWZmZXI7XG5cbiAgICAgICAgY29uc3QgaXNTaGFyZWRUeXBlZEFycmF5ID0gKGFUeXBlZEFycmF5KSA9PlxuICAgICAgICAgIGFUeXBlZEFycmF5LmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCO1xuXG4gICAgICAgIGNvbnN0IHR5cGVkQXJyYXlQYXJ0ID0gKGFUeXBlZEFycmF5LCBiZWdpbiwgZW5kKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzU2hhcmVkVHlwZWRBcnJheShhVHlwZWRBcnJheSlcbiAgICAgICAgICAgID8gYVR5cGVkQXJyYXkuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgICAgIDogYVR5cGVkQXJyYXkuc3ViYXJyYXkoYmVnaW4sIGVuZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaXNCaW5kYWJsZVR5cGVkQXJyYXkgPSAodikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB2ICYmXG4gICAgICAgICAgICAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpc1NRTGFibGVUeXBlZEFycmF5ID0gKHYpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdiAmJlxuICAgICAgICAgICAgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5ID0gKHYpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNCaW5kYWJsZVR5cGVkQXJyYXkodikgfHxcbiAgICAgICAgICAgIHRvc3MzKCdWYWx1ZSBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgVHlwZWRBcnJheSB0eXBlLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcblxuICAgICAgICBjb25zdCB0eXBlZEFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAodHlwZWRBcnJheSwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodHlwZWRBcnJheVBhcnQodHlwZWRBcnJheSwgYmVnaW4sIGVuZCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZsZXhpYmxlU3RyaW5nID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBpZiAoaXNTUUxhYmxlVHlwZWRBcnJheSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlUb1N0cmluZyhcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkodikgOiB2LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiB2LmpvaW4oJycpO1xuICAgICAgICAgIGVsc2UgaWYgKHdhc20uaXNQdHIodikpIHYgPSB3YXNtLmNzdHJUb0pzKHYpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsYXNzIFdhc21BbGxvY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICgyID09PSBhcmdzLmxlbmd0aCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1cGVyKCdBbGxvY2F0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdWx0Q29kZSA9IGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1dhc21BbGxvY0Vycm9yJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgV2FzbUFsbG9jRXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjYXBpLCB7XG4gICAgICAgICAgc3FsaXRlM19iaW5kX2Jsb2I6IHVuZGVmaW5lZCxcblxuICAgICAgICAgIHNxbGl0ZTNfYmluZF90ZXh0OiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MjogKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbjogKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICApID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uOiAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgIHhJbnZlcnNlLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfcHJlcGFyZV92MzogKFxuICAgICAgICAgICAgZGJQdHIsXG4gICAgICAgICAgICBzcWwsXG4gICAgICAgICAgICBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgc3RtdFB0clB0cixcbiAgICAgICAgICAgIHN0clB0clB0cixcbiAgICAgICAgICApID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19wcmVwYXJlX3YyOiAoXG4gICAgICAgICAgICBkYlB0cixcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHNxbEJ5dGVMZW4sXG4gICAgICAgICAgICBzdG10UHRyUHRyLFxuICAgICAgICAgICAgc3RyUHRyUHRyLFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX2V4ZWM6IChwRGIsIHNxbCwgY2FsbGJhY2ssIHBWb2lkLCBwRXJyTXNnKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfcmFuZG9tbmVzczogKG4sIG91dFB0cikgPT4ge30sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHV0aWwgPSB7XG4gICAgICAgICAgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5LFxuICAgICAgICAgIGZsZXhpYmxlU3RyaW5nLFxuICAgICAgICAgIGJpZ0ludEZpdHMzMixcbiAgICAgICAgICBiaWdJbnRGaXRzNjQsXG4gICAgICAgICAgYmlnSW50Rml0c0RvdWJsZSxcbiAgICAgICAgICBpc0JpbmRhYmxlVHlwZWRBcnJheSxcbiAgICAgICAgICBpc0ludDMyLFxuICAgICAgICAgIGlzU1FMYWJsZVR5cGVkQXJyYXksXG4gICAgICAgICAgaXNUeXBlZEFycmF5LFxuICAgICAgICAgIHR5cGVkQXJyYXlUb1N0cmluZyxcbiAgICAgICAgICBpc1VJVGhyZWFkOiAoKSA9PlxuICAgICAgICAgICAgZ2xvYmFsVGhpcy53aW5kb3cgPT09IGdsb2JhbFRoaXMgJiYgISFnbG9iYWxUaGlzLmRvY3VtZW50LFxuXG4gICAgICAgICAgaXNTaGFyZWRUeXBlZEFycmF5LFxuICAgICAgICAgIHRvc3M6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9zczMsXG4gICAgICAgICAgdHlwZWRBcnJheVBhcnQsXG5cbiAgICAgICAgICBhZmZpcm1EYkhlYWRlcjogZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSAnU1FMaXRlIGZvcm1hdCAzJztcbiAgICAgICAgICAgIGlmIChoZWFkZXIubGVuZ3RoID4gYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICB0b3NzMygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXIuY2hhckNvZGVBdChpKSAhPT0gYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICB0b3NzMygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhZmZpcm1Jc0RiOiBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4gPCA1MTIgfHwgbiAlIDUxMiAhPT0gMCkge1xuICAgICAgICAgICAgICB0b3NzMygnQnl0ZSBhcnJheSBzaXplJywgbiwgJ2lzIGludmFsaWQgZm9yIGFuIFNRTGl0ZTMgZGIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGJ5dGVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24od2FzbSwge1xuICAgICAgICAgIHB0clNpemVvZjogY29uZmlnLndhc21QdHJTaXplb2YgfHwgNCxcblxuICAgICAgICAgIHB0cklSOiBjb25maWcud2FzbVB0cklSIHx8ICdpMzInLFxuXG4gICAgICAgICAgYmlnSW50RW5hYmxlZDogISFjb25maWcuYmlnSW50RW5hYmxlZCxcblxuICAgICAgICAgIGV4cG9ydHM6XG4gICAgICAgICAgICBjb25maWcuZXhwb3J0cyB8fFxuICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgQVBJIGNvbmZpZy5leHBvcnRzIChXQVNNIG1vZHVsZSBleHBvcnRzKS4nKSxcblxuICAgICAgICAgIG1lbW9yeTpcbiAgICAgICAgICAgIGNvbmZpZy5tZW1vcnkgfHxcbiAgICAgICAgICAgIGNvbmZpZy5leHBvcnRzWydtZW1vcnknXSB8fFxuICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICdBUEkgY29uZmlnIG9iamVjdCByZXF1aXJlcyBhIFdlYkFzc2VtYmx5Lk1lbW9yeSBvYmplY3QnLFxuICAgICAgICAgICAgICAnaW4gZWl0aGVyIGNvbmZpZy5leHBvcnRzLm1lbW9yeSAoZXhwb3J0ZWQpJyxcbiAgICAgICAgICAgICAgJ29yIGNvbmZpZy5tZW1vcnkgKGltcG9ydGVkKS4nLFxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICByZWFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBkZWFsbG9jOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChzcmNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgaWYgKHNyY1R5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgc3JjVHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHNyY1R5cGVkQXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXkoc3JjVHlwZWRBcnJheSk7XG4gICAgICAgICAgY29uc3QgcFJldCA9IHdhc20uYWxsb2Moc3JjVHlwZWRBcnJheS5ieXRlTGVuZ3RoIHx8IDEpO1xuICAgICAgICAgIHdhc21cbiAgICAgICAgICAgIC5oZWFwRm9yU2l6ZShzcmNUeXBlZEFycmF5LmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLnNldChzcmNUeXBlZEFycmF5LmJ5dGVMZW5ndGggPyBzcmNUeXBlZEFycmF5IDogWzBdLCBwUmV0KTtcbiAgICAgICAgICByZXR1cm4gcFJldDtcbiAgICAgICAgfTtcblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qga2V5QWxsb2MgPSBjb25maWcuYWxsb2NFeHBvcnROYW1lLFxuICAgICAgICAgICAga2V5RGVhbGxvYyA9IGNvbmZpZy5kZWFsbG9jRXhwb3J0TmFtZSxcbiAgICAgICAgICAgIGtleVJlYWxsb2MgPSBjb25maWcucmVhbGxvY0V4cG9ydE5hbWU7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgW2tleUFsbG9jLCBrZXlEZWFsbG9jLCBrZXlSZWFsbG9jXSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IHdhc20uZXhwb3J0c1trZXldO1xuICAgICAgICAgICAgaWYgKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgcmVxdWlyZWQgZXhwb3J0c1snLCBrZXksICddIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhc20uYWxsb2MgPSBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGYuaW1wbChuKSB8fFxuICAgICAgICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKCdGYWlsZWQgdG8gYWxsb2NhdGUnLCBuLCAnIGJ5dGVzLicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FzbS5hbGxvYy5pbXBsID0gd2FzbS5leHBvcnRzW2tleUFsbG9jXTtcbiAgICAgICAgICB3YXNtLnJlYWxsb2MgPSBmdW5jdGlvbiBmKG0sIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG0yID0gZi5pbXBsKG0sIG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgPyBtMiB8fCBXYXNtQWxsb2NFcnJvci50b3NzKCdGYWlsZWQgdG8gcmVhbGxvY2F0ZScsIG4sICcgYnl0ZXMuJylcbiAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FzbS5yZWFsbG9jLmltcGwgPSB3YXNtLmV4cG9ydHNba2V5UmVhbGxvY107XG4gICAgICAgICAgd2FzbS5kZWFsbG9jID0gd2FzbS5leHBvcnRzW2tleURlYWxsb2NdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FzbS5jb21waWxlT3B0aW9uVXNlZCA9IGZ1bmN0aW9uIGYob3B0TmFtZSkge1xuICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGYuX3Jlc3VsdCkgcmV0dXJuIGYuX3Jlc3VsdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFmLl9vcHQpIHtcbiAgICAgICAgICAgICAgZi5fcnggPSAvXihbXj1dKyk9KC4rKS87XG4gICAgICAgICAgICAgIGYuX3J4SW50ID0gL14tP1xcZCskLztcbiAgICAgICAgICAgICAgZi5fb3B0ID0gZnVuY3Rpb24gKG9wdCwgcnYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZi5fcnguZXhlYyhvcHQpO1xuICAgICAgICAgICAgICAgIHJ2WzBdID0gbSA/IG1bMV0gOiBvcHQ7XG4gICAgICAgICAgICAgICAgcnZbMV0gPSBtID8gKGYuX3J4SW50LnRlc3QobVsyXSkgPyArbVsyXSA6IG1bMl0pIDogdHJ1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJjID0ge30sXG4gICAgICAgICAgICAgIG92ID0gWzAsIDBdO1xuICAgICAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgICAgICBrO1xuICAgICAgICAgICAgd2hpbGUgKChrID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0KGkrKykpKSB7XG4gICAgICAgICAgICAgIGYuX29wdChrLCBvdik7XG4gICAgICAgICAgICAgIHJjW292WzBdXSA9IG92WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChmLl9yZXN1bHQgPSByYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHt9O1xuICAgICAgICAgICAgb3B0TmFtZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICAgIHJjW3ZdID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBvcHROYW1lKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHROYW1lKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgIG9wdE5hbWVba10gPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkKGspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3B0TmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdzdHJpbmcnID09PSB0eXBlb2Ygb3B0TmFtZVxuICAgICAgICAgICAgPyAhIWNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQob3B0TmFtZSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2FzbS5wc3RhY2sgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICByZXN0b3JlOiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlLFxuXG4gICAgICAgICAgYWxsb2M6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBuICYmICEobiA9IHdhc20uc2l6ZW9mSVIobikpKSB7XG4gICAgICAgICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUgZm9yIHBzdGFjay5hbGxvYygnLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgICAgICAnKScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyhuKSB8fFxuICAgICAgICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdDb3VsZCBub3QgYWxsb2NhdGUnLFxuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgJ2J5dGVzIGZyb20gdGhlIHBzdGFjay4nLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhbGxvY0NodW5rczogZnVuY3Rpb24gKG4sIHN6KSB7XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBzeiAmJiAhKHN6ID0gd2FzbS5zaXplb2ZJUihzeikpKSB7XG4gICAgICAgICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgc2l6ZSB2YWx1ZSBmb3IgYWxsb2NDaHVua3MoJyxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVtID0gd2FzbS5wc3RhY2suYWxsb2MobiAqIHN6KTtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IG47ICsraSwgb2Zmc2V0ICs9IHN6KSByYy5wdXNoKG1lbSArIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFsbG9jUHRyOiAobiA9IDEsIHNhZmVQdHJTaXplID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIDEgPT09IG5cbiAgICAgICAgICAgICAgPyB3YXNtLnBzdGFjay5hbGxvYyhzYWZlUHRyU2l6ZSA/IDggOiB3YXNtLnB0clNpemVvZilcbiAgICAgICAgICAgICAgOiB3YXNtLnBzdGFjay5hbGxvY0NodW5rcyhuLCBzYWZlUHRyU2l6ZSA/IDggOiB3YXNtLnB0clNpemVvZik7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNhbGw6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFja1BvcyA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZihzcWxpdGUzKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2tQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3YXNtLnBzdGFjaywge1xuICAgICAgICAgIHBvaW50ZXI6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3B0cixcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcXVvdGE6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByZW1haW5pbmc6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfcmFuZG9tbmVzcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgMSA9PT0gYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgIHV0aWwuaXNUeXBlZEFycmF5KGFyZ3NbMF0pICYmXG4gICAgICAgICAgICAxID09PSBhcmdzWzBdLkJZVEVTX1BFUl9FTEVNRU5UXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB0YSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoMCA9PT0gdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19yYW5kb21uZXNzKDAsIDApO1xuICAgICAgICAgICAgICByZXR1cm4gdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgbiA9IHRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgciA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX3JhbmRvbW5lc3M7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYXAgPSB3YXNtLmhlYXA4dSgpO1xuICAgICAgICAgICAgICBjb25zdCBuQWxsb2MgPSBuIDwgNTEyID8gbiA6IDUxMjtcbiAgICAgICAgICAgICAgY29uc3QgcHRyID0gd2FzbS5wc3RhY2suYWxsb2MobkFsbG9jKTtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGogPSBuID4gbkFsbG9jID8gbkFsbG9jIDogbjtcbiAgICAgICAgICAgICAgICByKGosIHB0cik7XG4gICAgICAgICAgICAgICAgdGEuc2V0KHR5cGVkQXJyYXlQYXJ0KGhlYXAsIHB0ciwgcHRyICsgaiksIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgbiAtPSBqO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBqO1xuICAgICAgICAgICAgICB9IHdoaWxlIChuID4gMCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ0hpZ2hseSB1bmV4cGVjdGVkIChhbmQgaWdub3JlZCEpICcgK1xuICAgICAgICAgICAgICAgICAgJ2V4Y2VwdGlvbiBpbiBzcWxpdGUzX3JhbmRvbW5lc3MoKTonLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmFuZG9tbmVzcyguLi5hcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgX193YXNtZnNPcGZzRGlyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM193YXNtZnNfb3Bmc19kaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gX193YXNtZnNPcGZzRGlyKSByZXR1cm4gX193YXNtZnNPcGZzRGlyO1xuXG4gICAgICAgICAgY29uc3QgcGRpciA9IGNvbmZpZy53YXNtZnNPcGZzRGlyO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFwZGlyIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChfX3dhc21mc09wZnNEaXIgPSAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHBkaXIgJiZcbiAgICAgICAgICAgICAgMCA9PT1cbiAgICAgICAgICAgICAgICB3YXNtLnhDYWxsV3JhcHBlZChcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX3dhc21faW5pdF93YXNtZnMnLFxuICAgICAgICAgICAgICAgICAgJ2kzMicsXG4gICAgICAgICAgICAgICAgICBbJ3N0cmluZyddLFxuICAgICAgICAgICAgICAgICAgcGRpcixcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChfX3dhc21mc09wZnNEaXIgPSBwZGlyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAoX193YXNtZnNPcGZzRGlyID0gJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoX193YXNtZnNPcGZzRGlyID0gJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfd2FzbWZzX2ZpbGVuYW1lX2lzX3BlcnNpc3RlbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGNvbnN0IHAgPSBjYXBpLnNxbGl0ZTNfd2FzbWZzX29wZnNfZGlyKCk7XG4gICAgICAgICAgcmV0dXJuIHAgJiYgbmFtZSA/IG5hbWUuc3RhcnRzV2l0aChwICsgJy8nKSA6IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19kYl91c2VzX3ZmcyA9IGZ1bmN0aW9uIChwRGIsIHZmc05hbWUsIGRiTmFtZSA9IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcEsgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodmZzTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXBLKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICghcERiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwSyA9PT0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKDApID8gcEsgOiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBwSyA9PT0gY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhwRGIsIGRiTmFtZSkgPyBwSyA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3Zmc19saXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICAgICAgbGV0IHBWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoMCk7XG4gICAgICAgICAgd2hpbGUgKHBWZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9WZnMgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcyhwVmZzKTtcbiAgICAgICAgICAgIHJjLnB1c2god2FzbS5jc3RyVG9KcyhvVmZzLiR6TmFtZSkpO1xuICAgICAgICAgICAgcFZmcyA9IG9WZnMuJHBOZXh0O1xuICAgICAgICAgICAgb1Zmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfZGJfZXhwb3J0ID0gZnVuY3Rpb24gKHBEYiwgc2NoZW1hID0gMCkge1xuICAgICAgICAgIHBEYiA9IHdhc20ueFdyYXAudGVzdENvbnZlcnRBcmcoJ3NxbGl0ZTMqJywgcERiKTtcbiAgICAgICAgICBpZiAoIXBEYikgdG9zczMoJ0ludmFsaWQgc3FsaXRlMyogYXJndW1lbnQuJyk7XG4gICAgICAgICAgaWYgKCF3YXNtLmJpZ0ludEVuYWJsZWQpIHRvc3MzKCdCaWdJbnQ2NCBzdXBwb3J0IGlzIG5vdCBlbmFibGVkLicpO1xuICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICBsZXQgcE91dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcFNpemUgPSB3YXNtLnNjb3BlZEFsbG9jKDggKyB3YXNtLnB0clNpemVvZik7XG4gICAgICAgICAgICBjb25zdCBwcE91dCA9IHBTaXplICsgODtcblxuICAgICAgICAgICAgY29uc3QgelNjaGVtYSA9IHNjaGVtYVxuICAgICAgICAgICAgICA/IHdhc20uaXNQdHIoc2NoZW1hKVxuICAgICAgICAgICAgICAgID8gc2NoZW1hXG4gICAgICAgICAgICAgICAgOiB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZygnJyArIHNjaGVtYSlcbiAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgbGV0IHJjID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemUoXG4gICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgelNjaGVtYSxcbiAgICAgICAgICAgICAgcHBPdXQsXG4gICAgICAgICAgICAgIHBTaXplLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYykge1xuICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAnRGF0YWJhc2Ugc2VyaWFsaXphdGlvbiBmYWlsZWQgd2l0aCBjb2RlJyxcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcE91dCA9IHdhc20ucGVla1B0cihwcE91dCk7XG4gICAgICAgICAgICBjb25zdCBuT3V0ID0gd2FzbS5wZWVrKHBTaXplLCAnaTY0Jyk7XG4gICAgICAgICAgICByYyA9IG5PdXRcbiAgICAgICAgICAgICAgPyB3YXNtLmhlYXA4dSgpLnNsaWNlKHBPdXQsIHBPdXQgKyBOdW1iZXIobk91dCkpXG4gICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHBPdXQpIHdhc20uZXhwb3J0cy5zcWxpdGUzX2ZyZWUocE91dCk7XG4gICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyA9IChkYlBvaW50ZXIsIGRiTmFtZSA9IDApID0+XG4gICAgICAgICAgd2FzbS5zcWxpdGUzX3dhc21fZGJfdmZzKGRiUG9pbnRlciwgZGJOYW1lKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfYWdncmVnYXRlX2NvbnRleHQgPSAocEN0eCwgbikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQocEN0eCwgbikgfHxcbiAgICAgICAgICAgIChuXG4gICAgICAgICAgICAgID8gV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAgICdDYW5ub3QgYWxsb2NhdGUnLFxuICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICdieXRlcyBmb3Igc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCgpJyxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogMClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZGF0YSwgZGF0YUxlbikge1xuICAgICAgICAgIGxldCBwRGF0YTtcbiAgICAgICAgICBpZiAoZGF0YSAmJiB3YXNtLmlzUHRyKGRhdGEpKSB7XG4gICAgICAgICAgICBwRGF0YSA9IGRhdGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHBEYXRhID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8ICF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbiA8IDApIHtcbiAgICAgICAgICAgICAgZGF0YUxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICdJbnZhbGlkIDJuZCBhcmd1bWVudCBmb3Igc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbiA8IDApIHtcbiAgICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgM3JkIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Bvc2l4X2NyZWF0ZV9maWxlKCkuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJjID0gd2FzbS5zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUoXG4gICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICBwRGF0YSxcbiAgICAgICAgICAgICAgZGF0YUxlbixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmMpXG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdDcmVhdGlvbiBvZiBmaWxlIGZhaWxlZCB3aXRoIHNxbGl0ZTMgcmVzdWx0IGNvZGUnLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLmRlYWxsb2MocERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHZmcyxcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRhdGFMZW4sXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbmZpZy53YXJuKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkgaXMgZGVwcmVjYXRlZCBhbmQnLFxuICAgICAgICAgICAgJ3Nob3VsZCBiZSBhdm9pZGVkIGJlY2F1c2UgaXQgY2FuIGxlYWQgdG8gQy1sZXZlbCBjcmFzaGVzLicsXG4gICAgICAgICAgICAnU2VlIGl0cyBkb2N1bWVudGF0aW9uIGZvciBhbHRlcm5hdGl2ZSBvcHRpb25zLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcERhdGE7XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGRhdGEpKSB7XG4gICAgICAgICAgICAgIHBEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICBwRGF0YSA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCA0IHx8XG4gICAgICAgICAgICAgICAgIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fFxuICAgICAgICAgICAgICAgIGRhdGFMZW4gPCAwXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRhdGFMZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBEYXRhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbiA8IDApIHtcbiAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICAgICAgICBTUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgJ0ludmFsaWQgNHRoIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSB3YXNtLnNxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUoXG4gICAgICAgICAgICAgIHZmcyxcbiAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHBEYXRhLFxuICAgICAgICAgICAgICBkYXRhTGVuLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIGZpbGUgZmFpbGVkIHdpdGggc3FsaXRlMyByZXN1bHQgY29kZScsXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYyksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19zcWxfdG9fc3RyaW5nID0gKHNxbCkgPT4ge1xuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHNxbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNxbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeCA9IGZsZXhpYmxlU3RyaW5nKHYpO1xuICAgICAgICAgIHJldHVybiB4ID09PSB2ID8gdW5kZWZpbmVkIDogeDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXRpbC5pc1VJVGhyZWFkKCkpIHtcbiAgICAgICAgICBjb25zdCBfX2t2dmZzSW5mbyA9IGZ1bmN0aW9uICh3aGljaCkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgcmMucHJlZml4ID0gJ2t2dmZzLScgKyB3aGljaDtcbiAgICAgICAgICAgIHJjLnN0b3JlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCdzZXNzaW9uJyA9PT0gd2hpY2ggfHwgJycgPT09IHdoaWNoKVxuICAgICAgICAgICAgICByYy5zdG9yZXMucHVzaChnbG9iYWxUaGlzLnNlc3Npb25TdG9yYWdlKTtcbiAgICAgICAgICAgIGlmICgnbG9jYWwnID09PSB3aGljaCB8fCAnJyA9PT0gd2hpY2gpXG4gICAgICAgICAgICAgIHJjLnN0b3Jlcy5wdXNoKGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2t2dmZzX2NsZWFyID0gZnVuY3Rpb24gKHdoaWNoID0gJycpIHtcbiAgICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgICBjb25zdCBrdmluZm8gPSBfX2t2dmZzSW5mbyh3aGljaCk7XG4gICAgICAgICAgICBrdmluZm8uc3RvcmVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9SbSA9IFtdO1xuICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gcy5rZXkoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGsuc3RhcnRzV2l0aChrdmluZm8ucHJlZml4KSkgdG9SbS5wdXNoKGspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvUm0uZm9yRWFjaCgoa2spID0+IHMucmVtb3ZlSXRlbShraykpO1xuICAgICAgICAgICAgICByYyArPSB0b1JtLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfc2l6ZSA9IGZ1bmN0aW9uICh3aGljaCA9ICcnKSB7XG4gICAgICAgICAgICBsZXQgc3ogPSAwO1xuICAgICAgICAgICAgY29uc3Qga3ZpbmZvID0gX19rdnZmc0luZm8od2hpY2gpO1xuICAgICAgICAgICAga3ZpbmZvLnN0b3Jlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBzLmtleShpKTtcbiAgICAgICAgICAgICAgICBpZiAoay5zdGFydHNXaXRoKGt2aW5mby5wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICBzeiArPSBrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHN6ICs9IHMuZ2V0SXRlbShrKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzeiAqIDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhcGkuc3FsaXRlM19kYl9jb25maWcgPSBmdW5jdGlvbiAocERiLCBvcCwgLi4uYXJncykge1xuICAgICAgICAgIGlmICghdGhpcy5zKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX3dhc21fZGJfY29uZmlnX3MnLCAnaW50JywgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0aGlzLnBpaSA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0aGlzLmlwID0gd2FzbS54V3JhcCgnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCcsICdpbnQnLCBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZLRVk6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9UUklHR0VSOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfRlRTM19UT0tFTklaRVI6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9MT0FEX0VYVEVOU0lPTjpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTk9fQ0tQVF9PTl9DTE9TRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1FQU0c6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1RSSUdHRVJfRVFQOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfREVGRU5TSVZFOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19XUklUQUJMRV9TQ0hFTUE6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9BTFRFUl9UQUJMRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RNTDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RETDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1ZJRVc6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9GSUxFX0ZPUk1BVDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfVFJVU1RFRF9TQ0hFTUE6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1NUTVRfU0NBTlNUQVRVUzpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfUkVWRVJTRV9TQ0FOT1JERVI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmlwKHBEYiwgb3AsIGFyZ3NbMF0sIGFyZ3NbMV0gfHwgMCk7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xPT0tBU0lERTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGlpKHBEYiwgb3AsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19NQUlOREJOQU1FOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zKHBEYiwgb3AsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZChPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgcFZhbCxcbiAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBhcmc7XG4gICAgICAgICAgY29uc3QgdmFsVHlwZSA9IGNhcGkuc3FsaXRlM192YWx1ZV90eXBlKHBWYWwpO1xuICAgICAgICAgIHN3aXRjaCAodmFsVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9JTlRFR0VSOlxuICAgICAgICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2ludDY0KHBWYWwpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmJpZ0ludEZpdHNEb3VibGUoYXJnKSkgYXJnID0gTnVtYmVyKGFyZyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfZG91YmxlKHBWYWwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRkxPQVQ6XG4gICAgICAgICAgICAgIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV9kb3VibGUocFZhbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9URVhUOlxuICAgICAgICAgICAgICBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfdGV4dChwVmFsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0JMT0I6IHtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IGNhcGkuc3FsaXRlM192YWx1ZV9ieXRlcyhwVmFsKTtcbiAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfYmxvYihwVmFsKTtcbiAgICAgICAgICAgICAgaWYgKG4gJiYgIXBCbG9iKVxuICAgICAgICAgICAgICAgIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAgICdDYW5ub3QgYWxsb2NhdGUgbWVtb3J5IGZvciBibG9iIGFyZ3VtZW50IG9mJyxcbiAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAnYnl0ZShzKScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYXJnID0gbiA/IHdhc20uaGVhcDh1KCkuc2xpY2UocEJsb2IsIHBCbG9iICsgTnVtYmVyKG4pKSA6IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9OVUxMOlxuICAgICAgICAgICAgICBhcmcgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0aHJvd0lmQ2Fubm90Q29udmVydCkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTTUFUQ0gsXG4gICAgICAgICAgICAgICAgICAnVW5oYW5kbGVkIHNxbGl0ZTNfdmFsdWVfdHlwZSgpOicsXG4gICAgICAgICAgICAgICAgICB2YWxUeXBlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgYXJnYyxcbiAgICAgICAgICBwQXJndixcbiAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGNvbnN0IHRndCA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgICAgICAgIHRndC5wdXNoKFxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMoXG4gICAgICAgICAgICAgICAgd2FzbS5wZWVrUHRyKHBBcmd2ICsgd2FzbS5wdHJTaXplb2YgKiBpKSxcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0Z3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyA9IGZ1bmN0aW9uIChwQ3R4LCBlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBXYXNtQWxsb2NFcnJvcikge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbShwQ3R4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcihwQ3R4LCAnJyArIGUsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcyA9IGZ1bmN0aW9uIChwQ3R4LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludChwQ3R4LCB2YWwgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuYmlnSW50Rml0czMyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfaW50KHBDdHgsIE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuYmlnSW50Rml0c0RvdWJsZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2RvdWJsZShwQ3R4LCBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmJpZ0ludEZpdHM2NCh2YWwpKVxuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludDY0KHBDdHgsIHZhbCk7XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgICAgICdCaWdJbnQgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICdpcyB0b28gQmlnSW50IGZvciBpbnQ2NC4nLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b3NzMygnQmlnSW50IHZhbHVlJywgdmFsLnRvU3RyaW5nKCksICdpcyB0b28gQmlnSW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgICAgIGxldCBmO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIodmFsKSkge1xuICAgICAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfaW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICB3YXNtLmJpZ0ludEVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsKSAmJlxuICAgICAgICAgICAgICAgICAgdXRpbC5iaWdJbnRGaXRzNjQoQmlnSW50KHZhbCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBmID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQ2NDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfZG91YmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmKHBDdHgsIHZhbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF90ZXh0KHBDdHgsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X251bGwocEN0eCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkodmFsKTtcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfYmxvYihcbiAgICAgICAgICAgICAgICAgICAgcEN0eCxcbiAgICAgICAgICAgICAgICAgICAgcEJsb2IsXG4gICAgICAgICAgICAgICAgICAgIHZhbC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICBcIkRvbid0IG5vdCBob3cgdG8gaGFuZGxlIHRoaXMgVURGIHJlc3VsdCB2YWx1ZTpcIixcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWwsXG4gICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfY29sdW1uX2pzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHBTdG10LFxuICAgICAgICAgIGlDb2wsXG4gICAgICAgICAgdGhyb3dJZkNhbm5vdENvbnZlcnQgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB2ID0gY2FwaS5zcWxpdGUzX2NvbHVtbl92YWx1ZShwU3RtdCwgaUNvbCk7XG4gICAgICAgICAgcmV0dXJuIDAgPT09IHZcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyh2LCB0aHJvd0lmQ2Fubm90Q29udmVydCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19uZXdPbGRWYWx1ZSA9IGZ1bmN0aW9uIChwT2JqLCBpQ29sLCBpbXBsKSB7XG4gICAgICAgICAgaW1wbCA9IGNhcGlbaW1wbF07XG4gICAgICAgICAgaWYgKCF0aGlzLnB0cikgdGhpcy5wdHIgPSB3YXNtLmFsbG9jUHRyKCk7XG4gICAgICAgICAgZWxzZSB3YXNtLnBva2VQdHIodGhpcy5wdHIsIDApO1xuICAgICAgICAgIGNvbnN0IHJjID0gaW1wbChwT2JqLCBpQ29sLCB0aGlzLnB0cik7XG4gICAgICAgICAgaWYgKHJjKVxuICAgICAgICAgICAgcmV0dXJuIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzJdICsgJygpIGZhaWxlZCB3aXRoIGNvZGUgJyArIHJjLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBwdiA9IHdhc20ucGVla1B0cih0aGlzLnB0cik7XG4gICAgICAgICAgcmV0dXJuIHB2ID8gY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzKHB2LCB0cnVlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfbmV3X2pzID0gKHBEYiwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX25ldycpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfb2xkX2pzID0gKHBEYiwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX29sZCcpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM2NoYW5nZXNldF9uZXdfanMgPSAocENoYW5nZXNldEl0ZXIsIGlDb2wpID0+XG4gICAgICAgICAgX19uZXdPbGRWYWx1ZShwQ2hhbmdlc2V0SXRlciwgaUNvbCwgJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3Jyk7XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzY2hhbmdlc2V0X29sZF9qcyA9IChwQ2hhbmdlc2V0SXRlciwgaUNvbCkgPT5cbiAgICAgICAgICBfX25ld09sZFZhbHVlKHBDaGFuZ2VzZXRJdGVyLCBpQ29sLCAnc3FsaXRlM2NoYW5nZXNldF9vbGQnKTtcblxuICAgICAgICBjb25zdCBzcWxpdGUzID0ge1xuICAgICAgICAgIFdhc21BbGxvY0Vycm9yOiBXYXNtQWxsb2NFcnJvcixcbiAgICAgICAgICBTUUxpdGUzRXJyb3I6IFNRTGl0ZTNFcnJvcixcbiAgICAgICAgICBjYXBpLFxuICAgICAgICAgIHV0aWwsXG4gICAgICAgICAgd2FzbSxcbiAgICAgICAgICBjb25maWcsXG5cbiAgICAgICAgICB2ZXJzaW9uOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAgICAgY2xpZW50OiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBhc3luY1Bvc3RJbml0OiBhc3luYyBmdW5jdGlvbiBmZigpIHtcbiAgICAgICAgICAgIGlmIChmZi5pc1JlYWR5IGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIGZmLmlzUmVhZHk7XG4gICAgICAgICAgICBsZXQgbGlhID0gc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYztcbiAgICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVyc0FzeW5jO1xuICAgICAgICAgICAgY29uc3QgcG9zdEluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc3FsaXRlMy5fX2lzVW5kZXJUZXN0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNxbGl0ZTMudXRpbDtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzLlN0cnVjdEJpbmRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc3FsaXRlMztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYXRjaGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgY29uZmlnLmVycm9yKCdhbiBhc3luYyBzcWxpdGUzIGluaXRpYWxpemVyIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWxpYSB8fCAhbGlhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gKGZmLmlzUmVhZHkgPSBwb3N0SW5pdCgpLmNhdGNoKGNhdGNoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpYSA9IGxpYS5tYXAoKGYpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGYgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFzeW5jICh4KSA9PiBmKHNxbGl0ZTMpIDogZjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlhLnB1c2gocG9zdEluaXQpO1xuICAgICAgICAgICAgbGV0IHAgPSBQcm9taXNlLnJlc29sdmUoc3FsaXRlMyk7XG4gICAgICAgICAgICB3aGlsZSAobGlhLmxlbmd0aCkgcCA9IHAudGhlbihsaWEuc2hpZnQoKSk7XG4gICAgICAgICAgICByZXR1cm4gKGZmLmlzUmVhZHkgPSBwLmNhdGNoKGNhdGNoZXIpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2NyaXB0SW5mbzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLmZvckVhY2goKGYpID0+IHtcbiAgICAgICAgICAgIGYoc3FsaXRlMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzIGJvb3RzdHJhcCBpbml0aWFsaXplciB0aHJldzonLCBlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycztcbiAgICAgICAgc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gc3FsaXRlMztcbiAgICAgICAgcmV0dXJuIHNxbGl0ZTM7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzID0gW107XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYyA9IFtdO1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuZGVmYXVsdENvbmZpZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gdW5kZWZpbmVkO1xuXG4gICAgICBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICB0YXJnZXQuYmlnSW50RW5hYmxlZCA9ICEhZ2xvYmFsVGhpc1snQmlnSW50NjRBcnJheSddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRhcmdldC5leHBvcnRzKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ2V4cG9ydHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB0YXJnZXQuaW5zdGFuY2UgJiYgdGFyZ2V0Lmluc3RhbmNlLmV4cG9ydHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwdHJJUiA9IHRhcmdldC5wb2ludGVySVIgfHwgJ2kzMic7XG4gICAgICAgIGNvbnN0IHB0clNpemVvZiA9ICh0YXJnZXQucHRyU2l6ZW9mID1cbiAgICAgICAgICAnaTMyJyA9PT0gcHRySVJcbiAgICAgICAgICAgID8gNFxuICAgICAgICAgICAgOiAnaTY0JyA9PT0gcHRySVJcbiAgICAgICAgICAgICAgPyA4XG4gICAgICAgICAgICAgIDogdG9zcygnVW5oYW5kbGVkIHB0clNpemVvZjonLCBwdHJJUikpO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjYWNoZS5oZWFwU2l6ZSA9IDA7XG5cbiAgICAgICAgY2FjaGUubWVtb3J5ID0gbnVsbDtcblxuICAgICAgICBjYWNoZS5mcmVlRnVuY0luZGV4ZXMgPSBbXTtcblxuICAgICAgICBjYWNoZS5zY29wZWRBbGxvYyA9IFtdO1xuXG4gICAgICAgIGNhY2hlLnV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGNhY2hlLnV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG4gICAgICAgIHRhcmdldC5zaXplb2ZJUiA9IChuKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgICAgY2FzZSAnZjMyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgICAgY2FzZSAnZjY0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgIHJldHVybiBwdHJTaXplb2Y7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gKCcnICsgbikuZW5kc1dpdGgoJyonKSA/IHB0clNpemVvZiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaGVhcFdyYXBwZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghY2FjaGUubWVtb3J5KSB7XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgPVxuICAgICAgICAgICAgICB0YXJnZXQubWVtb3J5IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5XG4gICAgICAgICAgICAgICAgPyB0YXJnZXQubWVtb3J5XG4gICAgICAgICAgICAgICAgOiB0YXJnZXQuZXhwb3J0cy5tZW1vcnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYiA9IGNhY2hlLm1lbW9yeS5idWZmZXI7XG4gICAgICAgICAgY2FjaGUuSEVBUDggPSBuZXcgSW50OEFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVA4VSA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAxNlUgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDMyVSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNhY2hlLkhFQVA2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KGIpO1xuICAgICAgICAgICAgY2FjaGUuSEVBUDY0VSA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FjaGUuSEVBUDMyRiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuSEVBUDY0RiA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG4gICAgICAgICAgY2FjaGUuaGVhcFNpemUgPSBiLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5oZWFwOCA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVA4O1xuXG4gICAgICAgIHRhcmdldC5oZWFwOHUgPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAxNiA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAxNjtcblxuICAgICAgICB0YXJnZXQuaGVhcDE2dSA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAxNlU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAzMiA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAzMjtcblxuICAgICAgICB0YXJnZXQuaGVhcDMydSA9ICgpID0+IGhlYXBXcmFwcGVycygpLkhFQVAzMlU7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXBGb3JTaXplID0gZnVuY3Rpb24gKG4sIHVuc2lnbmVkID0gdHJ1ZSkge1xuICAgICAgICAgIGxldCBjdG9yO1xuICAgICAgICAgIGNvbnN0IGMgPVxuICAgICAgICAgICAgY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgPyBjYWNoZVxuICAgICAgICAgICAgICA6IGhlYXBXcmFwcGVycygpO1xuICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVA4O1xuICAgICAgICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQOFU7XG4gICAgICAgICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAxNjtcbiAgICAgICAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAxNlU7XG4gICAgICAgICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAzMjtcbiAgICAgICAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgICAgICAgIHJldHVybiBjLkhFQVAzMlU7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDhVIDogYy5IRUFQODtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDE2VSA6IGMuSEVBUDE2O1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gYy5IRUFQMzJVIDogYy5IRUFQMzI7XG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICBpZiAoYy5IRUFQNjQpIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDY0VSA6IGMuSEVBUDY0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0YXJnZXQuYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBnbG9iYWxUaGlzWydCaWdVaW50NjRBcnJheSddKSByZXR1cm4gYy5IRUFQNjRVO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4gPT09IGdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSkgcmV0dXJuIGMuSEVBUDY0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAnSW52YWxpZCBoZWFwRm9yU2l6ZSgpIHNpemU6IGV4cGVjdGluZyA4LCAxNiwgMzIsJyxcbiAgICAgICAgICAgICdvciAoaWYgQmlnSW50IGlzIGVuYWJsZWQpIDY0LicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuZnVuY3Rpb25UYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmV4cG9ydHMuX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuZnVuY3Rpb25FbnRyeSA9IGZ1bmN0aW9uIChmcHRyKSB7XG4gICAgICAgICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgICAgICAgIHJldHVybiBmcHRyIDwgZnQubGVuZ3RoID8gZnQuZ2V0KGZwdHIpIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5qc0Z1bmNUb1dhc20gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZykge1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl8gPSB7XG4gICAgICAgICAgICAgIHNpZ1R5cGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgICBpOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBwOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBQOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBzOiAnaTMyJyxcbiAgICAgICAgICAgICAgICBqOiAnaTY0JyxcbiAgICAgICAgICAgICAgICBmOiAnZjMyJyxcbiAgICAgICAgICAgICAgICBkOiAnZjY0JyxcbiAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgdHlwZUNvZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgICBmNjQ6IDB4N2MsXG4gICAgICAgICAgICAgICAgZjMyOiAweDdkLFxuICAgICAgICAgICAgICAgIGk2NDogMHg3ZSxcbiAgICAgICAgICAgICAgICBpMzI6IDB4N2YsXG4gICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgIHVsZWIxMjhFbmNvZGU6IGZ1bmN0aW9uICh0Z3QsIG1ldGhvZCwgbikge1xuICAgICAgICAgICAgICAgIGlmIChuIDwgMTI4KSB0Z3RbbWV0aG9kXShuKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRndFttZXRob2RdKG4gJSAxMjggfCAxMjgsIG4gPj4gNyk7XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgcnhKU2lnOiAvXihcXHcpXFwoKFxcdyopXFwpJC8sXG5cbiAgICAgICAgICAgICAgc2lnUGFyYW1zOiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGYuXy5yeEpTaWcuZXhlYyhzaWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtID8gbVsyXSA6IHNpZy5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgbGV0dGVyVHlwZTogKHgpID0+XG4gICAgICAgICAgICAgICAgZi5fLnNpZ1R5cGVzW3hdIHx8IHRvc3MoJ0ludmFsaWQgc2lnbmF0dXJlIGxldHRlcjonLCB4KSxcblxuICAgICAgICAgICAgICBwdXNoU2lnVHlwZTogKGRlc3QsIGxldHRlcikgPT5cbiAgICAgICAgICAgICAgICBkZXN0LnB1c2goZi5fLnR5cGVDb2Rlc1tmLl8ubGV0dGVyVHlwZShsZXR0ZXIpXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmdW5jKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gc2lnO1xuICAgICAgICAgICAgc2lnID0gZnVuYztcbiAgICAgICAgICAgIGZ1bmMgPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaWdQYXJhbXMgPSBmLl8uc2lnUGFyYW1zKHNpZyk7XG4gICAgICAgICAgY29uc3Qgd2FzbUNvZGUgPSBbMHgwMSwgMHg2MF07XG4gICAgICAgICAgZi5fLnVsZWIxMjhFbmNvZGUod2FzbUNvZGUsICdwdXNoJywgc2lnUGFyYW1zLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChjb25zdCB4IG9mIHNpZ1BhcmFtcykgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCB4KTtcbiAgICAgICAgICBpZiAoJ3YnID09PSBzaWdbMF0pIHdhc21Db2RlLnB1c2goMCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXNtQ29kZS5wdXNoKDEpO1xuICAgICAgICAgICAgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCBzaWdbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmLl8udWxlYjEyOEVuY29kZSh3YXNtQ29kZSwgJ3Vuc2hpZnQnLCB3YXNtQ29kZS5sZW5ndGgpO1xuICAgICAgICAgIHdhc21Db2RlLnVuc2hpZnQoXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHg2MSxcbiAgICAgICAgICAgIDB4NzMsXG4gICAgICAgICAgICAweDZkLFxuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3YXNtQ29kZS5wdXNoKFxuICAgICAgICAgICAgMHgwMixcbiAgICAgICAgICAgIDB4MDcsXG5cbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHg2NSxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDY2LFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDA3LFxuICAgICAgICAgICAgMHgwNSxcblxuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDY2LFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgICAgICAgbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheSh3YXNtQ29kZSkpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlOiB7IGY6IGZ1bmMgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKS5leHBvcnRzWydmJ107XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZywgc2NvcGVkKSB7XG4gICAgICAgICAgaWYgKHNjb3BlZCAmJiAhY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3NzKCdObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGZ1bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBzaWc7XG4gICAgICAgICAgICBzaWcgPSBmdW5jO1xuICAgICAgICAgICAgZnVuYyA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNpZyB8fCAhKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50czogZXhwZWN0aW5nIChmdW5jdGlvbixzaWduYXR1cmUpICcgK1xuICAgICAgICAgICAgICAgICdvciAoc2lnbmF0dXJlLGZ1bmN0aW9uKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgICAgICAgIGNvbnN0IG9sZExlbiA9IGZ0Lmxlbmd0aDtcbiAgICAgICAgICBsZXQgcHRyO1xuICAgICAgICAgIHdoaWxlIChjYWNoZS5mcmVlRnVuY0luZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwdHIgPSBjYWNoZS5mcmVlRnVuY0luZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoZnQuZ2V0KHB0cikpIHtcbiAgICAgICAgICAgICAgcHRyID0gbnVsbDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgIHB0ciA9IG9sZExlbjtcbiAgICAgICAgICAgIGZ0Lmdyb3coMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdC5zZXQocHRyLCBmdW5jKTtcbiAgICAgICAgICAgIGlmIChzY29wZWQpIHtcbiAgICAgICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgVHlwZUVycm9yKSkge1xuICAgICAgICAgICAgICBpZiAocHRyID09PSBvbGRMZW4pIGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5wdXNoKG9sZExlbik7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZwdHIgPSB0YXJnZXQuanNGdW5jVG9XYXNtKGZ1bmMsIHNpZyk7XG4gICAgICAgICAgICBmdC5zZXQocHRyLCBmcHRyKTtcbiAgICAgICAgICAgIGlmIChzY29wZWQpIHtcbiAgICAgICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChwdHIgPT09IG9sZExlbikgY2FjaGUuZnJlZUZ1bmNJbmRleGVzLnB1c2gob2xkTGVuKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0Lmluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpID0+XG4gICAgICAgICAgX19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCBmYWxzZSk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpID0+XG4gICAgICAgICAgX19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCB0cnVlKTtcblxuICAgICAgICB0YXJnZXQudW5pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbiAocHRyKSB7XG4gICAgICAgICAgaWYgKCFwdHIgJiYgMCAhPT0gcHRyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IGZpID0gY2FjaGUuZnJlZUZ1bmNJbmRleGVzO1xuICAgICAgICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICAgICAgICBmaS5wdXNoKHB0cik7XG4gICAgICAgICAgY29uc3QgcmMgPSBmdC5nZXQocHRyKTtcbiAgICAgICAgICBmdC5zZXQocHRyLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBlZWsgPSBmdW5jdGlvbiBmKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICAgICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgICAgICAgY29uc3QgYyA9XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICA/IGNhY2hlXG4gICAgICAgICAgICAgIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkocHRyKSA/IFtdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGxldCByYztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobGlzdCkgcHRyID0gYXJndW1lbnRzWzBdLnNoaWZ0KCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgICAgcmMgPSBjLkhFQVA4W3B0ciA+PiAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICAgICAgICByYyA9IGMuSEVBUDE2W3B0ciA+PiAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgICAgICAgICByYyA9IGMuSEVBUDMyW3B0ciA+PiAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICBjYXNlICdmMzInOlxuICAgICAgICAgICAgICAgIHJjID0gYy5IRUFQMzJGW3B0ciA+PiAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnZjY0JzpcbiAgICAgICAgICAgICAgICByYyA9IE51bWJlcihjLkhFQVA2NEZbcHRyID4+IDNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJjID0gQmlnSW50KGMuSEVBUDY0W3B0ciA+PiAzXSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0b3NzKCdJbnZhbGlkIHR5cGUgZm9yIHBlZWsoKTonLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaXN0KSBsaXN0LnB1c2gocmMpO1xuICAgICAgICAgIH0gd2hpbGUgKGxpc3QgJiYgYXJndW1lbnRzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGxpc3QgfHwgcmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBva2UgPSBmdW5jdGlvbiAocHRyLCB2YWx1ZSwgdHlwZSA9ICdpOCcpIHtcbiAgICAgICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgICAgICAgY29uc3QgYyA9XG4gICAgICAgICAgICBjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICA/IGNhY2hlXG4gICAgICAgICAgICAgIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwIG9mIEFycmF5LmlzQXJyYXkocHRyKSA/IHB0ciA6IFtwdHJdKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgICAgICBjYXNlICdpOCc6XG4gICAgICAgICAgICAgICAgYy5IRUFQOFtwID4+IDBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2kxNic6XG4gICAgICAgICAgICAgICAgYy5IRUFQMTZbcCA+PiAxXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgICAgICAgIGMuSEVBUDMyW3AgPj4gMl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICBjYXNlICdmMzInOlxuICAgICAgICAgICAgICAgIGMuSEVBUDMyRltwID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Y2NCc6XG4gICAgICAgICAgICAgICAgYy5IRUFQNjRGW3AgPj4gM10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgICAgICBpZiAoYy5IRUFQNjQpIHtcbiAgICAgICAgICAgICAgICAgIGMuSEVBUDY0W3AgPj4gM10gPSBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIGZvciBwb2tlKCk6ICcgKyB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnBlZWtQdHIgPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsIHB0cklSKTtcblxuICAgICAgICB0YXJnZXQucG9rZVB0ciA9IChwdHIsIHZhbHVlID0gMCkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgcHRySVIpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrOCA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2k4Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2U4ID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpOCcpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrMTYgPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsICdpMTYnKTtcblxuICAgICAgICB0YXJnZXQucG9rZTE2ID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpMTYnKTtcblxuICAgICAgICB0YXJnZXQucGVlazMyID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnaTMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2UzMiA9IChwdHIsIHZhbHVlKSA9PiB0YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBlZWs2NCA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2k2NCcpO1xuXG4gICAgICAgIHRhcmdldC5wb2tlNjQgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2k2NCcpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrMzJmID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnZjMyJyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2UzMmYgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2YzMicpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrNjRmID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnZjY0Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2U2NGYgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2Y2NCcpO1xuXG4gICAgICAgIHRhcmdldC5nZXRNZW1WYWx1ZSA9IHRhcmdldC5wZWVrO1xuXG4gICAgICAgIHRhcmdldC5nZXRQdHJWYWx1ZSA9IHRhcmdldC5wZWVrUHRyO1xuXG4gICAgICAgIHRhcmdldC5zZXRNZW1WYWx1ZSA9IHRhcmdldC5wb2tlO1xuXG4gICAgICAgIHRhcmdldC5zZXRQdHJWYWx1ZSA9IHRhcmdldC5wb2tlUHRyO1xuXG4gICAgICAgIHRhcmdldC5pc1B0cjMyID0gKHB0cikgPT5cbiAgICAgICAgICAnbnVtYmVyJyA9PT0gdHlwZW9mIHB0ciAmJiBwdHIgPT09IChwdHIgfCAwKSAmJiBwdHIgPj0gMDtcblxuICAgICAgICB0YXJnZXQuaXNQdHIgPSB0YXJnZXQuaXNQdHIzMjtcblxuICAgICAgICB0YXJnZXQuY3N0cmxlbiA9IGZ1bmN0aW9uIChwdHIpIHtcbiAgICAgICAgICBpZiAoIXB0ciB8fCAhdGFyZ2V0LmlzUHRyKHB0cikpIHJldHVybiBudWxsO1xuICAgICAgICAgIGNvbnN0IGggPSBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG4gICAgICAgICAgbGV0IHBvcyA9IHB0cjtcbiAgICAgICAgICBmb3IgKDsgaFtwb3NdICE9PSAwOyArK3Bvcykge31cbiAgICAgICAgICByZXR1cm4gcG9zIC0gcHRyO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fU0FCID1cbiAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICA6IFNoYXJlZEFycmF5QnVmZmVyO1xuICAgICAgICBjb25zdCBfX3V0ZjhEZWNvZGUgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUudXRmOERlY29kZXIuZGVjb2RlKFxuICAgICAgICAgICAgYXJyYXlCdWZmZXIuYnVmZmVyIGluc3RhbmNlb2YgX19TQUJcbiAgICAgICAgICAgICAgPyBhcnJheUJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKVxuICAgICAgICAgICAgICA6IGFycmF5QnVmZmVyLnN1YmFycmF5KGJlZ2luLCBlbmQpLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmNzdHJUb0pzID0gZnVuY3Rpb24gKHB0cikge1xuICAgICAgICAgIGNvbnN0IG4gPSB0YXJnZXQuY3N0cmxlbihwdHIpO1xuICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICA/IF9fdXRmOERlY29kZShoZWFwV3JhcHBlcnMoKS5IRUFQOFUsIHB0ciwgcHRyICsgbilcbiAgICAgICAgICAgIDogbnVsbCA9PT0gblxuICAgICAgICAgICAgICA/IG5cbiAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuanN0cmxlbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzdHIpIHJldHVybiBudWxsO1xuICAgICAgICAgIGNvbnN0IG4gPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBsZXQgdSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKHUgPj0gMHhkODAwICYmIHUgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIHUgPVxuICAgICAgICAgICAgICAgICgweDEwMDAwICsgKCh1ICYgMHgzZmYpIDw8IDEwKSkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1IDw9IDB4N2YpICsrbGVuO1xuICAgICAgICAgICAgZWxzZSBpZiAodSA8PSAweDdmZikgbGVuICs9IDI7XG4gICAgICAgICAgICBlbHNlIGlmICh1IDw9IDB4ZmZmZikgbGVuICs9IDM7XG4gICAgICAgICAgICBlbHNlIGxlbiArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5qc3RyY3B5ID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGpzdHIsXG4gICAgICAgICAgdGd0LFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgbWF4Qnl0ZXMgPSAtMSxcbiAgICAgICAgICBhZGROdWwgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGd0IHx8XG4gICAgICAgICAgICAoISh0Z3QgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpICYmICEodGd0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0b3NzKCdqc3RyY3B5KCkgdGFyZ2V0IG11c3QgYmUgYW4gSW50OEFycmF5IG9yIFVpbnQ4QXJyYXkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhCeXRlcyA8IDApIG1heEJ5dGVzID0gdGd0Lmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgICBpZiAoIShtYXhCeXRlcyA+IDApIHx8ICEob2Zmc2V0ID49IDApKSByZXR1cm4gMDtcbiAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBtYXggPSBqc3RyLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBiZWdpbiA9IG9mZnNldCxcbiAgICAgICAgICAgIGVuZCA9IG9mZnNldCArIG1heEJ5dGVzIC0gKGFkZE51bCA/IDEgOiAwKTtcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heCAmJiBvZmZzZXQgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgbGV0IHUgPSBqc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAodSA+PSAweGQ4MDAgJiYgdSA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgdSA9XG4gICAgICAgICAgICAgICAgKDB4MTAwMDAgKyAoKHUgJiAweDNmZikgPDwgMTApKSB8XG4gICAgICAgICAgICAgICAgKGpzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUgPD0gMHg3Zikge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0ID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSB1O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N2ZmKSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAxID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweGMwIHwgKHUgPj4gNik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodSA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDIgPj0gZW5kKSBicmVhaztcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ZTAgfCAodSA+PiAxMik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgMHgzZik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAzID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweGYwIHwgKHUgPj4gMTgpO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiAweDNmKTtcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAodSAmIDB4M2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWRkTnVsKSB0Z3Rbb2Zmc2V0KytdID0gMDtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0IC0gYmVnaW47XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmNzdHJuY3B5ID0gZnVuY3Rpb24gKHRndFB0ciwgc3JjUHRyLCBuKSB7XG4gICAgICAgICAgaWYgKCF0Z3RQdHIgfHwgIXNyY1B0cilcbiAgICAgICAgICAgIHRvc3MoJ2NzdHJuY3B5KCkgZG9lcyBub3QgYWNjZXB0IE5VTEwgc3RyaW5ncy4nKTtcbiAgICAgICAgICBpZiAobiA8IDApIG4gPSB0YXJnZXQuY3N0cmxlbihzdHJQdHIpICsgMTtcbiAgICAgICAgICBlbHNlIGlmICghKG4gPiAwKSkgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgaGVhcCA9IHRhcmdldC5oZWFwOHUoKTtcbiAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBjaDtcbiAgICAgICAgICBmb3IgKDsgaSA8IG4gJiYgKGNoID0gaGVhcFtzcmNQdHIgKyBpXSk7ICsraSkge1xuICAgICAgICAgICAgaGVhcFt0Z3RQdHIgKyBpXSA9IGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA8IG4pIGhlYXBbdGd0UHRyICsgaSsrXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmpzdHJUb1VpbnRBcnJheSA9IChzdHIsIGFkZE51bCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLnV0ZjhFbmNvZGVyLmVuY29kZShhZGROdWwgPyBzdHIgKyAnXFwwJyA6IHN0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hZmZpcm1BbGxvYyA9IChvYmosIGZ1bmNOYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShvYmouYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgICEob2JqLmRlYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdPYmplY3QgaXMgbWlzc2luZyBhbGxvYygpIGFuZC9vciBkZWFsbG9jKCkgZnVuY3Rpb24ocyknLFxuICAgICAgICAgICAgICAncmVxdWlyZWQgYnknLFxuICAgICAgICAgICAgICBmdW5jTmFtZSArICcoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hbGxvY0NTdHIgPSBmdW5jdGlvbiAoXG4gICAgICAgICAganN0cixcbiAgICAgICAgICByZXR1cm5XaXRoTGVuZ3RoLFxuICAgICAgICAgIGFsbG9jYXRvcixcbiAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsIGZ1bmNOYW1lKTtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBqc3RyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoMCkge1xuICAgICAgICAgICAgY29uc3QgbiA9IHRhcmdldC5qc3RybGVuKGpzdHIpLFxuICAgICAgICAgICAgICBwdHIgPSBhbGxvY2F0b3IobiArIDEpO1xuICAgICAgICAgICAgdGFyZ2V0LmpzdHJjcHkoanN0ciwgdGFyZ2V0LmhlYXA4dSgpLCBwdHIsIG4gKyAxLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgbl0gOiBwdHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBjYWNoZS51dGY4RW5jb2Rlci5lbmNvZGUoanN0ciksXG4gICAgICAgICAgICAgIHB0ciA9IGFsbG9jYXRvcih1Lmxlbmd0aCArIDEpLFxuICAgICAgICAgICAgICBoZWFwID0gaGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuICAgICAgICAgICAgaGVhcC5zZXQodSwgcHRyKTtcbiAgICAgICAgICAgIGhlYXBbcHRyICsgdS5sZW5ndGhdID0gMDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgdS5sZW5ndGhdIDogcHRyO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuYWxsb2NDU3RyaW5nID0gKGpzdHIsIHJldHVybldpdGhMZW5ndGggPSBmYWxzZSkgPT5cbiAgICAgICAgICBfX2FsbG9jQ1N0cihqc3RyLCByZXR1cm5XaXRoTGVuZ3RoLCB0YXJnZXQuYWxsb2MsICdhbGxvY0NTdHJpbmcoKScpO1xuXG4gICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1B1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsICdzY29wZWRBbGxvY1B1c2gnKTtcbiAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2MucHVzaChhKTtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQb3AgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgJ3Njb3BlZEFsbG9jUG9wJyk7XG4gICAgICAgICAgY29uc3QgbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgID8gY2FjaGUuc2NvcGVkQWxsb2MuaW5kZXhPZihzdGF0ZSlcbiAgICAgICAgICAgIDogY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAobiA8IDApIHRvc3MoJ0ludmFsaWQgc3RhdGUgb2JqZWN0IGZvciBzY29wZWRBbGxvY1BvcCgpLicpO1xuICAgICAgICAgIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSBzdGF0ZSA9IGNhY2hlLnNjb3BlZEFsbG9jW25dO1xuICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jLnNwbGljZShuLCAxKTtcbiAgICAgICAgICBmb3IgKGxldCBwOyAocCA9IHN0YXRlLnBvcCgpKTsgKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmZ1bmN0aW9uRW50cnkocCkpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnVuaW5zdGFsbEZ1bmN0aW9uKHApO1xuICAgICAgICAgICAgfSBlbHNlIHRhcmdldC5kZWFsbG9jKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2MgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGlmICghY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3NzKCdObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHAgPSB0YXJnZXQuYWxsb2Mobik7XG4gICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoIC0gMV0ucHVzaChwKTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LnNjb3BlZEFsbG9jLCAnbGV2ZWwnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IGNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MoXCJUaGUgJ2FjdGl2ZScgcHJvcGVydHkgaXMgcmVhZC1vbmx5LlwiKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jQ1N0cmluZyA9IChqc3RyLCByZXR1cm5XaXRoTGVuZ3RoID0gZmFsc2UpID0+XG4gICAgICAgICAgX19hbGxvY0NTdHIoXG4gICAgICAgICAgICBqc3RyLFxuICAgICAgICAgICAgcmV0dXJuV2l0aExlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvYyxcbiAgICAgICAgICAgICdzY29wZWRBbGxvY0NTdHJpbmcoKScsXG4gICAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBfX2FsbG9jTWFpbkFyZ3YgPSBmdW5jdGlvbiAoaXNTY29wZWQsIGxpc3QpIHtcbiAgICAgICAgICBjb25zdCBwTGlzdCA9IHRhcmdldFtpc1Njb3BlZCA/ICdzY29wZWRBbGxvYycgOiAnYWxsb2MnXShcbiAgICAgICAgICAgIChsaXN0Lmxlbmd0aCArIDEpICogdGFyZ2V0LnB0clNpemVvZixcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICBsaXN0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5wb2tlUHRyKFxuICAgICAgICAgICAgICBwTGlzdCArIHRhcmdldC5wdHJTaXplb2YgKiBpKyssXG4gICAgICAgICAgICAgIHRhcmdldFtpc1Njb3BlZCA/ICdzY29wZWRBbGxvY0NTdHJpbmcnIDogJ2FsbG9jQ1N0cmluZyddKCcnICsgZSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldC5wb2tlUHRyKHBMaXN0ICsgdGFyZ2V0LnB0clNpemVvZiAqIGksIDApO1xuICAgICAgICAgIHJldHVybiBwTGlzdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NNYWluQXJndiA9IChsaXN0KSA9PiBfX2FsbG9jTWFpbkFyZ3YodHJ1ZSwgbGlzdCk7XG5cbiAgICAgICAgdGFyZ2V0LmFsbG9jTWFpbkFyZ3YgPSAobGlzdCkgPT4gX19hbGxvY01haW5Bcmd2KGZhbHNlLCBsaXN0KTtcblxuICAgICAgICB0YXJnZXQuY0FyZ3ZUb0pzID0gKGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnYzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0YXJnZXQucGVla1B0cihwQXJndiArIHRhcmdldC5wdHJTaXplb2YgKiBpKTtcbiAgICAgICAgICAgIGxpc3QucHVzaChhcmcgPyB0YXJnZXQuY3N0clRvSnMoYXJnKSA6IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NDYWxsID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1BvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FsbG9jUHRyID0gZnVuY3Rpb24gKGhvd01hbnksIHNhZmVQdHJTaXplLCBtZXRob2QpIHtcbiAgICAgICAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgbWV0aG9kKTtcbiAgICAgICAgICBjb25zdCBwSXIgPSBzYWZlUHRyU2l6ZSA/ICdpNjQnIDogcHRySVI7XG4gICAgICAgICAgbGV0IG0gPSB0YXJnZXRbbWV0aG9kXShob3dNYW55ICogKHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZikpO1xuICAgICAgICAgIHRhcmdldC5wb2tlKG0sIDAsIHBJcik7XG4gICAgICAgICAgaWYgKDEgPT09IGhvd01hbnkpIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhID0gW21dO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaG93TWFueTsgKytpKSB7XG4gICAgICAgICAgICBtICs9IHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZjtcbiAgICAgICAgICAgIGFbaV0gPSBtO1xuICAgICAgICAgICAgdGFyZ2V0LnBva2UobSwgMCwgcElyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmFsbG9jUHRyID0gKGhvd01hbnkgPSAxLCBzYWZlUHRyU2l6ZSA9IHRydWUpID0+XG4gICAgICAgICAgX19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ2FsbG9jJyk7XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jUHRyID0gKGhvd01hbnkgPSAxLCBzYWZlUHRyU2l6ZSA9IHRydWUpID0+XG4gICAgICAgICAgX19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ3Njb3BlZEFsbG9jJyk7XG5cbiAgICAgICAgdGFyZ2V0LnhHZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0YXJnZXQuZXhwb3J0c1tuYW1lXSB8fCB0b3NzKCdDYW5ub3QgZmluZCBleHBvcnRlZCBzeW1ib2w6JywgbmFtZSlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYXJnY01pc21hdGNoID0gKGYsIG4pID0+XG4gICAgICAgICAgdG9zcyhmICsgJygpIHJlcXVpcmVzJywgbiwgJ2FyZ3VtZW50KHMpLicpO1xuXG4gICAgICAgIHRhcmdldC54Q2FsbCA9IGZ1bmN0aW9uIChmbmFtZSwgLi4uYXJncykge1xuICAgICAgICAgIGNvbnN0IGYgPSB0YXJnZXQueEdldChmbmFtZSk7XG4gICAgICAgICAgaWYgKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgICAgICAgIHRvc3MoJ0V4cG9ydGVkIHN5bWJvbCcsIGZuYW1lLCAnaXMgbm90IGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZm5hbWUsIGYubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gMiA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSlcbiAgICAgICAgICAgID8gZi5hcHBseShudWxsLCBhcmd1bWVudHNbMV0pXG4gICAgICAgICAgICA6IGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FjaGUueFdyYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0LmFyZyA9IG5ldyBNYXAoKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgeEFyZyA9IGNhY2hlLnhXcmFwLmNvbnZlcnQuYXJnLFxuICAgICAgICAgIHhSZXN1bHQgPSBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdDtcblxuICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICB4QXJnLnNldCgnaTY0JywgKGkpID0+IEJpZ0ludChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX194QXJnUHRyID1cbiAgICAgICAgICAnaTMyJyA9PT0gcHRySVIgPyAoaSkgPT4gaSB8IDAgOiAoaSkgPT4gQmlnSW50KGkpIHwgQmlnSW50KDApO1xuICAgICAgICB4QXJnXG4gICAgICAgICAgLnNldCgnaTMyJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJ2kxNicsIChpKSA9PiAoaSB8IDApICYgMHhmZmZmKVxuICAgICAgICAgIC5zZXQoJ2k4JywgKGkpID0+IChpIHwgMCkgJiAweGZmKVxuICAgICAgICAgIC5zZXQoJ2YzMicsIChpKSA9PiBOdW1iZXIoaSkudmFsdWVPZigpKVxuICAgICAgICAgIC5zZXQoJ2Zsb2F0JywgeEFyZy5nZXQoJ2YzMicpKVxuICAgICAgICAgIC5zZXQoJ2Y2NCcsIHhBcmcuZ2V0KCdmMzInKSlcbiAgICAgICAgICAuc2V0KCdkb3VibGUnLCB4QXJnLmdldCgnZjY0JykpXG4gICAgICAgICAgLnNldCgnaW50JywgeEFyZy5nZXQoJ2kzMicpKVxuICAgICAgICAgIC5zZXQoJ251bGwnLCAoaSkgPT4gaSlcbiAgICAgICAgICAuc2V0KG51bGwsIHhBcmcuZ2V0KCdudWxsJykpXG4gICAgICAgICAgLnNldCgnKionLCBfX3hBcmdQdHIpXG4gICAgICAgICAgLnNldCgnKicsIF9feEFyZ1B0cik7XG4gICAgICAgIHhSZXN1bHRcbiAgICAgICAgICAuc2V0KCcqJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJ3BvaW50ZXInLCBfX3hBcmdQdHIpXG4gICAgICAgICAgLnNldCgnbnVtYmVyJywgKHYpID0+IE51bWJlcih2KSlcbiAgICAgICAgICAuc2V0KCd2b2lkJywgKHYpID0+IHVuZGVmaW5lZClcbiAgICAgICAgICAuc2V0KCdudWxsJywgKHYpID0+IHYpXG4gICAgICAgICAgLnNldChudWxsLCB4UmVzdWx0LmdldCgnbnVsbCcpKTtcblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29weVRvUmVzdWx0ID0gW1xuICAgICAgICAgICAgJ2k4JyxcbiAgICAgICAgICAgICdpMTYnLFxuICAgICAgICAgICAgJ2kzMicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdmMzInLFxuICAgICAgICAgICAgJ2Zsb2F0JyxcbiAgICAgICAgICAgICdmNjQnLFxuICAgICAgICAgICAgJ2RvdWJsZScsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIGNvcHlUb1Jlc3VsdC5wdXNoKCdpNjQnKTtcbiAgICAgICAgICBjb25zdCBhZGFwdFB0ciA9IHhBcmcuZ2V0KHB0cklSKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgY29weVRvUmVzdWx0KSB7XG4gICAgICAgICAgICB4QXJnLnNldCh0ICsgJyonLCBhZGFwdFB0cik7XG4gICAgICAgICAgICB4UmVzdWx0LnNldCh0ICsgJyonLCBhZGFwdFB0cik7XG4gICAgICAgICAgICB4UmVzdWx0LnNldCh0LCB4QXJnLmdldCh0KSB8fCB0b3NzKCdNaXNzaW5nIGFyZyBjb252ZXJ0ZXI6JywgdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF9feEFyZ1N0cmluZyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdikgcmV0dXJuIHRhcmdldC5zY29wZWRBbGxvY0NTdHJpbmcodik7XG4gICAgICAgICAgcmV0dXJuIHYgPyBfX3hBcmdQdHIodikgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB4QXJnXG4gICAgICAgICAgLnNldCgnc3RyaW5nJywgX194QXJnU3RyaW5nKVxuICAgICAgICAgIC5zZXQoJ3V0ZjgnLCBfX3hBcmdTdHJpbmcpXG4gICAgICAgICAgLnNldCgncG9pbnRlcicsIF9feEFyZ1N0cmluZyk7XG5cbiAgICAgICAgeFJlc3VsdFxuICAgICAgICAgIC5zZXQoJ3N0cmluZycsIChpKSA9PiB0YXJnZXQuY3N0clRvSnMoaSkpXG4gICAgICAgICAgLnNldCgndXRmOCcsIHhSZXN1bHQuZ2V0KCdzdHJpbmcnKSlcbiAgICAgICAgICAuc2V0KCdzdHJpbmc6ZGVhbGxvYycsIChpKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaSA/IHRhcmdldC5jc3RyVG9KcyhpKSA6IG51bGw7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuZGVhbGxvYyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zZXQoJ3V0Zjg6ZGVhbGxvYycsIHhSZXN1bHQuZ2V0KCdzdHJpbmc6ZGVhbGxvYycpKVxuICAgICAgICAgIC5zZXQoJ2pzb24nLCAoaSkgPT4gSlNPTi5wYXJzZSh0YXJnZXQuY3N0clRvSnMoaSkpKVxuICAgICAgICAgIC5zZXQoJ2pzb246ZGVhbGxvYycsIChpKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaSA/IEpTT04ucGFyc2UodGFyZ2V0LmNzdHJUb0pzKGkpKSA6IG51bGw7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuZGVhbGxvYyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBBYnN0cmFjdEFyZ0FkYXB0ZXIgPSBjbGFzcyB7XG4gICAgICAgICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCAndW5uYW1lZCBhZGFwdGVyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb252ZXJ0QXJnKHYsIGFyZ3YsIGFyZ0luZGV4KSB7XG4gICAgICAgICAgICB0b3NzKCdBYnN0cmFjdEFyZ0FkYXB0ZXIgbXVzdCBiZSBzdWJjbGFzc2VkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyID0gY2xhc3MgRnVuY1B0ckFkYXB0ZXIgZXh0ZW5kcyBBYnN0cmFjdEFyZ0FkYXB0ZXIge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgICAgIGlmICh4QXJnLkZ1bmNQdHJBZGFwdGVyLndhcm5PblVzZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ3hBcmcuRnVuY1B0ckFkYXB0ZXIgaXMgYW4gaW50ZXJuYWwtb25seSBBUEknLFxuICAgICAgICAgICAgICAgICdhbmQgaXMgbm90IGludGVuZGVkIHRvIGJlIGludm9rZWQgZnJvbScsXG4gICAgICAgICAgICAgICAgJ2NsaWVudC1sZXZlbCBjb2RlLiBJbnZva2VkIHdpdGg6JyxcbiAgICAgICAgICAgICAgICBvcHQsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCAndW5uYW1lZCc7XG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IG9wdC5zaWduYXR1cmU7XG4gICAgICAgICAgICBpZiAob3B0LmNvbnRleHRLZXkgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkgPSBvcHQuY29udGV4dEtleTtcbiAgICAgICAgICAgICAgaWYgKCFvcHQuYmluZFNjb3BlKSBvcHQuYmluZFNjb3BlID0gJ2NvbnRleHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaW5kU2NvcGUgPVxuICAgICAgICAgICAgICBvcHQuYmluZFNjb3BlIHx8XG4gICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgJ0Z1bmNQdHJBZGFwdGVyIG9wdGlvbnMgcmVxdWlyZXMgYSBiaW5kU2NvcGUgKGV4cGxpY2l0IG9yIGltcGxpZWQpLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5pbmRleE9mKG9wdC5iaW5kU2NvcGUpIDwgMCkge1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIG9wdGlvbnMuYmluZFNjb3BlICgnICtcbiAgICAgICAgICAgICAgICAgIG9wdC5iaW5kTW9kICtcbiAgICAgICAgICAgICAgICAgICcpIGZvciBGdW5jUHRyQWRhcHRlci4gJyArXG4gICAgICAgICAgICAgICAgICAnRXhwZWN0aW5nIG9uZSBvZjogKCcgK1xuICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAgICcpJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNUcmFuc2llbnQgPSAndHJhbnNpZW50JyA9PT0gdGhpcy5iaW5kU2NvcGU7XG4gICAgICAgICAgICB0aGlzLmlzQ29udGV4dCA9ICdjb250ZXh0JyA9PT0gdGhpcy5iaW5kU2NvcGU7XG4gICAgICAgICAgICB0aGlzLmlzUGVybWFuZW50ID0gJ3Blcm1hbmVudCcgPT09IHRoaXMuYmluZFNjb3BlO1xuICAgICAgICAgICAgdGhpcy5zaW5nbGV0b24gPSAnc2luZ2xldG9uJyA9PT0gdGhpcy5iaW5kU2NvcGUgPyBbXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5jYWxsUHJveHkgPVxuICAgICAgICAgICAgICBvcHQuY2FsbFByb3h5IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvcHQuY2FsbFByb3h5IDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHRNYXAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjbSA9IHRoaXMuX19jbWFwIHx8ICh0aGlzLl9fY21hcCA9IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBsZXQgcmMgPSBjbS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHJjKSBjbS5zZXQoa2V5LCAocmMgPSBbXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnZlcnRBcmcodiwgYXJndiwgYXJnSW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gdGhpcy5zaW5nbGV0b247XG4gICAgICAgICAgICBpZiAoIXBhaXIgJiYgdGhpcy5pc0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgcGFpciA9IHRoaXMuY29udGV4dE1hcCh0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWlyICYmIHBhaXJbMF0gPT09IHYpIHJldHVybiBwYWlyWzFdO1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsUHJveHkpIHYgPSB0aGlzLmNhbGxQcm94eSh2KTtcbiAgICAgICAgICAgICAgY29uc3QgZnAgPSBfX2luc3RhbGxGdW5jdGlvbih2LCB0aGlzLnNpZ25hdHVyZSwgdGhpcy5pc1RyYW5zaWVudCk7XG4gICAgICAgICAgICAgIGlmIChGdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAnRnVuY1B0ckFkYXB0ZXIgaW5zdGFsbGVkJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgJ0AnICsgZnAsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFpclsxXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKEZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAgICAgJ0Z1bmNQdHJBZGFwdGVyIHVuaW5zdGFsbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICdAJyArIHBhaXJbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgcGFpclsxXSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhaXJbMF0gPSB2O1xuICAgICAgICAgICAgICAgIHBhaXJbMV0gPSBmcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5pc1B0cih2KSB8fCBudWxsID09PSB2IHx8IHVuZGVmaW5lZCA9PT0gdikge1xuICAgICAgICAgICAgICBpZiAocGFpciAmJiBwYWlyWzFdICYmIHBhaXJbMV0gIT09IHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCkge1xuICAgICAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXG4gICAgICAgICAgICAgICAgICAgICdGdW5jUHRyQWRhcHRlciB1bmluc3RhbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndiwgYXJnSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAnQCcgKyBwYWlyWzFdLFxuICAgICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2gocGFpclsxXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICBwYWlyWzBdID0gcGFpclsxXSA9IHYgfCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB2IHx8IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIEZ1bmNQdHJBZGFwdGVyIGFyZ3VtZW50IHR5cGUuICcgK1xuICAgICAgICAgICAgICAgICAgJ0V4cGVjdGluZyBhIGZ1bmN0aW9uIHBvaW50ZXIgb3IgYSAnICtcbiAgICAgICAgICAgICAgICAgICh0aGlzLm5hbWUgPyB0aGlzLm5hbWUgKyAnICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uIG1hdGNoaW5nIHNpZ25hdHVyZSAnICtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlICtcbiAgICAgICAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgeEFyZy5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSBmYWxzZTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwgPSBmYWxzZTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0ID0gY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpO1xuXG4gICAgICAgIHhBcmcuRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3BlcyA9IFtcbiAgICAgICAgICAndHJhbnNpZW50JyxcbiAgICAgICAgICAnY29udGV4dCcsXG4gICAgICAgICAgJ3NpbmdsZXRvbicsXG4gICAgICAgICAgJ3Blcm1hbmVudCcsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgX194QXJnQWRhcHRlckNoZWNrID0gKHQpID0+XG4gICAgICAgICAgeEFyZy5nZXQodCkgfHwgdG9zcygnQXJndW1lbnQgYWRhcHRlciBub3QgZm91bmQ6JywgdCk7XG5cbiAgICAgICAgY29uc3QgX194UmVzdWx0QWRhcHRlckNoZWNrID0gKHQpID0+XG4gICAgICAgICAgeFJlc3VsdC5nZXQodCkgfHwgdG9zcygnUmVzdWx0IGFkYXB0ZXIgbm90IGZvdW5kOicsIHQpO1xuXG4gICAgICAgIGNhY2hlLnhXcmFwLmNvbnZlcnRBcmcgPSAodCwgLi4uYXJncykgPT4gX194QXJnQWRhcHRlckNoZWNrKHQpKC4uLmFyZ3MpO1xuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0QXJnTm9DaGVjayA9ICh0LCAuLi5hcmdzKSA9PiB4QXJnLmdldCh0KSguLi5hcmdzKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0ID0gKHQsIHYpID0+XG4gICAgICAgICAgbnVsbCA9PT0gdCA/IHYgOiB0ID8gX194UmVzdWx0QWRhcHRlckNoZWNrKHQpKHYpIDogdW5kZWZpbmVkO1xuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0Tm9DaGVjayA9ICh0LCB2KSA9PlxuICAgICAgICAgIG51bGwgPT09IHQgPyB2IDogdCA/IHhSZXN1bHQuZ2V0KHQpKHYpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHRhcmdldC54V3JhcCA9IGZ1bmN0aW9uIChmQXJnLCByZXN1bHRUeXBlLCAuLi5hcmdUeXBlcykge1xuICAgICAgICAgIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSkge1xuICAgICAgICAgICAgYXJnVHlwZXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YXJnZXQuaXNQdHIoZkFyZykpIHtcbiAgICAgICAgICAgIGZBcmcgPVxuICAgICAgICAgICAgICB0YXJnZXQuZnVuY3Rpb25FbnRyeShmQXJnKSB8fFxuICAgICAgICAgICAgICB0b3NzKCdGdW5jdGlvbiBwb2ludGVyIG5vdCBmb3VuZCBpbiBXQVNNIGZ1bmN0aW9uIHRhYmxlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmSXNGdW5jID0gZkFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgICAgICAgIGNvbnN0IHhmID0gZklzRnVuYyA/IGZBcmcgOiB0YXJnZXQueEdldChmQXJnKTtcbiAgICAgICAgICBpZiAoZklzRnVuYykgZkFyZyA9IHhmLm5hbWUgfHwgJ3VubmFtZWQgZnVuY3Rpb24nO1xuICAgICAgICAgIGlmIChhcmdUeXBlcy5sZW5ndGggIT09IHhmLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZkFyZywgeGYubGVuZ3RoKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmVzdWx0VHlwZSAmJiAwID09PSB4Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gcmVzdWx0VHlwZSAmJiBudWxsICE9PSByZXN1bHRUeXBlKVxuICAgICAgICAgICAgX194UmVzdWx0QWRhcHRlckNoZWNrKHJlc3VsdFR5cGUpO1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBhcmdUeXBlcykge1xuICAgICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBBYnN0cmFjdEFyZ0FkYXB0ZXIpXG4gICAgICAgICAgICAgIHhBcmcuc2V0KHQsICguLi5hcmdzKSA9PiB0LmNvbnZlcnRBcmcoLi4uYXJncykpO1xuICAgICAgICAgICAgZWxzZSBfX3hBcmdBZGFwdGVyQ2hlY2sodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN4dyA9IGNhY2hlLnhXcmFwO1xuICAgICAgICAgIGlmICgwID09PSB4Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT5cbiAgICAgICAgICAgICAgYXJncy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IF9fYXJnY01pc21hdGNoKGZBcmcsIHhmLmxlbmd0aClcbiAgICAgICAgICAgICAgICA6IGN4dy5jb252ZXJ0UmVzdWx0KHJlc3VsdFR5cGUsIHhmLmNhbGwobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0geGYubGVuZ3RoKSBfX2FyZ2NNaXNtYXRjaChmQXJnLCB4Zi5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gYXJncylcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gY3h3LmNvbnZlcnRBcmdOb0NoZWNrKGFyZ1R5cGVzW2ldLCBhcmdzW2ldLCBhcmdzLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGN4dy5jb252ZXJ0UmVzdWx0Tm9DaGVjayhyZXN1bHRUeXBlLCB4Zi5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX194QWRhcHRlciA9IGZ1bmN0aW9uIChcbiAgICAgICAgICBmdW5jLFxuICAgICAgICAgIGFyZ2MsXG4gICAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICBtb2RlTmFtZSxcbiAgICAgICAgICB4Y3ZQYXJ0LFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0eXBlTmFtZSkge1xuICAgICAgICAgICAgaWYgKDEgPT09IGFyZ2MpIHJldHVybiB4Y3ZQYXJ0LmdldCh0eXBlTmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICgyID09PSBhcmdjKSB7XG4gICAgICAgICAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB4Y3ZQYXJ0LmdldCh0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIShhZGFwdGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhtb2RlTmFtZSwgJ3JlcXVpcmVzIGEgZnVuY3Rpb24gYXJndW1lbnQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeGN2UGFydC5zZXQodHlwZU5hbWUsIGFkYXB0ZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnSW52YWxpZCBhcmd1bWVudHMgdG8nLCBtb2RlTmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnhXcmFwLnJlc3VsdEFkYXB0ZXIgPSBmdW5jdGlvbiBmKHR5cGVOYW1lLCBhZGFwdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9feEFkYXB0ZXIoXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGVOYW1lLFxuICAgICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICAgICdyZXN1bHRBZGFwdGVyKCknLFxuICAgICAgICAgICAgeFJlc3VsdCxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC54V3JhcC5hcmdBZGFwdGVyID0gZnVuY3Rpb24gZih0eXBlTmFtZSwgYWRhcHRlcikge1xuICAgICAgICAgIHJldHVybiBfX3hBZGFwdGVyKFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICAnYXJnQWRhcHRlcigpJyxcbiAgICAgICAgICAgIHhBcmcsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQueFdyYXAuRnVuY1B0ckFkYXB0ZXIgPSB4QXJnLkZ1bmNQdHJBZGFwdGVyO1xuXG4gICAgICAgIHRhcmdldC54Q2FsbFdyYXBwZWQgPSBmdW5jdGlvbiAoZkFyZywgcmVzdWx0VHlwZSwgYXJnVHlwZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbM10pKSBhcmdzID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICAgIC54V3JhcChmQXJnLCByZXN1bHRUeXBlLCBhcmdUeXBlcyB8fCBbXSlcbiAgICAgICAgICAgIC5hcHBseShudWxsLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQueFdyYXAudGVzdENvbnZlcnRBcmcgPSBjYWNoZS54V3JhcC5jb252ZXJ0QXJnO1xuXG4gICAgICAgIHRhcmdldC54V3JhcC50ZXN0Q29udmVydFJlc3VsdCA9IGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlci55YXdsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25zdCB3ZmV0Y2ggPSAoKSA9PiBmZXRjaChjb25maWcudXJpLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pO1xuICAgICAgICBjb25zdCB3dWkgPSB0aGlzO1xuICAgICAgICBjb25zdCBmaW5hbFRoZW4gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy53YXNtVXRpbFRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGd0ID0gY29uZmlnLndhc21VdGlsVGFyZ2V0O1xuICAgICAgICAgICAgdGd0Lm1vZHVsZSA9IGFyZy5tb2R1bGU7XG4gICAgICAgICAgICB0Z3QuaW5zdGFuY2UgPSBhcmcuaW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGlmICghdGd0Lmluc3RhbmNlLmV4cG9ydHMubWVtb3J5KSB7XG4gICAgICAgICAgICAgIHRndC5tZW1vcnkgPVxuICAgICAgICAgICAgICAgIChjb25maWcuaW1wb3J0cyAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydHMuZW52ICYmXG4gICAgICAgICAgICAgICAgICBjb25maWcuaW1wb3J0cy5lbnYubWVtb3J5KSB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXCJNaXNzaW5nICdtZW1vcnknIG9iamVjdCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRndC5hbGxvYyAmJiBhcmcuaW5zdGFuY2UuZXhwb3J0cy5tYWxsb2MpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXhwb3J0cyA9IGFyZy5pbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICAgICAgICB0Z3QuYWxsb2MgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICBleHBvcnRzLm1hbGxvYyhuKSB8fCB0b3NzKCdBbGxvY2F0aW9uIG9mJywgbiwgJ2J5dGVzIGZhaWxlZC4nKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRndC5kZWFsbG9jID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmZyZWUobSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3dWkodGd0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbmZpZy5vbmxvYWQpIGNvbmZpZy5vbmxvYWQoYXJnLCBjb25maWcpO1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvYWRXYXNtID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdcbiAgICAgICAgICA/IGZ1bmN0aW9uIGxvYWRXYXNtU3RyZWFtaW5nKCkge1xuICAgICAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoXG4gICAgICAgICAgICAgICAgd2ZldGNoKCksXG4gICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydHMgfHwge30sXG4gICAgICAgICAgICAgICkudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24gbG9hZFdhc21PbGRTY2hvb2woKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3ZmV0Y2goKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICAgICAgICAudGhlbigoYnl0ZXMpID0+XG4gICAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgY29uZmlnLmltcG9ydHMgfHwge30pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGxvYWRXYXNtO1xuICAgICAgfS5iaW5kKGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcik7XG5cbiAgICAgICgndXNlIHN0cmljdCcpO1xuICAgICAgZ2xvYmFsVGhpcy5KYWNjd2FieXQgPSBmdW5jdGlvbiBTdHJ1Y3RCaW5kZXJGYWN0b3J5KGNvbmZpZykge1xuICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5KSAmJlxuICAgICAgICAgICEoY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICdjb25maWcuaGVhcCBtdXN0IGJlIFdlYkFzc2VtYmx5Lk1lbW9yeSBpbnN0YW5jZSBvciBhIGZ1bmN0aW9uLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBbJ2FsbG9jJywgJ2RlYWxsb2MnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgY29uZmlnW2tdIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgIHRvc3MoXCJDb25maWcgb3B0aW9uICdcIiArIGsgKyBcIicgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IFNCRiA9IFN0cnVjdEJpbmRlckZhY3Rvcnk7XG4gICAgICAgIGNvbnN0IGhlYXAgPVxuICAgICAgICAgICAgY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICA/IGNvbmZpZy5oZWFwXG4gICAgICAgICAgICAgIDogKCkgPT4gbmV3IFVpbnQ4QXJyYXkoY29uZmlnLmhlYXAuYnVmZmVyKSxcbiAgICAgICAgICBhbGxvYyA9IGNvbmZpZy5hbGxvYyxcbiAgICAgICAgICBkZWFsbG9jID0gY29uZmlnLmRlYWxsb2MsXG4gICAgICAgICAgbG9nID0gY29uZmlnLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgICAgICAgIG1lbWJlclByZWZpeCA9IGNvbmZpZy5tZW1iZXJQcmVmaXggfHwgJycsXG4gICAgICAgICAgbWVtYmVyU3VmZml4ID0gY29uZmlnLm1lbWJlclN1ZmZpeCB8fCAnJyxcbiAgICAgICAgICBiaWdJbnRFbmFibGVkID1cbiAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gY29uZmlnLmJpZ0ludEVuYWJsZWRcbiAgICAgICAgICAgICAgPyAhIWdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXVxuICAgICAgICAgICAgICA6ICEhY29uZmlnLmJpZ0ludEVuYWJsZWQsXG4gICAgICAgICAgQmlnSW50ID0gZ2xvYmFsVGhpc1snQmlnSW50J10sXG4gICAgICAgICAgQmlnSW50NjRBcnJheSA9IGdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSxcbiAgICAgICAgICBwdHJTaXplb2YgPSBjb25maWcucHRyU2l6ZW9mIHx8IDQsXG4gICAgICAgICAgcHRySVIgPSBjb25maWcucHRySVIgfHwgJ2kzMic7XG4gICAgICAgIGlmICghU0JGLmRlYnVnRmxhZ3MpIHtcbiAgICAgICAgICBTQkYuX19tYWtlRGVidWdGbGFncyA9IGZ1bmN0aW9uIChkZXJpdmVGcm9tID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGRlcml2ZUZyb20gJiYgZGVyaXZlRnJvbS5fX2ZsYWdzKVxuICAgICAgICAgICAgICBkZXJpdmVGcm9tID0gZGVyaXZlRnJvbS5fX2ZsYWdzO1xuICAgICAgICAgICAgY29uc3QgZiA9IGZ1bmN0aW9uIGYoZmxhZ3MpIHtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5fX2ZsYWdzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyA8IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmdldHRlcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLnNldHRlcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmFsbG9jO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmLl9fZmxhZ3MuZGVhbGxvYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmLl9fZmxhZ3MuZ2V0dGVyID0gMCAhPT0gKDB4MDEgJiBmbGFncyk7XG4gICAgICAgICAgICAgICAgZi5fX2ZsYWdzLnNldHRlciA9IDAgIT09ICgweDAyICYgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGYuX19mbGFncy5hbGxvYyA9IDAgIT09ICgweDA0ICYgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGYuX19mbGFncy5kZWFsbG9jID0gMCAhPT0gKDB4MDggJiBmbGFncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGYuX2ZsYWdzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCAnX19mbGFncycsIHtcbiAgICAgICAgICAgICAgaXRlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuY3JlYXRlKGRlcml2ZUZyb20pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWRlcml2ZUZyb20pIGYoMCk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFNCRi5kZWJ1Z0ZsYWdzID0gU0JGLl9fbWFrZURlYnVnRmxhZ3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzTGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlKTtcblxuICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpWzBdID09PSAyNTY7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgY29uc3QgaXNGdW5jU2lnID0gKHMpID0+ICcoJyA9PT0gc1sxXTtcblxuICAgICAgICBjb25zdCBpc1B0clNpZyA9IChzKSA9PiAncCcgPT09IHMgfHwgJ1AnID09PSBzO1xuICAgICAgICBjb25zdCBpc0F1dG9QdHJTaWcgPSAocykgPT4gJ1AnID09PSBzO1xuICAgICAgICBjb25zdCBzaWdMZXR0ZXIgPSAocykgPT4gKGlzRnVuY1NpZyhzKSA/ICdwJyA6IHNbMF0pO1xuXG4gICAgICAgIGNvbnN0IHNpZ0lSID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpOCc7XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpMzInO1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICByZXR1cm4gcHRySVI7XG4gICAgICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdpNjQnO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgIHJldHVybiAnZG91YmxlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnVW5oYW5kbGVkIHNpZ25hdHVyZSBJUjonLCBzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1CaWdJbnRBcnJheSA9IEJpZ0ludDY0QXJyYXlcbiAgICAgICAgICA/ICgpID0+IHRydWVcbiAgICAgICAgICA6ICgpID0+IHRvc3MoJ0JpZ0ludDY0QXJyYXkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblxuICAgICAgICBjb25zdCBzaWdEVkdldHRlciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgc3dpdGNoIChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICBjYXNlICdzJzoge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHB0clNpemVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnZ2V0SW50MzInO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdnZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRJbnQzMic7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRJbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2dldFVpbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnZ2V0QmlnSW50NjQnO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2V0RmxvYXQzMic7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRGbG9hdDY0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnVW5oYW5kbGVkIERhdGFWaWV3IGdldHRlciBmb3Igc2lnbmF0dXJlOicsIHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNpZ0RWU2V0dGVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocHRyU2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdzZXRJbnQzMic7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ3NldEJpZ0ludDY0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEludDMyJztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEludDgnO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgIHJldHVybiAnc2V0VWludDgnO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgIHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdzZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdzZXRGbG9hdDMyJztcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldEZsb2F0NjQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3NzKCdVbmhhbmRsZWQgRGF0YVZpZXcgc2V0dGVyIGZvciBzaWduYXR1cmU6Jywgcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc2lnRFZTZXRXcmFwcGVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNpZ0xldHRlcihzKSkge1xuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcjtcbiAgICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgIHN3aXRjaCAocHRyU2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcjtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoJ1VuaGFuZGxlZCBEYXRhVmlldyBzZXQgd3JhcHBlciBmb3Igc2lnbmF0dXJlOicsIHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNQcm9wTmFtZSA9IChzLCBrKSA9PiBzICsgJzo6JyArIGs7XG5cbiAgICAgICAgY29uc3QgX19wcm9wVGhyb3dPblNldCA9IGZ1bmN0aW9uIChzdHJ1Y3ROYW1lLCBwcm9wTmFtZSkge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB0b3NzKHNQcm9wTmFtZShzdHJ1Y3ROYW1lLCBwcm9wTmFtZSksICdpcyByZWFkLW9ubHkuJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19pbnN0YW5jZVBvaW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGNvbnN0IHhQdHJQcm9wTmFtZSA9ICcocG9pbnRlci1pcy1leHRlcm5hbCknO1xuXG4gICAgICAgIGNvbnN0IF9fZnJlZVN0cnVjdCA9IGZ1bmN0aW9uIChjdG9yLCBvYmosIG0pIHtcbiAgICAgICAgICBpZiAoIW0pIG0gPSBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQob2JqKTtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgX19pbnN0YW5jZVBvaW50ZXJNYXAuZGVsZXRlKG9iaik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoub25kaXNwb3NlKSkge1xuICAgICAgICAgICAgICBsZXQgeDtcbiAgICAgICAgICAgICAgd2hpbGUgKCh4ID0gb2JqLm9uZGlzcG9zZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB4LmNhbGwob2JqKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSB4LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdudW1iZXInID09PSB0eXBlb2YgeCkgZGVhbGxvYyh4KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICdvbmRpc3Bvc2UoKSBmb3InLFxuICAgICAgICAgICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICAgICAgJ3RocmV3LiBOT1QgcHJvcGFnYXRpbmcgaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5vbmRpc3Bvc2UgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5vbmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdvbmRpc3Bvc2UoKSBmb3InLFxuICAgICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICAgICd0aHJldy4gTk9UIHByb3BhZ2F0aW5nIGl0LicsXG4gICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBvYmoub25kaXNwb3NlO1xuICAgICAgICAgICAgaWYgKGN0b3IuZGVidWdGbGFncy5fX2ZsYWdzLmRlYWxsb2MpIHtcbiAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICdkZWJ1Zy5kZWFsbG9jOicsXG4gICAgICAgICAgICAgICAgb2JqW3hQdHJQcm9wTmFtZV0gPyAnRVhURVJOQUwnIDogJycsXG4gICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICdpbnN0YW5jZTonLFxuICAgICAgICAgICAgICAgIGN0b3Iuc3RydWN0SW5mby5zaXplb2YsXG4gICAgICAgICAgICAgICAgJ2J5dGVzIEAnICsgbSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb2JqW3hQdHJQcm9wTmFtZV0pIGRlYWxsb2MobSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJvcCA9ICh2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWxsb2NTdHJ1Y3QgPSBmdW5jdGlvbiAoY3Rvciwgb2JqLCBtKSB7XG4gICAgICAgICAgbGV0IGZpbGwgPSAhbTtcbiAgICAgICAgICBpZiAobSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgeFB0clByb3BOYW1lLCByb3AobSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbSA9IGFsbG9jKGN0b3Iuc3RydWN0SW5mby5zaXplb2YpO1xuICAgICAgICAgICAgaWYgKCFtKSB0b3NzKCdBbGxvY2F0aW9uIG9mJywgY3Rvci5zdHJ1Y3ROYW1lLCAnc3RydWN0dXJlIGZhaWxlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjdG9yLmRlYnVnRmxhZ3MuX19mbGFncy5hbGxvYykge1xuICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgJ2RlYnVnLmFsbG9jOicsXG4gICAgICAgICAgICAgICAgZmlsbCA/ICcnIDogJ0VYVEVSTkFMJyxcbiAgICAgICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgJ2luc3RhbmNlOicsXG4gICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZixcbiAgICAgICAgICAgICAgICAnYnl0ZXMgQCcgKyBtLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGwpIGhlYXAoKS5maWxsKDAsIG0sIG0gKyBjdG9yLnN0cnVjdEluZm8uc2l6ZW9mKTtcbiAgICAgICAgICAgIF9faW5zdGFuY2VQb2ludGVyTWFwLnNldChvYmosIG0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF9fZnJlZVN0cnVjdChjdG9yLCBvYmosIG0pO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1vcnlEdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoaGVhcCgpLnNsaWNlKHAsIHAgKyB0aGlzLnN0cnVjdEluZm8uc2l6ZW9mKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX21lbWJlcktleSA9IChrKSA9PiBtZW1iZXJQcmVmaXggKyBrICsgbWVtYmVyU3VmZml4O1xuICAgICAgICBjb25zdCBfX21lbWJlcktleVByb3AgPSByb3AoX19tZW1iZXJLZXkpO1xuXG4gICAgICAgIGNvbnN0IF9fbG9va3VwTWVtYmVyID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHN0cnVjdEluZm8sXG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICB0b3NzSWZOb3RGb3VuZCA9IHRydWUsXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBtID0gc3RydWN0SW5mby5tZW1iZXJzW21lbWJlck5hbWVdO1xuICAgICAgICAgIGlmICghbSAmJiAobWVtYmVyUHJlZml4IHx8IG1lbWJlclN1ZmZpeCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHN0cnVjdEluZm8ubWVtYmVycykpIHtcbiAgICAgICAgICAgICAgaWYgKHYua2V5ID09PSBtZW1iZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgbSA9IHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbSAmJiB0b3NzSWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgIHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsIG1lbWJlck5hbWUpLFxuICAgICAgICAgICAgICAgICdpcyBub3QgYSBtYXBwZWQgc3RydWN0IG1lbWJlci4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX21lbWJlclNpZ25hdHVyZSA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgZW1zY3JpcHRlbkZvcm1hdCA9IGZhbHNlLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoIWYuXylcbiAgICAgICAgICAgIGYuXyA9ICh4KSA9PlxuICAgICAgICAgICAgICB4LnJlcGxhY2UoL1tedmlwUHNqcmRjQ10vZywgJycpLnJlcGxhY2UoL1twUHNjQ10vZywgJ2knKTtcbiAgICAgICAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgICAgICAgIHJldHVybiBlbXNjcmlwdGVuRm9ybWF0ID8gZi5fKG0uc2lnbmF0dXJlKSA6IG0uc2lnbmF0dXJlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fcHRyUHJvcERlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MoXCJDYW5ub3QgYXNzaWduIHRoZSAncG9pbnRlcicgcHJvcGVydHkgb2YgYSBzdHJ1Y3QuXCIpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fc3RydWN0TWVtYmVyS2V5cyA9IHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnN0cnVjdEluZm8ubWVtYmVycykpIHtcbiAgICAgICAgICAgIGEucHVzaCh0aGlzLm1lbWJlcktleShrKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBfX3V0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICBjb25zdCBfX3V0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgICAgICAgY29uc3QgX19TQUIgPVxuICAgICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIDogU2hhcmVkQXJyYXlCdWZmZXI7XG4gICAgICAgIGNvbnN0IF9fdXRmOERlY29kZSA9IGZ1bmN0aW9uIChhcnJheUJ1ZmZlciwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgIHJldHVybiBfX3V0ZjhEZWNvZGVyLmRlY29kZShcbiAgICAgICAgICAgIGFycmF5QnVmZmVyLmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCXG4gICAgICAgICAgICAgID8gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgICAgICAgOiBhcnJheUJ1ZmZlci5zdWJhcnJheShiZWdpbiwgZW5kKSxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbWVtYmVySXNTdHJpbmcgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgdG9zc0lmTm90Rm91bmQgPSBmYWxzZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgICAgICAgcmV0dXJuIG0gJiYgMSA9PT0gbS5zaWduYXR1cmUubGVuZ3RoICYmICdzJyA9PT0gbS5zaWduYXR1cmVbMF1cbiAgICAgICAgICAgID8gbVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FmZmlybUNTdHJpbmdTaWduYXR1cmUgPSBmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgICAgaWYgKCdzJyA9PT0gbWVtYmVyLnNpZ25hdHVyZSkgcmV0dXJuO1xuICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAnSW52YWxpZCBtZW1iZXIgdHlwZSBzaWduYXR1cmUgZm9yIEMtc3RyaW5nIHZhbHVlOicsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZW1iZXIpLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1iZXJUb0pzU3RyaW5nID0gZnVuY3Rpb24gZihvYmosIG1lbWJlck5hbWUpIHtcbiAgICAgICAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgICAgICAgIF9fYWZmaXJtQ1N0cmluZ1NpZ25hdHVyZShtKTtcbiAgICAgICAgICBjb25zdCBhZGRyID0gb2JqW20ua2V5XTtcblxuICAgICAgICAgIGlmICghYWRkcikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgbGV0IHBvcyA9IGFkZHI7XG4gICAgICAgICAgY29uc3QgbWVtID0gaGVhcCgpO1xuICAgICAgICAgIGZvciAoOyBtZW1bcG9zXSAhPT0gMDsgKytwb3MpIHt9XG5cbiAgICAgICAgICByZXR1cm4gYWRkciA9PT0gcG9zID8gJycgOiBfX3V0ZjhEZWNvZGUobWVtLCBhZGRyLCBwb3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWRkT25EaXNwb3NlID0gZnVuY3Rpb24gKG9iaiwgLi4udikge1xuICAgICAgICAgIGlmIChvYmoub25kaXNwb3NlKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqLm9uZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgb2JqLm9uZGlzcG9zZSA9IFtvYmoub25kaXNwb3NlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqLm9uZGlzcG9zZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmoub25kaXNwb3NlLnB1c2goLi4udik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hbGxvY0NTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgY29uc3QgdSA9IF9fdXRmOEVuY29kZXIuZW5jb2RlKHN0cik7XG4gICAgICAgICAgY29uc3QgbWVtID0gYWxsb2ModS5sZW5ndGggKyAxKTtcbiAgICAgICAgICBpZiAoIW1lbSkgdG9zcygnQWxsb2NhdGlvbiBlcnJvciB3aGlsZSBkdXBsaWNhdGluZyBzdHJpbmc6Jywgc3RyKTtcbiAgICAgICAgICBjb25zdCBoID0gaGVhcCgpO1xuXG4gICAgICAgICAgaC5zZXQodSwgbWVtKTtcbiAgICAgICAgICBoW21lbSArIHUubGVuZ3RoXSA9IDA7XG5cbiAgICAgICAgICByZXR1cm4gbWVtO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fc2V0TWVtYmVyQ1N0cmluZyA9IGZ1bmN0aW9uIChvYmosIG1lbWJlck5hbWUsIHN0cikge1xuICAgICAgICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgX19hZmZpcm1DU3RyaW5nU2lnbmF0dXJlKG0pO1xuXG4gICAgICAgICAgY29uc3QgbWVtID0gX19hbGxvY0NTdHJpbmcoc3RyKTtcbiAgICAgICAgICBvYmpbbS5rZXldID0gbWVtO1xuICAgICAgICAgIF9fYWRkT25EaXNwb3NlKG9iaiwgbWVtKTtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IFN0cnVjdFR5cGUgPSBmdW5jdGlvbiBjdG9yKHN0cnVjdE5hbWUsIHN0cnVjdEluZm8pIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzWzJdICE9PSByb3ApIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdEbyBub3QgY2FsbCB0aGUgU3RydWN0VHlwZSBjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICdmcm9tIGNsaWVudC1sZXZlbCBjb2RlLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSksXG4gICAgICAgICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICBkaXNwb3NlOiByb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX19mcmVlU3RydWN0KHRoaXMuY29uc3RydWN0b3IsIHRoaXMpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGxvb2t1cE1lbWJlcjogcm9wKGZ1bmN0aW9uIChtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2xvb2t1cE1lbWJlcih0aGlzLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtZW1iZXJUb0pzU3RyaW5nOiByb3AoZnVuY3Rpb24gKG1lbWJlck5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX21lbWJlclRvSnNTdHJpbmcodGhpcywgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtYmVySXNTdHJpbmc6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19tZW1iZXJJc1N0cmluZyh0aGlzLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtYmVyS2V5OiBfX21lbWJlcktleVByb3AsXG4gICAgICAgICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgICAgICAgIG1lbWJlclNpZ25hdHVyZTogcm9wKGZ1bmN0aW9uIChtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX21lbWJlclNpZ25hdHVyZSh0aGlzLCBtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtZW1vcnlEdW1wOiByb3AoX19tZW1vcnlEdW1wKSxcbiAgICAgICAgICBwb2ludGVyOiBfX3B0clByb3BEZXNjcmlwdG9yLFxuICAgICAgICAgIHNldE1lbWJlckNTdHJpbmc6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZXRNZW1iZXJDU3RyaW5nKHRoaXMsIG1lbWJlck5hbWUsIHN0cik7XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oU3RydWN0VHlwZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICBhZGRPbkRpc3Bvc2U6IGZ1bmN0aW9uICguLi52KSB7XG4gICAgICAgICAgICBfX2FkZE9uRGlzcG9zZSh0aGlzLCAuLi52KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdFR5cGUsIHtcbiAgICAgICAgICBhbGxvY0NTdHJpbmc6IHJvcChfX2FsbG9jQ1N0cmluZyksXG4gICAgICAgICAgaXNBOiByb3AoKHYpID0+IHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSxcbiAgICAgICAgICBoYXNFeHRlcm5hbFBvaW50ZXI6IHJvcChcbiAgICAgICAgICAgICh2KSA9PiB2IGluc3RhbmNlb2YgU3RydWN0VHlwZSAmJiAhIXZbeFB0clByb3BOYW1lXSxcbiAgICAgICAgICApLFxuICAgICAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBpc051bWVyaWNWYWx1ZSA9ICh2KSA9PlxuICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh2KSB8fCB2IGluc3RhbmNlb2YgKEJpZ0ludCB8fCBOdW1iZXIpO1xuXG4gICAgICAgIGNvbnN0IG1ha2VNZW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gZihjdG9yLCBuYW1lLCBkZXNjcikge1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl8gPSB7IGdldHRlcnM6IHt9LCBzZXR0ZXJzOiB7fSwgc3c6IHt9IH07XG4gICAgICAgICAgICBjb25zdCBhID0gWydpJywgJ2MnLCAnQycsICdwJywgJ1AnLCAncycsICdmJywgJ2QnLCAndigpJ107XG4gICAgICAgICAgICBpZiAoYmlnSW50RW5hYmxlZCkgYS5wdXNoKCdqJyk7XG4gICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgZi5fLmdldHRlcnNbdl0gPSBzaWdEVkdldHRlcih2KTtcbiAgICAgICAgICAgICAgZi5fLnNldHRlcnNbdl0gPSBzaWdEVlNldHRlcih2KTtcbiAgICAgICAgICAgICAgZi5fLnN3W3ZdID0gc2lnRFZTZXRXcmFwcGVyKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByeFNpZzEgPSAvXltpcFBzamZkY0NdJC8sXG4gICAgICAgICAgICAgIHJ4U2lnMiA9IC9eW3ZpcFBzamZkY0NdXFwoW2lwUHNqZmRjQ10qXFwpJC87XG4gICAgICAgICAgICBmLnNpZ0NoZWNrID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwga2V5LCBzaWcpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzKG9iai5zdHJ1Y3ROYW1lLCAnYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBuYW1lZCcsIGtleSArICcuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnhTaWcxLnRlc3Qoc2lnKSB8fFxuICAgICAgICAgICAgICAgIHJ4U2lnMi50ZXN0KHNpZykgfHxcbiAgICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICAgJ01hbGZvcm1lZCBzaWduYXR1cmUgZm9yJyxcbiAgICAgICAgICAgICAgICAgIHNQcm9wTmFtZShvYmouc3RydWN0TmFtZSwgbmFtZSkgKyAnOicsXG4gICAgICAgICAgICAgICAgICBzaWcsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGtleSA9IGN0b3IubWVtYmVyS2V5KG5hbWUpO1xuICAgICAgICAgIGYuc2lnQ2hlY2soY3Rvci5wcm90b3R5cGUsIG5hbWUsIGtleSwgZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICAgICAgICBkZXNjci5rZXkgPSBrZXk7XG4gICAgICAgICAgZGVzY3IubmFtZSA9IG5hbWU7XG4gICAgICAgICAgY29uc3Qgc2lnR2x5cGggPSBzaWdMZXR0ZXIoZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICAgICAgICBjb25zdCB4UHJvcE5hbWUgPSBzUHJvcE5hbWUoY3Rvci5wcm90b3R5cGUuc3RydWN0TmFtZSwga2V5KTtcbiAgICAgICAgICBjb25zdCBkYmcgPSBjdG9yLnByb3RvdHlwZS5kZWJ1Z0ZsYWdzLl9fZmxhZ3M7XG5cbiAgICAgICAgICBjb25zdCBwcm9wID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBwcm9wLmNvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHByb3AuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHByb3AuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRiZy5nZXR0ZXIpIHtcbiAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICdkZWJ1Zy5nZXR0ZXI6JyxcbiAgICAgICAgICAgICAgICBmLl8uZ2V0dGVyc1tzaWdHbHlwaF0sXG4gICAgICAgICAgICAgICAgJ2ZvcicsXG4gICAgICAgICAgICAgICAgc2lnSVIoc2lnR2x5cGgpLFxuICAgICAgICAgICAgICAgIHhQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgICcrJyxcbiAgICAgICAgICAgICAgICBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgJ3N6JyxcbiAgICAgICAgICAgICAgICBkZXNjci5zaXplb2YsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmMgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgIGhlYXAoKS5idWZmZXIsXG4gICAgICAgICAgICAgIHRoaXMucG9pbnRlciArIGRlc2NyLm9mZnNldCxcbiAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgKVtmLl8uZ2V0dGVyc1tzaWdHbHlwaF1dKDAsIGlzTGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIGlmIChkYmcuZ2V0dGVyKSBsb2coJ2RlYnVnLmdldHRlcjonLCB4UHJvcE5hbWUsICdyZXN1bHQgPScsIHJjKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZXNjci5yZWFkT25seSkge1xuICAgICAgICAgICAgcHJvcC5zZXQgPSBfX3Byb3BUaHJvd09uU2V0KGN0b3IucHJvdG90eXBlLnN0cnVjdE5hbWUsIGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3Auc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaWYgKGRiZy5zZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAnZGVidWcuc2V0dGVyOicsXG4gICAgICAgICAgICAgICAgICBmLl8uc2V0dGVyc1tzaWdHbHlwaF0sXG4gICAgICAgICAgICAgICAgICAnZm9yJyxcbiAgICAgICAgICAgICAgICAgIHNpZ0lSKHNpZ0dseXBoKSxcbiAgICAgICAgICAgICAgICAgIHhQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICcrJyxcbiAgICAgICAgICAgICAgICAgIGRlc2NyLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICdzeicsXG4gICAgICAgICAgICAgICAgICBkZXNjci5zaXplb2YsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdDYW5ub3Qgc2V0IHN0cnVjdCBwcm9wZXJ0eSBvbiBkaXNwb3NlZCBpbnN0YW5jZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdikgdiA9IDA7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTnVtZXJpY1ZhbHVlKHYpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0b1B0clNpZyhkZXNjci5zaWduYXR1cmUpICYmXG4gICAgICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHYucG9pbnRlciB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGJnLnNldHRlcilcbiAgICAgICAgICAgICAgICAgICAgICBsb2coJ2RlYnVnLnNldHRlcjonLCB4UHJvcE5hbWUsICdyZXNvbHZlZCB0bycsIHYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdmFsdWUgZm9yIHBvaW50ZXItdHlwZScsIHhQcm9wTmFtZSArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgICAgaGVhcCgpLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIgKyBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgICApW2YuXy5zZXR0ZXJzW3NpZ0dseXBoXV0oMCwgZi5fLnN3W3NpZ0dseXBoXSh2KSwgaXNMaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHByb3ApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IFN0cnVjdEJpbmRlciA9IGZ1bmN0aW9uIFN0cnVjdEJpbmRlcihzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvKSB7XG4gICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cnVjdEluZm8gPSBzdHJ1Y3ROYW1lO1xuICAgICAgICAgICAgc3RydWN0TmFtZSA9IHN0cnVjdEluZm8ubmFtZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJ1Y3RJbmZvLm5hbWUpIHtcbiAgICAgICAgICAgIHN0cnVjdEluZm8ubmFtZSA9IHN0cnVjdE5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RydWN0TmFtZSkgdG9zcygnU3RydWN0IG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgbGV0IGxhc3RNZW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBzdHJ1Y3RJbmZvLm1lbWJlcnNba107XG4gICAgICAgICAgICBpZiAoIW0uc2l6ZW9mKSB0b3NzKHN0cnVjdE5hbWUsICdtZW1iZXInLCBrLCAnaXMgbWlzc2luZyBzaXplb2YuJyk7XG4gICAgICAgICAgICBlbHNlIGlmIChtLnNpemVvZiA9PT0gMSkge1xuICAgICAgICAgICAgICBtLnNpZ25hdHVyZSA9PT0gJ2MnIHx8XG4gICAgICAgICAgICAgICAgbS5zaWduYXR1cmUgPT09ICdDJyB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBzaXplb2Y9PTEgbWVtYmVyJyxcbiAgICAgICAgICAgICAgICAgIHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsIGspLFxuICAgICAgICAgICAgICAgICAgJ3dpdGggc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICAgIG0uc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gbS5zaXplb2YgJSA0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgc3RydWN0IG1lbWJlciBkZXNjcmlwdGlvbiA9JyxcbiAgICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgICAnZnJvbScsXG4gICAgICAgICAgICAgICAgICBzdHJ1Y3RJbmZvLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgIHN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAnbWVtYmVyJyxcbiAgICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgICAnc2l6ZW9mIGlzIG5vdCBhbGlnbmVkLiBzaXplb2Y9JyArIG0uc2l6ZW9mLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDAgIT09IG0ub2Zmc2V0ICUgNCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHN0cnVjdCBtZW1iZXIgZGVzY3JpcHRpb24gPScsXG4gICAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgICAgJ2Zyb20nLFxuICAgICAgICAgICAgICAgICAgc3RydWN0SW5mbyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgJ21lbWJlcicsXG4gICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgJ29mZnNldCBpcyBub3QgYWxpZ25lZC4gb2Zmc2V0PScgKyBtLm9mZnNldCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhc3RNZW1iZXIgfHwgbGFzdE1lbWJlci5vZmZzZXQgPCBtLm9mZnNldCkgbGFzdE1lbWJlciA9IG07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFsYXN0TWVtYmVyKSB0b3NzKCdObyBtZW1iZXIgcHJvcGVydHkgZGVzY3JpcHRpb25zIGZvdW5kLicpO1xuICAgICAgICAgIGVsc2UgaWYgKHN0cnVjdEluZm8uc2l6ZW9mIDwgbGFzdE1lbWJlci5vZmZzZXQgKyBsYXN0TWVtYmVyLnNpemVvZikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ0ludmFsaWQgc3RydWN0IGNvbmZpZzonLFxuICAgICAgICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAnbWF4IG1lbWJlciBvZmZzZXQgKCcgKyBsYXN0TWVtYmVyLm9mZnNldCArICcpICcsXG4gICAgICAgICAgICAgICdleHRlbmRzIHBhc3QgZW5kIG9mIHN0cnVjdCAoc2l6ZW9mPScgKyBzdHJ1Y3RJbmZvLnNpemVvZiArICcpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWJ1Z0ZsYWdzID0gcm9wKFNCRi5fX21ha2VEZWJ1Z0ZsYWdzKFN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKSk7XG5cbiAgICAgICAgICBjb25zdCBTdHJ1Y3RDdG9yID0gZnVuY3Rpb24gU3RydWN0Q3RvcihleHRlcm5hbE1lbW9yeSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cnVjdEN0b3IpKSB7XG4gICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgJ1RoZScsXG4gICAgICAgICAgICAgICAgc3RydWN0TmFtZSxcbiAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yIG1heSBvbmx5IGJlIGNhbGxlZCB2aWEgJ25ldycuXCIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGV4dGVybmFsTWVtb3J5ICE9PSAoZXh0ZXJuYWxNZW1vcnkgfCAwKSB8fFxuICAgICAgICAgICAgICAgIGV4dGVybmFsTWVtb3J5IDw9IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCBwb2ludGVyIHZhbHVlIGZvcicsIHN0cnVjdE5hbWUsICdjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfX2FsbG9jU3RydWN0KFN0cnVjdEN0b3IsIHRoaXMsIGV4dGVybmFsTWVtb3J5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9fYWxsb2NTdHJ1Y3QoU3RydWN0Q3RvciwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RDdG9yLCB7XG4gICAgICAgICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgICAgICAgaXNBOiByb3AoKHYpID0+IHYgaW5zdGFuY2VvZiBTdHJ1Y3RDdG9yKSxcbiAgICAgICAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgICAgICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgICAgICAgICAgbWV0aG9kSW5mb0ZvcktleTogcm9wKGZ1bmN0aW9uIChtS2V5KSB7fSksXG4gICAgICAgICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbyksXG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgU3RydWN0Q3Rvci5wcm90b3R5cGUgPSBuZXcgU3RydWN0VHlwZShzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvLCByb3ApO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdEN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgICAgICAgY29uc3RydWN0b3I6IHJvcChTdHJ1Y3RDdG9yKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goKG5hbWUpID0+XG4gICAgICAgICAgICBtYWtlTWVtYmVyV3JhcHBlcihTdHJ1Y3RDdG9yLCBuYW1lLCBzdHJ1Y3RJbmZvLm1lbWJlcnNbbmFtZV0pLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFN0cnVjdEN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIFN0cnVjdEJpbmRlci5TdHJ1Y3RUeXBlID0gU3RydWN0VHlwZTtcbiAgICAgICAgU3RydWN0QmluZGVyLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgU3RydWN0QmluZGVyLmFsbG9jQ1N0cmluZyA9IF9fYWxsb2NDU3RyaW5nO1xuICAgICAgICBpZiAoIVN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKSB7XG4gICAgICAgICAgU3RydWN0QmluZGVyLmRlYnVnRmxhZ3MgPSBTQkYuX19tYWtlRGVidWdGbGFncyhTQkYuZGVidWdGbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cnVjdEJpbmRlcjtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvc3MzID0gc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcztcbiAgICAgICAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaSxcbiAgICAgICAgICB3YXNtID0gc3FsaXRlMy53YXNtLFxuICAgICAgICAgIHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcih3YXNtKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcjtcblxuICAgICAgICBpZiAoMCkge1xuICAgICAgICAgIGNvbnN0IGRlYWxsb2MgPSB3YXNtLmV4cG9ydHNbc3FsaXRlMy5jb25maWcuZGVhbGxvY0V4cG9ydE5hbWVdO1xuICAgICAgICAgIGNvbnN0IG5GdW5jID0gd2FzbS5mdW5jdGlvblRhYmxlKCkubGVuZ3RoO1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuRnVuYzsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gd2FzbS5mdW5jdGlvbkVudHJ5KGkpO1xuICAgICAgICAgICAgaWYgKGRlYWxsb2MgPT09IGUpIHtcbiAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWFsbG9jICE9PSB3YXNtLmZ1bmN0aW9uRW50cnkoY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKSkge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ0ludGVybmFsIGVycm9yOiBjYW5ub3QgZmluZCBmdW5jdGlvbiBwb2ludGVyIGZvciBTUUxJVEVfV0FTTV9ERUFMTE9DLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMgPSBbXG4gICAgICAgICAgWydzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0JywgJ3ZvaWQqJywgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfYmluZF9kb3VibGUnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50JywgJ2Y2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19iaW5kX2ludCcsICdpbnQnLCAnc3FsaXRlM19zdG10KicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfbnVsbCcsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2JpbmRfcG9pbnRlcicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfYnVzeV9oYW5kbGVyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaSknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfYnVzeV90aW1lb3V0JywgJ2ludCcsICdzcWxpdGUzKicsICdpbnQnXSxcblxuICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jbGVhcl9iaW5kaW5ncycsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkJywgJ2ludCcsICdzcWxpdGUzKicsICcqJywgJyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX2Jsb2InLCAnKicsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fYnl0ZXMnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9jb3VudCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fZG91YmxlJywgJ2Y2NCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5faW50JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fbmFtZScsICdzdHJpbmcnLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX3RleHQnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl90eXBlJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fdmFsdWUnLCAnc3FsaXRlM192YWx1ZSonLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19jb21taXRfaG9vaycsXG4gICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfY29tbWl0X2hvb2snLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocCknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCcsICdzdHJpbmcnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCcsICdpbnQnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbXBsZXRlJywgJ2ludCcsICdzdHJpbmc6ZmxleGlibGUnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUnLCAnc3FsaXRlMyonLCAnc3FsaXRlM19jb250ZXh0KiddLFxuXG4gICAgICAgICAgWydzcWxpdGUzX2RhdGFfY291bnQnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGJfZmlsZW5hbWUnLCAnc3RyaW5nJywgJ3NxbGl0ZTMqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9oYW5kbGUnLCAnc3FsaXRlMyonLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9uYW1lJywgJ3N0cmluZycsICdzcWxpdGUzKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGJfc3RhdHVzJywgJ2ludCcsICdzcWxpdGUzKicsICdpbnQnLCAnKicsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19lcnJjb2RlJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19lcnJtc2cnLCAnc3RyaW5nJywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2Vycm9yX29mZnNldCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXJyc3RyJywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19leGVjJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnc3RyaW5nOmZsZXhpYmxlJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwcCknLFxuICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBhTmFtZXM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKHBWb2lkLCBuQ29scywgcENvbFZhbHMsIHBDb2xOYW1lcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFWYWxzID0gd2FzbS5jQXJndlRvSnMobkNvbHMsIHBDb2xWYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFOYW1lcykgYU5hbWVzID0gd2FzbS5jQXJndlRvSnMobkNvbHMsIHBDb2xOYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFWYWxzLCBhTmFtZXMpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXhwYW5kZWRfc3FsJywgJ3N0cmluZycsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcycsICdpbnQnLCAnc3FsaXRlMyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2ZpbGVfY29udHJvbCcsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJ2ludCcsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2ZpbmFsaXplJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2ZyZWUnLCB1bmRlZmluZWQsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2dldF9hdXRvY29tbWl0JywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19nZXRfYXV4ZGF0YScsICcqJywgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2luaXRpYWxpemUnLCB1bmRlZmluZWRdLFxuXG4gICAgICAgICAgWydzcWxpdGUzX2tleXdvcmRfY291bnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2tleXdvcmRfbmFtZScsICdpbnQnLCBbJ2ludCcsICcqKicsICcqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19rZXl3b3JkX2NoZWNrJywgJ2ludCcsIFsnc3RyaW5nJywgJ2ludCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbGlidmVyc2lvbicsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXInLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2xpbWl0JywgJ2ludCcsIFsnc3FsaXRlMyonLCAnaW50JywgJ2ludCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfbWFsbG9jJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX29wZW4nLCAnaW50JywgJ3N0cmluZycsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX29wZW5fdjInLCAnaW50JywgJ3N0cmluZycsICcqJywgJ2ludCcsICdzdHJpbmcnXSxcblxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4UHJvZ3Jlc3NIYW5kbGVyJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHApJyxcbiAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICdjb250ZXh0JyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3JlYWxsb2MnLCAnKicsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXNldCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcmVzdWx0X2Jsb2InLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2RvdWJsZScsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConLCAnZjY0J10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9pbnQnLCB1bmRlZmluZWQsICdzcWxpdGUzX2NvbnRleHQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfbnVsbCcsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19yZXN1bHRfcG9pbnRlcicsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnc3RyaW5nOnN0YXRpYycsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnLCB1bmRlZmluZWQsICdzcWxpdGUzX3ZhbHVlKicsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19yZXN1bHRfdGV4dCcsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYicsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3FsaXRlM19zZXRfYXV0aG9yaXplcjo6eEF1dGgnLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGknICsgJ3Nzc3MpJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAocFYsIGlDb2RlLCBzMCwgczEsIHMyLCBzMykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczAgJiYgd2FzbS5jc3RyVG9KcyhzMCk7XG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBzMSAmJiB3YXNtLmNzdHJUb0pzKHMxKTtcbiAgICAgICAgICAgICAgICAgICAgICBzMiA9IHMyICYmIHdhc20uY3N0clRvSnMoczIpO1xuICAgICAgICAgICAgICAgICAgICAgIHMzID0gczMgJiYgd2FzbS5jc3RyVG9KcyhzMyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHBWLCBpQ29kZSwgczAsIHMxLCBzMiwgczMpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc2V0X2F1eGRhdGEnLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneERlc3Ryb3lBdXhEYXRhJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KCopJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19zaHV0ZG93bicsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgWydzcWxpdGUzX3NvdXJjZWlkJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19zcWwnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RhdHVzJywgJ2ludCcsICdpbnQnLCAnKicsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdGVwJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0bXRfaXNleHBsYWluJywgJ2ludCcsIFsnc3FsaXRlM19zdG10KiddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RtdF9yZWFkb25seScsICdpbnQnLCBbJ3NxbGl0ZTNfc3RtdConXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3N0bXRfc3RhdHVzJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCcsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RyZ2xvYicsICdpbnQnLCAnc3RyaW5nJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdHJpY21wJywgJ2ludCcsICdzdHJpbmcnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0cmxpa2UnLCAnaW50JywgJ3N0cmluZycsICdzdHJpbmcnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0cm5pY21wJywgJ2ludCcsICdzdHJpbmcnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YScsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM190b3RhbF9jaGFuZ2VzJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3RyYWNlX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3RyYWNlX3YyOjpjYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShpcHBwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM190eG5fc3RhdGUnLCAnaW50JywgWydzcWxpdGUzKicsICdzdHJpbmcnXV0sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX2Jvb2xlYW4nLCAnaW50JywgJ3NxbGl0ZTNfZmlsZW5hbWUnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM191cmlfa2V5JywgJ3N0cmluZycsICdzcWxpdGUzX2ZpbGVuYW1lJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM191cmlfcGFyYW1ldGVyJywgJ3N0cmluZycsICdzcWxpdGUzX2ZpbGVuYW1lJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM191c2VyX2RhdGEnLCAndm9pZConLCAnc3FsaXRlM19jb250ZXh0KiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9ibG9iJywgJyonLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfYnl0ZXMnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2RvdWJsZScsICdmNjQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfZHVwJywgJ3NxbGl0ZTNfdmFsdWUqJywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2ZyZWUnLCB1bmRlZmluZWQsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9mcm9tYmluZCcsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfaW50JywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9ub2NoYW5nZScsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9wb2ludGVyJywgJyonLCAnc3FsaXRlM192YWx1ZSonLCAnc3RyaW5nOnN0YXRpYyddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9zdWJ0eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV90ZXh0JywgJ3N0cmluZycsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV90eXBlJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192ZnNfZmluZCcsICcqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM192ZnNfcmVnaXN0ZXInLCAnaW50JywgJ3NxbGl0ZTNfdmZzKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXInLCAnaW50JywgJ3NxbGl0ZTNfdmZzKiddLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChmYWxzZSAmJiB3YXNtLmNvbXBpbGVPcHRpb25Vc2VkKCdTUUxJVEVfRU5BQkxFX05PUk1BTElaRScpKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFtcbiAgICAgICAgICAgICdzcWxpdGUzX25vcm1hbGl6ZWRfc3FsJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfc3RtdConLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdhc20uZXhwb3J0cy5zcWxpdGUzX2FjdGl2YXRlX3NlZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFxuICAgICAgICAgICAgWydzcWxpdGUzX2tleScsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgICAgWydzcWxpdGUzX2tleV92MicsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJyonLCAnaW50J10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfcmVrZXknLCAnaW50JywgJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM19yZWtleV92MicsICdpbnQnLCAnc3FsaXRlMyonLCAnc3RyaW5nJywgJyonLCAnaW50J10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfYWN0aXZhdGVfc2VlJywgdW5kZWZpbmVkLCAnc3RyaW5nJ10sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQgPSBbXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfaW50NjQnLCAnaW50JywgWydzcWxpdGUzX3N0bXQqJywgJ2ludCcsICdpNjQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX2NoYW5nZXM2NCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5faW50NjQnLCAnaTY0JywgWydzcWxpdGUzX3N0bXQqJywgJ2ludCddXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfbW9kdWxlJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgWydzcWxpdGUzKicsICdzdHJpbmcnLCAnc3FsaXRlM19tb2R1bGUqJywgJyonXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdzcWxpdGUzX21vZHVsZSonLCAnKicsICcqJ10sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGVjbGFyZV92dGFiJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nOmZsZXhpYmxlJ11dLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2Rlc2VyaWFsaXplJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ2k2NCcsXG4gICAgICAgICAgICAnaTY0JyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX2Ryb3BfbW9kdWxlcycsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJyoqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19tYWxsb2M2NCcsICcqJywgJ2k2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19tc2l6ZScsICdpNjQnLCAnKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbicsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdpbnQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KHBwaXBwamopJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndikgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChwLCBkYiwgb3AsIHpEYiwgelRibCwgaUtleTEsIGlLZXkyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgIHAsXG4gICAgICAgICAgICAgICAgICAgICAgZGIsXG4gICAgICAgICAgICAgICAgICAgICAgb3AsXG4gICAgICAgICAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyh6RGIpLFxuICAgICAgICAgICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoelRibCksXG4gICAgICAgICAgICAgICAgICAgICAgaUtleTEsXG4gICAgICAgICAgICAgICAgICAgICAgaUtleTIsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9uZXcnLCAnaW50JywgWydzcWxpdGUzKicsICdpbnQnLCAnKionXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnLCAnaW50JywgWydzcWxpdGUzKicsICdpbnQnLCAnKionXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3JlYWxsb2M2NCcsICcqJywgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9pbnQ2NCcsIHVuZGVmaW5lZCwgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0JywgJ2ludCcsICcqJywgJ2k2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zZXJpYWxpemUnLCAnKicsICdzcWxpdGUzKicsICdzdHJpbmcnLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkJywgdW5kZWZpbmVkLCBbJ3NxbGl0ZTMqJywgJ2k2NCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RhdHVzNjQnLCAnaW50JywgJ2ludCcsICcqJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KGlpcHBqKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAocCwgb3AsIHowLCB6MSwgcm93aWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICAgICAgICBvcCxcbiAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHowKSxcbiAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHoxKSxcbiAgICAgICAgICAgICAgICAgICAgICByb3dpZCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX2ludDY0JywgJ2k2NCcsIFsnc3FsaXRlM19maWxlbmFtZScsICdzdHJpbmcnLCAnaTY0J11dLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9pbnQ2NCcsICdpNjQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nLCAnc3RyaW5nJywgJ3NxbGl0ZTNfaW5kZXhfaW5mbyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfZGlzdGluY3QnLCAnaW50JywgJ3NxbGl0ZTNfaW5kZXhfaW5mbyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdnRhYl9pbicsICdpbnQnLCAnc3FsaXRlM19pbmRleF9pbmZvKicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfaW5fZmlyc3QnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJywgJyoqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfaW5fbmV4dCcsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonLCAnKionXSxcblxuICAgICAgICAgIFsnc3FsaXRlM192dGFiX25vY2hhbmdlJywgJ2ludCcsICdzcWxpdGUzX2NvbnRleHQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlJywgJ2ludCcsICdzcWxpdGUzX2luZGV4X2luZm8qJywgJ2ludCcsICcqKiddLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQgJiYgISF3YXNtLmV4cG9ydHMuc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCkge1xuICAgICAgICAgIGNvbnN0IF9faXBzUHJveHkgPSB7XG4gICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBzKScsXG4gICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gKHAsIHMpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHAsIHdhc20uY3N0clRvSnMocykpIHwgMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQucHVzaChcbiAgICAgICAgICAgIC4uLltcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludCcsICd2b2lkKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlJyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZWdyb3VwKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnLCAnaW50JywgWycqKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludConLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjInLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICAgICAnaW50KicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneENvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICAgICAnaW50KicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ2ludCcsICd2b2lkKicsICdpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dEEnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0QicsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnaW50JywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZScsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2ludmVydCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4T3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcGkpJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfb3AnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnKionLCAnaW50KicsICdpbnQqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X3BrJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJyoqJywgJ2ludConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0JywgJ2ludCcsIFsnKionLCAnaW50JywgJyonXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcHApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInLCAnaW50JywgWycqKicsICdpbnQnLCAnKicsICdpbnQnXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneElucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcHApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fYXR0YWNoJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdzdHJpbmcnXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50KicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jb25maWcnLCAnaW50JywgWydpbnQnLCAndm9pZConXV0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY3JlYXRlJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nJywgJyoqJ11dLFxuXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fZGlmZicsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX3Nlc3Npb24qJywgJ3N0cmluZycsICdzdHJpbmcnLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9lbmFibGUnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCddXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50J11dLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHknLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJ11dLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50JywgJ3ZvaWQqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19zZXNzaW9uKicsICcqJywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlM19zZXNzaW9uKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMud2FzbSA9IFtcbiAgICAgICAgICBbJ3NxbGl0ZTNfd2FzbV9kYl9yZXNldCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfd2FzbV9kYl92ZnMnLCAnc3FsaXRlM192ZnMqJywgJ3NxbGl0ZTMqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfdmZzKicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUnLCAnaW50JywgJ3N0cmluZycsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM193YXNtX3Zmc191bmxpbmsnLCAnaW50JywgJ3NxbGl0ZTNfdmZzKicsICdzdHJpbmcnXSxcbiAgICAgICAgXTtcblxuICAgICAgICBzcWxpdGUzLlN0cnVjdEJpbmRlciA9IGdsb2JhbFRoaXMuSmFjY3dhYnl0KHtcbiAgICAgICAgICBoZWFwOiAwID8gd2FzbS5tZW1vcnkgOiB3YXNtLmhlYXA4dSxcbiAgICAgICAgICBhbGxvYzogd2FzbS5hbGxvYyxcbiAgICAgICAgICBkZWFsbG9jOiB3YXNtLmRlYWxsb2MsXG4gICAgICAgICAgYmlnSW50RW5hYmxlZDogd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgIG1lbWJlclByZWZpeDogJyQnLFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXMuSmFjY3dhYnl0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX3hTdHJpbmcgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3N0cmluZycpO1xuICAgICAgICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcignc3RyaW5nOmZsZXhpYmxlJywgKHYpID0+XG4gICAgICAgICAgICBfX3hTdHJpbmcodXRpbC5mbGV4aWJsZVN0cmluZyh2KSksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcihcbiAgICAgICAgICAgICdzdHJpbmc6c3RhdGljJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKHYpKSByZXR1cm4gdjtcbiAgICAgICAgICAgICAgdiA9ICcnICsgdjtcbiAgICAgICAgICAgICAgbGV0IHJjID0gdGhpc1t2XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjIHx8ICh0aGlzW3ZdID0gd2FzbS5hbGxvY0NTdHJpbmcodikpO1xuICAgICAgICAgICAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBfX3hBcmdQdHIgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJyonKTtcbiAgICAgICAgICBjb25zdCBuaWxUeXBlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzX2ZpbGVuYW1lJywgX194QXJnUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgIF9feEFyZ1B0cixcbiAgICAgICAgICApKCdzcWxpdGUzX3ZhbHVlKicsIF9feEFyZ1B0cikoJ3ZvaWQqJywgX194QXJnUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgICAgICBfX3hBcmdQdHIsXG4gICAgICAgICAgKSgnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCBfX3hBcmdQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgX194QXJnUHRyLFxuICAgICAgICAgICkoJ3NxbGl0ZTNfc3RtdConLCAodikgPT5cbiAgICAgICAgICAgIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIChzcWxpdGUzPy5vbzE/LlN0bXQgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzKicsICh2KSA9PlxuICAgICAgICAgICAgX194QXJnUHRyKFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgKHNxbGl0ZTM/Lm9vMT8uREIgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzX2luZGV4X2luZm8qJywgKHYpID0+XG4gICAgICAgICAgICBfX3hBcmdQdHIoXG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX2luZGV4X2luZm8gfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzX21vZHVsZSonLCAodikgPT5cbiAgICAgICAgICAgIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIChjYXBpLnNxbGl0ZTNfbW9kdWxlIHx8IG5pbFR5cGUpID8gdi5wb2ludGVyIDogdixcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKSgnc3FsaXRlM192ZnMqJywgKHYpID0+IHtcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodikgfHxcbiAgICAgICAgICAgICAgICBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICAgICAgICAnVW5rbm93biBzcWxpdGUzX3ZmcyBuYW1lOicsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX3hBcmdQdHIoXG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX3ZmcyB8fCBuaWxUeXBlKSA/IHYucG9pbnRlciA6IHYsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgX194UmNQdHIgPSB3YXNtLnhXcmFwLnJlc3VsdEFkYXB0ZXIoJyonKTtcbiAgICAgICAgICB3YXNtLnhXcmFwLnJlc3VsdEFkYXB0ZXIoJ3NxbGl0ZTMqJywgX194UmNQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgX194UmNQdHIsXG4gICAgICAgICAgKSgnc3FsaXRlM19zdG10KicsIF9feFJjUHRyKSgnc3FsaXRlM192YWx1ZSonLCBfX3hSY1B0cikoXG4gICAgICAgICAgICAnc3FsaXRlM192ZnMqJyxcbiAgICAgICAgICAgIF9feFJjUHRyLFxuICAgICAgICAgICkoJ3ZvaWQqJywgX194UmNQdHIpO1xuXG4gICAgICAgICAgaWYgKDAgPT09IHdhc20uZXhwb3J0cy5zcWxpdGUzX3N0ZXAubGVuZ3RoKSB7XG4gICAgICAgICAgICB3YXNtLnhXcmFwLmRvQXJnY0NoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICAgICAgICAnRGlzYWJsaW5nIHNxbGl0ZTMud2FzbS54V3JhcC5kb0FyZ2NDaGVjayBkdWUgdG8gZW52aXJvbm1lbnRhbCBxdWlya3MuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBjYXBpW2VbMF1dID0gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIHdhc20uYmluZGluZ1NpZ25hdHVyZXMud2FzbSkge1xuICAgICAgICAgICAgd2FzbVtlWzBdXSA9IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZkk2NERpc2FibGVkID0gZnVuY3Rpb24gKGZuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT5cbiAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICBmbmFtZSArICcoKSBpcyB1bmF2YWlsYWJsZSBkdWUgdG8gbGFjaycsXG4gICAgICAgICAgICAgICAgJ29mIEJpZ0ludCBzdXBwb3J0IGluIHRoaXMgYnVpbGQuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0KSB7XG4gICAgICAgICAgICBjYXBpW2VbMF1dID0gd2FzbS5iaWdJbnRFbmFibGVkXG4gICAgICAgICAgICAgID8gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKVxuICAgICAgICAgICAgICA6IGZJNjREaXNhYmxlZChlWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGUgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcztcblxuICAgICAgICAgIGlmICh3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2RiX2Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBfX2RiX2VyciA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAgICdzcWxpdGUzX3dhc21fZGJfZXJyb3InLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBmdW5jdGlvbiAocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHRDb2RlIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdENvZGUgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRDb2RlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnJyArIHJlc3VsdENvZGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q29kZSA9IHJlc3VsdENvZGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcERiID8gX19kYl9lcnIocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKSA6IHJlc3VsdENvZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvciA9IGZ1bmN0aW9uIChwRGIsIGVyckNvZGUsIG1zZykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfd2FzbV9kYl9lcnJvcigpIGlzIG5vdCBleHBvcnRlZC4nLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyckNvZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjSnNvbiA9IHdhc20ueENhbGwoJ3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24nKTtcbiAgICAgICAgICBpZiAoIWNKc29uKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICBcIk1haW50ZW5hbmNlIHJlcXVpcmVkOiBpbmNyZWFzZSBzcWxpdGUzX3dhc21fZW51bV9qc29uKCknc1wiLFxuICAgICAgICAgICAgICAnc3RhdGljIGJ1ZmZlciBzaXplIScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhc20uY3R5cGUgPSBKU09OLnBhcnNlKHdhc20uY3N0clRvSnMoY0pzb24pKTtcblxuICAgICAgICAgIGNvbnN0IGRlZmluZUdyb3VwcyA9IFtcbiAgICAgICAgICAgICdhY2Nlc3MnLFxuICAgICAgICAgICAgJ2F1dGhvcml6ZXInLFxuICAgICAgICAgICAgJ2Jsb2JGaW5hbGl6ZXJzJyxcbiAgICAgICAgICAgICdjaGFuZ2VzZXQnLFxuICAgICAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICAgICAnZGF0YVR5cGVzJyxcbiAgICAgICAgICAgICdkYkNvbmZpZycsXG4gICAgICAgICAgICAnZGJTdGF0dXMnLFxuICAgICAgICAgICAgJ2VuY29kaW5ncycsXG4gICAgICAgICAgICAnZmNudGwnLFxuICAgICAgICAgICAgJ2Zsb2NrJyxcbiAgICAgICAgICAgICdpb0NhcCcsXG4gICAgICAgICAgICAnbGltaXRzJyxcbiAgICAgICAgICAgICdvcGVuRmxhZ3MnLFxuICAgICAgICAgICAgJ3ByZXBhcmVGbGFncycsXG4gICAgICAgICAgICAncmVzdWx0Q29kZXMnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNTdGF0dXMnLFxuICAgICAgICAgICAgJ3N0bXRTdGF0dXMnLFxuICAgICAgICAgICAgJ3N5bmNGbGFncycsXG4gICAgICAgICAgICAndHJhY2UnLFxuICAgICAgICAgICAgJ3R4blN0YXRlJyxcbiAgICAgICAgICAgICd1ZGZGbGFncycsXG4gICAgICAgICAgICAndmVyc2lvbicsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICBkZWZpbmVHcm91cHMucHVzaCgnc2VyaWFsaXplJywgJ3Nlc3Npb24nLCAndnRhYicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgZGVmaW5lR3JvdXBzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMod2FzbS5jdHlwZVt0XSkpIHtcbiAgICAgICAgICAgICAgY2FwaVtlWzBdXSA9IGVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FzbS5mdW5jdGlvbkVudHJ5KGNhcGkuU1FMSVRFX1dBU01fREVBTExPQykpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdJbnRlcm5hbCBlcnJvcjogY2Fubm90IHJlc29sdmUgZXhwb3J0ZWQgZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAnZW50cnkgU1FMSVRFX1dBU01fREVBTExPQyAoPT0nICsgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DICsgJykuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IF9fcmNNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBbJ3Jlc3VsdENvZGVzJ10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh3YXNtLmN0eXBlW3RdKSkge1xuICAgICAgICAgICAgICBfX3JjTWFwW2VbMV1dID0gZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyID0gKHJjKSA9PiBfX3JjTWFwW3JjXTtcblxuICAgICAgICAgIGNvbnN0IG5vdFRoZXNlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICBXYXNtVGVzdFN0cnVjdDogdHJ1ZSxcblxuICAgICAgICAgICAgc3FsaXRlM19rdnZmc19tZXRob2RzOiAhdXRpbC5pc1VJVGhyZWFkKCksXG5cbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfaW5mbzogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfY29uc3RyYWludDogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfb3JkZXJieTogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICAgIHNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZTogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygd2FzbS5jdHlwZS5zdHJ1Y3RzKSB7XG4gICAgICAgICAgICBpZiAoIW5vdFRoZXNlW3MubmFtZV0pIHtcbiAgICAgICAgICAgICAgY2FwaVtzLm5hbWVdID0gc3FsaXRlMy5TdHJ1Y3RCaW5kZXIocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mbykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfaW5kZXhfY29uc3RyYWludCcsXG4gICAgICAgICAgICAgICdzcWxpdGUzX2luZGV4X29yZGVyYnknLFxuICAgICAgICAgICAgICAnc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlJyxcbiAgICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2luZGV4X2luZm9ba10gPSBjYXBpW2tdO1xuICAgICAgICAgICAgICBkZWxldGUgY2FwaVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM192dGFiX2NvbmZpZyA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAgICdzcWxpdGUzX3dhc21fdnRhYl9jb25maWcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF9fZGJBcmdjTWlzbWF0Y2ggPSAocERiLCBmLCBuKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgZiArICcoKSByZXF1aXJlcyAnICsgbiArICcgYXJndW1lbnQnICsgKDEgPT09IG4gPyAnJyA6ICdzJykgKyAnLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2VyckVuY29kaW5nID0gKHBEYikgPT4ge1xuICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIGNhcGkuU1FMSVRFX0ZPUk1BVCxcbiAgICAgICAgICAgICdTUUxJVEVfVVRGOCBpcyB0aGUgb25seSBzdXBwb3J0ZWQgZW5jb2RpbmcuJyxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYXJnUERiID0gKHBEYikgPT4gd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzKicpKHBEYik7XG4gICAgICAgIGNvbnN0IF9fYXJnU3RyID0gKHN0cikgPT4gKHdhc20uaXNQdHIoc3RyKSA/IHdhc20uY3N0clRvSnMoc3RyKSA6IHN0cik7XG4gICAgICAgIGNvbnN0IF9fZGJDbGVhbnVwTWFwID0gZnVuY3Rpb24gKHBEYiwgbW9kZSkge1xuICAgICAgICAgIHBEYiA9IF9fYXJnUERiKHBEYik7XG4gICAgICAgICAgbGV0IG0gPSB0aGlzLmRiTWFwLmdldChwRGIpO1xuICAgICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgICAgdGhpcy5kYk1hcC5kZWxldGUocERiKTtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW0gJiYgbW9kZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGJNYXAuc2V0KHBEYiwgKG0gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LmJpbmQoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICBkYk1hcDogbmV3IE1hcCgpLFxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZENvbGxhdGlvbiA9IGZ1bmN0aW9uIChwRGIsIG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAxKTtcbiAgICAgICAgICBpZiAoIW0uY29sbGF0aW9uKSBtLmNvbGxhdGlvbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBtLmNvbGxhdGlvbi5hZGQoX19hcmdTdHIobmFtZSkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuX2FkZFVERiA9IGZ1bmN0aW9uIChwRGIsIG5hbWUsIGFyaXR5LCBtYXApIHtcbiAgICAgICAgICBuYW1lID0gX19hcmdTdHIobmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsZXQgdSA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgaWYgKCF1KSBtYXAuc2V0KG5hbWUsICh1ID0gbmV3IFNldCgpKSk7XG4gICAgICAgICAgdS5hZGQoYXJpdHkgPCAwID8gLTEgOiBhcml0eSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkRnVuY3Rpb24gPSBmdW5jdGlvbiAocERiLCBuYW1lLCBhcml0eSkge1xuICAgICAgICAgIGNvbnN0IG0gPSBfX2RiQ2xlYW51cE1hcChwRGIsIDEpO1xuICAgICAgICAgIGlmICghbS51ZGYpIG0udWRmID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2FkZFVERihwRGIsIG5hbWUsIGFyaXR5LCBtLnVkZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyA9IGZ1bmN0aW9uIChwRGIsIG5hbWUsIGFyaXR5KSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgICAgICAgaWYgKCFtLnd1ZGYpIG0ud3VkZiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hZGRVREYocERiLCBuYW1lLCBhcml0eSwgbS53dWRmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfX2RiQ2xlYW51cE1hcC5jbGVhbnVwID0gZnVuY3Rpb24gKHBEYikge1xuICAgICAgICAgIHBEYiA9IF9fYXJnUERiKHBEYik7XG5cbiAgICAgICAgICBjb25zdCBjbG9zZUFyZ3MgPSBbcERiXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfYnVzeV9oYW5kbGVyJyxcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbW1pdF9ob29rJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAgICAgICAnc3FsaXRlM19zZXRfYXV0aG9yaXplcicsXG4gICAgICAgICAgICAnc3FsaXRlM190cmFjZV92MicsXG4gICAgICAgICAgICAnc3FsaXRlM191cGRhdGVfaG9vaycsXG4gICAgICAgICAgXSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IHdhc20uZXhwb3J0c1tuYW1lXTtcbiAgICAgICAgICAgIGNsb3NlQXJncy5sZW5ndGggPSB4Lmxlbmd0aDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNhcGlbbmFtZV0oLi4uY2xvc2VBcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdjbG9zZS10aW1lIGNhbGwgb2YnLFxuICAgICAgICAgICAgICAgIG5hbWUgKyAnKCcsXG4gICAgICAgICAgICAgICAgY2xvc2VBcmdzLFxuICAgICAgICAgICAgICAgICcpIHRocmV3OicsXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMCk7XG4gICAgICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICAgICAgaWYgKG0uY29sbGF0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbS5jb2xsYXRpb24pIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9VVEY4LFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbS5jb2xsYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtYXAgPSBpID8gbS53dWRmIDogbS51ZGY7XG4gICAgICAgICAgICBpZiAoIWZtYXApIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IGlcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblxuICAgICAgICAgICAgICA6IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjI7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZm1hcCkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZVswXSxcbiAgICAgICAgICAgICAgICBhcml0aWVzID0gZVsxXTtcbiAgICAgICAgICAgICAgY29uc3QgZmFyZ3MgPSBbcERiLCBuYW1lLCAwLCBjYXBpLlNRTElURV9VVEY4LCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgaWYgKGkpIGZhcmdzLnB1c2goMCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYXJpdHkgb2YgYXJpdGllcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmYXJnc1syXSA9IGFyaXR5O1xuICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShudWxsLCBmYXJncyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcml0aWVzLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbWFwLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBtLnVkZjtcbiAgICAgICAgICBkZWxldGUgbS53dWRmO1xuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNDbG9zZVYyID0gd2FzbS54V3JhcChcbiAgICAgICAgICAgICdzcWxpdGUzX2Nsb3NlX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNhcGkuc3FsaXRlM19jbG9zZV92MiA9IGZ1bmN0aW9uIChwRGIpIHtcbiAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2Nsb3NlX3YyJywgMSk7XG4gICAgICAgICAgICBpZiAocERiKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuY2xlYW51cChwRGIpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3FsaXRlM0Nsb3NlVjIocERiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhcGkuc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyKSB7XG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzU2Vzc2lvbkRlbGV0ZSA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fZGVsZXRlJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFsnc3FsaXRlM19zZXNzaW9uKiddLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY2FwaS5zcWxpdGUzc2Vzc2lvbl9kZWxldGUgPSBmdW5jdGlvbiAocFNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZScsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwU2Vzc2lvbikge1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcihwU2Vzc2lvbiwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX3NxbGl0ZTNTZXNzaW9uRGVsZXRlKHBTZXNzaW9uKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSAoYXJndiwgYXJnSW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdhcmd2WycgK1xuICAgICAgICAgICAgICBhcmdJbmRleCArXG4gICAgICAgICAgICAgICddOicgK1xuICAgICAgICAgICAgICBhcmd2WzBdICtcbiAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyhhcmd2WzFdKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlQ29sbGF0aW9uVjIgPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneENvbXBhcmUnLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwaXApJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RGVzdHJveScsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIHpOYW1lLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXJnLFxuICAgICAgICAgICAgeENvbXBhcmUsXG4gICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICg2ICE9PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInLCA2KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKDAgPT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FwaS5TUUxJVEVfVVRGOCAhPT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVDb2xsYXRpb25WMihcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgek5hbWUsXG4gICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgcEFyZyxcbiAgICAgICAgICAgICAgICB4Q29tcGFyZSxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHJjICYmIHhDb21wYXJlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRDb2xsYXRpb24ocERiLCB6TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IocERiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICB6TmFtZSxcbiAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgcEFyZyxcbiAgICAgICAgICAgIHhDb21wYXJlLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIDUgPT09IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIHpOYW1lLFxuICAgICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgICBwQXJnLFxuICAgICAgICAgICAgICAgICAgeENvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbicsIDUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29udGV4dEtleSA9IGZ1bmN0aW9uIChhcmd2LCBhcmdJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgYXJndlswXSArXG4gICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgIChhcmd2WzJdIDwgMCA/IC0xIDogYXJndlsyXSkgK1xuICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICBhcmdJbmRleCArXG4gICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoYXJndlsxXSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgX19jZlByb3h5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICB4SW52ZXJzZUFuZFN0ZXA6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwaXApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwQ3R4LCAuLi5jYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzKGFyZ2MsIHBBcmd2KSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4RmluYWxBbmRWYWx1ZToge1xuICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KHApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanMocEN0eCwgY2FsbGJhY2socEN0eCkpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeEZ1bmM6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwaXApJyxcbiAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzKFxuICAgICAgICAgICAgICAgICAgICAgIHBDdHgsXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socEN0eCwgLi4uY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcyhhcmdjLCBwQXJndikpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeERlc3Ryb3k6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgIGNvbnRleHRLZXksXG5cbiAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBWb2lkKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwVm9pZCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VERiB4RGVzdHJveSBtZXRob2QgdGhyZXc6JywgZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNDcmVhdGVGdW5jdGlvbiA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RnVuYycsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhGdW5jLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4U3RlcCcsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneEZpbmFsJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hEZXN0cm95JyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueERlc3Ryb3ksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlV2luZG93RnVuY3Rpb24gPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hTdGVwJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEludmVyc2VBbmRTdGVwLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RmluYWwnLFxuICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54RmluYWxBbmRWYWx1ZSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneFZhbHVlJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hJbnZlcnNlJyxcbiAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEludmVyc2VBbmRTdGVwLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RGVzdHJveScsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhEZXN0cm95LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjInLFxuICAgICAgICAgICAgICAgIGYubGVuZ3RoLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgwID09PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgIGVUZXh0UmVwIHw9IGNhcGkuU1FMSVRFX1VURjg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNhcGkuU1FMSVRFX1VURjggIT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZXJyRW5jb2RpbmcocERiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gX19zcWxpdGUzQ3JlYXRlRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lLFxuICAgICAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgcEFwcCxcbiAgICAgICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAwID09PSByYyAmJlxuICAgICAgICAgICAgICAgICh4RnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICB4U3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICB4RmluYWwgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeERlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkRnVuY3Rpb24ocERiLCBmdW5jTmFtZSwgbkFyZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MigpIHNldHVwIHRocmV3OicsIGUpO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIFVERiB0aHJldzogJyArIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbicsIGYubGVuZ3RoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24gPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICB4VmFsdWUsXG4gICAgICAgICAgICB4SW52ZXJzZSxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2VyckVuY29kaW5nKHBEYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IF9fc3FsaXRlM0NyZWF0ZVdpbmRvd0Z1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgICAgICB4SW52ZXJzZSxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgPT09IHJjICYmXG4gICAgICAgICAgICAgICAgKHhTdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgIHhGaW5hbCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICB4VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeEludmVyc2UgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgeERlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyhwRGIsIGZ1bmNOYW1lLCBuQXJnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbigpIHNldHVwIHRocmV3OicsIGUpO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIFVERiB0aHJldzogJyArIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIudWRmU2V0UmVzdWx0ID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmU2V0UmVzdWx0ID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZlNldFJlc3VsdCA9XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanM7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyLnVkZkNvbnZlcnRBcmdzID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPVxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPVxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzO1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mi51ZGZTZXRFcnJvciA9XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uLnVkZlNldEVycm9yID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZlNldEVycm9yID1cbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcztcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX2ZsZXhpU3RyaW5nID0gKHYsIG4pID0+IHtcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgbiA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgbiA9IHYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgdiA9IHV0aWwudHlwZWRBcnJheVRvU3RyaW5nKFxuICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KHYpIDogdixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICB2ID0gdi5qb2luKCcnKTtcbiAgICAgICAgICAgICAgbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt2LCBuXTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgX19wcmVwYXJlID0ge1xuICAgICAgICAgICAgYmFzaWM6IHdhc20ueFdyYXAoJ3NxbGl0ZTNfcHJlcGFyZV92MycsICdpbnQnLCBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdKSxcblxuICAgICAgICAgICAgZnVsbDogd2FzbS54V3JhcCgnc3FsaXRlM19wcmVwYXJlX3YzJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjMgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgc3FsTGVuLFxuICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgcHBTdG10LFxuICAgICAgICAgICAgcHpUYWlsLFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfcHJlcGFyZV92MycsIGYubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFt4U3FsLCB4U3FsTGVuXSA9IF9fZmxleGlTdHJpbmcoc3FsLCBzcWxMZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgeFNxbCkge1xuICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfX3ByZXBhcmUuYmFzaWMoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICB4U3FsLFxuICAgICAgICAgICAgICAgICAgeFNxbExlbixcbiAgICAgICAgICAgICAgICAgIHByZXBGbGFncyxcbiAgICAgICAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX19wcmVwYXJlLmZ1bGwoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICB4U3FsLFxuICAgICAgICAgICAgICAgICAgeFNxbExlbixcbiAgICAgICAgICAgICAgICAgIHByZXBGbGFncyxcbiAgICAgICAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIFNRTCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX3ByZXBhcmVfdjIvdjMoKS4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHNxbExlbixcbiAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19wcmVwYXJlX3YzKHBEYiwgc3FsLCBzcWxMZW4sIDAsIHBwU3RtdCwgcHpUYWlsKVxuICAgICAgICAgICAgICA6IF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM19wcmVwYXJlX3YyJywgZi5sZW5ndGgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgX19iaW5kVGV4dCA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfYmluZF90ZXh0JywgJ2ludCcsIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBjb25zdCBfX2JpbmRCbG9iID0gd2FzbS54V3JhcCgnc3FsaXRlM19iaW5kX2Jsb2InLCAnaW50JywgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfc3RtdConLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19iaW5kX3RleHQgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcFN0bXQsXG4gICAgICAgICAgICBpQ29sLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIG5UZXh0LFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfYmluZF90ZXh0JyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5pc1B0cih0ZXh0KSB8fCBudWxsID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRUZXh0KHBTdG10LCBpQ29sLCB0ZXh0LCBuVGV4dCwgeERlc3Ryb3kpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IG5ldyBVaW50OEFycmF5KHRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBNZW0pKSB7XG4gICAgICAgICAgICAgIHRleHQgPSBwTWVtLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHAsIG47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSh0ZXh0KTtcbiAgICAgICAgICAgICAgICBuID0gdGV4dC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGV4dCkge1xuICAgICAgICAgICAgICAgIFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgM3JkIGFyZ3VtZW50IHR5cGUgZm9yIHNxbGl0ZTNfYmluZF90ZXh0KCkuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRUZXh0KHBTdG10LCBpQ29sLCBwLCBuLCBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB3YXNtLmRlYWxsb2MocCk7XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBTdG10LFxuICAgICAgICAgICAgaUNvbCxcbiAgICAgICAgICAgIHBNZW0sXG4gICAgICAgICAgICBuTWVtLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfYmluZF9ibG9iJyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5pc1B0cihwTWVtKSB8fCBudWxsID09PSBwTWVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRCbG9iKHBTdG10LCBpQ29sLCBwTWVtLCBuTWVtLCB4RGVzdHJveSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBNZW0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICBwTWVtID0gbmV3IFVpbnQ4QXJyYXkocE1lbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocE1lbSkpIHtcbiAgICAgICAgICAgICAgcE1lbSA9IHBNZW0uam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcCwgbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHBNZW0pKSB7XG4gICAgICAgICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShwTWVtKTtcbiAgICAgICAgICAgICAgICBuID0gbk1lbSA+PSAwID8gbk1lbSA6IHBNZW0uYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBNZW0pIHtcbiAgICAgICAgICAgICAgICBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyhwTWVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2JpbmRfYmxvYigpLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX19iaW5kQmxvYihwU3RtdCwgaUNvbCwgcCwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgd2FzbS5kZWFsbG9jKHApO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNhcGkuc3FsaXRlM19jb25maWcgPSBmdW5jdGlvbiAob3AsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfQ09WRVJJTkdfSU5ERVhfU0NBTjpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUVNU1RBVFVTOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TTUFMTF9NQUxMT0M6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NPUlRFUlJFRl9TSVpFOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TVE1USlJOTF9TUElMTDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfVVJJOlxuICAgICAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2NvbmZpZ19pKG9wLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTE9PS0FTSURFOlxuICAgICAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2NvbmZpZ19paShcbiAgICAgICAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgICAgICAgYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUVNREJfTUFYU0laRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9jb25maWdfaihvcCwgYXJnc1swXSk7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVE1BTExPQzpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUTVVURVg6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVFBDQUNIRTI6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVFBDQUNIRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfSEVBUDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTE9HOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NQUxMT0M6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01NQVBfU0laRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTVVMVElUSFJFQUQ6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01VVEVYOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQUdFQ0FDSEU6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRTI6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUENBQ0hFX0hEUlNaOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QTUFTWjpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU0VSSUFMSVpFRDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU0lOR0xFVEhSRUFEOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TUUxMT0c6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1dJTjMyX0hFQVBTSVpFOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9OT1RGT1VORDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IF9fYXV0b0V4dEZwdHIgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbiAoZlB0cikge1xuICAgICAgICAgICAgaWYgKGZQdHIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBmUHRyID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oJ2kocHBwKScsIGZQdHIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoIHx8ICF3YXNtLmlzUHRyKGZQdHIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9NSVNVU0U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYyA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uKGZQdHIpO1xuICAgICAgICAgICAgaWYgKGZQdHIgIT09IGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICBpZiAoMCA9PT0gcmMpIF9fYXV0b0V4dEZwdHIuYWRkKGZQdHIpO1xuICAgICAgICAgICAgICBlbHNlIHdhc20udW5pbnN0YWxsRnVuY3Rpb24oZlB0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbiAoZlB0cikge1xuICAgICAgICAgICAgaWYgKCFmUHRyIHx8IDEgIT09IGFyZ3VtZW50cy5sZW5ndGggfHwgIXdhc20uaXNQdHIoZlB0cikpIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbihmUHRyKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24oKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnAgb2YgX19hdXRvRXh0RnB0cikgd2FzbS51bmluc3RhbGxGdW5jdGlvbihmcCk7XG4gICAgICAgICAgICBfX2F1dG9FeHRGcHRyLmNsZWFyKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBLdnZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZCgna3Z2ZnMnKTtcbiAgICAgICAgaWYgKHBLdnZmcykge1xuICAgICAgICAgIGlmICh1dGlsLmlzVUlUaHJlYWQoKSkge1xuICAgICAgICAgICAgY29uc3Qga3Z2ZnNNZXRob2RzID0gbmV3IGNhcGkuc3FsaXRlM19rdnZmc19tZXRob2RzKFxuICAgICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHMoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWxldGUgY2FwaS5zcWxpdGUzX2t2dmZzX21ldGhvZHM7XG5cbiAgICAgICAgICAgIGNvbnN0IGt2dmZzTWFrZUtleSA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2ssXG4gICAgICAgICAgICAgIHBzdGFjayA9IHdhc20ucHN0YWNrO1xuXG4gICAgICAgICAgICBjb25zdCBrdnZmc1N0b3JhZ2UgPSAoekNsYXNzKSA9PlxuICAgICAgICAgICAgICAxMTUgPT09IHdhc20ucGVlayh6Q2xhc3MpID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGt2dmZzSW1wbHMgPSB7XG4gICAgICAgICAgICAgIHhSZWFkOiAoekNsYXNzLCB6S2V5LCB6QnVmLCBuQnVmKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIGFzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHpYS2V5ID0ga3Z2ZnNNYWtlS2V5KHpDbGFzcywgektleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXpYS2V5KSByZXR1cm4gLTM7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqS2V5ID0gd2FzbS5jc3RyVG9Kcyh6WEtleSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqViA9IGt2dmZzU3RvcmFnZSh6Q2xhc3MpLmdldEl0ZW0oaktleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWpWKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuViA9IGpWLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGlmIChuQnVmIDw9IDApIHJldHVybiBuVjtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKDEgPT09IG5CdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzbS5wb2tlKHpCdWYsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblY7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCB6ViA9IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKGpWKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuQnVmID4gblYgKyAxKSBuQnVmID0gblYgKyAxO1xuICAgICAgICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5jb3B5V2l0aGluKHpCdWYsIHpWLCB6ViArIG5CdWYgLSAxKTtcbiAgICAgICAgICAgICAgICAgIHdhc20ucG9rZSh6QnVmICsgbkJ1ZiAtIDEsIDApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5CdWYgLSAxO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2t2c3RvcmFnZVJlYWQoKScsIGUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBwc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKGFzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4V3JpdGU6ICh6Q2xhc3MsIHpLZXksIHpEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgelhLZXkgPSBrdnZmc01ha2VLZXkoekNsYXNzLCB6S2V5KTtcbiAgICAgICAgICAgICAgICAgIGlmICghelhLZXkpIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaktleSA9IHdhc20uY3N0clRvSnMoelhLZXkpO1xuICAgICAgICAgICAgICAgICAga3Z2ZnNTdG9yYWdlKHpDbGFzcykuc2V0SXRlbShqS2V5LCB3YXNtLmNzdHJUb0pzKHpEYXRhKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdrdnN0b3JhZ2VXcml0ZSgpJywgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhEZWxldGU6ICh6Q2xhc3MsIHpLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB6WEtleSA9IGt2dmZzTWFrZUtleSh6Q2xhc3MsIHpLZXkpO1xuICAgICAgICAgICAgICAgICAgaWYgKCF6WEtleSkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICBrdnZmc1N0b3JhZ2UoekNsYXNzKS5yZW1vdmVJdGVtKHdhc20uY3N0clRvSnMoelhLZXkpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2t2c3RvcmFnZURlbGV0ZSgpJywgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKGt2dmZzSW1wbHMpKSB7XG4gICAgICAgICAgICAgIGt2dmZzTWV0aG9kc1trdnZmc01ldGhvZHMubWVtYmVyS2V5KGspXSA9IHdhc20uaW5zdGFsbEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIGt2dmZzTWV0aG9kcy5tZW1iZXJTaWduYXR1cmUoayksXG4gICAgICAgICAgICAgICAga3Z2ZnNJbXBsc1trXSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHBLdnZmcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBzcWxpdGUzLnZlcnNpb24gPSB7XG4gICAgICAgICAgbGliVmVyc2lvbjogJzMuNDUuMycsXG4gICAgICAgICAgbGliVmVyc2lvbk51bWJlcjogMzA0NTAwMyxcbiAgICAgICAgICBzb3VyY2VJZDpcbiAgICAgICAgICAgICcyMDI0LTA0LTE1IDEzOjM0OjA1IDg2NTNiNzU4ODcwZTZlZjBjOThkNDZiM2FjZTI3ODQ5MDU0YWY4NWRhODkxZWIxMjFlOWFhYTUzN2YxZTgzNTUnLFxuICAgICAgICAgIGRvd25sb2FkVmVyc2lvbjogMzQ1MDMwMCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9zczMgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBzcWxpdGUzLlNRTGl0ZTNFcnJvciguLi5hcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpLFxuICAgICAgICAgIHdhc20gPSBzcWxpdGUzLndhc20sXG4gICAgICAgICAgdXRpbCA9IHNxbGl0ZTMudXRpbDtcblxuICAgICAgICBjb25zdCBfX3B0ck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICAgICAgY29uc3QgX19zdG10TWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgICBjb25zdCBnZXRPd25PcHRpb24gPSAob3B0cywgcCwgZGZsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9wdHMsIHApO1xuICAgICAgICAgIHJldHVybiBkID8gZC52YWx1ZSA6IGRmbHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY2hlY2tTcWxpdGUzUmMgPSBmdW5jdGlvbiAoZGJQdHIsIHNxbGl0ZVJlc3VsdENvZGUpIHtcbiAgICAgICAgICBpZiAoc3FsaXRlUmVzdWx0Q29kZSkge1xuICAgICAgICAgICAgaWYgKGRiUHRyIGluc3RhbmNlb2YgREIpIGRiUHRyID0gZGJQdHIucG9pbnRlcjtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICBzcWxpdGVSZXN1bHRDb2RlLFxuICAgICAgICAgICAgICAnc3FsaXRlMyByZXN1bHQgY29kZScsXG4gICAgICAgICAgICAgIHNxbGl0ZVJlc3VsdENvZGUgKyAnOicsXG4gICAgICAgICAgICAgIGRiUHRyXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfZXJybXNnKGRiUHRyKVxuICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2VycnN0cihzcWxpdGVSZXN1bHRDb2RlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19kYlRyYWNlVG9Db25zb2xlID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgJ2koaXBwcCknLFxuICAgICAgICAgIGZ1bmN0aW9uICh0LCBjLCBwLCB4KSB7XG4gICAgICAgICAgICBpZiAoY2FwaS5TUUxJVEVfVFJBQ0VfU1RNVCA9PT0gdCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAnU1FMIFRSQUNFICMnICsgKyt0aGlzLmNvdW50ZXIgKyAnIHZpYSBzcWxpdGUzQCcgKyBjICsgJzonLFxuICAgICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoeCksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfS5iaW5kKHsgY291bnRlcjogMCB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBfX3Zmc1Bvc3RPcGVuU3FsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjb25zdCBkYkN0b3JIZWxwZXIgPSBmdW5jdGlvbiBjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoIWN0b3IuX25hbWUydmZzKSB7XG4gICAgICAgICAgICBjdG9yLl9uYW1lMnZmcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBjb25zdCBpc1dvcmtlclRocmVhZCA9XG4gICAgICAgICAgICAgICdmdW5jdGlvbicgPT09IHR5cGVvZiBpbXBvcnRTY3JpcHRzXG4gICAgICAgICAgICAgICAgPyAobikgPT5cbiAgICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICAgJ1RoZSBWRlMgZm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICAgICdpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgbWFpbiB3aW5kb3cgdGhyZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgY3Rvci5fbmFtZTJ2ZnNbJzpsb2NhbFN0b3JhZ2U6J10gPSB7XG4gICAgICAgICAgICAgIHZmczogJ2t2dmZzJyxcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IGlzV29ya2VyVGhyZWFkIHx8ICgoKSA9PiAnbG9jYWwnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdG9yLl9uYW1lMnZmc1snOnNlc3Npb25TdG9yYWdlOiddID0ge1xuICAgICAgICAgICAgICB2ZnM6ICdrdnZmcycsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBpc1dvcmtlclRocmVhZCB8fCAoKCkgPT4gJ3Nlc3Npb24nKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9wdCA9IGN0b3Iubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgICBsZXQgZm4gPSBvcHQuZmlsZW5hbWUsXG4gICAgICAgICAgICB2ZnNOYW1lID0gb3B0LnZmcyxcbiAgICAgICAgICAgIGZsYWdzU3RyID0gb3B0LmZsYWdzO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgnc3RyaW5nJyAhPT0gdHlwZW9mIGZuICYmICdudW1iZXInICE9PSB0eXBlb2YgZm4pIHx8XG4gICAgICAgICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGZsYWdzU3RyIHx8XG4gICAgICAgICAgICAodmZzTmFtZSAmJlxuICAgICAgICAgICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIHZmc05hbWUgJiZcbiAgICAgICAgICAgICAgJ251bWJlcicgIT09IHR5cGVvZiB2ZnNOYW1lKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IoJ0ludmFsaWQgREIgY3RvciBhcmdzJywgb3B0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdG9zczMoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBEQiBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZuSnMgPSAnbnVtYmVyJyA9PT0gdHlwZW9mIGZuID8gd2FzbS5jc3RyVG9KcyhmbikgOiBmbjtcbiAgICAgICAgICBjb25zdCB2ZnNDaGVjayA9IGN0b3IuX25hbWUydmZzW2ZuSnNdO1xuICAgICAgICAgIGlmICh2ZnNDaGVjaykge1xuICAgICAgICAgICAgdmZzTmFtZSA9IHZmc0NoZWNrLnZmcztcbiAgICAgICAgICAgIGZuID0gZm5KcyA9IHZmc0NoZWNrLmZpbGVuYW1lKGZuSnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcERiLFxuICAgICAgICAgICAgb2ZsYWdzID0gMDtcbiAgICAgICAgICBpZiAoZmxhZ3NTdHIuaW5kZXhPZignYycpID49IDApIHtcbiAgICAgICAgICAgIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX0NSRUFURSB8IGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxhZ3NTdHIuaW5kZXhPZigndycpID49IDApIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX1JFQURXUklURTtcbiAgICAgICAgICBpZiAoMCA9PT0gb2ZsYWdzKSBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9SRUFET05MWTtcbiAgICAgICAgICBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9FWFJFU0NPREU7XG4gICAgICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwUHRyID0gd2FzbS5wc3RhY2suYWxsb2NQdHIoKTtcbiAgICAgICAgICAgIGxldCByYyA9IGNhcGkuc3FsaXRlM19vcGVuX3YyKGZuLCBwUHRyLCBvZmxhZ3MsIHZmc05hbWUgfHwgMCk7XG4gICAgICAgICAgICBwRGIgPSB3YXNtLnBlZWtQdHIocFB0cik7XG4gICAgICAgICAgICBjaGVja1NxbGl0ZTNSYyhwRGIsIHJjKTtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMocERiLCAxKTtcbiAgICAgICAgICAgIGlmIChmbGFnc1N0ci5pbmRleE9mKCd0JykgPj0gMCkge1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfdHJhY2VfdjIoXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1RSQUNFX1NUTVQsXG4gICAgICAgICAgICAgICAgX19kYlRyYWNlVG9Db25zb2xlLFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAocERiKSBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gZm5KcztcbiAgICAgICAgICBfX3B0ck1hcC5zZXQodGhpcywgcERiKTtcbiAgICAgICAgICBfX3N0bXRNYXAuc2V0KHRoaXMsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwVmZzID0gY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhwRGIpO1xuICAgICAgICAgICAgaWYgKCFwVmZzKVxuICAgICAgICAgICAgICB0b3NzMygnSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBnZXQgVkZTIGZvciBuZXcgZGIgaGFuZGxlLicpO1xuICAgICAgICAgICAgY29uc3QgcG9zdEluaXRTcWwgPSBfX3Zmc1Bvc3RPcGVuU3FsW3BWZnNdO1xuICAgICAgICAgICAgaWYgKHBvc3RJbml0U3FsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgcG9zdEluaXRTcWwodGhpcywgc3FsaXRlMyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc3RJbml0U3FsKSB7XG4gICAgICAgICAgICAgIGNoZWNrU3FsaXRlM1JjKHBEYiwgY2FwaS5zcWxpdGUzX2V4ZWMocERiLCBwb3N0SW5pdFNxbCwgMCwgMCwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlblNxbCA9IGZ1bmN0aW9uIChwVmZzLCBzcWwpIHtcbiAgICAgICAgICBfX3Zmc1Bvc3RPcGVuU3FsW3BWZnNdID0gc3FsO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGZpbGVuYW1lID0gJzptZW1vcnk6JyxcbiAgICAgICAgICBmbGFncyA9ICdjJyxcbiAgICAgICAgICB2ZnMgPSBudWxsLFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSB7fTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAxID09PSBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gJiZcbiAgICAgICAgICAgICdvYmplY3QnID09PSB0eXBlb2YgYXJndW1lbnRzWzBdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGFyZywgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGFyZy5mbGFncykgYXJnLmZsYWdzID0gJ2MnO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnLnZmcykgYXJnLnZmcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBhcmcuZmlsZW5hbWUpIGFyZy5maWxlbmFtZSA9ICc6bWVtb3J5Oic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgYXJnLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgICAgICBhcmcudmZzID0gdmZzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IERCID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBkYkN0b3JIZWxwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIERCLmRiQ3RvckhlbHBlciA9IGRiQ3RvckhlbHBlcjtcblxuICAgICAgICBjb25zdCBCaW5kVHlwZXMgPSB7XG4gICAgICAgICAgbnVsbDogMSxcbiAgICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgICAgc3RyaW5nOiAzLFxuICAgICAgICAgIGJvb2xlYW46IDQsXG4gICAgICAgICAgYmxvYjogNSxcbiAgICAgICAgfTtcbiAgICAgICAgQmluZFR5cGVzWyd1bmRlZmluZWQnXSA9PSBCaW5kVHlwZXMubnVsbDtcbiAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgIEJpbmRUeXBlcy5iaWdpbnQgPSBCaW5kVHlwZXMubnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgU3RtdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoQmluZFR5cGVzICE9PSBhcmd1bWVudHNbMl0pIHtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICdEbyBub3QgY2FsbCB0aGUgU3RtdCBjb25zdHJ1Y3RvciBkaXJlY3RseS4gVXNlIERCLnByZXBhcmUoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kYiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBfX3B0ck1hcC5zZXQodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICB0aGlzLnBhcmFtZXRlckNvdW50ID0gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50KHRoaXMucG9pbnRlcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtRGJPcGVuID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgaWYgKCFkYi5wb2ludGVyKSB0b3NzMygnREIgaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1Db2xJbmRleCA9IGZ1bmN0aW9uIChzdG10LCBuZHgpIHtcbiAgICAgICAgICBpZiAobmR4ICE9PSAobmR4IHwgMCkgfHwgbmR4IDwgMCB8fCBuZHggPj0gc3RtdC5jb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgdG9zczMoJ0NvbHVtbiBpbmRleCcsIG5keCwgJ2lzIG91dCBvZiByYW5nZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcGFyc2VFeGVjQXJncyA9IGZ1bmN0aW9uIChkYiwgYXJncykge1xuICAgICAgICAgIGNvbnN0IG91dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgb3V0Lm9wdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBhcmdzWzBdIHx8XG4gICAgICAgICAgICAgICAgdXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KGFyZ3NbMF0pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICBvdXQuc3FsID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzWzBdICYmICdvYmplY3QnID09PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBvdXQub3B0LnNxbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgb3V0LnNxbCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50IGNvdW50IGZvciBleGVjKCkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC5zcWwgPSB1dGlsLmZsZXhpYmxlU3RyaW5nKG91dC5zcWwpO1xuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIG91dC5zcWwpIHtcbiAgICAgICAgICAgIHRvc3MzKCdNaXNzaW5nIFNRTCBhcmd1bWVudCBvciB1bnN1cHBvcnRlZCBTUUwgdmFsdWUgdHlwZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3B0ID0gb3V0Lm9wdDtcbiAgICAgICAgICBzd2l0Y2ggKG9wdC5yZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAncmVzdWx0Um93cyc6XG4gICAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBvcHQucmVzdWx0Um93cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzYXZlU3FsJzpcbiAgICAgICAgICAgICAgaWYgKCFvcHQuc2F2ZVNxbCkgb3B0LnNhdmVTcWwgPSBbXTtcbiAgICAgICAgICAgICAgb3V0LnJldHVyblZhbCA9ICgpID0+IG9wdC5zYXZlU3FsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSAndGhpcyc6XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBkYjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByZXR1cm5WYWx1ZSB2YWx1ZTonLCBvcHQucmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdC5jYWxsYmFjayAmJiAhb3B0LnJldHVyblZhbHVlICYmIHVuZGVmaW5lZCAhPT0gb3B0LnJvd01vZGUpIHtcbiAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICBvdXQucmV0dXJuVmFsID0gKCkgPT4gb3B0LnJlc3VsdFJvd3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHQuY2FsbGJhY2sgfHwgb3B0LnJlc3VsdFJvd3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodW5kZWZpbmVkID09PSBvcHQucm93TW9kZSA/ICdhcnJheScgOiBvcHQucm93TW9kZSkge1xuICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10LmdldChbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3N0bXQnOlxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKSkge1xuICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICdleGVjKCk6IGludmFsaWQgcm93TW9kZSBmb3IgYSByZXN1bHRSb3dzIGFycmF5OiBtdXN0JyxcbiAgICAgICAgICAgICAgICAgICAgXCJiZSBvbmUgb2YgJ2FycmF5JywgJ29iamVjdCcsXCIsXG4gICAgICAgICAgICAgICAgICAgICdhIHJlc3VsdCBjb2x1bW4gbnVtYmVyLCBvciBjb2x1bW4gbmFtZSByZWZlcmVuY2UuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIob3B0LnJvd01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICBvdXQuY2JBcmcgPSAoc3RtdCkgPT4gc3RtdC5nZXQob3B0LnJvd01vZGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICdzdHJpbmcnID09PSB0eXBlb2Ygb3B0LnJvd01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIG9wdC5yb3dNb2RlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICckJyA9PT0gb3B0LnJvd01vZGVbMF1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0ICRjb2xOYW1lID0gb3B0LnJvd01vZGUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgb3V0LmNiQXJnID0gKHN0bXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBzdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKVskY29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQgPT09IHJjXG4gICAgICAgICAgICAgICAgICAgICAgPyB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdleGVjKCk6IHVua25vd24gcmVzdWx0IGNvbHVtbjonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAkY29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IHJjO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByb3dNb2RlOicsIG9wdC5yb3dNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEZpcnN0Um93ID0gKGRiLCBzcWwsIGJpbmQsIC4uLmdldEFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG10ID0gZGIucHJlcGFyZShzcWwpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHN0bXQuYmluZChiaW5kKS5zdGVwKClcbiAgICAgICAgICAgICAgPyBzdG10LmdldCguLi5nZXRBcmdzKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN0bXQucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEFsbCA9IChkYiwgc3FsLCBiaW5kLCByb3dNb2RlKSA9PlxuICAgICAgICAgIGRiLmV4ZWMoe1xuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgYmluZCxcbiAgICAgICAgICAgIHJvd01vZGUsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTogJ3Jlc3VsdFJvd3MnLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIERCLmNoZWNrUmMgPSAoZGIsIHJlc3VsdENvZGUpID0+IGNoZWNrU3FsaXRlM1JjKGRiLCByZXN1bHRDb2RlKTtcblxuICAgICAgICBEQi5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgaXNPcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFmZmlybU9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9uY2xvc2UgJiYgdGhpcy5vbmNsb3NlLmJlZm9yZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZS5iZWZvcmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwRGIgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9fc3RtdE1hcC5nZXQodGhpcykpLmZvckVhY2goKGssIHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocyAmJiBzLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHMuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBfX3N0bXRNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSAmJiB0aGlzLm9uY2xvc2UuYWZ0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UuYWZ0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hhbmdlczogZnVuY3Rpb24gKHRvdGFsID0gZmFsc2UsIHNpeHR5Rm91ciA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXI7XG4gICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpeHR5Rm91clxuICAgICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NChwKVxuICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXMocCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc2l4dHlGb3VyXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY2hhbmdlczY0KHApXG4gICAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfY2hhbmdlcyhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJGaWxlbmFtZTogZnVuY3Rpb24gKGRiTmFtZSA9ICdtYWluJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19kYl9maWxlbmFtZShhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlciwgZGJOYW1lKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJOYW1lOiBmdW5jdGlvbiAoZGJOdW1iZXIgPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2RiX25hbWUoYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXIsIGRiTnVtYmVyKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJWZnNOYW1lOiBmdW5jdGlvbiAoZGJOYW1lID0gMCkge1xuICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgY29uc3QgcFZmcyA9IGNhcGkuc3FsaXRlM19qc19kYl92ZnMoXG4gICAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyLFxuICAgICAgICAgICAgICBkYk5hbWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHBWZnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBWZnMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJjID0gd2FzbS5jc3RyVG9Kcyh2LiR6TmFtZSk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcHJlcGFyZTogZnVuY3Rpb24gKHNxbCkge1xuICAgICAgICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgbGV0IHBwU3RtdCwgcFN0bXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcFN0bXQgPSB3YXNtLnBzdGFjay5hbGxvYyg4KTtcbiAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyKHRoaXMucG9pbnRlciwgc3FsLCAtMSwgcHBTdG10LCBudWxsKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcFN0bXQgPSB3YXNtLnBlZWtQdHIocHBTdG10KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwU3RtdCkgdG9zczMoJ0Nhbm5vdCBwcmVwYXJlIGVtcHR5IFNRTC4nKTtcbiAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgIF9fc3RtdE1hcC5nZXQodGhpcylbcFN0bXRdID0gc3RtdDtcbiAgICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBleGVjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXJzZUV4ZWNBcmdzKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIWFyZy5zcWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRvc3MzKCdleGVjKCkgcmVxdWlyZXMgYW4gU1FMIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGFyZy5vcHQ7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9wdC5jYWxsYmFjaztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFJvd3MgPSBBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKVxuICAgICAgICAgICAgICA/IG9wdC5yZXN1bHRSb3dzXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN0bXQ7XG4gICAgICAgICAgICBsZXQgYmluZCA9IG9wdC5iaW5kO1xuICAgICAgICAgICAgbGV0IGV2YWxGaXJzdFJlc3VsdCA9ICEhKFxuICAgICAgICAgICAgICBhcmcuY2JBcmcgfHxcbiAgICAgICAgICAgICAgb3B0LmNvbHVtbk5hbWVzIHx8XG4gICAgICAgICAgICAgIHJlc3VsdFJvd3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICBjb25zdCBzYXZlU3FsID0gQXJyYXkuaXNBcnJheShvcHQuc2F2ZVNxbClcbiAgICAgICAgICAgICAgPyBvcHQuc2F2ZVNxbFxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzVEEgPSB1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkoYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGxldCBzcWxCeXRlTGVuID0gaXNUQVxuICAgICAgICAgICAgICAgID8gYXJnLnNxbC5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgOiB3YXNtLmpzdHJsZW4oYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBwU3RtdCA9IHdhc20uc2NvcGVkQWxsb2MoXG4gICAgICAgICAgICAgICAgMiAqIHdhc20ucHRyU2l6ZW9mICsgKHNxbEJ5dGVMZW4gKyAxKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgcHpUYWlsID0gcHBTdG10ICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGxldCBwU3FsID0gcHpUYWlsICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGNvbnN0IHBTcWxFbmQgPSBwU3FsICsgc3FsQnl0ZUxlbjtcbiAgICAgICAgICAgICAgaWYgKGlzVEEpIHdhc20uaGVhcDgoKS5zZXQoYXJnLnNxbCwgcFNxbCk7XG4gICAgICAgICAgICAgIGVsc2Ugd2FzbS5qc3RyY3B5KGFyZy5zcWwsIHdhc20uaGVhcDgoKSwgcFNxbCwgc3FsQnl0ZUxlbiwgZmFsc2UpO1xuICAgICAgICAgICAgICB3YXNtLnBva2UocFNxbCArIHNxbEJ5dGVMZW4sIDApO1xuICAgICAgICAgICAgICB3aGlsZSAocFNxbCAmJiB3YXNtLnBlZWsocFNxbCwgJ2k4JykpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2VQdHIoW3BwU3RtdCwgcHpUYWlsXSwgMCk7XG4gICAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICBwU3FsLFxuICAgICAgICAgICAgICAgICAgICBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBwcFN0bXQsXG4gICAgICAgICAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwU3RtdCA9IHdhc20ucGVla1B0cihwcFN0bXQpO1xuICAgICAgICAgICAgICAgIHBTcWwgPSB3YXNtLnBlZWtQdHIocHpUYWlsKTtcbiAgICAgICAgICAgICAgICBzcWxCeXRlTGVuID0gcFNxbEVuZCAtIHBTcWw7XG4gICAgICAgICAgICAgICAgaWYgKCFwU3RtdCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHNhdmVTcWwpIHNhdmVTcWwucHVzaChjYXBpLnNxbGl0ZTNfc3FsKHBTdG10KS50cmltKCkpO1xuICAgICAgICAgICAgICAgIHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZCAmJiBzdG10LnBhcmFtZXRlckNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgICAgICAgICAgICBiaW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2YWxGaXJzdFJlc3VsdCAmJiBzdG10LmNvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ290Q29sTmFtZXMgPSBBcnJheS5pc0FycmF5KG9wdC5jb2x1bW5OYW1lcykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgIGV2YWxGaXJzdFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFyZy5jYkFyZyB8fCByZXN1bHRSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBzdG10LnN0ZXAoKTsgc3RtdC5fbG9ja2VkQnlFeGVjID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gZ290Q29sTmFtZXMrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0bXQuZ2V0Q29sdW1uTmFtZXMob3B0LmNvbHVtbk5hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdG10Ll9sb2NrZWRCeUV4ZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGFyZy5jYkFyZyhzdG10KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Um93cykgcmVzdWx0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGZhbHNlID09PSBjYWxsYmFjay5jYWxsKG9wdCwgcm93LCBzdG10KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0bXQuX2xvY2tlZEJ5RXhlYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGdvdENvbE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0bXQuZ2V0Q29sdW1uTmFtZXMob3B0LmNvbHVtbk5hbWVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RtdC5zdGVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0bXQucmVzZXQoKS5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHN0bXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHN0YWNrKTtcbiAgICAgICAgICAgICAgaWYgKHN0bXQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RtdC5fbG9ja2VkQnlFeGVjO1xuICAgICAgICAgICAgICAgIHN0bXQuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZy5yZXR1cm5WYWwoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY3JlYXRlRnVuY3Rpb246IGZ1bmN0aW9uIGYobmFtZSwgeEZ1bmMsIG9wdCkge1xuICAgICAgICAgICAgY29uc3QgaXNGdW5jID0gKGYpID0+IGYgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3B0ID0gbmFtZTtcbiAgICAgICAgICAgICAgICBuYW1lID0gb3B0Lm5hbWU7XG4gICAgICAgICAgICAgICAgeEZ1bmMgPSBvcHQueEZ1bmMgfHwgMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jKHhGdW5jKSkge1xuICAgICAgICAgICAgICAgICAgb3B0ID0geEZ1bmM7XG4gICAgICAgICAgICAgICAgICB4RnVuYyA9IG9wdC54RnVuYyB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHQpIG9wdCA9IHt9O1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgbmFtZSkge1xuICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCBhcmd1bWVudHM6IG1pc3NpbmcgZnVuY3Rpb24gbmFtZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB4U3RlcCA9IG9wdC54U3RlcCB8fCAwO1xuICAgICAgICAgICAgbGV0IHhGaW5hbCA9IG9wdC54RmluYWwgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHhWYWx1ZSA9IG9wdC54VmFsdWUgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHhJbnZlcnNlID0gb3B0LnhJbnZlcnNlIHx8IDA7XG4gICAgICAgICAgICBsZXQgaXNXaW5kb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXNGdW5jKHhGdW5jKSkge1xuICAgICAgICAgICAgICBpc1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jKHhTdGVwKSB8fCBpc0Z1bmMoeEZpbmFsKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKCdBbWJpZ3VvdXMgYXJndW1lbnRzOiBzY2FsYXIgb3IgYWdncmVnYXRlPycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHhTdGVwID0geEZpbmFsID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jKHhTdGVwKSkge1xuICAgICAgICAgICAgICBpZiAoIWlzRnVuYyh4RmluYWwpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgeEZpbmFsKCkgY2FsbGJhY2sgZm9yIGFnZ3JlZ2F0ZSBvciB3aW5kb3cgVURGLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHhGdW5jID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jKHhGaW5hbCkpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgeFN0ZXAoKSBjYWxsYmFjayBmb3IgYWdncmVnYXRlIG9yIHdpbmRvdyBVREYuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b3NzMygnTWlzc2luZyBmdW5jdGlvbi10eXBlIHByb3BlcnRpZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmFsc2UgPT09IGlzV2luZG93KSB7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmMoeFZhbHVlKSB8fCBpc0Z1bmMoeEludmVyc2UpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAneFZhbHVlIGFuZCB4SW52ZXJzZSBhcmUgbm90IHBlcm1pdHRlZCBmb3Igbm9uLXdpbmRvdyBVREZzLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeFZhbHVlKSkge1xuICAgICAgICAgICAgICBpZiAoIWlzRnVuYyh4SW52ZXJzZSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzMygneEludmVyc2UgbXVzdCBiZSBwcm92aWRlZCBpZiB4VmFsdWUgaXMuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXNXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeEludmVyc2UpKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCd4VmFsdWUgbXVzdCBiZSBwcm92aWRlZCBpZiB4SW52ZXJzZSBpcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBBcHAgPSBvcHQucEFwcDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdW5kZWZpbmVkICE9PSBwQXBwICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHBBcHAgJiZcbiAgICAgICAgICAgICAgKCdudW1iZXInICE9PSB0eXBlb2YgcEFwcCB8fCAhdXRpbC5pc0ludDMyKHBBcHApKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIHZhbHVlIGZvciBwQXBwIHByb3BlcnR5LiBNdXN0IGJlIGEgbGVnYWwgV0FTTSBwb2ludGVyIHZhbHVlLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB4RGVzdHJveSA9IG9wdC54RGVzdHJveSB8fCAwO1xuICAgICAgICAgICAgaWYgKHhEZXN0cm95ICYmICFpc0Z1bmMoeERlc3Ryb3kpKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCd4RGVzdHJveSBwcm9wZXJ0eSBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZkZsYWdzID0gMDtcbiAgICAgICAgICAgIGlmIChnZXRPd25PcHRpb24ob3B0LCAnZGV0ZXJtaW5pc3RpYycpKVxuICAgICAgICAgICAgICBmRmxhZ3MgfD0gY2FwaS5TUUxJVEVfREVURVJNSU5JU1RJQztcbiAgICAgICAgICAgIGlmIChnZXRPd25PcHRpb24ob3B0LCAnZGlyZWN0T25seScpKVxuICAgICAgICAgICAgICBmRmxhZ3MgfD0gY2FwaS5TUUxJVEVfRElSRUNUT05MWTtcbiAgICAgICAgICAgIGlmIChnZXRPd25PcHRpb24ob3B0LCAnaW5ub2N1b3VzJykpIGZGbGFncyB8PSBjYXBpLlNRTElURV9JTk5PQ1VPVVM7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgeEFyaXR5ID0geEZ1bmMgfHwgeFN0ZXA7XG4gICAgICAgICAgICBjb25zdCBhcml0eSA9IGdldE93bk9wdGlvbihvcHQsICdhcml0eScpO1xuICAgICAgICAgICAgY29uc3QgYXJpdHlBcmcgPVxuICAgICAgICAgICAgICAnbnVtYmVyJyA9PT0gdHlwZW9mIGFyaXR5XG4gICAgICAgICAgICAgICAgPyBhcml0eVxuICAgICAgICAgICAgICAgIDogeEFyaXR5Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyB4QXJpdHkubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgaWYgKGlzV2luZG93KSB7XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXJpdHlBcmcsXG4gICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfVVRGOCB8IGZGbGFncyxcbiAgICAgICAgICAgICAgICBwQXBwIHx8IDAsXG4gICAgICAgICAgICAgICAgeFN0ZXAsXG4gICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgICAgICB4SW52ZXJzZSxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MihcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhcml0eUFyZyxcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9VVEY4IHwgZkZsYWdzLFxuICAgICAgICAgICAgICAgIHBBcHAgfHwgMCxcbiAgICAgICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEQi5jaGVja1JjKHRoaXMsIHJjKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzZWxlY3RWYWx1ZTogZnVuY3Rpb24gKHNxbCwgYmluZCwgYXNUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIDAsIGFzVHlwZSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdFZhbHVlczogZnVuY3Rpb24gKHNxbCwgYmluZCwgYXNUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBzdG10ID0gdGhpcy5wcmVwYXJlKHNxbCksXG4gICAgICAgICAgICAgIHJjID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdG10LnN0ZXAoKSkgcmMucHVzaChzdG10LmdldCgwLCBhc1R5cGUpKTtcbiAgICAgICAgICAgICAgc3RtdC5yZXNldCgpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzZWxlY3RBcnJheTogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0Rmlyc3RSb3codGhpcywgc3FsLCBiaW5kLCBbXSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdE9iamVjdDogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0Rmlyc3RSb3codGhpcywgc3FsLCBiaW5kLCB7fSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdEFycmF5czogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0QWxsKHRoaXMsIHNxbCwgYmluZCwgJ2FycmF5Jyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdE9iamVjdHM6IGZ1bmN0aW9uIChzcWwsIGJpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NlbGVjdEFsbCh0aGlzLCBzcWwsIGJpbmQsICdvYmplY3QnKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgb3BlblN0YXRlbWVudENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVyID8gT2JqZWN0LmtleXMoX19zdG10TWFwLmdldCh0aGlzKSkubGVuZ3RoIDogMDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgbGV0IG9wZW5lciA9ICdCRUdJTic7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgaWYgKC9bXmEtekEtWl0vLnRlc3QoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgZm9yIEJFR0lOIHF1YWxpZmllci4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3BlbmVyICs9ICcgJyArIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcykuZXhlYyhvcGVuZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgICAgdGhpcy5leGVjKCdDT01NSVQnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLmV4ZWMoJ1JPTExCQUNLJyk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNhdmVwb2ludDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcykuZXhlYygnU0FWRVBPSU5UIG9vMScpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgICAgdGhpcy5leGVjKCdSRUxFQVNFIG9vMScpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhlYygnUk9MTEJBQ0sgdG8gU0FWRVBPSU5UIG9vMTsgUkVMRUFTRSBTQVZFUE9JTlQgb28xJyk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNoZWNrUmM6IGZ1bmN0aW9uIChyZXN1bHRDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tTcWxpdGUzUmModGhpcywgcmVzdWx0Q29kZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1TdG10T3BlbiA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgICAgaWYgKCFzdG10LnBvaW50ZXIpIHRvc3MzKCdTdG10IGhhcyBiZWVuIGNsb3NlZC4nKTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpc1N1cHBvcnRlZEJpbmRUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBsZXQgdCA9IEJpbmRUeXBlc1tudWxsID09PSB2IHx8IHVuZGVmaW5lZCA9PT0gdiA/ICdudWxsJyA6IHR5cGVvZiB2XTtcbiAgICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udWxsOlxuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVtYmVyOlxuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJpZ2ludDpcbiAgICAgICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkgcmV0dXJuIHQ7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHYpID8gQmluZFR5cGVzLmJsb2IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTdXBwb3J0ZWRCaW5kVHlwZSh2KSB8fFxuICAgICAgICAgICAgdG9zczMoJ1Vuc3VwcG9ydGVkIGJpbmQoKSBhcmd1bWVudCB0eXBlOicsIHR5cGVvZiB2KVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtUGFyYW1JbmRleCA9IGZ1bmN0aW9uIChzdG10LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCBuID1cbiAgICAgICAgICAgICdudW1iZXInID09PSB0eXBlb2Yga2V5XG4gICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4KHN0bXQucG9pbnRlciwga2V5KTtcbiAgICAgICAgICBpZiAoMCA9PT0gbiB8fCAhdXRpbC5pc0ludDMyKG4pKSB7XG4gICAgICAgICAgICB0b3NzMygnSW52YWxpZCBiaW5kKCkgcGFyYW1ldGVyIG5hbWU6ICcgKyBrZXkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA8IDEgfHwgbiA+IHN0bXQucGFyYW1ldGVyQ291bnQpXG4gICAgICAgICAgICB0b3NzMygnQmluZCBpbmRleCcsIGtleSwgJ2lzIG91dCBvZiByYW5nZS4nKTtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMgPSBmdW5jdGlvbiAoc3RtdCwgY3VycmVudE9wTmFtZSkge1xuICAgICAgICAgIGlmIChzdG10Ll9sb2NrZWRCeUV4ZWMpIHtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAnT3BlcmF0aW9uIGlzIGlsbGVnYWwgd2hlbiBzdGF0ZW1lbnQgaXMgbG9ja2VkOicsXG4gICAgICAgICAgICAgIGN1cnJlbnRPcE5hbWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaW5kT25lID0gZnVuY3Rpb24gZihzdG10LCBuZHgsIGJpbmRUeXBlLCB2YWwpIHtcbiAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMoYWZmaXJtU3RtdE9wZW4oc3RtdCksICdiaW5kKCknKTtcbiAgICAgICAgICBpZiAoIWYuXykge1xuICAgICAgICAgICAgZi5fdG9vQmlnSW50ID0gKHYpID0+XG4gICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICdCaWdJbnQgdmFsdWUgaXMgdG9vIGJpZyB0byBzdG9yZSB3aXRob3V0IHByZWNpc2lvbiBsb3NzOicsXG4gICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGYuXyA9IHtcbiAgICAgICAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoc3RtdCwgbmR4LCB2YWwsIGFzQmxvYikge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwU3RyLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IGFzQmxvYlxuICAgICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iXG4gICAgICAgICAgICAgICAgICA6IGNhcGkuc3FsaXRlM19iaW5kX3RleHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoc3RtdC5wb2ludGVyLCBuZHgsIHBTdHIsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZSh2YWwpO1xuICAgICAgICAgIG5keCA9IGFmZmlybVBhcmFtSW5kZXgoc3RtdCwgbmR4KTtcbiAgICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICBudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwgPyBCaW5kVHlwZXMubnVsbCA6IGJpbmRUeXBlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udWxsOlxuICAgICAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX251bGwoc3RtdC5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLnN0cmluZzpcbiAgICAgICAgICAgICAgcmMgPSBmLl8uc3RyaW5nKHN0bXQsIG5keCwgdmFsLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVtYmVyOiB7XG4gICAgICAgICAgICAgIGxldCBtO1xuICAgICAgICAgICAgICBpZiAodXRpbC5pc0ludDMyKHZhbCkpIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQ7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCdiaWdpbnQnID09PSB0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmJpZ0ludEZpdHM2NCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBmLl90b29CaWdJbnQodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2ludDY0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5iaWdJbnRGaXRzRG91YmxlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2RvdWJsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZi5fdG9vQmlnSW50KHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICAgICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50NjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9kb3VibGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJjID0gbShzdG10LnBvaW50ZXIsIG5keCwgdmFsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5ib29sZWFuOlxuICAgICAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX2ludChzdG10LnBvaW50ZXIsIG5keCwgdmFsID8gMSA6IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJsb2I6IHtcbiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmMgPSBmLl8uc3RyaW5nKHN0bXQsIG5keCwgdmFsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBVaW50OEFycmF5KHZhbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgJ0JpbmRpbmcgYSB2YWx1ZSBhcyBhIGJsb2IgcmVxdWlyZXMnLFxuICAgICAgICAgICAgICAgICAgJ3RoYXQgaXQgYmUgYSBzdHJpbmcsIFVpbnQ4QXJyYXksIEludDhBcnJheSwgb3IgQXJyYXlCdWZmZXIuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHBCbG9iID0gd2FzbS5hbGxvYyh2YWwuYnl0ZUxlbmd0aCB8fCAxKTtcbiAgICAgICAgICAgICAgd2FzbS5oZWFwOCgpLnNldCh2YWwuYnl0ZUxlbmd0aCA/IHZhbCA6IFswXSwgcEJsb2IpO1xuICAgICAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX2Jsb2IoXG4gICAgICAgICAgICAgICAgc3RtdC5wb2ludGVyLFxuICAgICAgICAgICAgICAgIG5keCxcbiAgICAgICAgICAgICAgICBwQmxvYixcbiAgICAgICAgICAgICAgICB2YWwuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybignVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6JywgdmFsKTtcbiAgICAgICAgICAgICAgdG9zczMoJ1Vuc3VwcG9ydGVkIGJpbmQoKSBhcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyYykgREIuY2hlY2tSYyhzdG10LmRiLnBvaW50ZXIsIHJjKTtcbiAgICAgICAgICBzdG10Ll9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfTtcblxuICAgICAgICBTdG10LnByb3RvdHlwZSA9IHtcbiAgICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlcikge1xuICAgICAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWModGhpcywgJ2ZpbmFsaXplKCknKTtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfZmluYWxpemUodGhpcy5wb2ludGVyKTtcbiAgICAgICAgICAgICAgZGVsZXRlIF9fc3RtdE1hcC5nZXQodGhpcy5kYilbdGhpcy5wb2ludGVyXTtcbiAgICAgICAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbWF5R2V0O1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJhbWV0ZXJDb3VudDtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvY2tlZEJ5RXhlYztcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGI7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2xlYXJCaW5kaW5nczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKGFmZmlybVN0bXRPcGVuKHRoaXMpLCAnY2xlYXJCaW5kaW5ncygpJyk7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY2xlYXJfYmluZGluZ3ModGhpcy5wb2ludGVyKTtcbiAgICAgICAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoYWxzb0NsZWFyQmluZHMpIHtcbiAgICAgICAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyh0aGlzLCAncmVzZXQoKScpO1xuICAgICAgICAgICAgaWYgKGFsc29DbGVhckJpbmRzKSB0aGlzLmNsZWFyQmluZGluZ3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX3Jlc2V0KGFmZmlybVN0bXRPcGVuKHRoaXMpLnBvaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBjaGVja1NxbGl0ZTNSYyh0aGlzLmRiLCByYyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWZmaXJtU3RtdE9wZW4odGhpcyk7XG4gICAgICAgICAgICBsZXQgbmR4LCBhcmc7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5keCA9IDE7XG4gICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbmR4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCBiaW5kKCkgYXJndW1lbnRzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wYXJhbWV0ZXJDb3VudCkge1xuICAgICAgICAgICAgICB0b3NzMygnVGhpcyBzdGF0ZW1lbnQgaGFzIG5vIGJpbmRhYmxlIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBCaW5kVHlwZXMubnVsbCwgYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAnV2hlbiBiaW5kaW5nIGFuIGFycmF5LCBhbiBpbmRleCBhcmd1bWVudCBpcyBub3QgcGVybWl0dGVkLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmcuZm9yRWFjaCgodiwgaSkgPT5cbiAgICAgICAgICAgICAgICBiaW5kT25lKHRoaXMsIGkgKyAxLCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZSh2KSwgdiksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICBhcmcgPSBuZXcgVWludDhBcnJheShhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgYXJnICYmICF1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICdXaGVuIGJpbmRpbmcgYW4gb2JqZWN0LCBhbiBpbmRleCBhcmd1bWVudCBpcyBub3QgcGVybWl0dGVkLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goKGspID0+XG4gICAgICAgICAgICAgICAgYmluZE9uZSh0aGlzLCBrLCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmdba10pLCBhcmdba10pLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBiaW5kT25lKHRoaXMsIG5keCwgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUoYXJnKSwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvc3MzKCdTaG91bGQgbm90IHJlYWNoIHRoaXMgcG9pbnQuJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGJpbmRBc0Jsb2I6IGZ1bmN0aW9uIChuZHgsIGFyZykge1xuICAgICAgICAgICAgYWZmaXJtU3RtdE9wZW4odGhpcyk7XG4gICAgICAgICAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmcgPSBuZHg7XG4gICAgICAgICAgICAgIG5keCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ID0gYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUoYXJnKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgQmluZFR5cGVzLnN0cmluZyAhPT0gdCAmJlxuICAgICAgICAgICAgICBCaW5kVHlwZXMuYmxvYiAhPT0gdCAmJlxuICAgICAgICAgICAgICBCaW5kVHlwZXMubnVsbCAhPT0gdFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIHZhbHVlIHR5cGUgZm9yIGJpbmRBc0Jsb2IoKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBCaW5kVHlwZXMuYmxvYiwgYXJnKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3RlcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKHRoaXMsICdzdGVwKCknKTtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX3N0ZXAoYWZmaXJtU3RtdE9wZW4odGhpcykucG9pbnRlcik7XG4gICAgICAgICAgICBzd2l0Y2ggKHJjKSB7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRE9ORTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX21heUdldCA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9ST1c6XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9tYXlHZXQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc3RlcCgpIHJjPScsXG4gICAgICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICAgICAgJ1NRTCA9JyxcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19zcWwodGhpcy5wb2ludGVyKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIERCLmNoZWNrUmModGhpcy5kYi5wb2ludGVyLCByYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHN0ZXBSZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdGVwRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKG5keCwgYXNUeXBlKSB7XG4gICAgICAgICAgICBpZiAoIWFmZmlybVN0bXRPcGVuKHRoaXMpLl9tYXlHZXQpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ1N0bXQuc3RlcCgpIGhhcyBub3QgKHJlY2VudGx5KSByZXR1cm5lZCB0cnVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmR4KSkge1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBuZHhbaV0gPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZHg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5keCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG5keCkge1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBuZHhbY2FwaS5zcWxpdGUzX2NvbHVtbl9uYW1lKHRoaXMucG9pbnRlciwgaSldID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWZmaXJtQ29sSW5kZXgodGhpcywgbmR4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gYXNUeXBlXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY29sdW1uX3R5cGUodGhpcy5wb2ludGVyLCBuZHgpXG4gICAgICAgICAgICAgICAgOiBhc1R5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX05VTEw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfSU5URUdFUjoge1xuICAgICAgICAgICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9pbnQ2NCh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHJjID49IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSICYmXG4gICAgICAgICAgICAgICAgICAgIHJjIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihyYykudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19jb2x1bW5fZG91YmxlKHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcmMgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAgICAgICAgICAgICAgICAgICByYyA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICAgJ0ludGVnZXIgaXMgb3V0IG9mIHJhbmdlIGZvciBKUyBpbnRlZ2VyIHJhbmdlOiAnICsgcmMsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmlzSW50MzIocmMpID8gcmMgfCAwIDogcmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRkxPQVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fZG91YmxlKHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9URVhUOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX3RleHQodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0JMT0I6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9ieXRlcyh0aGlzLnBvaW50ZXIsIG5keCksXG4gICAgICAgICAgICAgICAgICBwdHIgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2Jsb2IodGhpcy5wb2ludGVyLCBuZHgpLFxuICAgICAgICAgICAgICAgICAgcmMgPSBuZXcgVWludDhBcnJheShuKTtcblxuICAgICAgICAgICAgICAgIGlmIChuKSByYy5zZXQod2FzbS5oZWFwOHUoKS5zbGljZShwdHIsIHB0ciArIG4pLCAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuICYmIHRoaXMuZGIuX2Jsb2JYZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGIuX2Jsb2JYZmVyLnB1c2gocmMuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICBcIkRvbid0IGtub3cgaG93IHRvIHRyYW5zbGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUgb2YgcmVzdWx0IGNvbHVtbiAjJyArIG5keCArICcuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9zczMoJ05vdCByZWFjaGVkLicpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRJbnQ6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZHgsIGNhcGkuU1FMSVRFX0lOVEVHRVIpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRGbG9hdDogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfRkxPQVQpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRTdHJpbmc6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZHgsIGNhcGkuU1FMSVRFX1RFWFQpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRCbG9iOiBmdW5jdGlvbiAobmR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobmR4LCBjYXBpLlNRTElURV9CTE9CKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0SlNPTjogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfU1RSSU5HKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09PSBzID8gcyA6IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldENvbHVtbk5hbWU6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUoXG4gICAgICAgICAgICAgIGFmZmlybUNvbEluZGV4KGFmZmlybVN0bXRPcGVuKHRoaXMpLCBuZHgpLnBvaW50ZXIsXG4gICAgICAgICAgICAgIG5keCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldENvbHVtbk5hbWVzOiBmdW5jdGlvbiAodGd0ID0gW10pIHtcbiAgICAgICAgICAgIGFmZmlybUNvbEluZGV4KGFmZmlybVN0bXRPcGVuKHRoaXMpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgdGd0LnB1c2goY2FwaS5zcWxpdGUzX2NvbHVtbl9uYW1lKHRoaXMucG9pbnRlciwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRndDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0UGFyYW1JbmRleDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1TdG10T3Blbih0aGlzKS5wYXJhbWV0ZXJDb3VudFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCh0aGlzLnBvaW50ZXIsIG5hbWUpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHByb3AgPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX3B0ck1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiAoKSA9PiB0b3NzMygnVGhlIHBvaW50ZXIgcHJvcGVydHkgaXMgcmVhZC1vbmx5LicpLFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0bXQucHJvdG90eXBlLCAncG9pbnRlcicsIHByb3ApO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEQi5wcm90b3R5cGUsICdwb2ludGVyJywgcHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RtdC5wcm90b3R5cGUsICdjb2x1bW5Db3VudCcsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX2NvdW50KHRoaXMucG9pbnRlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICgpID0+IHRvc3MzKCdUaGUgY29sdW1uQ291bnQgcHJvcGVydHkgaXMgcmVhZC1vbmx5LicpLFxuICAgICAgICB9KTtcblxuICAgICAgICBzcWxpdGUzLm9vMSA9IHtcbiAgICAgICAgICBEQixcbiAgICAgICAgICBTdG10LFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1dGlsLmlzVUlUaHJlYWQoKSkge1xuICAgICAgICAgIHNxbGl0ZTMub28xLkpzU3RvcmFnZURiID0gZnVuY3Rpb24gKHN0b3JhZ2VOYW1lID0gJ3Nlc3Npb24nKSB7XG4gICAgICAgICAgICBpZiAoJ3Nlc3Npb24nICE9PSBzdG9yYWdlTmFtZSAmJiAnbG9jYWwnICE9PSBzdG9yYWdlTmFtZSkge1xuICAgICAgICAgICAgICB0b3NzMyhcIkpzU3RvcmFnZURiIGRiIG5hbWUgbXVzdCBiZSBvbmUgb2YgJ3Nlc3Npb24nIG9yICdsb2NhbCcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGJDdG9ySGVscGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICBmaWxlbmFtZTogc3RvcmFnZU5hbWUsXG4gICAgICAgICAgICAgIGZsYWdzOiAnYycsXG4gICAgICAgICAgICAgIHZmczogJ2t2dmZzJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgamRiID0gc3FsaXRlMy5vbzEuSnNTdG9yYWdlRGI7XG4gICAgICAgICAgamRiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoREIucHJvdG90eXBlKTtcblxuICAgICAgICAgIGpkYi5jbGVhclN0b3JhZ2UgPSBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfY2xlYXI7XG5cbiAgICAgICAgICBqZGIucHJvdG90eXBlLmNsZWFyU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqZGIuY2xlYXJTdG9yYWdlKGFmZmlybURiT3Blbih0aGlzKS5maWxlbmFtZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGpkYi5zdG9yYWdlU2l6ZSA9IGNhcGkuc3FsaXRlM19qc19rdnZmc19zaXplO1xuXG4gICAgICAgICAgamRiLnByb3RvdHlwZS5zdG9yYWdlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqZGIuc3RvcmFnZVNpemUoYWZmaXJtRGJPcGVuKHRoaXMpLmZpbGVuYW1lKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChzcWxpdGUzKSB7XG4gICAgICAgIHNxbGl0ZTMuaW5pdFdvcmtlcjFBUEkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghKGdsb2JhbFRoaXMuV29ya2VyR2xvYmFsU2NvcGUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRvc3MoJ2luaXRXb3JrZXIxQVBJKCkgbXVzdCBiZSBydW4gZnJvbSBhIFdvcmtlciB0aHJlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNxbGl0ZTMgPSB0aGlzLnNxbGl0ZTMgfHwgdG9zcygnTWlzc2luZyB0aGlzLnNxbGl0ZTMgb2JqZWN0LicpO1xuICAgICAgICAgIGNvbnN0IERCID0gc3FsaXRlMy5vbzEuREI7XG5cbiAgICAgICAgICBjb25zdCBnZXREYklkID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSB3U3RhdGUuaWRNYXAuZ2V0KGRiKTtcbiAgICAgICAgICAgIGlmIChpZCkgcmV0dXJuIGlkO1xuICAgICAgICAgICAgaWQgPSAnZGIjJyArICsrd1N0YXRlLmlkU2VxICsgJ0AnICsgZGIucG9pbnRlcjtcblxuICAgICAgICAgICAgd1N0YXRlLmlkTWFwLnNldChkYiwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCB3U3RhdGUgPSB7XG4gICAgICAgICAgICBkYkxpc3Q6IFtdLFxuXG4gICAgICAgICAgICBpZFNlcTogMCxcblxuICAgICAgICAgICAgaWRNYXA6IG5ldyBXZWFrTWFwKCksXG5cbiAgICAgICAgICAgIHhmZXI6IFtdLFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IG5ldyBEQihvcHQpO1xuICAgICAgICAgICAgICB0aGlzLmRic1tnZXREYklkKGRiKV0gPSBkYjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpIDwgMCkgdGhpcy5kYkxpc3QucHVzaChkYik7XG4gICAgICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKGRiLCBhbHNvVW5saW5rKSB7XG4gICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRic1tnZXREYklkKGRiKV07XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwVmZzID0gc3FsaXRlMy53YXNtLnNxbGl0ZTNfd2FzbV9kYl92ZnMoZGIucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZE5keCA9IHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpO1xuICAgICAgICAgICAgICAgIGlmIChkZE5keCA+PSAwKSB0aGlzLmRiTGlzdC5zcGxpY2UoZGROZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhbHNvVW5saW5rICYmIGZpbGVuYW1lICYmIHBWZnMpIHtcbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMud2FzbS5zcWxpdGUzX3dhc21fdmZzX3VubGluayhwVmZzLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAobXNnLCB4ZmVyTGlzdCkge1xuICAgICAgICAgICAgICBpZiAoeGZlckxpc3QgJiYgeGZlckxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZShtc2csIEFycmF5LmZyb20oeGZlckxpc3QpKTtcbiAgICAgICAgICAgICAgICB4ZmVyTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAgICAgICBnZXREYjogZnVuY3Rpb24gKGlkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuZGJzW2lkXSB8fFxuICAgICAgICAgICAgICAgIChyZXF1aXJlID8gdG9zcygnVW5rbm93biAob3IgY2xvc2VkKSBEQiBJRDonLCBpZCkgOiB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBhZmZpcm1EYk9wZW4gPSBmdW5jdGlvbiAoZGIgPSB3U3RhdGUuZGJMaXN0WzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gZGIgJiYgZGIucG9pbnRlciA/IGRiIDogdG9zcygnREIgaXMgbm90IG9wZW5lZC4nKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZ2V0TXNnRGIgPSBmdW5jdGlvbiAobXNnRGF0YSwgYWZmaXJtRXhpc3RzID0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgZGIgPSB3U3RhdGUuZ2V0RGIobXNnRGF0YS5kYklkLCBmYWxzZSkgfHwgd1N0YXRlLmRiTGlzdFswXTtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1FeGlzdHMgPyBhZmZpcm1EYk9wZW4oZGIpIDogZGI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGdldERlZmF1bHREYklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdTdGF0ZS5kYkxpc3RbMF0gJiYgZ2V0RGJJZCh3U3RhdGUuZGJMaXN0WzBdKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZ3Vlc3NWZnMgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAvXmZpbGU6LisodmZzPShcXHcrKSkvLmV4ZWMoZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX3Zmc19maW5kKG0gPyBtWzJdIDogMCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGlzU3BlY2lhbERiRmlsZW5hbWUgPSAobikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICcnID09PSBuIHx8ICc6JyA9PT0gblswXTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3Qgd01zZ0hhbmRsZXIgPSB7XG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2FyZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBldi5hcmdzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGlmIChhcmdzLnNpbXVsYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdUaHJvd2luZyBiZWNhdXNlIG9mIHNpbXVsYXRlRXJyb3IgZmxhZy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGxldCBieXRlQXJyYXksIHBWZnM7XG4gICAgICAgICAgICAgIG9hcmdzLnZmcyA9IGFyZ3MudmZzO1xuICAgICAgICAgICAgICBpZiAoaXNTcGVjaWFsRGJGaWxlbmFtZShhcmdzLmZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9hcmdzLmZpbGVuYW1lID0gYXJncy5maWxlbmFtZSB8fCAnJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYXJncy5maWxlbmFtZSA9IGFyZ3MuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5ID0gYXJncy5ieXRlQXJyYXk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVBcnJheSkgcFZmcyA9IGd1ZXNzVmZzKGFyZ3MuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwVmZzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBNZW07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHBNZW0gPSBzcWxpdGUzLndhc20uYWxsb2NGcm9tVHlwZWRBcnJheShieXRlQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBzcWxpdGUzLndhc20uc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZShcbiAgICAgICAgICAgICAgICAgICAgcFZmcyxcbiAgICAgICAgICAgICAgICAgICAgb2FyZ3MuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBNZW0sXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyYykgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhyYyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNxbGl0ZTMuU1FMaXRlM0Vycm9yKFxuICAgICAgICAgICAgICAgICAgICBlLm5hbWUgKyAnIGNyZWF0aW5nICcgKyBhcmdzLmZpbGVuYW1lICsgJzogJyArIGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBNZW0pIHNxbGl0ZTMud2FzbS5kZWFsbG9jKHBNZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkYiA9IHdTdGF0ZS5vcGVuKG9hcmdzKTtcbiAgICAgICAgICAgICAgcmMuZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgICAgICAgICAgcmMucGVyc2lzdGVudCA9ICEhc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfZGJfdXNlc192ZnMoXG4gICAgICAgICAgICAgICAgZGIucG9pbnRlcixcbiAgICAgICAgICAgICAgICAnb3BmcycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJjLmRiSWQgPSBnZXREYklkKGRiKTtcbiAgICAgICAgICAgICAgcmMudmZzID0gZGIuZGJWZnNOYW1lKCk7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldiwgZmFsc2UpO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZGIgJiYgZGIuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvVW5saW5rID1cbiAgICAgICAgICAgICAgICAgIGV2LmFyZ3MgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICAgID8gISFldi5hcmdzLnVubGlua1xuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdTdGF0ZS5jbG9zZShkYiwgZG9VbmxpbmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCByYyA9XG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICA/IHsgc3FsOiBldi5hcmdzIH1cbiAgICAgICAgICAgICAgICAgIDogZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBpZiAoJ3N0bXQnID09PSByYy5yb3dNb2RlKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCByb3dNb2RlIGZvciAnZXhlYyc6IHN0bXQgbW9kZVwiLFxuICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IHdvcmsgaW4gdGhlIFdvcmtlciBBUEkuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyYy5zcWwpIHtcbiAgICAgICAgICAgICAgICB0b3NzKFwiJ2V4ZWMnIHJlcXVpcmVzIGlucHV0IFNRTC5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldik7XG4gICAgICAgICAgICAgIGlmIChyYy5jYWxsYmFjayB8fCBBcnJheS5pc0FycmF5KHJjLnJlc3VsdFJvd3MpKSB7XG4gICAgICAgICAgICAgICAgZGIuX2Jsb2JYZmVyID0gd1N0YXRlLnhmZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdGhlQ2FsbGJhY2sgPSByYy5jYWxsYmFjaztcbiAgICAgICAgICAgICAgbGV0IHJvd051bWJlciA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGhhZENvbE5hbWVzID0gISFyYy5jb2x1bW5OYW1lcztcbiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhZENvbE5hbWVzKSByYy5jb2x1bW5OYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSBmdW5jdGlvbiAocm93LCBzdG10KSB7XG4gICAgICAgICAgICAgICAgICB3U3RhdGUucG9zdChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoZUNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzOiByYy5jb2x1bW5OYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6ICsrcm93TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3U3RhdGUueGZlcixcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZUNvdW50ID0gISFyYy5jb3VudENoYW5nZXNcbiAgICAgICAgICAgICAgICAgID8gZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKVxuICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGIuZXhlYyhyYyk7XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gY2hhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgIHJjLmNoYW5nZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKSAtIGNoYW5nZUNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSB0aGVDYWxsYmFjaztcblxuICAgICAgICAgICAgICAgICAgd1N0YXRlLnBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGVDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZXM6IHJjLmNvbHVtbk5hbWVzLFxuICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYi5fYmxvYlhmZXI7XG4gICAgICAgICAgICAgICAgaWYgKHJjLmNhbGxiYWNrKSByYy5jYWxsYmFjayA9IHRoZUNhbGxiYWNrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdjb25maWctZ2V0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgc3JjID0gc3FsaXRlMy5jb25maWc7XG4gICAgICAgICAgICAgIFsnYmlnSW50RW5hYmxlZCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGspKSByY1trXSA9IHNyY1trXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJjLnZlcnNpb24gPSBzcWxpdGUzLnZlcnNpb247XG4gICAgICAgICAgICAgIHJjLnZmc0xpc3QgPSBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc192ZnNfbGlzdCgpO1xuICAgICAgICAgICAgICByYy5vcGZzRW5hYmxlZCA9ICEhc3FsaXRlMy5vcGZzO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBleHBvcnQ6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IGdldE1zZ0RiKGV2KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5OiBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19kYl9leHBvcnQoZGIucG9pbnRlciksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGRiLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG1pbWV0eXBlOiAnYXBwbGljYXRpb24veC1zcWxpdGUzJyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgd1N0YXRlLnhmZXIucHVzaChyZXNwb25zZS5ieXRlQXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9zczogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1Rlc3Rpbmcgd29ya2VyIGV4Y2VwdGlvbicpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ29wZnMtdHJlZSc6IGFzeW5jIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBpZiAoIXNxbGl0ZTMub3BmcykgdG9zcygnT1BGUyBzdXBwb3J0IGlzIHVuYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNxbGl0ZTMub3Bmcy50cmVlTGlzdCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGFzeW5jIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgZXYgPSBldi5kYXRhO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCxcbiAgICAgICAgICAgICAgZGJJZCA9IGV2LmRiSWQsXG4gICAgICAgICAgICAgIGV2VHlwZSA9IGV2LnR5cGU7XG4gICAgICAgICAgICBjb25zdCBhcnJpdmFsVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdNc2dIYW5kbGVyLmhhc093blByb3BlcnR5KGV2VHlwZSkgJiZcbiAgICAgICAgICAgICAgICB3TXNnSGFuZGxlcltldlR5cGVdIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgd01zZ0hhbmRsZXJbZXZUeXBlXShldik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9zcygnVW5rbm93biBkYiB3b3JrZXIgbWVzc2FnZSB0eXBlOicsIGV2LnR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgZXZUeXBlID0gJ2Vycm9yJztcbiAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogZXYudHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBlcnJvckNsYXNzOiBlcnIubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogZXYsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhY2sgPVxuICAgICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBlcnIuc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgPyBlcnIuc3RhY2suc3BsaXQoL1xcblxccyovKVxuICAgICAgICAgICAgICAgICAgICA6IGVyci5zdGFjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoMClcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICAgICAgICAgICAgJ1dvcmtlciBpcyBwcm9wYWdhdGluZyBhbiBleGNlcHRpb24gdG8gbWFpbiB0aHJlYWQuJyxcbiAgICAgICAgICAgICAgICAgICdSZXBvcnRpbmcgaXQgX2hlcmVfIGZvciB0aGUgc3RhY2sgdHJhY2U6JyxcbiAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYklkKSB7XG4gICAgICAgICAgICAgIGRiSWQgPSByZXN1bHQuZGJJZCB8fCBnZXREZWZhdWx0RGJJZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3U3RhdGUucG9zdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2VHlwZSxcbiAgICAgICAgICAgICAgICBkYklkOiBkYklkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogZXYubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHdvcmtlclJlY2VpdmVkVGltZTogYXJyaXZhbFRpbWUsXG4gICAgICAgICAgICAgICAgd29ya2VyUmVzcG9uZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgICAgIGRlcGFydHVyZVRpbWU6IGV2LmRlcGFydHVyZVRpbWUsXG5cbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgd1N0YXRlLnhmZXIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnc3FsaXRlMy1hcGknLFxuICAgICAgICAgICAgcmVzdWx0OiAnd29ya2VyMS1yZWFkeScsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh7IHNxbGl0ZTMgfSk7XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgY29uc3Qgd2FzbSA9IHNxbGl0ZTMud2FzbSxcbiAgICAgICAgICBjYXBpID0gc3FsaXRlMy5jYXBpLFxuICAgICAgICAgIHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gICAgICAgIGNvbnN0IHZmcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgdnRhYiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgU3RydWN0QmluZGVyID0gc3FsaXRlMy5TdHJ1Y3RCaW5kZXI7XG4gICAgICAgIHNxbGl0ZTMudmZzID0gdmZzO1xuICAgICAgICBzcWxpdGUzLnZ0YWIgPSB2dGFiO1xuXG4gICAgICAgIGNvbnN0IHNpaSA9IGNhcGkuc3FsaXRlM19pbmRleF9pbmZvO1xuXG4gICAgICAgIHNpaS5wcm90b3R5cGUubnRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChuLCBhc1B0ciA9IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy4kbkNvbnN0cmFpbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwdHIgPVxuICAgICAgICAgICAgdGhpcy4kYUNvbnN0cmFpbnQgK1xuICAgICAgICAgICAgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludC5zdHJ1Y3RJbmZvLnNpemVvZiAqIG47XG4gICAgICAgICAgcmV0dXJuIGFzUHRyID8gcHRyIDogbmV3IHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQocHRyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaWkucHJvdG90eXBlLm50aENvbnN0cmFpbnRVc2FnZSA9IGZ1bmN0aW9uIChuLCBhc1B0ciA9IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy4kbkNvbnN0cmFpbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwdHIgPVxuICAgICAgICAgICAgdGhpcy4kYUNvbnN0cmFpbnRVc2FnZSArXG4gICAgICAgICAgICBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlLnN0cnVjdEluZm8uc2l6ZW9mICogbjtcbiAgICAgICAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZShwdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpaS5wcm90b3R5cGUubnRoT3JkZXJCeSA9IGZ1bmN0aW9uIChuLCBhc1B0ciA9IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy4kbk9yZGVyQnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwdHIgPVxuICAgICAgICAgICAgdGhpcy4kYU9yZGVyQnkgKyBzaWkuc3FsaXRlM19pbmRleF9vcmRlcmJ5LnN0cnVjdEluZm8uc2l6ZW9mICogbjtcbiAgICAgICAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfb3JkZXJieShwdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgICAgICAgdGd0LFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZnVuYyxcbiAgICAgICAgICBhcHBseUFyZ2NDaGVjayA9IGNhbGxlZS5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrLFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoISh0Z3QgaW5zdGFuY2VvZiBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZSkpIHtcbiAgICAgICAgICAgIHRvc3MoJ1VzYWdlIGVycm9yOiB0YXJnZXQgb2JqZWN0IGlzLW5vdC1hIFN0cnVjdFR5cGUuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIXdhc20uaXNQdHIoZnVuYykpIHtcbiAgICAgICAgICAgIHRvc3MoJ1VzYWdlIGVycnJvcjogZXhwZWN0aW5nIGEgRnVuY3Rpb24gb3IgV0FTTSBwb2ludGVyIHRvIG9uZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAobiwgZikgPT4gY2FsbGVlKHRndCwgbiwgZiwgYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbGxlZS5hcmdjUHJveHkpIHtcbiAgICAgICAgICAgIGNhbGxlZS5hcmdjUHJveHkgPSBmdW5jdGlvbiAodGd0LCBmdW5jTmFtZSwgZnVuYywgc2lnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jLmxlbmd0aCAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0FyZ3VtZW50IG1pc21hdGNoIGZvcicsXG4gICAgICAgICAgICAgICAgICAgIHRndC5zdHJ1Y3RJbmZvLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICc6OicgK1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAnOiBOYXRpdmUgc2lnbmF0dXJlIGlzOicsXG4gICAgICAgICAgICAgICAgICAgIHNpZyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QuZm9yRWFjaCgodiwgbmR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2FzbS51bmluc3RhbGxGdW5jdGlvbih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2lnTiA9IHRndC5tZW1iZXJTaWduYXR1cmUobmFtZSk7XG4gICAgICAgICAgaWYgKHNpZ04ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ01lbWJlcicsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICdkb2VzIG5vdCBoYXZlIGEgZnVuY3Rpb24gcG9pbnRlciBzaWduYXR1cmU6JyxcbiAgICAgICAgICAgICAgc2lnTixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbUtleSA9IHRndC5tZW1iZXJLZXkobmFtZSk7XG4gICAgICAgICAgY29uc3QgZlByb3h5ID1cbiAgICAgICAgICAgIGFwcGx5QXJnY0NoZWNrICYmICF3YXNtLmlzUHRyKGZ1bmMpXG4gICAgICAgICAgICAgID8gY2FsbGVlLmFyZ2NQcm94eSh0Z3QsIG1lbUtleSwgZnVuYywgc2lnTilcbiAgICAgICAgICAgICAgOiBmdW5jO1xuICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGZQcm94eSkpIHtcbiAgICAgICAgICAgIGlmIChmUHJveHkgJiYgIXdhc20uZnVuY3Rpb25FbnRyeShmUHJveHkpKSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1BvaW50ZXInLCBmUHJveHksICdpcyBub3QgYSBXQVNNIGZ1bmN0aW9uIHRhYmxlIGVudHJ5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGd0W21lbUtleV0gPSBmUHJveHk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBGdW5jID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgICAgIGZQcm94eSxcbiAgICAgICAgICAgICAgdGd0Lm1lbWJlclNpZ25hdHVyZShuYW1lLCB0cnVlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0Z3RbbWVtS2V5XSA9IHBGdW5jO1xuICAgICAgICAgICAgaWYgKCF0Z3Qub25kaXNwb3NlIHx8ICF0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QpIHtcbiAgICAgICAgICAgICAgdGd0LmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgICAgICAnb25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgaGFuZGxlcicsXG4gICAgICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRndC5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdC5wdXNoKG1lbUtleSwgcEZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKG4sIGYpID0+IGNhbGxlZSh0Z3QsIG4sIGYsIGFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgaW5zdGFsbE1ldGhvZHMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgc3RydWN0SW5zdGFuY2UsXG4gICAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgICBhcHBseUFyZ2NDaGVjayA9IGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVjayxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobWV0aG9kcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXRob2RzW2tdO1xuICAgICAgICAgICAgY29uc3QgcHJpb3IgPSBzZWVuLmdldChtKTtcbiAgICAgICAgICAgIGlmIChwcmlvcikge1xuICAgICAgICAgICAgICBjb25zdCBta2V5ID0gc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KGspO1xuICAgICAgICAgICAgICBzdHJ1Y3RJbnN0YW5jZVtta2V5XSA9XG4gICAgICAgICAgICAgICAgc3RydWN0SW5zdGFuY2Vbc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KHByaW9yKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kKHN0cnVjdEluc3RhbmNlLCBrLCBtLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgICAgICAgIHNlZW4uc2V0KG0sIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RydWN0SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBmdW5jLFxuICAgICAgICAgIGFwcGx5QXJnY0NoZWNrID0gaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrLFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgbmFtZSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG5hbWVcbiAgICAgICAgICAgID8gaW5zdGFsbE1ldGhvZHModGhpcywgLi4uYXJndW1lbnRzKVxuICAgICAgICAgICAgOiBpbnN0YWxsTWV0aG9kKHRoaXMsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2RzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIG1ldGhvZHMsXG4gICAgICAgICAgYXBwbHlBcmdjQ2hlY2sgPSBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2ssXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBpbnN0YWxsTWV0aG9kcyh0aGlzLCBtZXRob2RzLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3Zmcy5wcm90b3R5cGUucmVnaXN0ZXJWZnMgPSBmdW5jdGlvbiAoYXNEZWZhdWx0ID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2Ygc3FsaXRlMy5jYXBpLnNxbGl0ZTNfdmZzKSkge1xuICAgICAgICAgICAgdG9zcygnRXhwZWN0aW5nIGEgc3FsaXRlM192ZnMtdHlwZSBhcmd1bWVudC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfdmZzX3JlZ2lzdGVyKHRoaXMsIGFzRGVmYXVsdCA/IDEgOiAwKTtcbiAgICAgICAgICBpZiAocmMpIHtcbiAgICAgICAgICAgIHRvc3MoJ3NxbGl0ZTNfdmZzX3JlZ2lzdGVyKCcsIHRoaXMsICcpIGZhaWxlZCB3aXRoIHJjJywgcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5wb2ludGVyICE9PSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodGhpcy4kek5hbWUpKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnQlVHOiBzcWxpdGUzX3Zmc19maW5kKHZmcy4kek5hbWUpIGZhaWxlZCBmb3IganVzdC1pbnN0YWxsZWQgVkZTJyxcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZmcy5pbnN0YWxsVmZzID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgY29uc3QgcHJvcExpc3QgPSBbJ2lvJywgJ3ZmcyddO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHByb3BMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBvID0gb3B0W2tleV07XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kcyhvLnN0cnVjdCwgby5tZXRob2RzLCAhIW8uYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICAgICAgICBpZiAoJ3ZmcycgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghby5zdHJ1Y3QuJHpOYW1lICYmICdzdHJpbmcnID09PSB0eXBlb2Ygby5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBvLnN0cnVjdC5hZGRPbkRpc3Bvc2UoXG4gICAgICAgICAgICAgICAgICAgIChvLnN0cnVjdC4kek5hbWUgPSB3YXNtLmFsbG9jQ1N0cmluZyhvLm5hbWUpKSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG8uc3RydWN0LnJlZ2lzdGVyVmZzKCEhby5hc0RlZmF1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY291bnQpXG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnTWlzdXNlOiBpbnN0YWxsVmZzKCkgb3B0aW9ucyBvYmplY3QgcmVxdWlyZXMgYXQgbGVhc3QnLFxuICAgICAgICAgICAgICAnb25lIG9mOicsXG4gICAgICAgICAgICAgIHByb3BMaXN0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3hXcmFwRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBTdHJ1Y3RUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdHIsIHJlbW92ZU1hcHBpbmcgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHB0ciA9IG5ldyBTdHJ1Y3RUeXBlKCk7XG4gICAgICAgICAgICBpZiAocHRyIGluc3RhbmNlb2YgU3RydWN0VHlwZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldChwdHIucG9pbnRlciwgcHRyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXdhc20uaXNQdHIocHRyKSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHRvJyxcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lICsgJygpJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYyA9IHRoaXMuZ2V0KHB0cik7XG4gICAgICAgICAgICBpZiAocmVtb3ZlTWFwcGluZykgdGhpcy5kZWxldGUocHRyKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9LmJpbmQobmV3IE1hcCgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBTdHJ1Y3RQdHJNYXBwZXIgPSBmdW5jdGlvbiAobmFtZSwgU3RydWN0VHlwZSkge1xuICAgICAgICAgIGNvbnN0IF9feFdyYXAgPSBfX3hXcmFwRmFjdG9yeShuYW1lLCBTdHJ1Y3RUeXBlKTtcblxuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgIFN0cnVjdFR5cGUsXG5cbiAgICAgICAgICAgIGNyZWF0ZTogKHBwT3V0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gX194V3JhcCgpO1xuICAgICAgICAgICAgICB3YXNtLnBva2VQdHIocHBPdXQsIHJjLnBvaW50ZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQ6IChwQ09iaikgPT4gX194V3JhcChwQ09iaiksXG5cbiAgICAgICAgICAgIHVuZ2V0OiAocENPYmopID0+IF9feFdyYXAocENPYmosIHRydWUpLFxuXG4gICAgICAgICAgICBkaXNwb3NlOiAocENPYmopID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IF9feFdyYXAocENPYmosIHRydWUpO1xuICAgICAgICAgICAgICBpZiAobykgby5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZ0YWIueFZ0YWIgPSBTdHJ1Y3RQdHJNYXBwZXIoJ3hWdGFiJywgY2FwaS5zcWxpdGUzX3Z0YWIpO1xuXG4gICAgICAgIHZ0YWIueEN1cnNvciA9IFN0cnVjdFB0ck1hcHBlcigneEN1cnNvcicsIGNhcGkuc3FsaXRlM192dGFiX2N1cnNvcik7XG5cbiAgICAgICAgdnRhYi54SW5kZXhJbmZvID0gKHBJZHhJbmZvKSA9PiBuZXcgY2FwaS5zcWxpdGUzX2luZGV4X2luZm8ocElkeEluZm8pO1xuXG4gICAgICAgIHZ0YWIueEVycm9yID0gZnVuY3Rpb24gZihtZXRob2ROYW1lLCBlcnIsIGRlZmF1bHRSYykge1xuICAgICAgICAgIGlmIChmLmVycm9yUmVwb3J0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZi5lcnJvclJlcG9ydGVyKFxuICAgICAgICAgICAgICAgICdzcWxpdGUzX21vZHVsZTo6JyArIG1ldGhvZE5hbWUgKyAnKCk6ICcgKyBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByYztcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikgcmMgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgcmMgPSBkZWZhdWx0UmM7XG4gICAgICAgICAgZWxzZSBpZiAoZXJyIGluc3RhbmNlb2Ygc3FsaXRlMy5TUUxpdGUzRXJyb3IpIHJjID0gZXJyLnJlc3VsdENvZGU7XG4gICAgICAgICAgcmV0dXJuIHJjIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICB9O1xuICAgICAgICB2dGFiLnhFcnJvci5lcnJvclJlcG9ydGVyID0gMSA/IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSA6IGZhbHNlO1xuXG4gICAgICAgIHZ0YWIueFJvd2lkID0gKHBwUm93aWQ2NCwgdmFsdWUpID0+IHdhc20ucG9rZShwcFJvd2lkNjQsIHZhbHVlLCAnaTY0Jyk7XG5cbiAgICAgICAgdnRhYi5zZXR1cE1vZHVsZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICBsZXQgY3JlYXRlZE1vZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IG1vZCA9XG4gICAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgY2FwaS5zcWxpdGUzX21vZHVsZVxuICAgICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgICAgOiBvcHQuc3RydWN0IHx8IChjcmVhdGVkTW9kID0gbmV3IGNhcGkuc3FsaXRlM19tb2R1bGUoKSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHMgPSBvcHQubWV0aG9kcyB8fCB0b3NzKFwiTWlzc2luZyAnbWV0aG9kcycgb2JqZWN0LlwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh7XG4gICAgICAgICAgICAgIHhDb25uZWN0OiAneENyZWF0ZScsXG4gICAgICAgICAgICAgIHhEaXNjb25uZWN0OiAneERlc3Ryb3knLFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgayA9IGVbMF0sXG4gICAgICAgICAgICAgICAgdiA9IGVbMV07XG4gICAgICAgICAgICAgIGlmICh0cnVlID09PSBtZXRob2RzW2tdKSBtZXRob2RzW2tdID0gbWV0aG9kc1t2XTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAodHJ1ZSA9PT0gbWV0aG9kc1t2XSkgbWV0aG9kc1t2XSA9IG1ldGhvZHNba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmNhdGNoRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICBjb25zdCBmd3JhcCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBmdW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKFsneENvbm5lY3QnLCAneENyZWF0ZSddLmluZGV4T2YobWV0aG9kTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwRGIsIHBBdXgsIGFyZ2MsIGFyZ3YsIHBwVnRhYiwgcHpFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYyguLi5hcmd1bWVudHMpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc20uZGVhbGxvYyh3YXNtLnBlZWtQdHIocHpFcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc20ucG9rZVB0cihwekVyciwgd2FzbS5hbGxvY0NTdHJpbmcoZS5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2dGFiLnhFcnJvcihtZXRob2ROYW1lLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoLi4uYXJncykgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2dGFiLnhFcnJvcihtZXRob2ROYW1lLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNvbnN0IG1uYW1lcyA9IFtcbiAgICAgICAgICAgICAgICAneENyZWF0ZScsXG4gICAgICAgICAgICAgICAgJ3hDb25uZWN0JyxcbiAgICAgICAgICAgICAgICAneEJlc3RJbmRleCcsXG4gICAgICAgICAgICAgICAgJ3hEaXNjb25uZWN0JyxcbiAgICAgICAgICAgICAgICAneERlc3Ryb3knLFxuICAgICAgICAgICAgICAgICd4T3BlbicsXG4gICAgICAgICAgICAgICAgJ3hDbG9zZScsXG4gICAgICAgICAgICAgICAgJ3hGaWx0ZXInLFxuICAgICAgICAgICAgICAgICd4TmV4dCcsXG4gICAgICAgICAgICAgICAgJ3hFb2YnLFxuICAgICAgICAgICAgICAgICd4Q29sdW1uJyxcbiAgICAgICAgICAgICAgICAneFJvd2lkJyxcbiAgICAgICAgICAgICAgICAneFVwZGF0ZScsXG4gICAgICAgICAgICAgICAgJ3hCZWdpbicsXG4gICAgICAgICAgICAgICAgJ3hTeW5jJyxcbiAgICAgICAgICAgICAgICAneENvbW1pdCcsXG4gICAgICAgICAgICAgICAgJ3hSb2xsYmFjaycsXG4gICAgICAgICAgICAgICAgJ3hGaW5kRnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICd4UmVuYW1lJyxcbiAgICAgICAgICAgICAgICAneFNhdmVwb2ludCcsXG4gICAgICAgICAgICAgICAgJ3hSZWxlYXNlJyxcbiAgICAgICAgICAgICAgICAneFJvbGxiYWNrVG8nLFxuICAgICAgICAgICAgICAgICd4U2hhZG93TmFtZScsXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIGNvbnN0IHJlbWV0aG9kcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBtbmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gbWV0aG9kc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoIShtIGluc3RhbmNlb2YgRnVuY3Rpb24pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgneENvbm5lY3QnID09PSBrICYmIG1ldGhvZHMueENyZWF0ZSA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgcmVtZXRob2RzW2tdID0gbWV0aG9kcy54Q3JlYXRlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ3hDcmVhdGUnID09PSBrICYmIG1ldGhvZHMueENvbm5lY3QgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IG1ldGhvZHMueENvbm5lY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IGZ3cmFwKGssIG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kcyhtb2QsIHJlbWV0aG9kcywgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zdGFsbE1ldGhvZHMobW9kLCBtZXRob2RzLCAhIW9wdC5hcHBseUFyZ2NDaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA9PT0gbW9kLiRpVmVyc2lvbikge1xuICAgICAgICAgICAgICBsZXQgdjtcbiAgICAgICAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2Ygb3B0LmlWZXJzaW9uKSB2ID0gb3B0LmlWZXJzaW9uO1xuICAgICAgICAgICAgICBlbHNlIGlmIChtb2QuJHhTaGFkb3dOYW1lKSB2ID0gMztcbiAgICAgICAgICAgICAgZWxzZSBpZiAobW9kLiR4U2F2ZVBvaW50IHx8IG1vZC4keFJlbGVhc2UgfHwgbW9kLiR4Um9sbGJhY2tUbylcbiAgICAgICAgICAgICAgICB2ID0gMjtcbiAgICAgICAgICAgICAgZWxzZSB2ID0gMTtcbiAgICAgICAgICAgICAgbW9kLiRpVmVyc2lvbiA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZWRNb2QpIGNyZWF0ZWRNb2QuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfbW9kdWxlLnByb3RvdHlwZS5zZXR1cE1vZHVsZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICByZXR1cm4gdnRhYi5zZXR1cE1vZHVsZS5jYWxsKHRoaXMsIG9wdCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFsbE9wZnNWZnMgPSBmdW5jdGlvbiBjYWxsZWUob3B0aW9ucykge1xuICAgICAgICAgIGlmICghZ2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlciB8fCAhZ2xvYmFsVGhpcy5BdG9taWNzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGluc3RhbGwgT1BGUzogTWlzc2luZyBTaGFyZWRBcnJheUJ1ZmZlciBhbmQvb3IgQXRvbWljcy4gJyArXG4gICAgICAgICAgICAgICAgICAnVGhlIHNlcnZlciBtdXN0IGVtaXQgdGhlIENPT1AvQ09FUCByZXNwb25zZSBoZWFkZXJzIHRvIGVuYWJsZSB0aG9zZS4gJyArXG4gICAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vc3FsaXRlLm9yZy93YXNtL2RvYy90cnVuay9wZXJzaXN0ZW5jZS5tZCNjb29wLWNvZXAnLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdUaGUgT1BGUyBzcWxpdGUzX3ZmcyBjYW5ub3QgcnVuIGluIHRoZSBtYWluIHRocmVhZCAnICtcbiAgICAgICAgICAgICAgICAgICdiZWNhdXNlIGl0IHJlcXVpcmVzIEF0b21pY3Mud2FpdCgpLicsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUucHJvdG90eXBlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgfHxcbiAgICAgICAgICAgICFuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBPUEZTIEFQSXMuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTChnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYpLnNlYXJjaFBhcmFtcztcbiAgICAgICAgICBpZiAodXJsUGFyYW1zLmhhcygnb3Bmcy1kaXNhYmxlJykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3FsaXRlMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3B0aW9ucy52ZXJib3NlID0gdXJsUGFyYW1zLmhhcygnb3Bmcy12ZXJib3NlJylcbiAgICAgICAgICAgICAgPyArdXJsUGFyYW1zLmdldCgnb3Bmcy12ZXJib3NlJykgfHwgMlxuICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG9wdGlvbnMuc2FuaXR5Q2hlY2tzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNhbml0eUNoZWNrcyA9IHVybFBhcmFtcy5oYXMoJ29wZnMtc2FuaXR5LWNoZWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG9wdGlvbnMucHJveHlVcmkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHJveHlVcmkgPSBjYWxsZWUuZGVmYXVsdFByb3h5VXJpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucy5wcm94eVVyaSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wcm94eVVyaSA9IG9wdGlvbnMucHJveHlVcmkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGhlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHByb21pc2VSZXNvbHZlXyxcbiAgICAgICAgICAgIHByb21pc2VSZWplY3RfLFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgbG9nZ2VycyA9IFtcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IsXG4gICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4sXG4gICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBsb2dJbXBsID0gKGxldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcmJvc2UgPiBsZXZlbClcbiAgICAgICAgICAgICAgICBsb2dnZXJzW2xldmVsXSgnT1BGUyBzeW5jZXI6JywgLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbG9nID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMiwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCB3YXJuID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMSwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9ICguLi5hcmdzKSA9PiBsb2dJbXBsKDAsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgdG9zcyA9IHNxbGl0ZTMudXRpbC50b3NzO1xuICAgICAgICAgICAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaTtcbiAgICAgICAgICAgIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgICAgICBjb25zdCB3YXNtID0gc3FsaXRlMy53YXNtO1xuICAgICAgICAgICAgY29uc3Qgc3FsaXRlM192ZnMgPSBjYXBpLnNxbGl0ZTNfdmZzO1xuICAgICAgICAgICAgY29uc3Qgc3FsaXRlM19maWxlID0gY2FwaS5zcWxpdGUzX2ZpbGU7XG4gICAgICAgICAgICBjb25zdCBzcWxpdGUzX2lvX21ldGhvZHMgPSBjYXBpLnNxbGl0ZTNfaW9fbWV0aG9kcztcblxuICAgICAgICAgICAgY29uc3Qgb3Bmc1V0aWwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICBjb25zdCB0aGlzVGhyZWFkSGFzT1BGUyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlICYmXG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgIC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlICYmXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3RvcnlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLm1ldHJpY3MgPSB7XG4gICAgICAgICAgICAgIGR1bXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgayxcbiAgICAgICAgICAgICAgICAgIG4gPSAwLFxuICAgICAgICAgICAgICAgICAgdCA9IDAsXG4gICAgICAgICAgICAgICAgICB3ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gc3RhdGUub3BJZHMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBtZXRyaWNzW2tdO1xuICAgICAgICAgICAgICAgICAgbiArPSBtLmNvdW50O1xuICAgICAgICAgICAgICAgICAgdCArPSBtLnRpbWU7XG4gICAgICAgICAgICAgICAgICB3ICs9IG0ud2FpdDtcbiAgICAgICAgICAgICAgICAgIG0uYXZnVGltZSA9IG0uY291bnQgJiYgbS50aW1lID8gbS50aW1lIC8gbS5jb3VudCA6IDA7XG4gICAgICAgICAgICAgICAgICBtLmF2Z1dhaXQgPSBtLmNvdW50ICYmIG0ud2FpdCA/IG0ud2FpdCAvIG0uY291bnQgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2coXG4gICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgICAgICAnbWV0cmljcyBmb3InLFxuICAgICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgJzonLFxuICAgICAgICAgICAgICAgICAgbWV0cmljcyxcbiAgICAgICAgICAgICAgICAgICdcXG5Ub3RhbCBvZicsXG4gICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgJ29wKHMpIGZvcicsXG4gICAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgICAgJ21zIChpbmNsLiAnICsgdyArICcgbXMgb2Ygd2FpdGluZyBvbiB0aGUgYXN5bmMgc2lkZSknLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcubG9nKCdTZXJpYWxpemF0aW9uIG1ldHJpY3M6JywgbWV0cmljcy5zMTFuKTtcbiAgICAgICAgICAgICAgICBXLnBvc3RNZXNzYWdlKHsgdHlwZTogJ29wZnMtYXN5bmMtbWV0cmljcycgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGs7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IChtKSA9PiAobS5jb3VudCA9IG0udGltZSA9IG0ud2FpdCA9IDApO1xuICAgICAgICAgICAgICAgIGZvciAoayBpbiBzdGF0ZS5vcElkcykge1xuICAgICAgICAgICAgICAgICAgcigobWV0cmljc1trXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHMgPSAobWV0cmljcy5zMTFuID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICAgICAgcyA9IHMuc2VyaWFsaXplID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBzLmNvdW50ID0gcy50aW1lID0gMDtcbiAgICAgICAgICAgICAgICBzID0gbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBzLmNvdW50ID0gcy50aW1lID0gMDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvcGZzSW9NZXRob2RzID0gbmV3IHNxbGl0ZTNfaW9fbWV0aG9kcygpO1xuICAgICAgICAgICAgY29uc3Qgb3Bmc1ZmcyA9IG5ldyBzcWxpdGUzX3ZmcygpLmFkZE9uRGlzcG9zZSgoKSA9PlxuICAgICAgICAgICAgICBvcGZzSW9NZXRob2RzLmRpc3Bvc2UoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZVdhc1JlamVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVJlamVjdCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcHJvbWlzZVdhc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgb3Bmc1Zmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0XyhlcnIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VSZXNvbHZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICBwcm9taXNlV2FzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlXyhzcWxpdGUzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBXID0gbmV3IFdvcmtlcihcbiAgICAgICAgICAgICAgbmV3IFVSTCgnc3FsaXRlMy1vcGZzLWFzeW5jLXByb3h5LmpzJywgaW1wb3J0Lm1ldGEudXJsKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcHJvbWlzZVdhc1JlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVJlamVjdChcbiAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1RpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgT1BGUyBhc3luYyBwcm94eSB3b3JrZXIuJyxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNDAwMCk7XG4gICAgICAgICAgICBXLl9vcmlnaW5hbE9uRXJyb3IgPSBXLm9uZXJyb3I7XG4gICAgICAgICAgICBXLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgT1BGUyBhc3luY2VyOicsIGVycik7XG4gICAgICAgICAgICAgIHByb21pc2VSZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0xvYWRpbmcgT1BGUyBhc3luYyBXb3JrZXIgZmFpbGVkIGZvciB1bmtub3duIHJlYXNvbnMuJyxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBEVmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZFZmcyA9IHBEVmZzID8gbmV3IHNxbGl0ZTNfdmZzKHBEVmZzKSA6IG51bGw7XG4gICAgICAgICAgICBvcGZzSW9NZXRob2RzLiRpVmVyc2lvbiA9IDE7XG4gICAgICAgICAgICBvcGZzVmZzLiRpVmVyc2lvbiA9IDI7XG4gICAgICAgICAgICBvcGZzVmZzLiRzek9zRmlsZSA9IGNhcGkuc3FsaXRlM19maWxlLnN0cnVjdEluZm8uc2l6ZW9mO1xuICAgICAgICAgICAgb3Bmc1Zmcy4kbXhQYXRobmFtZSA9IDEwMjQ7XG4gICAgICAgICAgICBvcGZzVmZzLiR6TmFtZSA9IHdhc20uYWxsb2NDU3RyaW5nKCdvcGZzJyk7XG5cbiAgICAgICAgICAgIG9wZnNWZnMuJHhEbE9wZW4gPVxuICAgICAgICAgICAgICBvcGZzVmZzLiR4RGxFcnJvciA9XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhEbFN5bSA9XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhEbENsb3NlID1cbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgb3Bmc1Zmcy5hZGRPbkRpc3Bvc2UoXG4gICAgICAgICAgICAgICckek5hbWUnLFxuICAgICAgICAgICAgICBvcGZzVmZzLiR6TmFtZSxcbiAgICAgICAgICAgICAgJ2NsZWFudXAgZGVmYXVsdCBWRlMgd3JhcHBlcicsXG4gICAgICAgICAgICAgICgpID0+IChkVmZzID8gZFZmcy5kaXNwb3NlKCkgOiBudWxsKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHN0YXRlLnZlcmJvc2UgPSBvcHRpb25zLnZlcmJvc2U7XG4gICAgICAgICAgICBzdGF0ZS5saXR0bGVFbmRpYW4gPSAoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICAgICAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlcilbMF0gPT09IDI1NjtcbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgIHN0YXRlLmFzeW5jSWRsZVdhaXRUaW1lID0gMTUwO1xuXG4gICAgICAgICAgICBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zID0gMTtcblxuICAgICAgICAgICAgc3RhdGUuZmlsZUJ1ZmZlclNpemUgPSAxMDI0ICogNjQ7XG4gICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0ID0gc3RhdGUuZmlsZUJ1ZmZlclNpemU7XG5cbiAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplID0gb3Bmc1Zmcy4kbXhQYXRobmFtZSAqIDI7XG5cbiAgICAgICAgICAgIHN0YXRlLnNhYklPID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKFxuICAgICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSArIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0YXRlLm9wSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG5cbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMud2hpY2hPcCA9IGkrKztcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy5yYyA9IGkrKztcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54QWNjZXNzID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54Q2xvc2UgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhEZWxldGUgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhEZWxldGVOb1dhaXQgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhGaWxlU2l6ZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueExvY2sgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhPcGVuID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54UmVhZCA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueFNsZWVwID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54U3luYyA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueFRydW5jYXRlID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54VW5sb2NrID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54V3JpdGUgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLm1rZGlyID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkc1snb3Bmcy1hc3luYy1tZXRyaWNzJ10gPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzWydvcGZzLWFzeW5jLXNodXRkb3duJ10gPSBpKys7XG5cbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMucmV0cnkgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLnNhYk9QID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKGkgKiA0KTtcbiAgICAgICAgICAgICAgb3Bmc1V0aWwubWV0cmljcy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5zcTNDb2RlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdTUUxJVEVfQUNDRVNTX0VYSVNUUycsXG4gICAgICAgICAgICAgICdTUUxJVEVfQUNDRVNTX1JFQURXUklURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfQlVTWScsXG4gICAgICAgICAgICAgICdTUUxJVEVfRVJST1InLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9BQ0NFU1MnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0NMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9ERUxFVEUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0ZTWU5DJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9TSE9SVF9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9UUlVOQ0FURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfSU9FUlJfVU5MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9XUklURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19FWENMVVNJVkUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0xPQ0tfTk9ORScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19QRU5ESU5HJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1JFU0VSVkVEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1NIQVJFRCcsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS0VEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9NSVNVU0UnLFxuICAgICAgICAgICAgICAnU1FMSVRFX05PVEZPVU5EJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX0NSRUFURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX01BSU5fREInLFxuICAgICAgICAgICAgICAnU1FMSVRFX09QRU5fUkVBRE9OTFknLFxuICAgICAgICAgICAgXS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IChzdGF0ZS5zcTNDb2Rlc1trXSA9IGNhcGlba10pKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IG5vdCBmb3VuZDonLCBrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5vcGZzRmxhZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgT1BGU19VTkxPQ0tfQVNBUDogMHgwMSxcblxuICAgICAgICAgICAgICBkZWZhdWx0VW5sb2NrQXNhcDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgb3BSdW4gPSAob3AsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3BOZHggPSBzdGF0ZS5vcElkc1tvcF0gfHwgdG9zcygnSW52YWxpZCBvcCBJRDonLCBvcCk7XG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKTtcbiAgICAgICAgICAgICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3AsIG9wTmR4KTtcbiAgICAgICAgICAgICAgQXRvbWljcy5ub3RpZnkoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy53aGljaE9wKTtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICBBdG9taWNzLndhaXQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYywgLTEpO1xuICAgICAgICAgICAgICBjb25zdCByYyA9IEF0b21pY3MubG9hZChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJjKTtcbiAgICAgICAgICAgICAgbWV0cmljc1tvcF0ud2FpdCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgICAgICAgICAgIGlmIChyYyAmJiBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGVycm9yKG9wICsgJygpIGFzeW5jIGVycm9yOicsIC4uLmVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwuZGVidWcgPSB7XG4gICAgICAgICAgICAgIGFzeW5jU2h1dGRvd246ICgpID0+IHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ1NodXR0aW5nIGRvd24gT1BGUyBhc3luYyBsaXN0ZW5lci4gVGhlIE9QRlMgVkZTIHdpbGwgbm8gbG9uZ2VyIHdvcmsuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG9wUnVuKCdvcGZzLWFzeW5jLXNodXRkb3duJyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFzeW5jUmVzdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAnQXR0ZW1wdGluZyB0byByZXN0YXJ0IE9QRlMgVkZTIGFzeW5jIGxpc3RlbmVyLiBNaWdodCB3b3JrLCBtaWdodCBub3QuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1yZXN0YXJ0JyB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGluaXRTMTFuID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuczExbikgcmV0dXJuIHN0YXRlLnMxMW47XG4gICAgICAgICAgICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCksXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JyksXG4gICAgICAgICAgICAgICAgdmlld1U4ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuU2l6ZSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHZpZXdEViA9IG5ldyBEYXRhVmlldyhcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYklPLFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExbk9mZnNldCxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IFR5cGVJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBUeXBlSWRzLm51bWJlciA9IHtcbiAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICBzaXplOiA4LFxuICAgICAgICAgICAgICAgIGdldHRlcjogJ2dldEZsb2F0NjQnLFxuICAgICAgICAgICAgICAgIHNldHRlcjogJ3NldEZsb2F0NjQnLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUeXBlSWRzLmJpZ2ludCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMixcbiAgICAgICAgICAgICAgICBzaXplOiA4LFxuICAgICAgICAgICAgICAgIGdldHRlcjogJ2dldEJpZ0ludDY0JyxcbiAgICAgICAgICAgICAgICBzZXR0ZXI6ICdzZXRCaWdJbnQ2NCcsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFR5cGVJZHMuYm9vbGVhbiA9IHtcbiAgICAgICAgICAgICAgICBpZDogMyxcbiAgICAgICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgICAgIGdldHRlcjogJ2dldEludDMyJyxcbiAgICAgICAgICAgICAgICBzZXR0ZXI6ICdzZXRJbnQzMicsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFR5cGVJZHMuc3RyaW5nID0geyBpZDogNCB9O1xuXG4gICAgICAgICAgICAgIGNvbnN0IGdldFR5cGVJZCA9ICh2KSA9PlxuICAgICAgICAgICAgICAgIFR5cGVJZHNbdHlwZW9mIHZdIHx8XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICdNYWludGVuYW5jZSByZXF1aXJlZDogdGhpcyB2YWx1ZSB0eXBlIGNhbm5vdCBiZSBzZXJpYWxpemVkLicsXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IGdldFR5cGVJZEJ5SWQgPSAodGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aWQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5udW1iZXIuaWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlSWRzLm51bWJlcjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5iaWdpbnQuaWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlSWRzLmJpZ2ludDtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5ib29sZWFuLmlkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUlkcy5ib29sZWFuO1xuICAgICAgICAgICAgICAgICAgY2FzZSBUeXBlSWRzLnN0cmluZy5pZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVJZHMuc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIElEOicsIHRpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4uZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoY2xlYXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICsrbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplLmNvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdjID0gdmlld1U4WzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gYXJnYyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoYXJnYykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZUlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDEsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAgIHY7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgKytpLCArK29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlSWRzLnB1c2goZ2V0VHlwZUlkQnlJZCh2aWV3VThbb2Zmc2V0XSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gdHlwZUlkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdiA9IHZpZXdEVlt0LmdldHRlcl0ob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSB0LnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbiA9IHZpZXdEVi5nZXRJbnQzMihvZmZzZXQsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgdiA9IHRleHREZWNvZGVyLmRlY29kZSh2aWV3VTguc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyKSB2aWV3VThbMF0gPSAwO1xuXG4gICAgICAgICAgICAgICAgbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICsrbWV0cmljcy5zMTFuLnNlcmlhbGl6ZS5jb3VudDtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGxldCBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgIHZpZXdVOFswXSA9IGFyZ3MubGVuZ3RoICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7ICsraSwgKytvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkcy5wdXNoKGdldFR5cGVJZChhcmdzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdVOFtvZmZzZXRdID0gdHlwZUlkc1tpXS5pZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0eXBlSWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5zZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3RFZbdC5zZXR0ZXJdKG9mZnNldCwgYXJnc1tpXSwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdC5zaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmlld0RWLnNldEludDMyKG9mZnNldCwgcy5ieXRlTGVuZ3RoLCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIHZpZXdVOC5zZXQocywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZpZXdVOFswXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldHJpY3MuczExbi5zZXJpYWxpemUudGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zMTFuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmFuZG9tRmlsZW5hbWUgPSBmdW5jdGlvbiBmKGxlbiA9IDE2KSB7XG4gICAgICAgICAgICAgIGlmICghZi5fY2hhcnMpIHtcbiAgICAgICAgICAgICAgICBmLl9jaGFycyA9XG4gICAgICAgICAgICAgICAgICAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICtcbiAgICAgICAgICAgICAgICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgK1xuICAgICAgICAgICAgICAgICAgJzAxMjM0Njc4OSc7XG4gICAgICAgICAgICAgICAgZi5fbiA9IGYuX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5keCA9IChNYXRoLnJhbmRvbSgpICogKGYuX24gKiA2NCkpICUgZi5fbiB8IDA7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGYuX2NoYXJzW25keF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGEuam9pbignJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBfX29wZW5GaWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9wVGltZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgb3BUaW1lci5vcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wVGltZXIuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBtVGltZVN0YXJ0ID0gKG9wKSA9PiB7XG4gICAgICAgICAgICAgIG9wVGltZXIuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgb3BUaW1lci5vcCA9IG9wO1xuICAgICAgICAgICAgICArK21ldHJpY3Nbb3BdLmNvdW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG1UaW1lRW5kID0gKCkgPT5cbiAgICAgICAgICAgICAgKG1ldHJpY3Nbb3BUaW1lci5vcF0udGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIG9wVGltZXIuc3RhcnQpO1xuXG4gICAgICAgICAgICBjb25zdCBpb1N5bmNXcmFwcGVycyA9IHtcbiAgICAgICAgICAgICAgeENoZWNrUmVzZXJ2ZWRMb2NrOiBmdW5jdGlvbiAocEZpbGUsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCBmLmxvY2tUeXBlID8gMSA6IDAsICdpMzInKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeENsb3NlOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4Q2xvc2UnKTtcbiAgICAgICAgICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4Q2xvc2UnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZi5zcTNGaWxlKSBmLnNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeERldmljZUNoYXJhY3RlcmlzdGljczogZnVuY3Rpb24gKHBGaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeEZpbGVDb250cm9sOiBmdW5jdGlvbiAocEZpbGUsIG9wSWQsIHBBcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGaWxlU2l6ZTogZnVuY3Rpb24gKHBGaWxlLCBwU3o2NCkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hGaWxlU2l6ZScpO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IG9wUnVuKCd4RmlsZVNpemUnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT0gcmMpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN6ID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpWzBdO1xuICAgICAgICAgICAgICAgICAgICB3YXNtLnBva2UocFN6NjQsIHN6LCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHJlYWRpbmcgeEZpbGVTaXplKCkgcmVzdWx0OicsIGUpO1xuICAgICAgICAgICAgICAgICAgICByYyA9IHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhMb2NrOiBmdW5jdGlvbiAocEZpbGUsIGxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneExvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWYubG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHJjID0gb3BSdW4oJ3hMb2NrJywgcEZpbGUsIGxvY2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4UmVhZDogZnVuY3Rpb24gKHBGaWxlLCBwRGVzdCwgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4UmVhZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4UmVhZCcsIHBGaWxlLCBuLCBOdW1iZXIob2Zmc2V0NjQpKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYyB8fCBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEID09PSByYykge1xuICAgICAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLnNldChmLnNhYlZpZXcuc3ViYXJyYXkoMCwgbiksIHBEZXN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcigneFJlYWQoJywgYXJndW1lbnRzLCAnKSBmYWlsZWQ6JywgZSwgZik7XG4gICAgICAgICAgICAgICAgICByYyA9IGNhcGkuU1FMSVRFX0lPRVJSX1JFQUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4U3luYzogZnVuY3Rpb24gKHBGaWxlLCBmbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hTeW5jJyk7XG4gICAgICAgICAgICAgICAgKyttZXRyaWNzLnhTeW5jLmNvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hTeW5jJywgcEZpbGUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFRydW5jYXRlOiBmdW5jdGlvbiAocEZpbGUsIHN6NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4VHJ1bmNhdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4VHJ1bmNhdGUnLCBwRmlsZSwgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFVubG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hVbmxvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGNhcGkuU1FMSVRFX0xPQ0tfTk9ORSA9PT0gbG9ja1R5cGUgJiYgZi5sb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgICAgcmMgPSBvcFJ1bigneFVubG9jaycsIHBGaWxlLCBsb2NrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4V3JpdGU6IGZ1bmN0aW9uIChwRmlsZSwgcFNyYywgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4V3JpdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZi5zYWJWaWV3LnNldCh3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBTcmMsIHBTcmMgKyBuKSk7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4V3JpdGUnLCBwRmlsZSwgbiwgTnVtYmVyKG9mZnNldDY0KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ3hXcml0ZSgnLCBhcmd1bWVudHMsICcpIGZhaWxlZDonLCBlLCBmKTtcbiAgICAgICAgICAgICAgICAgIHJjID0gY2FwaS5TUUxJVEVfSU9FUlJfV1JJVEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdmZzU3luY1dyYXBwZXJzID0ge1xuICAgICAgICAgICAgICB4QWNjZXNzOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIGZsYWdzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneEFjY2VzcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hBY2Nlc3MnLCB3YXNtLmNzdHJUb0pzKHpOYW1lKSk7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIHJjID8gMCA6IDEsICdpMzInKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWU6IGZ1bmN0aW9uIChwVmZzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKFxuICAgICAgICAgICAgICAgICAgcE91dCxcbiAgICAgICAgICAgICAgICAgIDI0NDA1ODcuNSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gODY0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAnZG91YmxlJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2UoXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICAgMjQ0MDU4Ny41ICogODY0MDAwMDAgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICdpNjQnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhEZWxldGU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneERlbGV0ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oXG4gICAgICAgICAgICAgICAgICAneERlbGV0ZScsXG4gICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHpOYW1lKSxcbiAgICAgICAgICAgICAgICAgIGRvU3luY0RpcixcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGdWxsUGF0aG5hbWU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FybignT1BGUyB4R2V0TGFzdEVycm9yKCkgaGFzIG5vdGhpbmcgc2Vuc2libGUgdG8gcmV0dXJuLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIHhPcGVuOiBmdW5jdGlvbiBmKHBWZnMsIHpOYW1lLCBwRmlsZSwgZmxhZ3MsIHBPdXRGbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hPcGVuJyk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZnNGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHpOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB6TmFtZSA9IHJhbmRvbUZpbGVuYW1lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHpOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FwaS5zcWxpdGUzX3VyaV9ib29sZWFuKHpOYW1lLCAnb3Bmcy11bmxvY2stYXNhcCcsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZnNGbGFncyB8PSBzdGF0ZS5vcGZzRmxhZ3MuT1BGU19VTkxPQ0tfQVNBUDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHpOYW1lID0gd2FzbS5jc3RyVG9Kcyh6TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBmaC5maWQgPSBwRmlsZTtcbiAgICAgICAgICAgICAgICBmaC5maWxlbmFtZSA9IHpOYW1lO1xuICAgICAgICAgICAgICAgIGZoLnNhYiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihzdGF0ZS5maWxlQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgZmguZmxhZ3MgPSBmbGFncztcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4T3BlbicsIHBGaWxlLCB6TmFtZSwgZmxhZ3MsIG9wZnNGbGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYykge1xuICAgICAgICAgICAgICAgICAgaWYgKGZoLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0RmxhZ3MsIGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFksICdpMzInKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9fb3BlbkZpbGVzW3BGaWxlXSA9IGZoO1xuICAgICAgICAgICAgICAgICAgZmguc2FiVmlldyA9IHN0YXRlLnNhYkZpbGVCdWZWaWV3O1xuICAgICAgICAgICAgICAgICAgZmguc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgICAgICAgZmguc3EzRmlsZS4kcE1ldGhvZHMgPSBvcGZzSW9NZXRob2RzLnBvaW50ZXI7XG4gICAgICAgICAgICAgICAgICBmaC5sb2NrVHlwZSA9IGNhcGkuU1FMSVRFX0xPQ0tfTk9ORTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZFZmcykge1xuICAgICAgICAgICAgICBvcGZzVmZzLiR4UmFuZG9tbmVzcyA9IGRWZnMuJHhSYW5kb21uZXNzO1xuICAgICAgICAgICAgICBvcGZzVmZzLiR4U2xlZXAgPSBkVmZzLiR4U2xlZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wZnNWZnMuJHhSYW5kb21uZXNzKSB7XG4gICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54UmFuZG9tbmVzcyA9IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhcCA9IHdhc20uaGVhcDh1KCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbk91dDsgKytpKVxuICAgICAgICAgICAgICAgICAgaGVhcFtwT3V0ICsgaV0gPSAoTWF0aC5yYW5kb20oKSAqIDI1NTAwMCkgJiAweGZmO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcGZzVmZzLiR4U2xlZXApIHtcbiAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhTbGVlcCA9IGZ1bmN0aW9uIChwVmZzLCBtcykge1xuICAgICAgICAgICAgICAgIEF0b21pY3Mud2FpdChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnhTbGVlcCwgMCwgbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGZzVXRpbC5nZXRSZXNvbHZlZFBhdGggPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHNwbGl0SXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBVUkwoZmlsZW5hbWUsICdmaWxlOi8vaXJyZWxldmFudCcpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gc3BsaXRJdCA/IHAuc3BsaXQoJy8nKS5maWx0ZXIoKHYpID0+ICEhdikgOiBwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUgPSBhc3luYyBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgICBhYnNGaWxlbmFtZSxcbiAgICAgICAgICAgICAgY3JlYXRlRGlycyA9IGZhbHNlLFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBvcGZzVXRpbC5nZXRSZXNvbHZlZFBhdGgoYWJzRmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgIGxldCBkaCA9IG9wZnNVdGlsLnJvb3REaXJlY3Rvcnk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgZGlyTmFtZSBvZiBwYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGRoID0gYXdhaXQgZGguZ2V0RGlyZWN0b3J5SGFuZGxlKGRpck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiAhIWNyZWF0ZURpcnMsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFtkaCwgZmlsZW5hbWVdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwubWtkaXIgPSBhc3luYyBmdW5jdGlvbiAoYWJzRGlyTmFtZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKFxuICAgICAgICAgICAgICAgICAgYWJzRGlyTmFtZSArICcvZmlsZXBhcnQnLFxuICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5lbnRyeUV4aXN0cyA9IGFzeW5jIGZ1bmN0aW9uIChmc0VudHJ5TmFtZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtkaCwgZm5dID0gYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoZnNFbnRyeU5hbWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRoLmdldEZpbGVIYW5kbGUoZm4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5yYW5kb21GaWxlbmFtZSA9IHJhbmRvbUZpbGVuYW1lO1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5yZWdpc3RlclZmcyA9IChhc0RlZmF1bHQgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfdmZzX3JlZ2lzdGVyKFxuICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICBhc0RlZmF1bHQgPyAxIDogMCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnRyZWVMaXN0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCBkb0RpciA9IGFzeW5jIGZ1bmN0aW9uIGNhbGxlZShkaXJIYW5kbGUsIHRndCkge1xuICAgICAgICAgICAgICAgIHRndC5uYW1lID0gZGlySGFuZGxlLm5hbWU7XG4gICAgICAgICAgICAgICAgdGd0LmRpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0Z3QuZmlsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgnZGlyZWN0b3J5JyA9PT0gaGFuZGxlLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViRGlyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmRpcnMucHVzaChzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsZWUoaGFuZGxlLCBzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmZpbGVzLnB1c2goaGFuZGxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3Qgcm9vdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGF3YWl0IGRvRGlyKG9wZnNVdGlsLnJvb3REaXJlY3RvcnksIHJvb3QpO1xuICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnJtZnIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpciA9IG9wZnNVdGlsLnJvb3REaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgb3B0ID0geyByZWN1cnNlOiB0cnVlIH07XG4gICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaGFuZGxlIG9mIGRpci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGRpci5yZW1vdmVFbnRyeShoYW5kbGUubmFtZSwgb3B0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudW5saW5rID0gYXN5bmMgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICBmc0VudHJ5TmFtZSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlID0gZmFsc2UsXG4gICAgICAgICAgICAgIHRocm93T25FcnJvciA9IGZhbHNlLFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZpbGVuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICAgIGZzRW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KGZpbGVuYW1lUGFydCwgeyByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICd1bmxpbmsoJyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAnKSBmYWlsZWQ6ICcgKyBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudHJhdmVyc2UgPSBhc3luYyBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRPcHQgPSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogb3Bmc1V0aWwucm9vdERpcmVjdG9yeSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHQpIHtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IGNhbGxiYWNrOiBvcHQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHQsIG9wdCB8fCB7fSk7XG4gICAgICAgICAgICAgIGNvbnN0IGRvRGlyID0gYXN5bmMgZnVuY3Rpb24gY2FsbGVlKGRpckhhbmRsZSwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gb3B0LmNhbGxiYWNrKGhhbmRsZSwgZGlySGFuZGxlLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdC5yZWN1cnNpdmUgJiYgJ2RpcmVjdG9yeScgPT09IGhhbmRsZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gKGF3YWl0IGNhbGxlZShoYW5kbGUsIGRlcHRoICsgMSkpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGRvRGlyKG9wdC5kaXJlY3RvcnksIDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgaW1wb3J0RGJDaHVua2VkID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjb25zdCBbaERpciwgZm5hbWVQYXJ0XSA9IGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxldCBzYWggPSBhd2FpdCBoRmlsZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgICAgIGxldCBuV3JvdGUgPSAwLFxuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBuV3JvdGUgJiYgY2h1bmsuYnl0ZUxlbmd0aCA+PSAxNSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHsgYXQ6IG5Xcm90ZSB9KTtcbiAgICAgICAgICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobldyb3RlIDwgNTEyIHx8IDAgIT09IG5Xcm90ZSAlIDUxMikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0lucHV0IHNpemUnLFxuICAgICAgICAgICAgICAgICAgICBuV3JvdGUsXG4gICAgICAgICAgICAgICAgICAgICdpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLicsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KDIwKTtcbiAgICAgICAgICAgICAgICAgIHNhaC5yZWFkKGhlYWRlciwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBzYWggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5pbXBvcnREYiA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlbmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RGJDaHVua2VkKGZpbGVuYW1lLCBieXRlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICAgICAgICB1dGlsLmFmZmlybUlzRGIoYnl0ZXMpO1xuICAgICAgICAgICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsZXQgc2FoLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBuV3JvdGUgPSAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNhaCA9IGF3YWl0IGhGaWxlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7IGF0OiAwIH0pO1xuICAgICAgICAgICAgICAgIGlmIChuV3JvdGUgIT0gbikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIHRvIHdyaXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG4gK1xuICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMgYnV0IHdyb3RlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG5Xcm90ZSArXG4gICAgICAgICAgICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FoKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHNhaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc3FsaXRlMy5vbzEpIHtcbiAgICAgICAgICAgICAgY29uc3QgT3Bmc0RiID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBzcWxpdGUzLm9vMS5EQi5kYkN0b3JIZWxwZXIubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBvcHQudmZzID0gb3Bmc1Zmcy4kek5hbWU7XG4gICAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgT3Bmc0RiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3FsaXRlMy5vbzEuREIucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuT3Bmc0RiID0gT3Bmc0RiO1xuICAgICAgICAgICAgICBPcGZzRGIuaW1wb3J0RGIgPSBvcGZzVXRpbC5pbXBvcnREYjtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLnNldFZmc1Bvc3RPcGVuU3FsKFxuICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAob28xRGIsIHNxbGl0ZTMpIHtcbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2J1c3lfdGltZW91dChvbzFEYiwgMTAwMDApO1xuICAgICAgICAgICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfZXhlYyhcbiAgICAgICAgICAgICAgICAgICAgb28xRGIsXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAncHJhZ21hIGpvdXJuYWxfbW9kZT1ERUxFVEU7JyxcblxuICAgICAgICAgICAgICAgICAgICAgICdwcmFnbWEgY2FjaGVfc2l6ZT0tMTYzODQ7JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUoKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWQgPSBzcTNGaWxlLnBvaW50ZXI7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlbkZsYWdzID1cbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQjtcbiAgICAgICAgICAgICAgICBjb25zdCBwT3V0ID0gd2FzbS5zY29wZWRBbGxvYyg4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYkZpbGUgPSAnL3Nhbml0eS9jaGVjay9maWxlJyArIHJhbmRvbUZpbGVuYW1lKDgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpEYkZpbGUgPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhkYkZpbGUpO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSgnVGhpcyBpcyDDpCBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgcmMgPSBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgbG9nKCdkZXNlcmlhbGl6ZSgpIHNheXM6JywgcmMpO1xuICAgICAgICAgICAgICAgIGlmICgnVGhpcyBpcyDDpCBzdHJpbmcuJyAhPT0gcmNbMF0pIHRvc3MoJ1N0cmluZyBkMTNuIGVycm9yLicpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGxvZygneEFjY2VzcygnLCBkYkZpbGUsICcpIGV4aXN0cyA/PScsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IHZmc1N5bmNXcmFwcGVycy54T3BlbihcbiAgICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIHpEYkZpbGUsXG4gICAgICAgICAgICAgICAgICBmaWQsXG4gICAgICAgICAgICAgICAgICBvcGVuRmxhZ3MsXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgJ29wZW4gcmMgPScsXG4gICAgICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgICAgICdzdGF0ZS5zYWJPUFZpZXdbeE9wZW5dID0nLFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiT1BWaWV3W3N0YXRlLm9wSWRzLnhPcGVuXSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSByYykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ29wZW4gZmFpbGVkIHdpdGggY29kZScsIHJjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhBY2Nlc3Mob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAwLCBwT3V0KTtcbiAgICAgICAgICAgICAgICByYyA9IHdhc20ucGVlayhwT3V0LCAnaTMyJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYykgdG9zcygneEFjY2VzcygpIGZhaWxlZCB0byBkZXRlY3QgZmlsZS4nKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhTeW5jKHNxM0ZpbGUucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJjKSB0b3NzKCdzeW5jIGZhaWxlZCB3LyByYycsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhUcnVuY2F0ZShzcTNGaWxlLnBvaW50ZXIsIDEwMjQpO1xuICAgICAgICAgICAgICAgIGlmIChyYykgdG9zcygndHJ1bmNhdGUgZmFpbGVkIHcvIHJjJywgcmMpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCAwLCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54RmlsZVNpemUoc3EzRmlsZS5wb2ludGVyLCBwT3V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hGaWxlU2l6ZSBmYWlsZWQgdy8gcmMnLCByYyk7XG4gICAgICAgICAgICAgICAgbG9nKCd4RmlsZVNpemUgc2F5czonLCB3YXNtLnBlZWsocE91dCwgJ2k2NCcpKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhXcml0ZShzcTNGaWxlLnBvaW50ZXIsIHpEYkZpbGUsIDEwLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hXcml0ZSgpIGZhaWxlZCEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkQnVmID0gd2FzbS5zY29wZWRBbGxvYygxNik7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54UmVhZChzcTNGaWxlLnBvaW50ZXIsIHJlYWRCdWYsIDYsIDIpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShyZWFkQnVmICsgNiwgMCk7XG4gICAgICAgICAgICAgICAgbGV0IGpSZWFkID0gd2FzbS5jc3RyVG9KcyhyZWFkQnVmKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hSZWFkKCkgZ290OicsIGpSZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3Nhbml0eScgIT09IGpSZWFkKSB0b3NzKCdVbmV4cGVjdGVkIHhSZWFkKCkgdmFsdWUuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZmc1N5bmNXcmFwcGVycy54U2xlZXApIHtcbiAgICAgICAgICAgICAgICAgIGxvZygneFNsZWVwKClpbmcgYmVmb3JlIGNsb3NlKClpbmcuLi4nKTtcbiAgICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54U2xlZXAob3Bmc1Zmcy5wb2ludGVyLCAyMDAwKTtcbiAgICAgICAgICAgICAgICAgIGxvZygnd2FraW5nIHVwIGZyb20geFNsZWVwKCknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54Q2xvc2UoZmlkKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hDbG9zZSByYyA9JywgcmMsICdzYWJPUFZpZXcgPScsIHN0YXRlLnNhYk9QVmlldyk7XG4gICAgICAgICAgICAgICAgbG9nKCdEZWxldGluZyBmaWxlOicsIGRiRmlsZSk7XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhEZWxldGUob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAweDEyMzQpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAgICdFeHBlY3RpbmcgMCBmcm9tIHhBY2Nlc3MoJyxcbiAgICAgICAgICAgICAgICAgICAgZGJGaWxlLFxuICAgICAgICAgICAgICAgICAgICAnKSBhZnRlciB4RGVsZXRlKCkuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgd2FybignRW5kIG9mIE9QRlMgc2FuaXR5IGNoZWNrcy4nKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgVy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoeyBkYXRhIH0pIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLXVuYXZhaWxhYmxlJzpcbiAgICAgICAgICAgICAgICAgIHByb21pc2VSZWplY3QobmV3IEVycm9yKGRhdGEucGF5bG9hZC5qb2luKCcgJykpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtbG9hZGVkJzpcbiAgICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1pbml0JywgYXJnczogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLWFzeW5jLWluaXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0cnVlID09PSBwcm9taXNlV2FzUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICAgICAgICAgICAgICAgICAgICBpbzogeyBzdHJ1Y3Q6IG9wZnNJb01ldGhvZHMsIG1ldGhvZHM6IGlvU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgdmZzOiB7IHN0cnVjdDogb3Bmc1ZmcywgbWV0aG9kczogdmZzU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJPUFZpZXcgPSBuZXcgSW50MzJBcnJheShzdGF0ZS5zYWJPUCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYkZpbGVCdWZWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpbml0UzExbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zYW5pdHlDaGVja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1J1bm5pbmcgc2FuaXR5IGNoZWNrcyBiZWNhdXNlIG9mIG9wZnMtc2FuaXR5LWNoZWNrIFVSTCBhcmcuLi4nLFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgc2FuaXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1RocmVhZEhhc09QRlMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RGlyZWN0b3J5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFcub25lcnJvciA9IFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3FsaXRlMy5vcGZzID0gb3Bmc1V0aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wZnNVdGlsLnJvb3REaXJlY3RvcnkgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0VuZCBvZiBPUEZTIHNxbGl0ZTNfdmZzIHNldHVwLicsIG9wZnNWZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChwcm9taXNlUmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9XG4gICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIG1lc3NhZ2UgZnJvbSB0aGUgT1BGUyBhc3luYyB3b3JrZXI6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KG5ldyBFcnJvcihlcnJNc2cpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhlUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID0gJ3NxbGl0ZTMtb3Bmcy1hc3luYy1wcm94eS5qcyc7XG4gICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYy5wdXNoKFxuICAgICAgICAgIGFzeW5jIChzcWxpdGUzKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgcHJveHlKcyA9IGluc3RhbGxPcGZzVmZzLmRlZmF1bHRQcm94eVVyaTtcbiAgICAgICAgICAgICAgaWYgKHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID1cbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyICsgcHJveHlKcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFsbE9wZnNWZnMoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICAgICAnSWdub3JpbmcgaW5hYmlsaXR5IHRvIGluc3RhbGwgT1BGUyBzcWxpdGUzX3ZmczonLFxuICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcignaW5zdGFsbE9wZnNWZnMoKSBleGNlcHRpb246JywgZSk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGNvbnN0IHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zcztcbiAgICAgICAgY29uc3QgdG9zczMgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gICAgICAgIGNvbnN0IGluaXRQcm9taXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGk7XG4gICAgICAgIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG5cbiAgICAgICAgY29uc3QgU0VDVE9SX1NJWkUgPSA0MDk2O1xuICAgICAgICBjb25zdCBIRUFERVJfTUFYX1BBVEhfU0laRSA9IDUxMjtcbiAgICAgICAgY29uc3QgSEVBREVSX0ZMQUdTX1NJWkUgPSA0O1xuICAgICAgICBjb25zdCBIRUFERVJfRElHRVNUX1NJWkUgPSA4O1xuICAgICAgICBjb25zdCBIRUFERVJfQ09SUFVTX1NJWkUgPSBIRUFERVJfTUFYX1BBVEhfU0laRSArIEhFQURFUl9GTEFHU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0ZMQUdTID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gICAgICAgIGNvbnN0IEhFQURFUl9PRkZTRVRfRElHRVNUID0gSEVBREVSX0NPUlBVU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0RBVEEgPSBTRUNUT1JfU0laRTtcblxuICAgICAgICBjb25zdCBQRVJTSVNURU5UX0ZJTEVfVFlQRVMgPVxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQiB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0pPVVJOQUwgfFxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fU1VQRVJfSk9VUk5BTCB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9XQUw7XG5cbiAgICAgICAgY29uc3QgT1BBUVVFX0RJUl9OQU1FID0gJy5vcGFxdWUnO1xuXG4gICAgICAgIGNvbnN0IGdldFJhbmRvbU5hbWUgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbkRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgbmFtZTogJ29wZnMtc2FocG9vbCcsXG4gICAgICAgICAgZGlyZWN0b3J5OiB1bmRlZmluZWQsXG4gICAgICAgICAgaW5pdGlhbENhcGFjaXR5OiA2LFxuICAgICAgICAgIGNsZWFyT25Jbml0OiBmYWxzZSxcblxuICAgICAgICAgIHZlcmJvc2l0eTogMixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbG9nZ2VycyA9IFtcbiAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcixcbiAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuLFxuICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbG9nID0gc3FsaXRlMy5jb25maWcubG9nO1xuICAgICAgICBjb25zdCB3YXJuID0gc3FsaXRlMy5jb25maWcud2FybjtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBzcWxpdGUzLmNvbmZpZy5lcnJvcjtcblxuICAgICAgICBjb25zdCBfX21hcFZmc1RvUG9vbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZ2V0UG9vbEZvclZmcyA9IChwVmZzKSA9PiBfX21hcFZmc1RvUG9vbC5nZXQocFZmcyk7XG4gICAgICAgIGNvbnN0IHNldFBvb2xGb3JWZnMgPSAocFZmcywgcG9vbCkgPT4ge1xuICAgICAgICAgIGlmIChwb29sKSBfX21hcFZmc1RvUG9vbC5zZXQocFZmcywgcG9vbCk7XG4gICAgICAgICAgZWxzZSBfX21hcFZmc1RvUG9vbC5kZWxldGUocFZmcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tYXBTcWxpdGUzRmlsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZ2V0UG9vbEZvclBGaWxlID0gKHBGaWxlKSA9PiBfX21hcFNxbGl0ZTNGaWxlLmdldChwRmlsZSk7XG4gICAgICAgIGNvbnN0IHNldFBvb2xGb3JQRmlsZSA9IChwRmlsZSwgcG9vbCkgPT4ge1xuICAgICAgICAgIGlmIChwb29sKSBfX21hcFNxbGl0ZTNGaWxlLnNldChwRmlsZSwgcG9vbCk7XG4gICAgICAgICAgZWxzZSBfX21hcFNxbGl0ZTNGaWxlLmRlbGV0ZShwRmlsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaW9NZXRob2RzID0ge1xuICAgICAgICAgIHhDaGVja1Jlc2VydmVkTG9jazogZnVuY3Rpb24gKHBGaWxlLCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKCd4Q2hlY2tSZXNlcnZlZExvY2snKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIHdhc20ucG9rZTMyKHBPdXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Q2xvc2U6IGZ1bmN0aW9uIChwRmlsZSkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBvb2wubG9nKGB4Q2xvc2UgJHtmaWxlLnBhdGh9YCk7XG4gICAgICAgICAgICAgICAgcG9vbC5tYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZmlsZS5zYWguZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5mbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fREVMRVRFT05DTE9TRSkge1xuICAgICAgICAgICAgICAgICAgcG9vbC5kZWxldGVQYXRoKGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhEZXZpY2VDaGFyYWN0ZXJpc3RpY3M6IGZ1bmN0aW9uIChwRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhGaWxlQ29udHJvbDogZnVuY3Rpb24gKHBGaWxlLCBvcElkLCBwQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RmlsZVNpemU6IGZ1bmN0aW9uIChwRmlsZSwgcFN6NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhGaWxlU2l6ZWApO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGZpbGUuc2FoLmdldFNpemUoKSAtIEhFQURFUl9PRkZTRVRfREFUQTtcblxuICAgICAgICAgICAgd2FzbS5wb2tlNjQocFN6NjQsIEJpZ0ludChzaXplKSk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhMb2NrOiBmdW5jdGlvbiAocEZpbGUsIGxvY2tUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4TG9jayAke2xvY2tUeXBlfWApO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgZmlsZS5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4UmVhZDogZnVuY3Rpb24gKHBGaWxlLCBwRGVzdCwgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhSZWFkICR7ZmlsZS5wYXRofSAke259IEAgJHtvZmZzZXQ2NH1gKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5SZWFkID0gZmlsZS5zYWgucmVhZChcbiAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBEZXN0LCBwRGVzdCArIG4pLFxuICAgICAgICAgICAgICAgIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIE51bWJlcihvZmZzZXQ2NCkgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKG5SZWFkIDwgbikge1xuICAgICAgICAgICAgICAgIHdhc20uaGVhcDh1KCkuZmlsbCgwLCBwRGVzdCArIG5SZWFkLCBwRGVzdCArIG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4U2VjdG9yU2l6ZTogZnVuY3Rpb24gKHBGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gU0VDVE9SX1NJWkU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4U3luYzogZnVuY3Rpb24gKHBGaWxlLCBmbGFncykge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZyhgeFN5bmMgJHtmbGFnc31gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmlsZS5zYWguZmx1c2goKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHhUcnVuY2F0ZTogZnVuY3Rpb24gKHBGaWxlLCBzejY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4VHJ1bmNhdGUgJHtzejY0fWApO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmaWxlLnNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEgKyBOdW1iZXIoc3o2NCkpO1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeFVubG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZygneFVubG9jaycpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgZmlsZS5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4V3JpdGU6IGZ1bmN0aW9uIChwRmlsZSwgcFNyYywgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhXcml0ZSAke2ZpbGUucGF0aH0gJHtufSAke29mZnNldDY0fWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgbkJ5dGVzID0gZmlsZS5zYWgud3JpdGUoXG4gICAgICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5zdWJhcnJheShwU3JjLCBwU3JjICsgbiksXG4gICAgICAgICAgICAgICAgeyBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgTnVtYmVyKG9mZnNldDY0KSB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gbiA9PT0gbkJ5dGVzID8gMCA6IHRvc3MoJ1Vua25vd24gd3JpdGUoKSBmYWlsdXJlLicpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvcGZzSW9NZXRob2RzID0gbmV3IGNhcGkuc3FsaXRlM19pb19tZXRob2RzKCk7XG4gICAgICAgIG9wZnNJb01ldGhvZHMuJGlWZXJzaW9uID0gMTtcbiAgICAgICAgc3FsaXRlMy52ZnMuaW5zdGFsbFZmcyh7XG4gICAgICAgICAgaW86IHsgc3RydWN0OiBvcGZzSW9NZXRob2RzLCBtZXRob2RzOiBpb01ldGhvZHMgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdmZzTWV0aG9kcyA9IHtcbiAgICAgICAgICB4QWNjZXNzOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIGZsYWdzLCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwb29sLmdldFBhdGgoek5hbWUpO1xuICAgICAgICAgICAgICB3YXNtLnBva2UzMihwT3V0LCBwb29sLmhhc0ZpbGVuYW1lKG5hbWUpID8gMSA6IDApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB3YXNtLnBva2UzMihwT3V0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeEN1cnJlbnRUaW1lOiBmdW5jdGlvbiAocFZmcywgcE91dCkge1xuICAgICAgICAgICAgd2FzbS5wb2tlKFxuICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAyNDQwNTg3LjUgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDg2NDAwMDAwLFxuICAgICAgICAgICAgICAnZG91YmxlJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhDdXJyZW50VGltZUludDY0OiBmdW5jdGlvbiAocFZmcywgcE91dCkge1xuICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIDI0NDA1ODcuNSAqIDg2NDAwMDAwICsgbmV3IERhdGUoKS5nZXRUaW1lKCksICdpNjQnKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeERlbGV0ZTogZnVuY3Rpb24gKHBWZnMsIHpOYW1lLCBkb1N5bmNEaXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhEZWxldGUgJHt3YXNtLmNzdHJUb0pzKHpOYW1lKX1gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBvb2wuZGVsZXRlUGF0aChwb29sLmdldFBhdGgoek5hbWUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoZSk7XG4gICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUl9ERUxFVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RnVsbFBhdGhuYW1lOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIG5PdXQsIHBPdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgICAgICAgIHJldHVybiBpIDwgbk91dCA/IDAgOiBjYXBpLlNRTElURV9DQU5UT1BFTjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBwb29sLnBvcEVycigpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhHZXRMYXN0RXJyb3IgJHtuT3V0fSBlID1gLCBlKTtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY01zZywgbl0gPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhlLm1lc3NhZ2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIHdhc20uY3N0cm5jcHkocE91dCwgY01zZywgbk91dCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gPiBuT3V0KSB3YXNtLnBva2U4KHBPdXQgKyBuT3V0IC0gMSwgMCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlID8gZS5zcWxpdGUzUmMgfHwgY2FwaS5TUUxJVEVfSU9FUlIgOiAwO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB4T3BlbjogZnVuY3Rpb24gZihwVmZzLCB6TmFtZSwgcEZpbGUsIGZsYWdzLCBwT3V0RmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcG9vbC5sb2coYHhPcGVuICR7d2FzbS5jc3RyVG9Kcyh6TmFtZSl9ICR7ZmxhZ3N9YCk7XG5cbiAgICAgICAgICAgICAgY29uc3QgcGF0aCA9XG4gICAgICAgICAgICAgICAgek5hbWUgJiYgd2FzbS5wZWVrOCh6TmFtZSlcbiAgICAgICAgICAgICAgICAgID8gcG9vbC5nZXRQYXRoKHpOYW1lKVxuICAgICAgICAgICAgICAgICAgOiBnZXRSYW5kb21OYW1lKCk7XG4gICAgICAgICAgICAgIGxldCBzYWggPSBwb29sLmdldFNBSEZvclBhdGgocGF0aCk7XG4gICAgICAgICAgICAgIGlmICghc2FoICYmIGZsYWdzICYgY2FwaS5TUUxJVEVfT1BFTl9DUkVBVEUpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9vbC5nZXRGaWxlQ291bnQoKSA8IHBvb2wuZ2V0Q2FwYWNpdHkoKSkge1xuICAgICAgICAgICAgICAgICAgc2FoID0gcG9vbC5uZXh0QXZhaWxhYmxlU0FIKCk7XG4gICAgICAgICAgICAgICAgICBwb29sLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgcGF0aCwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b3NzKCdTQUggcG9vbCBpcyBmdWxsLiBDYW5ub3QgY3JlYXRlIGZpbGUnLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzYWgpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdmaWxlIG5vdCBmb3VuZDonLCBwYXRoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB7IHBhdGgsIGZsYWdzLCBzYWggfTtcbiAgICAgICAgICAgICAgcG9vbC5tYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmaWxlKTtcbiAgICAgICAgICAgICAgZmlsZS5sb2NrVHlwZSA9IGNhcGkuU1FMSVRFX0xPQ0tfTk9ORTtcbiAgICAgICAgICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBjYXBpLnNxbGl0ZTNfZmlsZShwRmlsZSk7XG4gICAgICAgICAgICAgIHNxM0ZpbGUuJHBNZXRob2RzID0gb3Bmc0lvTWV0aG9kcy5wb2ludGVyO1xuICAgICAgICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlMzIocE91dEZsYWdzLCBmbGFncyk7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBwb29sLnN0b3JlRXJyKGUpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjcmVhdGVPcGZzVmZzID0gZnVuY3Rpb24gKHZmc05hbWUpIHtcbiAgICAgICAgICBpZiAoc3FsaXRlMy5jYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodmZzTmFtZSkpIHtcbiAgICAgICAgICAgIHRvc3MzKCdWRlMgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQ6JywgdmZzTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9wZnNWZnMgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcygpO1xuXG4gICAgICAgICAgY29uc3QgcERWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQobnVsbCk7XG4gICAgICAgICAgY29uc3QgZFZmcyA9IHBEVmZzID8gbmV3IGNhcGkuc3FsaXRlM192ZnMocERWZnMpIDogbnVsbDtcbiAgICAgICAgICBvcGZzVmZzLiRpVmVyc2lvbiA9IDI7XG4gICAgICAgICAgb3Bmc1Zmcy4kc3pPc0ZpbGUgPSBjYXBpLnNxbGl0ZTNfZmlsZS5zdHJ1Y3RJbmZvLnNpemVvZjtcbiAgICAgICAgICBvcGZzVmZzLiRteFBhdGhuYW1lID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gICAgICAgICAgb3Bmc1Zmcy5hZGRPbkRpc3Bvc2UoXG4gICAgICAgICAgICAob3Bmc1Zmcy4kek5hbWUgPSB3YXNtLmFsbG9jQ1N0cmluZyh2ZnNOYW1lKSksXG4gICAgICAgICAgICAoKSA9PiBzZXRQb29sRm9yVmZzKG9wZnNWZnMucG9pbnRlciwgMCksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChkVmZzKSB7XG4gICAgICAgICAgICBvcGZzVmZzLiR4UmFuZG9tbmVzcyA9IGRWZnMuJHhSYW5kb21uZXNzO1xuICAgICAgICAgICAgb3Bmc1Zmcy4keFNsZWVwID0gZFZmcy4keFNsZWVwO1xuICAgICAgICAgICAgZFZmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3Bmc1Zmcy4keFJhbmRvbW5lc3MgJiYgIXZmc01ldGhvZHMueFJhbmRvbW5lc3MpIHtcbiAgICAgICAgICAgIHZmc01ldGhvZHMueFJhbmRvbW5lc3MgPSBmdW5jdGlvbiAocFZmcywgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICBmb3IgKDsgaSA8IG5PdXQ7ICsraSlcbiAgICAgICAgICAgICAgICBoZWFwW3BPdXQgKyBpXSA9IChNYXRoLnJhbmRvbSgpICogMjU1MDAwKSAmIDB4ZmY7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFvcGZzVmZzLiR4U2xlZXAgJiYgIXZmc01ldGhvZHMueFNsZWVwKSB7XG4gICAgICAgICAgICB2ZnNNZXRob2RzLnhTbGVlcCA9IChwVmZzLCBtcykgPT4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3FsaXRlMy52ZnMuaW5zdGFsbFZmcyh7XG4gICAgICAgICAgICB2ZnM6IHsgc3RydWN0OiBvcGZzVmZzLCBtZXRob2RzOiB2ZnNNZXRob2RzIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG9wZnNWZnM7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xhc3MgT3Bmc1NBSFBvb2wge1xuICAgICAgICAgIHZmc0RpcjtcblxuICAgICAgICAgICNkaFZmc1Jvb3Q7XG5cbiAgICAgICAgICAjZGhPcGFxdWU7XG5cbiAgICAgICAgICAjZGhWZnNQYXJlbnQ7XG5cbiAgICAgICAgICAjbWFwU0FIVG9OYW1lID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgI21hcEZpbGVuYW1lVG9TQUggPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAjYXZhaWxhYmxlU0FIID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgI21hcFMzRmlsZVRvT0ZpbGVfID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgI2FwQm9keSA9IG5ldyBVaW50OEFycmF5KEhFQURFUl9DT1JQVVNfU0laRSk7XG5cbiAgICAgICAgICAjZHZCb2R5O1xuXG4gICAgICAgICAgI2NWZnM7XG5cbiAgICAgICAgICAjdmVyYm9zaXR5O1xuXG4gICAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuI3ZlcmJvc2l0eSA9IG9wdGlvbnMudmVyYm9zaXR5ID8/IG9wdGlvbkRlZmF1bHRzLnZlcmJvc2l0eTtcbiAgICAgICAgICAgIHRoaXMudmZzTmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25EZWZhdWx0cy5uYW1lO1xuICAgICAgICAgICAgdGhpcy4jY1ZmcyA9IGNyZWF0ZU9wZnNWZnModGhpcy52ZnNOYW1lKTtcbiAgICAgICAgICAgIHNldFBvb2xGb3JWZnModGhpcy4jY1Zmcy5wb2ludGVyLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmZzRGlyID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgJy4nICsgdGhpcy52ZnNOYW1lO1xuICAgICAgICAgICAgdGhpcy4jZHZCb2R5ID0gbmV3IERhdGFWaWV3KFxuICAgICAgICAgICAgICB0aGlzLiNhcEJvZHkuYnVmZmVyLFxuICAgICAgICAgICAgICB0aGlzLiNhcEJvZHkuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0aGlzLnJlc2V0KFxuICAgICAgICAgICAgICAhIShvcHRpb25zLmNsZWFyT25Jbml0ID8/IG9wdGlvbkRlZmF1bHRzLmNsZWFyT25Jbml0KSxcbiAgICAgICAgICAgICkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLiRlcnJvcikgdGhyb3cgdGhpcy4kZXJyb3I7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhcGFjaXR5KClcbiAgICAgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmFkZENhcGFjaXR5KFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmluaXRpYWxDYXBhY2l0eSB8fCBvcHRpb25EZWZhdWx0cy5pbml0aWFsQ2FwYWNpdHksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgI2xvZ0ltcGwobGV2ZWwsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2ZXJib3NpdHkgPiBsZXZlbClcbiAgICAgICAgICAgICAgbG9nZ2Vyc1tsZXZlbF0odGhpcy52ZnNOYW1lICsgJzonLCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ0ltcGwoMiwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICAgICAgdGhpcy4jbG9nSW1wbCgxLCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICAgICAgdGhpcy4jbG9nSW1wbCgwLCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRWZnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jY1ZmcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRDYXBhY2l0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXBTQUhUb05hbWUuc2l6ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRGaWxlQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5zaXplO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldEZpbGVOYW1lcygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICAgICAgICBjb25zdCBpdGVyID0gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5rZXlzKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgaXRlcikgcmMucHVzaChuKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyBhZGRDYXBhY2l0eShuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICAgICAgICBjb25zdCBoID0gYXdhaXQgdGhpcy4jZGhPcGFxdWUuZ2V0RmlsZUhhbmRsZShuYW1lLCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLnNldChhaCwgbmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoYWgsICcnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhcGFjaXR5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVkdWNlQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgbGV0IG5SbSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFoIG9mIEFycmF5LmZyb20odGhpcy4jYXZhaWxhYmxlU0FIKSkge1xuICAgICAgICAgICAgICBpZiAoblJtID09PSBuIHx8IHRoaXMuZ2V0RmlsZUNvdW50KCkgPT09IHRoaXMuZ2V0Q2FwYWNpdHkoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLiNtYXBTQUhUb05hbWUuZ2V0KGFoKTtcblxuICAgICAgICAgICAgICBhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaE9wYXF1ZS5yZW1vdmVFbnRyeShuYW1lKTtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLmRlbGV0ZShhaCk7XG4gICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoYWgpO1xuICAgICAgICAgICAgICArK25SbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuUm07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVsZWFzZUFjY2Vzc0hhbmRsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFoIG9mIHRoaXMuI21hcFNBSFRvTmFtZS5rZXlzKCkpIGFoLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLiNtYXBTQUhUb05hbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5jbGVhcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIGFjcXVpcmVBY2Nlc3NIYW5kbGVzKGNsZWFyRmlsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gW107XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IFtuYW1lLCBoXSBvZiB0aGlzLiNkaE9wYXF1ZSkge1xuICAgICAgICAgICAgICBpZiAoJ2ZpbGUnID09PSBoLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKFtuYW1lLCBoXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgZmlsZXMubWFwKGFzeW5jIChbbmFtZSwgaF0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5zZXQoYWgsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNsZWFyRmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChhaCwgJycsIDApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZ2V0QXNzb2NpYXRlZFBhdGgoYWgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2V0KHBhdGgsIGFoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguYWRkKGFoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVFcnIoZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VBY2Nlc3NIYW5kbGVzKCk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldEFzc29jaWF0ZWRQYXRoKHNhaCkge1xuICAgICAgICAgICAgc2FoLnJlYWQodGhpcy4jYXBCb2R5LCB7IGF0OiAwIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHRoaXMuI2R2Qm9keS5nZXRVaW50MzIoSEVBREVSX09GRlNFVF9GTEFHUyk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMuI2FwQm9keVswXSAmJlxuICAgICAgICAgICAgICAoZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UgfHxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQRVJTSVNURU5UX0ZJTEVfVFlQRVMpID09PSAwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgYFJlbW92aW5nIGZpbGUgd2l0aCB1bmV4cGVjdGVkIGZsYWdzICR7ZmxhZ3MudG9TdHJpbmcoMTYpfWAsXG4gICAgICAgICAgICAgICAgdGhpcy4jYXBCb2R5LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVEaWdlc3QgPSBuZXcgVWludDMyQXJyYXkoSEVBREVSX0RJR0VTVF9TSVpFIC8gNCk7XG4gICAgICAgICAgICBzYWgucmVhZChmaWxlRGlnZXN0LCB7IGF0OiBIRUFERVJfT0ZGU0VUX0RJR0VTVCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBEaWdlc3QgPSB0aGlzLmNvbXB1dGVEaWdlc3QodGhpcy4jYXBCb2R5KTtcbiAgICAgICAgICAgIGlmIChmaWxlRGlnZXN0LmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBjb21wRGlnZXN0W2ldKSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoQnl0ZXMgPSB0aGlzLiNhcEJvZHkuZmluZEluZGV4KCh2KSA9PiAwID09PSB2KTtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHBhdGhCeXRlcykge1xuICAgICAgICAgICAgICAgIHNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwYXRoQnl0ZXNcbiAgICAgICAgICAgICAgICA/IHRleHREZWNvZGVyLmRlY29kZSh0aGlzLiNhcEJvZHkuc3ViYXJyYXkoMCwgcGF0aEJ5dGVzKSlcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybignRGlzYXNzb2NpYXRpbmcgZmlsZSB3aXRoIGJhZCBkaWdlc3QuJyk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRBc3NvY2lhdGVkUGF0aChzYWgsIHBhdGgsIGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmMgPSB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHBhdGgsIHRoaXMuI2FwQm9keSk7XG4gICAgICAgICAgICBpZiAoSEVBREVSX01BWF9QQVRIX1NJWkUgPD0gZW5jLndyaXR0ZW4gKyAxKSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1BhdGggdG9vIGxvbmc6JywgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNhcEJvZHkuZmlsbCgwLCBlbmMud3JpdHRlbiwgSEVBREVSX01BWF9QQVRIX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy4jZHZCb2R5LnNldFVpbnQzMihIRUFERVJfT0ZGU0VUX0ZMQUdTLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IHRoaXMuY29tcHV0ZURpZ2VzdCh0aGlzLiNhcEJvZHkpO1xuICAgICAgICAgICAgc2FoLndyaXRlKHRoaXMuI2FwQm9keSwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgIHNhaC53cml0ZShkaWdlc3QsIHsgYXQ6IEhFQURFUl9PRkZTRVRfRElHRVNUIH0pO1xuICAgICAgICAgICAgc2FoLmZsdXNoKCk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2V0KHBhdGgsIHNhaCk7XG4gICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoc2FoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguYWRkKHNhaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tcHV0ZURpZ2VzdChieXRlQXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBoMSA9IDB4ZGVhZGJlZWY7XG4gICAgICAgICAgICBsZXQgaDIgPSAweDQxYzZjZTU3O1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJ5dGVBcnJheSkge1xuICAgICAgICAgICAgICBoMSA9IDMxICogaDEgKyB2ICogMzA3O1xuICAgICAgICAgICAgICBoMiA9IDMxICogaDIgKyB2ICogMzA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShbaDEgPj4+IDAsIGgyID4+PiAwXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVzZXQoY2xlYXJGaWxlcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pc1JlYWR5O1xuICAgICAgICAgICAgbGV0IGggPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICAgICAgICAgIGxldCBwcmV2LCBwcmV2TmFtZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZCBvZiB0aGlzLnZmc0Rpci5zcGxpdCgnLycpKSB7XG4gICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGg7XG4gICAgICAgICAgICAgICAgaCA9IGF3YWl0IGguZ2V0RGlyZWN0b3J5SGFuZGxlKGQsIHsgY3JlYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNkaFZmc1Jvb3QgPSBoO1xuICAgICAgICAgICAgdGhpcy4jZGhWZnNQYXJlbnQgPSBwcmV2O1xuICAgICAgICAgICAgdGhpcy4jZGhPcGFxdWUgPSBhd2FpdCB0aGlzLiNkaFZmc1Jvb3QuZ2V0RGlyZWN0b3J5SGFuZGxlKFxuICAgICAgICAgICAgICBPUEFRVUVfRElSX05BTUUsXG4gICAgICAgICAgICAgIHsgY3JlYXRlOiB0cnVlIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlQWNjZXNzSGFuZGxlcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNxdWlyZUFjY2Vzc0hhbmRsZXMoY2xlYXJGaWxlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0UGF0aChhcmcpIHtcbiAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGFyZykpIGFyZyA9IHdhc20uY3N0clRvSnMoYXJnKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGFyZyBpbnN0YW5jZW9mIFVSTCA/IGFyZyA6IG5ldyBVUkwoYXJnLCAnZmlsZTovL2xvY2FsaG9zdC8nKVxuICAgICAgICAgICAgKS5wYXRobmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGVQYXRoKHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhaCA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KHBhdGgpO1xuICAgICAgICAgICAgaWYgKHNhaCkge1xuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIXNhaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdG9yZUVycihlLCBjb2RlKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICBlLnNxbGl0ZTNSYyA9IGNvZGUgfHwgY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRlcnJvciA9IGU7XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3BFcnIoKSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHRoaXMuJGVycm9yO1xuICAgICAgICAgICAgdGhpcy4kZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dEF2YWlsYWJsZVNBSCgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtyY10gPSB0aGlzLiNhdmFpbGFibGVTQUgua2V5cygpO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uZ2V0KHBGaWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmaWxlKSB7XG4gICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICB0aGlzLiNtYXBTM0ZpbGVUb09GaWxlXy5zZXQocEZpbGUsIGZpbGUpO1xuICAgICAgICAgICAgICBzZXRQb29sRm9yUEZpbGUocEZpbGUsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uZGVsZXRlKHBGaWxlKTtcbiAgICAgICAgICAgICAgc2V0UG9vbEZvclBGaWxlKHBGaWxlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzRmlsZW5hbWUobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguaGFzKG5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFNBSEZvclBhdGgocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlbW92ZVZmcygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jY1Zmcy5wb2ludGVyIHx8ICF0aGlzLiNkaE9wYXF1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHRoaXMuI2NWZnMucG9pbnRlcik7XG4gICAgICAgICAgICB0aGlzLiNjVmZzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGhWZnNSb290LnJlbW92ZUVudHJ5KE9QQVFVRV9ESVJfTkFNRSwge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuI2RoT3BhcXVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaFZmc1BhcmVudC5yZW1vdmVFbnRyeSh0aGlzLiNkaFZmc1Jvb3QubmFtZSwge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuI2RoVmZzUm9vdCA9IHRoaXMuI2RoVmZzUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcih0aGlzLnZmc05hbWUsICdyZW1vdmVWZnMoKSBmYWlsZWQ6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRGaWxlKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhaCA9XG4gICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KG5hbWUpIHx8IHRvc3MoJ0ZpbGUgbm90IGZvdW5kOicsIG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbiA9IHNhaC5nZXRTaXplKCkgLSBIRUFERVJfT0ZGU0VUX0RBVEE7XG4gICAgICAgICAgICBjb25zdCBiID0gbmV3IFVpbnQ4QXJyYXkobiA+IDAgPyBuIDogMCk7XG4gICAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgblJlYWQgPSBzYWgucmVhZChiLCB7IGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgfSk7XG4gICAgICAgICAgICAgIGlmIChuUmVhZCAhPSBuKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCB0byByZWFkICcgKyBuICsgJyBieXRlcyBidXQgcmVhZCAnICsgblJlYWQgKyAnLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgaW1wb3J0RGJDaHVua2VkKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBzYWggPVxuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKSB8fFxuICAgICAgICAgICAgICB0aGlzLm5leHRBdmFpbGFibGVTQUgoKSB8fFxuICAgICAgICAgICAgICB0b3NzKCdObyBhdmFpbGFibGUgaGFuZGxlcyB0byBpbXBvcnQgdG8uJyk7XG4gICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICBsZXQgbldyb3RlID0gMCxcbiAgICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aGlsZSAodW5kZWZpbmVkICE9PSAoY2h1bmsgPSBhd2FpdCBjYWxsYmFjaygpKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbldyb3RlICYmIGNodW5rLmJ5dGVMZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhaC53cml0ZShjaHVuaywgeyBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgbldyb3RlIH0pO1xuICAgICAgICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuV3JvdGUgPCA1MTIgfHwgMCAhPT0gbldyb3RlICUgNTEyKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICdJbnB1dCBzaXplJyxcbiAgICAgICAgICAgICAgICAgIG5Xcm90ZSxcbiAgICAgICAgICAgICAgICAgICdpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgyMCk7XG4gICAgICAgICAgICAgICAgc2FoLnJlYWQoaGVhZGVyLCB7IGF0OiAwIH0pO1xuICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsIDFdKSwge1xuICAgICAgICAgICAgICAgIGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyAxOCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgbmFtZSwgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCKTtcbiAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW1wb3J0RGIobmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydERiQ2h1bmtlZChuYW1lLCBieXRlcyk7XG4gICAgICAgICAgICBjb25zdCBzYWggPVxuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKSB8fFxuICAgICAgICAgICAgICB0aGlzLm5leHRBdmFpbGFibGVTQUgoKSB8fFxuICAgICAgICAgICAgICB0b3NzKCdObyBhdmFpbGFibGUgaGFuZGxlcyB0byBpbXBvcnQgdG8uJyk7XG4gICAgICAgICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuIDwgNTEyIHx8IG4gJSA1MTIgIT0gMCkge1xuICAgICAgICAgICAgICB0b3NzKCdCeXRlIGFycmF5IHNpemUgaXMgaW52YWxpZCBmb3IgYW4gU1FMaXRlIGRiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gJ1NRTGl0ZSBmb3JtYXQgMyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoaGVhZGVyLmNoYXJDb2RlQXQoaSkgIT09IGJ5dGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUgZGF0YWJhc2UgaGVhZGVyLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuV3JvdGUgPSBzYWgud3JpdGUoYnl0ZXMsIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSB9KTtcbiAgICAgICAgICAgIGlmIChuV3JvdGUgIT0gbikge1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCB0byB3cml0ZSAnICsgbiArICcgYnl0ZXMgYnV0IHdyb3RlICcgKyBuV3JvdGUgKyAnLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsIDFdKSwge1xuICAgICAgICAgICAgICAgIGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyAxOCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBuYW1lLCBjYXBpLlNRTElURV9PUEVOX01BSU5fREIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5Xcm90ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzcyBPcGZzU0FIUG9vbFV0aWwge1xuICAgICAgICAgICNwO1xuXG4gICAgICAgICAgY29uc3RydWN0b3Ioc2FoUG9vbCkge1xuICAgICAgICAgICAgdGhpcy4jcCA9IHNhaFBvb2w7XG4gICAgICAgICAgICB0aGlzLnZmc05hbWUgPSBzYWhQb29sLnZmc05hbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgYWRkQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuYWRkQ2FwYWNpdHkobik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVkdWNlQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AucmVkdWNlQ2FwYWNpdHkobik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0Q2FwYWNpdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC5nZXRDYXBhY2l0eSh0aGlzLiNwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRGaWxlQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC5nZXRGaWxlQ291bnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0RmlsZU5hbWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZ2V0RmlsZU5hbWVzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVzZXJ2ZU1pbmltdW1DYXBhY2l0eShtaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLiNwLmdldENhcGFjaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gYyA8IG1pbiA/IHRoaXMuI3AuYWRkQ2FwYWNpdHkobWluIC0gYykgOiBjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydEZpbGUobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZXhwb3J0RmlsZShuYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbXBvcnREYihuYW1lLCBieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuaW1wb3J0RGIobmFtZSwgYnl0ZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHdpcGVGaWxlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLnJlc2V0KHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVubGluayhmaWxlbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZGVsZXRlUGF0aChmaWxlbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVtb3ZlVmZzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AucmVtb3ZlVmZzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbkNoZWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRoID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgICAgICAgY29uc3QgZm4gPSAnLm9wZnMtc2FocG9vbC1zeW5jLWNoZWNrLScgKyBnZXRSYW5kb21OYW1lKCk7XG4gICAgICAgICAgY29uc3QgZmggPSBhd2FpdCBkaC5nZXRGaWxlSGFuZGxlKGZuLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCBhaCA9IGF3YWl0IGZoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICBjb25zdCBjbG9zZSA9IGFoLmNsb3NlKCk7XG4gICAgICAgICAgYXdhaXQgY2xvc2U7XG4gICAgICAgICAgYXdhaXQgZGgucmVtb3ZlRW50cnkoZm4pO1xuICAgICAgICAgIGlmIChjbG9zZT8udGhlbikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ1RoZSBsb2NhbCBPUEZTIEFQSSBpcyB0b28gb2xkIGZvciBvcGZzLXNhaHBvb2w6JyxcbiAgICAgICAgICAgICAgJ2l0IGhhcyBhbiBhc3luYyBGaWxlU3lzdGVtU3luY0FjY2Vzc0hhbmRsZS5jbG9zZSgpIG1ldGhvZC4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGluc3RhbmNlQ291bnRlciA9IDA7XG5cbiAgICAgICAgc3FsaXRlMy5pbnN0YWxsT3Bmc1NBSFBvb2xWZnMgPSBhc3luYyBmdW5jdGlvbiAoXG4gICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHZmc05hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9uRGVmYXVsdHMubmFtZTtcbiAgICAgICAgICBpZiAoMCAmJiAyID09PSArK2luc3RhbmNlQ291bnRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKdXN0IHRlc3RpbmcgcmVqZWN0aW9uLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5pdFByb21pc2VzW3Zmc05hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdFByb21pc2VzW3Zmc05hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUucHJvdG90eXBlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgfHxcbiAgICAgICAgICAgICFuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChpbml0UHJvbWlzZXNbdmZzTmFtZV0gPSBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIE9QRlMgQVBJcy4nKSxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gYXBpVmVyc2lvbkNoZWNrKClcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuJHRlc3RUaHJvd0luSW5pdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG9wdGlvbnMuJHRlc3RUaHJvd0luSW5pdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB0aGVQb29sID0gbmV3IE9wZnNTQUhQb29sKG9wdGlvbnMpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhlUG9vbC5pc1JlYWR5XG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcG9vbFV0aWwgPSBuZXcgT3Bmc1NBSFBvb2xVdGlsKHRoZVBvb2wpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNxbGl0ZTMub28xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9vMSA9IHNxbGl0ZTMub28xO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGVWZnMgPSB0aGVQb29sLmdldFZmcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBPcGZzU0FIUG9vbERiID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBvbzEuREIuZGJDdG9ySGVscGVyLm5vcm1hbGl6ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0LnZmcyA9IHRoZVZmcy4kek5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgb28xLkRCLmRiQ3RvckhlbHBlci5jYWxsKHRoaXMsIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIE9wZnNTQUhQb29sRGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvbzEuREIucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICBwb29sVXRpbC5PcGZzU0FIUG9vbERiID0gT3Bmc1NBSFBvb2xEYjtcbiAgICAgICAgICAgICAgICAgICAgb28xLkRCLmRiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlblNxbChcbiAgICAgICAgICAgICAgICAgICAgICB0aGVWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob28xRGIsIHNxbGl0ZTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2V4ZWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9vMURiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByYWdtYSBqb3VybmFsX21vZGU9REVMRVRFOycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByYWdtYSBjYWNoZV9zaXplPS0xNjM4NDsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhlUG9vbC5sb2coJ1ZGUyBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwb29sVXRpbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhlUG9vbC5yZW1vdmVWZnMoKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgU0FCQyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHBvcnRzOlxuICAgICAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdhc21FeHBvcnRzID8gTW9kdWxlWydhc20nXSA6IHdhc21FeHBvcnRzLFxuICAgICAgICAgICAgbWVtb3J5OiBNb2R1bGUud2FzbU1lbW9yeSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fCB7fSxcbiAgICAgICAgKTtcblxuICAgICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgPSBTQUJDO1xuICAgICAgICBsZXQgc3FsaXRlMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzcWxpdGUzID0gZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzQXBpQm9vdHN0cmFwKCkgZXJyb3I6JywgZSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwO1xuICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWc7XG4gICAgICAgIH1cblxuICAgICAgICBNb2R1bGUuc3FsaXRlMyA9IHNxbGl0ZTM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoaXMgaXMgbm90IHJ1bm5pbmcgaW4gYW4gRW1zY3JpcHRlbiBtb2R1bGUgY29udGV4dCwgc28nLFxuICAgICAgICAgICdnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAoKSBpcyBfbm90XyBiZWluZyBjYWxsZWQgZHVlIHRvIGxhY2snLFxuICAgICAgICAgICdvZiBjb25maWcgaW5mbyBmb3IgdGhlIFdBU00gZW52aXJvbm1lbnQuJyxcbiAgICAgICAgICAnSXQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkuJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzcWxpdGUzSW5pdE1vZHVsZS5yZWFkeTtcbiAgfTtcbn0pKCk7XG5cbmNvbnN0IHRvRXhwb3J0Rm9yRVNNID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgb3JpZ2luYWxJbml0ID0gc3FsaXRlM0luaXRNb2R1bGU7XG4gIGlmICghb3JpZ2luYWxJbml0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0V4cGVjdGluZyBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlIHRvIGJlIGRlZmluZWQgYnkgdGhlIEVtc2NyaXB0ZW4gYnVpbGQuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW5pdE1vZHVsZVN0YXRlID0gKGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICB7XG4gICAgICBtb2R1bGVTY3JpcHQ6IGdsb2JhbFRoaXM/LmRvY3VtZW50Py5jdXJyZW50U2NyaXB0LFxuICAgICAgaXNXb3JrZXI6ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUsXG4gICAgICBsb2NhdGlvbjogZ2xvYmFsVGhpcy5sb2NhdGlvbixcbiAgICAgIHVybFBhcmFtczogZ2xvYmFsVGhpcz8ubG9jYXRpb24/LmhyZWZcbiAgICAgICAgPyBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zXG4gICAgICAgIDogbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxuICAgIH0sXG4gICkpO1xuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUgPSBpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcyhcbiAgICAnc3FsaXRlMy5kZWJ1Z01vZHVsZScsXG4gIClcbiAgICA/ICguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4oJ3NxbGl0ZTMuZGVidWdNb2R1bGU6JywgLi4uYXJncylcbiAgICA6ICgpID0+IHt9O1xuXG4gIGlmIChpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcygnc3FsaXRlMy5kaXInKSkge1xuICAgIGluaXRNb2R1bGVTdGF0ZS5zcWxpdGUzRGlyID1cbiAgICAgIGluaXRNb2R1bGVTdGF0ZS51cmxQYXJhbXMuZ2V0KCdzcWxpdGUzLmRpcicpICsgJy8nO1xuICB9IGVsc2UgaWYgKGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQpIHtcbiAgICBjb25zdCBsaSA9IGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQuc3JjLnNwbGl0KCcvJyk7XG4gICAgbGkucG9wKCk7XG4gICAgaW5pdE1vZHVsZVN0YXRlLnNxbGl0ZTNEaXIgPSBsaS5qb2luKCcvJykgKyAnLyc7XG4gIH1cblxuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlID0gZnVuY3Rpb24gZmYoLi4uYXJncykge1xuICAgIHJldHVybiBvcmlnaW5hbEluaXQoLi4uYXJncylcbiAgICAgIC50aGVuKChFbXNjcmlwdGVuTW9kdWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBFbXNjcmlwdGVuTW9kdWxlLnNxbGl0ZTM7XG4gICAgICAgIHMuc2NyaXB0SW5mbyA9IGluaXRNb2R1bGVTdGF0ZTtcblxuICAgICAgICBpZiAoZmYuX19pc1VuZGVyVGVzdCkgcy5fX2lzVW5kZXJUZXN0ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZiA9IHMuYXN5bmNQb3N0SW5pdDtcbiAgICAgICAgZGVsZXRlIHMuYXN5bmNQb3N0SW5pdDtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIGxvYWRpbmcgc3FsaXRlMyBtb2R1bGU6JywgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgfTtcbiAgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZS5yZWFkeSA9IG9yaWdpbmFsSW5pdC5yZWFkeTtcblxuICBpZiAoZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlLm1vZHVsZVNjcmlwdCkge1xuICAgIGNvbnN0IHNpbSA9IGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZTtcbiAgICBsZXQgc3JjID0gc2ltLm1vZHVsZVNjcmlwdC5zcmMuc3BsaXQoJy8nKTtcbiAgICBzcmMucG9wKCk7XG4gICAgc2ltLnNjcmlwdERpciA9IHNyYy5qb2luKCcvJykgKyAnLyc7XG4gIH1cbiAgaW5pdE1vZHVsZVN0YXRlLmRlYnVnTW9kdWxlKCdzcWxpdGUzSW5pdE1vZHVsZVN0YXRlID0nLCBpbml0TW9kdWxlU3RhdGUpO1xuICBpZiAoMCkge1xuICAgIGNvbnNvbGUud2FybignUmVwbGFjZWQgc3FsaXRlM0luaXRNb2R1bGUoKScpO1xuICAgIGNvbnNvbGUud2FybignZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmID0nLCBnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYpO1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGRvY3VtZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA9JyxcbiAgICAgICAgZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQ/LnNyYyxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlO1xufSkoKTtcbnNxbGl0ZTNJbml0TW9kdWxlID0gdG9FeHBvcnRGb3JFU007XG5leHBvcnQgZGVmYXVsdCBzcWxpdGUzSW5pdE1vZHVsZTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiLi9jaHVuay9cIiArIGNodW5rSWQgKyBcIi5cIiArIFwiNjI0MDQwNDQzNzU2ZTQzZjdkOTlcIiArIFwiLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGkgPSBzY3JpcHRzLmxlbmd0aCAtIDE7XG5cdFx0XHR3aGlsZSAoaSA+IC0xICYmICghc2NyaXB0VXJsIHx8ICEvXmh0dHAocz8pOi8udGVzdChzY3JpcHRVcmwpKSkgc2NyaXB0VXJsID0gc2NyaXB0c1tpLS1dLnNyYztcblx0XHR9XG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvXmJsb2I6LywgXCJcIikucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsICsgXCIuLi9cIjsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmIgPSBzZWxmLmxvY2F0aW9uICsgXCIvLi4vLi4vXCI7XG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgY2h1bmtzXG4vLyBcIjFcIiBtZWFucyBcImFscmVhZHkgbG9hZGVkXCJcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwidmVuZG9ycy1ub2RlX21vZHVsZXNfc3FsaXRlX29yZ19zcWxpdGUtd2FzbV9zcWxpdGUtd2FzbV9qc3dhc21fc3FsaXRlMy13b3JrZXIxLWJ1bmRsZXItZnJpZW5kbHlfbWpzXCI6IDFcbn07XG5cbi8vIG5vIGNodW5rIGluc3RhbGwgZnVuY3Rpb24gbmVlZGVkXG4vLyBubyBjaHVuayBsb2FkaW5nXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3QiLCIvKlxuICAyMDIyLTA1LTIzXG5cbiAgVGhlIGF1dGhvciBkaXNjbGFpbXMgY29weXJpZ2h0IHRvIHRoaXMgc291cmNlIGNvZGUuICBJbiBwbGFjZSBvZiBhXG4gIGxlZ2FsIG5vdGljZSwgaGVyZSBpcyBhIGJsZXNzaW5nOlxuXG4gICogICBNYXkgeW91IGRvIGdvb2QgYW5kIG5vdCBldmlsLlxuICAqICAgTWF5IHlvdSBmaW5kIGZvcmdpdmVuZXNzIGZvciB5b3Vyc2VsZiBhbmQgZm9yZ2l2ZSBvdGhlcnMuXG4gICogICBNYXkgeW91IHNoYXJlIGZyZWVseSwgbmV2ZXIgdGFraW5nIG1vcmUgdGhhbiB5b3UgZ2l2ZS5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIFRoaXMgaXMgYSBKUyBXb3JrZXIgZmlsZSBmb3IgdGhlIG1haW4gc3FsaXRlMyBhcGkuIEl0IGxvYWRzXG4gIHNxbGl0ZTMuanMsIGluaXRpYWxpemVzIHRoZSBtb2R1bGUsIGFuZCBwb3N0TWVzc2FnZSgpJ3MgYSBtZXNzYWdlXG4gIGFmdGVyIHRoZSBtb2R1bGUgaXMgaW5pdGlhbGl6ZWQ6XG5cbiAge3R5cGU6ICdzcWxpdGUzLWFwaScsIHJlc3VsdDogJ3dvcmtlcjEtcmVhZHknfVxuXG4gIFRoaXMgc2VlbWluZ2x5IHN1cGVyZmx1b3VzIGxldmVsIG9mIGluZGlyZWN0aW9uIGlzIG5lY2Vzc2FyeSB3aGVuXG4gIGxvYWRpbmcgc3FsaXRlMy5qcyB2aWEgYSBXb3JrZXIuIEluc3RhbnRpYXRpbmcgYSB3b3JrZXIgd2l0aCBuZXdcbiAgV29ya2VyKFwic3FsaXRlLmpzXCIpIHdpbGwgbm90IChjYW5ub3QpIGNhbGwgc3FsaXRlM0luaXRNb2R1bGUoKSB0b1xuICBpbml0aWFsaXplIHRoZSBtb2R1bGUgZHVlIHRvIGEgdGltaW5nL29yZGVyLW9mLW9wZXJhdGlvbnMgY29uZmxpY3RcbiAgKGFuZCB0aGF0IHN5bWJvbCBpcyBub3QgZXhwb3J0ZWQgaW4gYSB3YXkgdGhhdCBhIFdvcmtlciBsb2FkaW5nIGl0XG4gIHRoYXQgd2F5IGNhbiBzZWUgaXQpLiAgVGh1cyBKUyBjb2RlIHdhbnRpbmcgdG8gbG9hZCB0aGUgc3FsaXRlM1xuICBXb3JrZXItc3BlY2lmaWMgQVBJIG5lZWRzIHRvIHBhc3MgX3RoaXNfIGZpbGUgKG9yIGVxdWl2YWxlbnQpIHRvIHRoZVxuICBXb3JrZXIgY29uc3RydWN0b3IgYW5kIHRoZW4gbGlzdGVuIGZvciBhbiBldmVudCBpbiB0aGUgZm9ybSBzaG93blxuICBhYm92ZSBpbiBvcmRlciB0byBrbm93IHdoZW4gdGhlIG1vZHVsZSBoYXMgY29tcGxldGVkIGluaXRpYWxpemF0aW9uLlxuXG4gIFRoaXMgZmlsZSBhY2NlcHRzIGEgVVJMIGFyZ3VtZW50cyB0byBhZGp1c3QgaG93IGl0IGxvYWRzIHNxbGl0ZTMuanM6XG5cbiAgLSBgc3FsaXRlMy5kaXJgLCBpZiBzZXQsIHRyZWF0cyB0aGUgZ2l2ZW4gZGlyZWN0b3J5IG5hbWUgYXMgdGhlXG4gICAgZGlyZWN0b3J5IGZyb20gd2hpY2ggYHNxbGl0ZTMuanNgIHdpbGwgYmUgbG9hZGVkLlxuKi9cbmltcG9ydCB7IGRlZmF1bHQgYXMgc3FsaXRlM0luaXRNb2R1bGUgfSBmcm9tICcuL3NxbGl0ZTMtYnVuZGxlci1mcmllbmRseS5tanMnO1xuc3FsaXRlM0luaXRNb2R1bGUoKS50aGVuKChzcWxpdGUzKSA9PiBzcWxpdGUzLmluaXRXb3JrZXIxQVBJKCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9