(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!*********************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-opfs-async-proxy.js ***!
  \*********************************************************************************************/
__webpack_require__.r(__webpack_exports__);
/*
  2022-09-16

  The author disclaims copyright to this source code.  In place of a
  legal notice, here is a blessing:

  *   May you do good and not evil.
  *   May you find forgiveness for yourself and forgive others.
  *   May you share freely, never taking more than you give.

  ***********************************************************************

  A Worker which manages asynchronous OPFS handles on behalf of a
  synchronous API which controls it via a combination of Worker
  messages, SharedArrayBuffer, and Atomics. It is the asynchronous
  counterpart of the API defined in sqlite3-vfs-opfs.js.

  Highly indebted to:

  https://github.com/rhashimoto/wa-sqlite/blob/master/src/examples/OriginPrivateFileSystemVFS.js

  for demonstrating how to use the OPFS APIs.

  This file is to be loaded as a Worker. It does not have any direct
  access to the sqlite3 JS/WASM bits, so any bits which it needs (most
  notably SQLITE_xxx integer codes) have to be imported into it via an
  initialization process.

  This file represents an implementation detail of a larger piece of
  code, and not a public interface. Its details may change at any time
  and are not intended to be used by any client-level code.

  2022-11-27: Chrome v108 changes some async methods to synchronous, as
  documented at:

  https://developer.chrome.com/blog/sync-methods-for-accesshandles/

  Firefox v111 and Safari 16.4, both released in March 2023, also
  include this.

  We cannot change to the sync forms at this point without breaking
  clients who use Chrome v104-ish or higher. truncate(), getSize(),
  flush(), and close() are now (as of v108) synchronous. Calling them
  with an "await", as we have to for the async forms, is still legal
  with the sync forms but is superfluous. Calling the async forms with
  theFunc().then(...) is not compatible with the change to
  synchronous, but we do do not use those APIs that way. i.e. we don't
  _need_ to change anything for this, but at some point (after Chrome
  versions (approximately) 104-107 are extinct) should change our
  usage of those methods to remove the "await".
*/

const wPost = (type, ...args) => postMessage({ type, payload: args });
const installAsyncProxy = function (self) {
  const toss = function (...args) {
    throw new Error(args.join(' '));
  };
  if (globalThis.window === globalThis) {
    toss(
      'This code cannot run from the main thread.',
      'Load it as a Worker from a separate Worker.',
    );
  } else if (!navigator?.storage?.getDirectory) {
    toss('This API requires navigator.storage.getDirectory.');
  }

  /**
   * Will hold state copied to this object from the syncronous side of
   *      this API.
   */
  const state = Object.create(null);

  /**
   * verbose:
   *
   *      0 = no logging output
   *      1 = only errors
   *      2 = warnings and errors
   *      3 = debug, warnings, and errors
   */
  state.verbose = 1;

  const loggers = {
    0: console.error.bind(console),
    1: console.warn.bind(console),
    2: console.log.bind(console),
  };
  const logImpl = (level, ...args) => {
    if (state.verbose > level) loggers[level]('OPFS asyncer:', ...args);
  };
  const log = (...args) => logImpl(2, ...args);
  const warn = (...args) => logImpl(1, ...args);
  const error = (...args) => logImpl(0, ...args);
  const metrics = Object.create(null);
  metrics.reset = () => {
    let k;
    const r = (m) => (m.count = m.time = m.wait = 0);
    for (k in state.opIds) {
      r((metrics[k] = Object.create(null)));
    }
    let s = (metrics.s11n = Object.create(null));
    s = s.serialize = Object.create(null);
    s.count = s.time = 0;
    s = metrics.s11n.deserialize = Object.create(null);
    s.count = s.time = 0;
  };
  metrics.dump = () => {
    let k,
      n = 0,
      t = 0,
      w = 0;
    for (k in state.opIds) {
      const m = metrics[k];
      n += m.count;
      t += m.time;
      w += m.wait;
      m.avgTime = m.count && m.time ? m.time / m.count : 0;
    }
    console.log(
      globalThis?.location?.href,
      'metrics for',
      globalThis?.location?.href,
      ':\n',
      metrics,
      '\nTotal of',
      n,
      'op(s) for',
      t,
      'ms',
      'approx',
      w,
      'ms spent waiting on OPFS APIs.',
    );
    console.log('Serialization metrics:', metrics.s11n);
  };

  /**
   * __openFiles is a map of sqlite3_file pointers (integers) to
   *      metadata related to a given OPFS file handles. The pointers are, in
   *      this side of the interface, opaque file handle IDs provided by the
   *      synchronous part of this constellation. Each value is an object
   *      with a structure demonstrated in the xOpen() impl.
   */
  const __openFiles = Object.create(null);
  /**
   * __implicitLocks is a Set of sqlite3_file pointers (integers) which were
   *      "auto-locked".  i.e. those for which we obtained a sync access
   *      handle without an explicit xLock() call. Such locks will be
   *      released during db connection idle time, whereas a sync access
   *      handle obtained via xLock(), or subsequently xLock()'d after
   *      auto-acquisition, will not be released until xUnlock() is called.
   *
   *      Maintenance reminder: if we relinquish auto-locks at the end of the
   *      operation which acquires them, we pay a massive performance
   *      penalty: speedtest1 benchmarks take up to 4x as long. By delaying
   *      the lock release until idle time, the hit is negligible.
   */
  const __implicitLocks = new Set();

  /**
   * Expects an OPFS file path. It gets resolved, such that ".."
   *      components are properly expanded, and returned. If the 2nd arg is
   *      true, the result is returned as an array of path elements, else an
   *      absolute path string is returned.
   */
  const getResolvedPath = function (filename, splitIt) {
    const p = new URL(filename, 'file://irrelevant').pathname;
    return splitIt ? p.split('/').filter((v) => !!v) : p;
  };

  /**
   * Takes the absolute path to a filesystem element. Returns an array
   *      of [handleOfContainingDir, filename]. If the 2nd argument is truthy
   *      then each directory element leading to the file is created along
   *      the way. Throws if any creation or resolution fails.
   */
  const getDirForFilename = async function f(absFilename, createDirs = false) {
    const path = getResolvedPath(absFilename, true);
    const filename = path.pop();
    let dh = state.rootDir;
    for (const dirName of path) {
      if (dirName) {
        dh = await dh.getDirectoryHandle(dirName, { create: !!createDirs });
      }
    }
    return [dh, filename];
  };

  /**
   * If the given file-holding object has a sync handle attached to it,
   *      that handle is remove and asynchronously closed. Though it may
   *      sound sensible to continue work as soon as the close() returns
   *      (noting that it's asynchronous), doing so can cause operations
   *      performed soon afterwards, e.g. a call to getSyncHandle() to fail
   *      because they may happen out of order from the close(). OPFS does
   *      not guaranty that the actual order of operations is retained in
   *      such cases. i.e.  always "await" on the result of this function.
   */
  const closeSyncHandle = async (fh) => {
    if (fh.syncHandle) {
      log('Closing sync handle for', fh.filenameAbs);
      const h = fh.syncHandle;
      delete fh.syncHandle;
      delete fh.xLock;
      __implicitLocks.delete(fh.fid);
      return h.close();
    }
  };

  /**
   * A proxy for closeSyncHandle() which is guaranteed to not throw.
   *
   *      This function is part of a lock/unlock step in functions which
   *      require a sync access handle but may be called without xLock()
   *      having been called first. Such calls need to release that
   *      handle to avoid locking the file for all of time. This is an
   *      _attempt_ at reducing cross-tab contention but it may prove
   *      to be more of a problem than a solution and may need to be
   *      removed.
   */
  const closeSyncHandleNoThrow = async (fh) => {
    try {
      await closeSyncHandle(fh);
    } catch (e) {
      warn('closeSyncHandleNoThrow() ignoring:', e, fh);
    }
  };

  /* Release all auto-locks. */
  const releaseImplicitLocks = async () => {
    if (__implicitLocks.size) {
      /* Release all auto-locks. */
      for (const fid of __implicitLocks) {
        const fh = __openFiles[fid];
        await closeSyncHandleNoThrow(fh);
        log('Auto-unlocked', fid, fh.filenameAbs);
      }
    }
  };

  /**
   * An experiment in improving concurrency by freeing up implicit locks
   *      sooner. This is known to impact performance dramatically but it has
   *      also shown to improve concurrency considerably.
   *
   *      If fh.releaseImplicitLocks is truthy and fh is in __implicitLocks,
   *      this routine returns closeSyncHandleNoThrow(), else it is a no-op.
   */
  const releaseImplicitLock = async (fh) => {
    if (fh.releaseImplicitLocks && __implicitLocks.has(fh.fid)) {
      return closeSyncHandleNoThrow(fh);
    }
  };

  /**
   * An error class specifically for use with getSyncHandle(), the goal
   *      of which is to eventually be able to distinguish unambiguously
   *      between locking-related failures and other types, noting that we
   *      cannot currently do so because createSyncAccessHandle() does not
   *      define its exceptions in the required level of detail.
   *
   *      2022-11-29: according to:
   *
   *      https://github.com/whatwg/fs/pull/21
   *
   *      NoModificationAllowedError will be the standard exception thrown
   *      when acquisition of a sync access handle fails due to a locking
   *      error. As of this writing, that error type is not visible in the
   *      dev console in Chrome v109, nor is it documented in MDN, but an
   *      error with that "name" property is being thrown from the OPFS
   *      layer.
   */
  class GetSyncHandleError extends Error {
    constructor(errorObject, ...msg) {
      super(
        [...msg, ': ' + errorObject.name + ':', errorObject.message].join(' '),
        {
          cause: errorObject,
        },
      );
      this.name = 'GetSyncHandleError';
    }
  }
  GetSyncHandleError.convertRc = (e, rc) => {
    if (true) {
      return e instanceof GetSyncHandleError &&
        (e.cause.name === 'NoModificationAllowedError' ||
          /* Inconsistent exception.name from Chrome/ium with the
                 same exception.message text: */
          (e.cause.name === 'DOMException' &&
            0 === e.cause.message.indexOf('Access Handles cannot')))
        ? /*console.warn("SQLITE_BUSY",e),*/
          state.sq3Codes.SQLITE_BUSY
        : rc;
    } else {}
  };
  /**
   * Returns the sync access handle associated with the given file
   *      handle object (which must be a valid handle object, as created by
   *      xOpen()), lazily opening it if needed.
   *
   *      In order to help alleviate cross-tab contention for a dabase, if
   *      an exception is thrown while acquiring the handle, this routine
   *      will wait briefly and try again, up to some fixed number of
   *      times. If acquisition still fails at that point it will give up
   *      and propagate the exception. Client-level code will see that as
   *      an I/O error.
   */
  const getSyncHandle = async (fh, opName) => {
    if (!fh.syncHandle) {
      const t = performance.now();
      log('Acquiring sync handle for', fh.filenameAbs);
      const maxTries = 6,
        msBase = state.asyncIdleWaitTime * 2;
      let i = 1,
        ms = msBase;
      for (; true; ms = msBase * ++i) {
        try {
          //if(i<3) toss("Just testing getSyncHandle() wait-and-retry.");
          //TODO? A config option which tells it to throw here
          //randomly every now and then, for testing purposes.
          fh.syncHandle = await fh.fileHandle.createSyncAccessHandle();
          break;
        } catch (e) {
          if (i === maxTries) {
            throw new GetSyncHandleError(
              e,
              'Error getting sync handle for',
              opName + '().',
              maxTries,
              'attempts failed.',
              fh.filenameAbs,
            );
          }
          warn(
            'Error getting sync handle for',
            opName + '(). Waiting',
            ms,
            'ms and trying again.',
            fh.filenameAbs,
            e,
          );
          Atomics.wait(state.sabOPView, state.opIds.retry, 0, ms);
        }
      }
      log(
        'Got',
        opName + '() sync handle for',
        fh.filenameAbs,
        'in',
        performance.now() - t,
        'ms',
      );
      if (!fh.xLock) {
        __implicitLocks.add(fh.fid);
        log(
          'Acquired implicit lock for',
          opName + '()',
          fh.fid,
          fh.filenameAbs,
        );
      }
    }
    return fh.syncHandle;
  };

  /**
   * Stores the given value at state.sabOPView[state.opIds.rc] and then
   *      Atomics.notify()'s it.
   */
  const storeAndNotify = (opName, value) => {
    log(opName + '() => notify(', value, ')');
    Atomics.store(state.sabOPView, state.opIds.rc, value);
    Atomics.notify(state.sabOPView, state.opIds.rc);
  };

  /** Throws if fh is a file-holding object which is flagged as read-only. */
  const affirmNotRO = function (opName, fh) {
    if (fh.readOnly) toss(opName + '(): File is read-only: ' + fh.filenameAbs);
  };

  /**
   * We track 2 different timers: the "metrics" timer records how much
   *      time we spend performing work. The "wait" timer records how much
   *      time we spend waiting on the underlying OPFS timer. See the calls
   *      to mTimeStart(), mTimeEnd(), wTimeStart(), and wTimeEnd()
   *      throughout this file to see how they're used.
   */
  const __mTimer = Object.create(null);
  __mTimer.op = undefined;
  __mTimer.start = undefined;
  const mTimeStart = (op) => {
    __mTimer.start = performance.now();
    __mTimer.op = op;
    //metrics[op] || toss("Maintenance required: missing metrics for",op);
    ++metrics[op].count;
  };
  const mTimeEnd = () =>
    (metrics[__mTimer.op].time += performance.now() - __mTimer.start);
  const __wTimer = Object.create(null);
  __wTimer.op = undefined;
  __wTimer.start = undefined;
  const wTimeStart = (op) => {
    __wTimer.start = performance.now();
    __wTimer.op = op;
    //metrics[op] || toss("Maintenance required: missing metrics for",op);
  };
  const wTimeEnd = () =>
    (metrics[__wTimer.op].wait += performance.now() - __wTimer.start);

  /**
   * Gets set to true by the 'opfs-async-shutdown' command to quit the
   *      wait loop. This is only intended for debugging purposes: we cannot
   *      inspect this file's state while the tight waitLoop() is running and
   *      need a way to stop that loop for introspection purposes.
   */
  let flagAsyncShutdown = false;

  /**
   * Asynchronous wrappers for sqlite3_vfs and sqlite3_io_methods
   *      methods, as well as helpers like mkdir(). Maintenance reminder:
   *      members are in alphabetical order to simplify finding them.
   */
  const vfsAsyncImpls = {
    'opfs-async-metrics': async () => {
      mTimeStart('opfs-async-metrics');
      metrics.dump();
      storeAndNotify('opfs-async-metrics', 0);
      mTimeEnd();
    },
    'opfs-async-shutdown': async () => {
      flagAsyncShutdown = true;
      storeAndNotify('opfs-async-shutdown', 0);
    },
    mkdir: async (dirname) => {
      mTimeStart('mkdir');
      let rc = 0;
      wTimeStart('mkdir');
      try {
        await getDirForFilename(dirname + '/filepart', true);
      } catch (e) {
        state.s11n.storeException(2, e);
        rc = state.sq3Codes.SQLITE_IOERR;
      } finally {
        wTimeEnd();
      }
      storeAndNotify('mkdir', rc);
      mTimeEnd();
    },
    xAccess: async (filename) => {
      mTimeStart('xAccess');
      /* OPFS cannot support the full range of xAccess() queries
         sqlite3 calls for. We can essentially just tell if the file
         is accessible, but if it is then it's automatically writable
         (unless it's locked, which we cannot(?) know without trying
         to open it). OPFS does not have the notion of read-only.

         The return semantics of this function differ from sqlite3's
         xAccess semantics because we are limited in what we can
         communicate back to our synchronous communication partner: 0 =
         accessible, non-0 means not accessible.
      */
      let rc = 0;
      wTimeStart('xAccess');
      try {
        const [dh, fn] = await getDirForFilename(filename);
        await dh.getFileHandle(fn);
      } catch (e) {
        state.s11n.storeException(2, e);
        rc = state.sq3Codes.SQLITE_IOERR;
      } finally {
        wTimeEnd();
      }
      storeAndNotify('xAccess', rc);
      mTimeEnd();
    },
    xClose: async function (fid /*sqlite3_file pointer*/) {
      const opName = 'xClose';
      mTimeStart(opName);
      __implicitLocks.delete(fid);
      const fh = __openFiles[fid];
      let rc = 0;
      wTimeStart(opName);
      if (fh) {
        delete __openFiles[fid];
        await closeSyncHandle(fh);
        if (fh.deleteOnClose) {
          try {
            await fh.dirHandle.removeEntry(fh.filenamePart);
          } catch (e) {
            warn('Ignoring dirHandle.removeEntry() failure of', fh, e);
          }
        }
      } else {
        state.s11n.serialize();
        rc = state.sq3Codes.SQLITE_NOTFOUND;
      }
      wTimeEnd();
      storeAndNotify(opName, rc);
      mTimeEnd();
    },
    xDelete: async function (...args) {
      mTimeStart('xDelete');
      const rc = await vfsAsyncImpls.xDeleteNoWait(...args);
      storeAndNotify('xDelete', rc);
      mTimeEnd();
    },
    xDeleteNoWait: async function (filename, syncDir = 0, recursive = false) {
      /* The syncDir flag is, for purposes of the VFS API's semantics,
         ignored here. However, if it has the value 0x1234 then: after
         deleting the given file, recursively try to delete any empty
         directories left behind in its wake (ignoring any errors and
         stopping at the first failure).

         That said: we don't know for sure that removeEntry() fails if
         the dir is not empty because the API is not documented. It has,
         however, a "recursive" flag which defaults to false, so
         presumably it will fail if the dir is not empty and that flag
         is false.
      */
      let rc = 0;
      wTimeStart('xDelete');
      try {
        while (filename) {
          const [hDir, filenamePart] = await getDirForFilename(filename, false);
          if (!filenamePart) break;
          await hDir.removeEntry(filenamePart, { recursive });
          if (0x1234 !== syncDir) break;
          recursive = false;
          filename = getResolvedPath(filename, true);
          filename.pop();
          filename = filename.join('/');
        }
      } catch (e) {
        state.s11n.storeException(2, e);
        rc = state.sq3Codes.SQLITE_IOERR_DELETE;
      }
      wTimeEnd();
      return rc;
    },
    xFileSize: async function (fid /*sqlite3_file pointer*/) {
      mTimeStart('xFileSize');
      const fh = __openFiles[fid];
      let rc = 0;
      wTimeStart('xFileSize');
      try {
        const sz = await (await getSyncHandle(fh, 'xFileSize')).getSize();
        state.s11n.serialize(Number(sz));
      } catch (e) {
        state.s11n.storeException(1, e);
        rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR);
      }
      await releaseImplicitLock(fh);
      wTimeEnd();
      storeAndNotify('xFileSize', rc);
      mTimeEnd();
    },
    xLock: async function (
      fid /*sqlite3_file pointer*/,
      lockType /*SQLITE_LOCK_...*/,
    ) {
      mTimeStart('xLock');
      const fh = __openFiles[fid];
      let rc = 0;
      const oldLockType = fh.xLock;
      fh.xLock = lockType;
      if (!fh.syncHandle) {
        wTimeStart('xLock');
        try {
          await getSyncHandle(fh, 'xLock');
          __implicitLocks.delete(fid);
        } catch (e) {
          state.s11n.storeException(1, e);
          rc = GetSyncHandleError.convertRc(
            e,
            state.sq3Codes.SQLITE_IOERR_LOCK,
          );
          fh.xLock = oldLockType;
        }
        wTimeEnd();
      }
      storeAndNotify('xLock', rc);
      mTimeEnd();
    },
    xOpen: async function (
      fid /*sqlite3_file pointer*/,
      filename,
      flags /*SQLITE_OPEN_...*/,
      opfsFlags /*OPFS_...*/,
    ) {
      const opName = 'xOpen';
      mTimeStart(opName);
      const create = state.sq3Codes.SQLITE_OPEN_CREATE & flags;
      wTimeStart('xOpen');
      try {
        let hDir, filenamePart;
        try {
          [hDir, filenamePart] = await getDirForFilename(filename, !!create);
        } catch (e) {
          state.s11n.storeException(1, e);
          storeAndNotify(opName, state.sq3Codes.SQLITE_NOTFOUND);
          mTimeEnd();
          wTimeEnd();
          return;
        }
        const hFile = await hDir.getFileHandle(filenamePart, { create });
        wTimeEnd();
        const fh = Object.assign(Object.create(null), {
          fid: fid,
          filenameAbs: filename,
          filenamePart: filenamePart,
          dirHandle: hDir,
          fileHandle: hFile,
          sabView: state.sabFileBufView,
          readOnly: create
            ? false
            : state.sq3Codes.SQLITE_OPEN_READONLY & flags,
          deleteOnClose: !!(state.sq3Codes.SQLITE_OPEN_DELETEONCLOSE & flags),
        });
        fh.releaseImplicitLocks =
          opfsFlags & state.opfsFlags.OPFS_UNLOCK_ASAP ||
          state.opfsFlags.defaultUnlockAsap;
        if (
          false
        ) {}
        __openFiles[fid] = fh;
        storeAndNotify(opName, 0);
      } catch (e) {
        wTimeEnd();
        error(opName, e);
        state.s11n.storeException(1, e);
        storeAndNotify(opName, state.sq3Codes.SQLITE_IOERR);
      }
      mTimeEnd();
    },
    xRead: async function (fid /*sqlite3_file pointer*/, n, offset64) {
      mTimeStart('xRead');
      let rc = 0,
        nRead;
      const fh = __openFiles[fid];
      try {
        wTimeStart('xRead');
        nRead = (await getSyncHandle(fh, 'xRead')).read(
          fh.sabView.subarray(0, n),
          { at: Number(offset64) },
        );
        wTimeEnd();
        if (nRead < n) {
          /* Zero-fill remaining bytes */
          fh.sabView.fill(0, nRead, n);
          rc = state.sq3Codes.SQLITE_IOERR_SHORT_READ;
        }
      } catch (e) {
        if (undefined === nRead) wTimeEnd();
        error('xRead() failed', e, fh);
        state.s11n.storeException(1, e);
        rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR_READ);
      }
      await releaseImplicitLock(fh);
      storeAndNotify('xRead', rc);
      mTimeEnd();
    },
    xSync: async function (fid /*sqlite3_file pointer*/, flags /*ignored*/) {
      mTimeStart('xSync');
      const fh = __openFiles[fid];
      let rc = 0;
      if (!fh.readOnly && fh.syncHandle) {
        try {
          wTimeStart('xSync');
          await fh.syncHandle.flush();
        } catch (e) {
          state.s11n.storeException(2, e);
          rc = state.sq3Codes.SQLITE_IOERR_FSYNC;
        }
        wTimeEnd();
      }
      storeAndNotify('xSync', rc);
      mTimeEnd();
    },
    xTruncate: async function (fid /*sqlite3_file pointer*/, size) {
      mTimeStart('xTruncate');
      let rc = 0;
      const fh = __openFiles[fid];
      wTimeStart('xTruncate');
      try {
        affirmNotRO('xTruncate', fh);
        await (await getSyncHandle(fh, 'xTruncate')).truncate(size);
      } catch (e) {
        error('xTruncate():', e, fh);
        state.s11n.storeException(2, e);
        rc = GetSyncHandleError.convertRc(
          e,
          state.sq3Codes.SQLITE_IOERR_TRUNCATE,
        );
      }
      await releaseImplicitLock(fh);
      wTimeEnd();
      storeAndNotify('xTruncate', rc);
      mTimeEnd();
    },
    xUnlock: async function (
      fid /*sqlite3_file pointer*/,
      lockType /*SQLITE_LOCK_...*/,
    ) {
      mTimeStart('xUnlock');
      let rc = 0;
      const fh = __openFiles[fid];
      if (state.sq3Codes.SQLITE_LOCK_NONE === lockType && fh.syncHandle) {
        wTimeStart('xUnlock');
        try {
          await closeSyncHandle(fh);
        } catch (e) {
          state.s11n.storeException(1, e);
          rc = state.sq3Codes.SQLITE_IOERR_UNLOCK;
        }
        wTimeEnd();
      }
      storeAndNotify('xUnlock', rc);
      mTimeEnd();
    },
    xWrite: async function (fid /*sqlite3_file pointer*/, n, offset64) {
      mTimeStart('xWrite');
      let rc;
      const fh = __openFiles[fid];
      wTimeStart('xWrite');
      try {
        affirmNotRO('xWrite', fh);
        rc =
          n ===
          (await getSyncHandle(fh, 'xWrite')).write(fh.sabView.subarray(0, n), {
            at: Number(offset64),
          })
            ? 0
            : state.sq3Codes.SQLITE_IOERR_WRITE;
      } catch (e) {
        error('xWrite():', e, fh);
        state.s11n.storeException(1, e);
        rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR_WRITE);
      }
      await releaseImplicitLock(fh);
      wTimeEnd();
      storeAndNotify('xWrite', rc);
      mTimeEnd();
    },
  }; /*vfsAsyncImpls*/

  const initS11n = () => {
    /**
     * ACHTUNG: this code is 100% duplicated in the other half of this
     *        proxy! The documentation is maintained in the "synchronous half".
     */
    if (state.s11n) return state.s11n;
    const textDecoder = new TextDecoder(),
      textEncoder = new TextEncoder('utf-8'),
      viewU8 = new Uint8Array(
        state.sabIO,
        state.sabS11nOffset,
        state.sabS11nSize,
      ),
      viewDV = new DataView(
        state.sabIO,
        state.sabS11nOffset,
        state.sabS11nSize,
      );
    state.s11n = Object.create(null);
    const TypeIds = Object.create(null);
    TypeIds.number = {
      id: 1,
      size: 8,
      getter: 'getFloat64',
      setter: 'setFloat64',
    };
    TypeIds.bigint = {
      id: 2,
      size: 8,
      getter: 'getBigInt64',
      setter: 'setBigInt64',
    };
    TypeIds.boolean = {
      id: 3,
      size: 4,
      getter: 'getInt32',
      setter: 'setInt32',
    };
    TypeIds.string = { id: 4 };
    const getTypeId = (v) =>
      TypeIds[typeof v] ||
      toss('Maintenance required: this value type cannot be serialized.', v);
    const getTypeIdById = (tid) => {
      switch (tid) {
        case TypeIds.number.id:
          return TypeIds.number;
        case TypeIds.bigint.id:
          return TypeIds.bigint;
        case TypeIds.boolean.id:
          return TypeIds.boolean;
        case TypeIds.string.id:
          return TypeIds.string;
        default:
          toss('Invalid type ID:', tid);
      }
    };
    state.s11n.deserialize = function (clear = false) {
      ++metrics.s11n.deserialize.count;
      const t = performance.now();
      const argc = viewU8[0];
      const rc = argc ? [] : null;
      if (argc) {
        const typeIds = [];
        let offset = 1,
          i,
          n,
          v;
        for (i = 0; i < argc; ++i, ++offset) {
          typeIds.push(getTypeIdById(viewU8[offset]));
        }
        for (i = 0; i < argc; ++i) {
          const t = typeIds[i];
          if (t.getter) {
            v = viewDV[t.getter](offset, state.littleEndian);
            offset += t.size;
          } else {
            /*String*/
            n = viewDV.getInt32(offset, state.littleEndian);
            offset += 4;
            v = textDecoder.decode(viewU8.slice(offset, offset + n));
            offset += n;
          }
          rc.push(v);
        }
      }
      if (clear) viewU8[0] = 0;
      //log("deserialize:",argc, rc);
      metrics.s11n.deserialize.time += performance.now() - t;
      return rc;
    };
    state.s11n.serialize = function (...args) {
      const t = performance.now();
      ++metrics.s11n.serialize.count;
      if (args.length) {
        //log("serialize():",args);
        const typeIds = [];
        let i = 0,
          offset = 1;
        viewU8[0] = args.length & 0xff /* header = # of args */;
        for (; i < args.length; ++i, ++offset) {
          /* Write the TypeIds.id value into the next args.length
             bytes. */
          typeIds.push(getTypeId(args[i]));
          viewU8[offset] = typeIds[i].id;
        }
        for (i = 0; i < args.length; ++i) {
          /* Deserialize the following bytes based on their
             corresponding TypeIds.id from the header. */
          const t = typeIds[i];
          if (t.setter) {
            viewDV[t.setter](offset, args[i], state.littleEndian);
            offset += t.size;
          } else {
            /*String*/
            const s = textEncoder.encode(args[i]);
            viewDV.setInt32(offset, s.byteLength, state.littleEndian);
            offset += 4;
            viewU8.set(s, offset);
            offset += s.byteLength;
          }
        }
        //log("serialize() result:",viewU8.slice(0,offset));
      } else {
        viewU8[0] = 0;
      }
      metrics.s11n.serialize.time += performance.now() - t;
    };

    state.s11n.storeException = state.asyncS11nExceptions
      ? (priority, e) => {
          if (priority <= state.asyncS11nExceptions) {
            state.s11n.serialize([e.name, ': ', e.message].join(''));
          }
        }
      : () => {};

    return state.s11n;
  }; /*initS11n()*/

  const waitLoop = async function f() {
    const opHandlers = Object.create(null);
    for (let k of Object.keys(state.opIds)) {
      const vi = vfsAsyncImpls[k];
      if (!vi) continue;
      const o = Object.create(null);
      opHandlers[state.opIds[k]] = o;
      o.key = k;
      o.f = vi;
    }
    while (!flagAsyncShutdown) {
      try {
        if (
          'not-equal' !==
          Atomics.wait(
            state.sabOPView,
            state.opIds.whichOp,
            0,
            state.asyncIdleWaitTime,
          )
        ) {
          /* Maintenance note: we compare against 'not-equal' because

             https://github.com/tomayac/sqlite-wasm/issues/12

             is reporting that this occassionally, under high loads,
             returns 'ok', which leads to the whichOp being 0 (which
             isn't a valid operation ID and leads to an exception,
             along with a corresponding ugly console log
             message). Unfortunately, the conditions for that cannot
             be reliably reproduced. The only place in our code which
             writes a 0 to the state.opIds.whichOp SharedArrayBuffer
             index is a few lines down from here, and that instance
             is required in order for clear communication between
             the sync half of this proxy and this half.
          */
          await releaseImplicitLocks();
          continue;
        }
        const opId = Atomics.load(state.sabOPView, state.opIds.whichOp);
        Atomics.store(state.sabOPView, state.opIds.whichOp, 0);
        const hnd =
          opHandlers[opId] ?? toss('No waitLoop handler for whichOp #', opId);
        const args =
          state.s11n.deserialize(
            true /* clear s11n to keep the caller from confusing this with
                  an exception string written by the upcoming
                  operation */,
          ) || [];
        //warn("waitLoop() whichOp =",opId, hnd, args);
        if (hnd.f) await hnd.f(...args);
        else error('Missing callback for opId', opId);
      } catch (e) {
        error('in waitLoop():', e);
      }
    }
  };

  navigator.storage
    .getDirectory()
    .then(function (d) {
      state.rootDir = d;
      globalThis.onmessage = function ({ data }) {
        switch (data.type) {
          case 'opfs-async-init': {
            /* Receive shared state from synchronous partner */
            const opt = data.args;
            for (const k in opt) state[k] = opt[k];
            state.verbose = opt.verbose ?? 1;
            state.sabOPView = new Int32Array(state.sabOP);
            state.sabFileBufView = new Uint8Array(
              state.sabIO,
              0,
              state.fileBufferSize,
            );
            state.sabS11nView = new Uint8Array(
              state.sabIO,
              state.sabS11nOffset,
              state.sabS11nSize,
            );
            Object.keys(vfsAsyncImpls).forEach((k) => {
              if (!Number.isFinite(state.opIds[k])) {
                toss('Maintenance required: missing state.opIds[', k, ']');
              }
            });
            initS11n();
            metrics.reset();
            log('init state', state);
            wPost('opfs-async-inited');
            waitLoop();
            break;
          }
          case 'opfs-async-restart':
            if (flagAsyncShutdown) {
              warn(
                'Restarting after opfs-async-shutdown. Might or might not work.',
              );
              flagAsyncShutdown = false;
              waitLoop();
            }
            break;
          case 'opfs-async-metrics':
            metrics.dump();
            break;
        }
      };
      wPost('opfs-async-loaded');
    })
    .catch((e) => error('error initializing OPFS asyncer:', e));
}; /*installAsyncProxy()*/
if (!globalThis.SharedArrayBuffer) {
  wPost(
    'opfs-unavailable',
    'Missing SharedArrayBuffer API.',
    'The server must emit the COOP/COEP response headers to enable that.',
  );
} else if (!globalThis.Atomics) {
  wPost(
    'opfs-unavailable',
    'Missing Atomics API.',
    'The server must emit the COOP/COEP response headers to enable that.',
  );
} else if (
  !globalThis.FileSystemHandle ||
  !globalThis.FileSystemDirectoryHandle ||
  !globalThis.FileSystemFileHandle ||
  !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
  !navigator?.storage?.getDirectory
) {
  wPost('opfs-unavailable', 'Missing required OPFS APIs.');
} else {
  installAsyncProxy(self);
}

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jaHVuay92ZW5kb3JzLW5vZGVfbW9kdWxlc19zcWxpdGVfb3JnX3NxbGl0ZS13YXNtX3NxbGl0ZS13YXNtX2pzd2FzbV9zcWxpdGUzLW9wZnMtYXN5bmMtcHJveHlfanMuNjI0MDQwNDQzNzU2ZTQzZjdkOTkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87O1VDVkE7VUFDQTs7Ozs7V0NEQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7OztBQ05BO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYiwrQ0FBK0MscUJBQXFCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNCQUFzQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssRUFFTjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUlrRDtBQUM1RCxVQUFVLEVBUUQ7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1NRTGl0ZS1XZWJDbGllbnQvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1NRTGl0ZS1XZWJDbGllbnQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vU1FMaXRlLVdlYkNsaWVudC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL1NRTGl0ZS1XZWJDbGllbnQvLi9ub2RlX21vZHVsZXMvQHNxbGl0ZS5vcmcvc3FsaXRlLXdhc20vc3FsaXRlLXdhc20vanN3YXNtL3NxbGl0ZTMtb3Bmcy1hc3luYy1wcm94eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgKCkgPT4ge1xucmV0dXJuICIsIi8vIFRoZSByZXF1aXJlIHNjb3BlXG52YXIgX193ZWJwYWNrX3JlcXVpcmVfXyA9IHt9O1xuXG4iLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvKlxuICAyMDIyLTA5LTE2XG5cbiAgVGhlIGF1dGhvciBkaXNjbGFpbXMgY29weXJpZ2h0IHRvIHRoaXMgc291cmNlIGNvZGUuICBJbiBwbGFjZSBvZiBhXG4gIGxlZ2FsIG5vdGljZSwgaGVyZSBpcyBhIGJsZXNzaW5nOlxuXG4gICogICBNYXkgeW91IGRvIGdvb2QgYW5kIG5vdCBldmlsLlxuICAqICAgTWF5IHlvdSBmaW5kIGZvcmdpdmVuZXNzIGZvciB5b3Vyc2VsZiBhbmQgZm9yZ2l2ZSBvdGhlcnMuXG4gICogICBNYXkgeW91IHNoYXJlIGZyZWVseSwgbmV2ZXIgdGFraW5nIG1vcmUgdGhhbiB5b3UgZ2l2ZS5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgV29ya2VyIHdoaWNoIG1hbmFnZXMgYXN5bmNocm9ub3VzIE9QRlMgaGFuZGxlcyBvbiBiZWhhbGYgb2YgYVxuICBzeW5jaHJvbm91cyBBUEkgd2hpY2ggY29udHJvbHMgaXQgdmlhIGEgY29tYmluYXRpb24gb2YgV29ya2VyXG4gIG1lc3NhZ2VzLCBTaGFyZWRBcnJheUJ1ZmZlciwgYW5kIEF0b21pY3MuIEl0IGlzIHRoZSBhc3luY2hyb25vdXNcbiAgY291bnRlcnBhcnQgb2YgdGhlIEFQSSBkZWZpbmVkIGluIHNxbGl0ZTMtdmZzLW9wZnMuanMuXG5cbiAgSGlnaGx5IGluZGVidGVkIHRvOlxuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGFzaGltb3RvL3dhLXNxbGl0ZS9ibG9iL21hc3Rlci9zcmMvZXhhbXBsZXMvT3JpZ2luUHJpdmF0ZUZpbGVTeXN0ZW1WRlMuanNcblxuICBmb3IgZGVtb25zdHJhdGluZyBob3cgdG8gdXNlIHRoZSBPUEZTIEFQSXMuXG5cbiAgVGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZCBhcyBhIFdvcmtlci4gSXQgZG9lcyBub3QgaGF2ZSBhbnkgZGlyZWN0XG4gIGFjY2VzcyB0byB0aGUgc3FsaXRlMyBKUy9XQVNNIGJpdHMsIHNvIGFueSBiaXRzIHdoaWNoIGl0IG5lZWRzIChtb3N0XG4gIG5vdGFibHkgU1FMSVRFX3h4eCBpbnRlZ2VyIGNvZGVzKSBoYXZlIHRvIGJlIGltcG9ydGVkIGludG8gaXQgdmlhIGFuXG4gIGluaXRpYWxpemF0aW9uIHByb2Nlc3MuXG5cbiAgVGhpcyBmaWxlIHJlcHJlc2VudHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGEgbGFyZ2VyIHBpZWNlIG9mXG4gIGNvZGUsIGFuZCBub3QgYSBwdWJsaWMgaW50ZXJmYWNlLiBJdHMgZGV0YWlscyBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG4gIGFuZCBhcmUgbm90IGludGVuZGVkIHRvIGJlIHVzZWQgYnkgYW55IGNsaWVudC1sZXZlbCBjb2RlLlxuXG4gIDIwMjItMTEtMjc6IENocm9tZSB2MTA4IGNoYW5nZXMgc29tZSBhc3luYyBtZXRob2RzIHRvIHN5bmNocm9ub3VzLCBhc1xuICBkb2N1bWVudGVkIGF0OlxuXG4gIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vYmxvZy9zeW5jLW1ldGhvZHMtZm9yLWFjY2Vzc2hhbmRsZXMvXG5cbiAgRmlyZWZveCB2MTExIGFuZCBTYWZhcmkgMTYuNCwgYm90aCByZWxlYXNlZCBpbiBNYXJjaCAyMDIzLCBhbHNvXG4gIGluY2x1ZGUgdGhpcy5cblxuICBXZSBjYW5ub3QgY2hhbmdlIHRvIHRoZSBzeW5jIGZvcm1zIGF0IHRoaXMgcG9pbnQgd2l0aG91dCBicmVha2luZ1xuICBjbGllbnRzIHdobyB1c2UgQ2hyb21lIHYxMDQtaXNoIG9yIGhpZ2hlci4gdHJ1bmNhdGUoKSwgZ2V0U2l6ZSgpLFxuICBmbHVzaCgpLCBhbmQgY2xvc2UoKSBhcmUgbm93IChhcyBvZiB2MTA4KSBzeW5jaHJvbm91cy4gQ2FsbGluZyB0aGVtXG4gIHdpdGggYW4gXCJhd2FpdFwiLCBhcyB3ZSBoYXZlIHRvIGZvciB0aGUgYXN5bmMgZm9ybXMsIGlzIHN0aWxsIGxlZ2FsXG4gIHdpdGggdGhlIHN5bmMgZm9ybXMgYnV0IGlzIHN1cGVyZmx1b3VzLiBDYWxsaW5nIHRoZSBhc3luYyBmb3JtcyB3aXRoXG4gIHRoZUZ1bmMoKS50aGVuKC4uLikgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgY2hhbmdlIHRvXG4gIHN5bmNocm9ub3VzLCBidXQgd2UgZG8gZG8gbm90IHVzZSB0aG9zZSBBUElzIHRoYXQgd2F5LiBpLmUuIHdlIGRvbid0XG4gIF9uZWVkXyB0byBjaGFuZ2UgYW55dGhpbmcgZm9yIHRoaXMsIGJ1dCBhdCBzb21lIHBvaW50IChhZnRlciBDaHJvbWVcbiAgdmVyc2lvbnMgKGFwcHJveGltYXRlbHkpIDEwNC0xMDcgYXJlIGV4dGluY3QpIHNob3VsZCBjaGFuZ2Ugb3VyXG4gIHVzYWdlIG9mIHRob3NlIG1ldGhvZHMgdG8gcmVtb3ZlIHRoZSBcImF3YWl0XCIuXG4qL1xuJ3VzZSBzdHJpY3QnO1xuY29uc3Qgd1Bvc3QgPSAodHlwZSwgLi4uYXJncykgPT4gcG9zdE1lc3NhZ2UoeyB0eXBlLCBwYXlsb2FkOiBhcmdzIH0pO1xuY29uc3QgaW5zdGFsbEFzeW5jUHJveHkgPSBmdW5jdGlvbiAoc2VsZikge1xuICBjb25zdCB0b3NzID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICB9O1xuICBpZiAoZ2xvYmFsVGhpcy53aW5kb3cgPT09IGdsb2JhbFRoaXMpIHtcbiAgICB0b3NzKFxuICAgICAgJ1RoaXMgY29kZSBjYW5ub3QgcnVuIGZyb20gdGhlIG1haW4gdGhyZWFkLicsXG4gICAgICAnTG9hZCBpdCBhcyBhIFdvcmtlciBmcm9tIGEgc2VwYXJhdGUgV29ya2VyLicsXG4gICAgKTtcbiAgfSBlbHNlIGlmICghbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3RvcnkpIHtcbiAgICB0b3NzKCdUaGlzIEFQSSByZXF1aXJlcyBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkuJyk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBob2xkIHN0YXRlIGNvcGllZCB0byB0aGlzIG9iamVjdCBmcm9tIHRoZSBzeW5jcm9ub3VzIHNpZGUgb2ZcbiAgICogICAgICB0aGlzIEFQSS5cbiAgICovXG4gIGNvbnN0IHN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvKipcbiAgICogdmVyYm9zZTpcbiAgICpcbiAgICogICAgICAwID0gbm8gbG9nZ2luZyBvdXRwdXRcbiAgICogICAgICAxID0gb25seSBlcnJvcnNcbiAgICogICAgICAyID0gd2FybmluZ3MgYW5kIGVycm9yc1xuICAgKiAgICAgIDMgPSBkZWJ1Zywgd2FybmluZ3MsIGFuZCBlcnJvcnNcbiAgICovXG4gIHN0YXRlLnZlcmJvc2UgPSAxO1xuXG4gIGNvbnN0IGxvZ2dlcnMgPSB7XG4gICAgMDogY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLFxuICAgIDE6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpLFxuICAgIDI6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gIH07XG4gIGNvbnN0IGxvZ0ltcGwgPSAobGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoc3RhdGUudmVyYm9zZSA+IGxldmVsKSBsb2dnZXJzW2xldmVsXSgnT1BGUyBhc3luY2VyOicsIC4uLmFyZ3MpO1xuICB9O1xuICBjb25zdCBsb2cgPSAoLi4uYXJncykgPT4gbG9nSW1wbCgyLCAuLi5hcmdzKTtcbiAgY29uc3Qgd2FybiA9ICguLi5hcmdzKSA9PiBsb2dJbXBsKDEsIC4uLmFyZ3MpO1xuICBjb25zdCBlcnJvciA9ICguLi5hcmdzKSA9PiBsb2dJbXBsKDAsIC4uLmFyZ3MpO1xuICBjb25zdCBtZXRyaWNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbWV0cmljcy5yZXNldCA9ICgpID0+IHtcbiAgICBsZXQgaztcbiAgICBjb25zdCByID0gKG0pID0+IChtLmNvdW50ID0gbS50aW1lID0gbS53YWl0ID0gMCk7XG4gICAgZm9yIChrIGluIHN0YXRlLm9wSWRzKSB7XG4gICAgICByKChtZXRyaWNzW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgIH1cbiAgICBsZXQgcyA9IChtZXRyaWNzLnMxMW4gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBzID0gcy5zZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICAgIHMgPSBtZXRyaWNzLnMxMW4uZGVzZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICB9O1xuICBtZXRyaWNzLmR1bXAgPSAoKSA9PiB7XG4gICAgbGV0IGssXG4gICAgICBuID0gMCxcbiAgICAgIHQgPSAwLFxuICAgICAgdyA9IDA7XG4gICAgZm9yIChrIGluIHN0YXRlLm9wSWRzKSB7XG4gICAgICBjb25zdCBtID0gbWV0cmljc1trXTtcbiAgICAgIG4gKz0gbS5jb3VudDtcbiAgICAgIHQgKz0gbS50aW1lO1xuICAgICAgdyArPSBtLndhaXQ7XG4gICAgICBtLmF2Z1RpbWUgPSBtLmNvdW50ICYmIG0udGltZSA/IG0udGltZSAvIG0uY291bnQgOiAwO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGdsb2JhbFRoaXM/LmxvY2F0aW9uPy5ocmVmLFxuICAgICAgJ21ldHJpY3MgZm9yJyxcbiAgICAgIGdsb2JhbFRoaXM/LmxvY2F0aW9uPy5ocmVmLFxuICAgICAgJzpcXG4nLFxuICAgICAgbWV0cmljcyxcbiAgICAgICdcXG5Ub3RhbCBvZicsXG4gICAgICBuLFxuICAgICAgJ29wKHMpIGZvcicsXG4gICAgICB0LFxuICAgICAgJ21zJyxcbiAgICAgICdhcHByb3gnLFxuICAgICAgdyxcbiAgICAgICdtcyBzcGVudCB3YWl0aW5nIG9uIE9QRlMgQVBJcy4nLFxuICAgICk7XG4gICAgY29uc29sZS5sb2coJ1NlcmlhbGl6YXRpb24gbWV0cmljczonLCBtZXRyaWNzLnMxMW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfX29wZW5GaWxlcyBpcyBhIG1hcCBvZiBzcWxpdGUzX2ZpbGUgcG9pbnRlcnMgKGludGVnZXJzKSB0b1xuICAgKiAgICAgIG1ldGFkYXRhIHJlbGF0ZWQgdG8gYSBnaXZlbiBPUEZTIGZpbGUgaGFuZGxlcy4gVGhlIHBvaW50ZXJzIGFyZSwgaW5cbiAgICogICAgICB0aGlzIHNpZGUgb2YgdGhlIGludGVyZmFjZSwgb3BhcXVlIGZpbGUgaGFuZGxlIElEcyBwcm92aWRlZCBieSB0aGVcbiAgICogICAgICBzeW5jaHJvbm91cyBwYXJ0IG9mIHRoaXMgY29uc3RlbGxhdGlvbi4gRWFjaCB2YWx1ZSBpcyBhbiBvYmplY3RcbiAgICogICAgICB3aXRoIGEgc3RydWN0dXJlIGRlbW9uc3RyYXRlZCBpbiB0aGUgeE9wZW4oKSBpbXBsLlxuICAgKi9cbiAgY29uc3QgX19vcGVuRmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvKipcbiAgICogX19pbXBsaWNpdExvY2tzIGlzIGEgU2V0IG9mIHNxbGl0ZTNfZmlsZSBwb2ludGVycyAoaW50ZWdlcnMpIHdoaWNoIHdlcmVcbiAgICogICAgICBcImF1dG8tbG9ja2VkXCIuICBpLmUuIHRob3NlIGZvciB3aGljaCB3ZSBvYnRhaW5lZCBhIHN5bmMgYWNjZXNzXG4gICAqICAgICAgaGFuZGxlIHdpdGhvdXQgYW4gZXhwbGljaXQgeExvY2soKSBjYWxsLiBTdWNoIGxvY2tzIHdpbGwgYmVcbiAgICogICAgICByZWxlYXNlZCBkdXJpbmcgZGIgY29ubmVjdGlvbiBpZGxlIHRpbWUsIHdoZXJlYXMgYSBzeW5jIGFjY2Vzc1xuICAgKiAgICAgIGhhbmRsZSBvYnRhaW5lZCB2aWEgeExvY2soKSwgb3Igc3Vic2VxdWVudGx5IHhMb2NrKCknZCBhZnRlclxuICAgKiAgICAgIGF1dG8tYWNxdWlzaXRpb24sIHdpbGwgbm90IGJlIHJlbGVhc2VkIHVudGlsIHhVbmxvY2soKSBpcyBjYWxsZWQuXG4gICAqXG4gICAqICAgICAgTWFpbnRlbmFuY2UgcmVtaW5kZXI6IGlmIHdlIHJlbGlucXVpc2ggYXV0by1sb2NrcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgKiAgICAgIG9wZXJhdGlvbiB3aGljaCBhY3F1aXJlcyB0aGVtLCB3ZSBwYXkgYSBtYXNzaXZlIHBlcmZvcm1hbmNlXG4gICAqICAgICAgcGVuYWx0eTogc3BlZWR0ZXN0MSBiZW5jaG1hcmtzIHRha2UgdXAgdG8gNHggYXMgbG9uZy4gQnkgZGVsYXlpbmdcbiAgICogICAgICB0aGUgbG9jayByZWxlYXNlIHVudGlsIGlkbGUgdGltZSwgdGhlIGhpdCBpcyBuZWdsaWdpYmxlLlxuICAgKi9cbiAgY29uc3QgX19pbXBsaWNpdExvY2tzID0gbmV3IFNldCgpO1xuXG4gIC8qKlxuICAgKiBFeHBlY3RzIGFuIE9QRlMgZmlsZSBwYXRoLiBJdCBnZXRzIHJlc29sdmVkLCBzdWNoIHRoYXQgXCIuLlwiXG4gICAqICAgICAgY29tcG9uZW50cyBhcmUgcHJvcGVybHkgZXhwYW5kZWQsIGFuZCByZXR1cm5lZC4gSWYgdGhlIDJuZCBhcmcgaXNcbiAgICogICAgICB0cnVlLCB0aGUgcmVzdWx0IGlzIHJldHVybmVkIGFzIGFuIGFycmF5IG9mIHBhdGggZWxlbWVudHMsIGVsc2UgYW5cbiAgICogICAgICBhYnNvbHV0ZSBwYXRoIHN0cmluZyBpcyByZXR1cm5lZC5cbiAgICovXG4gIGNvbnN0IGdldFJlc29sdmVkUGF0aCA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgc3BsaXRJdCkge1xuICAgIGNvbnN0IHAgPSBuZXcgVVJMKGZpbGVuYW1lLCAnZmlsZTovL2lycmVsZXZhbnQnKS5wYXRobmFtZTtcbiAgICByZXR1cm4gc3BsaXRJdCA/IHAuc3BsaXQoJy8nKS5maWx0ZXIoKHYpID0+ICEhdikgOiBwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgYWJzb2x1dGUgcGF0aCB0byBhIGZpbGVzeXN0ZW0gZWxlbWVudC4gUmV0dXJucyBhbiBhcnJheVxuICAgKiAgICAgIG9mIFtoYW5kbGVPZkNvbnRhaW5pbmdEaXIsIGZpbGVuYW1lXS4gSWYgdGhlIDJuZCBhcmd1bWVudCBpcyB0cnV0aHlcbiAgICogICAgICB0aGVuIGVhY2ggZGlyZWN0b3J5IGVsZW1lbnQgbGVhZGluZyB0byB0aGUgZmlsZSBpcyBjcmVhdGVkIGFsb25nXG4gICAqICAgICAgdGhlIHdheS4gVGhyb3dzIGlmIGFueSBjcmVhdGlvbiBvciByZXNvbHV0aW9uIGZhaWxzLlxuICAgKi9cbiAgY29uc3QgZ2V0RGlyRm9yRmlsZW5hbWUgPSBhc3luYyBmdW5jdGlvbiBmKGFic0ZpbGVuYW1lLCBjcmVhdGVEaXJzID0gZmFsc2UpIHtcbiAgICBjb25zdCBwYXRoID0gZ2V0UmVzb2x2ZWRQYXRoKGFic0ZpbGVuYW1lLCB0cnVlKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGgucG9wKCk7XG4gICAgbGV0IGRoID0gc3RhdGUucm9vdERpcjtcbiAgICBmb3IgKGNvbnN0IGRpck5hbWUgb2YgcGF0aCkge1xuICAgICAgaWYgKGRpck5hbWUpIHtcbiAgICAgICAgZGggPSBhd2FpdCBkaC5nZXREaXJlY3RvcnlIYW5kbGUoZGlyTmFtZSwgeyBjcmVhdGU6ICEhY3JlYXRlRGlycyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtkaCwgZmlsZW5hbWVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgZ2l2ZW4gZmlsZS1ob2xkaW5nIG9iamVjdCBoYXMgYSBzeW5jIGhhbmRsZSBhdHRhY2hlZCB0byBpdCxcbiAgICogICAgICB0aGF0IGhhbmRsZSBpcyByZW1vdmUgYW5kIGFzeW5jaHJvbm91c2x5IGNsb3NlZC4gVGhvdWdoIGl0IG1heVxuICAgKiAgICAgIHNvdW5kIHNlbnNpYmxlIHRvIGNvbnRpbnVlIHdvcmsgYXMgc29vbiBhcyB0aGUgY2xvc2UoKSByZXR1cm5zXG4gICAqICAgICAgKG5vdGluZyB0aGF0IGl0J3MgYXN5bmNocm9ub3VzKSwgZG9pbmcgc28gY2FuIGNhdXNlIG9wZXJhdGlvbnNcbiAgICogICAgICBwZXJmb3JtZWQgc29vbiBhZnRlcndhcmRzLCBlLmcuIGEgY2FsbCB0byBnZXRTeW5jSGFuZGxlKCkgdG8gZmFpbFxuICAgKiAgICAgIGJlY2F1c2UgdGhleSBtYXkgaGFwcGVuIG91dCBvZiBvcmRlciBmcm9tIHRoZSBjbG9zZSgpLiBPUEZTIGRvZXNcbiAgICogICAgICBub3QgZ3VhcmFudHkgdGhhdCB0aGUgYWN0dWFsIG9yZGVyIG9mIG9wZXJhdGlvbnMgaXMgcmV0YWluZWQgaW5cbiAgICogICAgICBzdWNoIGNhc2VzLiBpLmUuICBhbHdheXMgXCJhd2FpdFwiIG9uIHRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0IGNsb3NlU3luY0hhbmRsZSA9IGFzeW5jIChmaCkgPT4ge1xuICAgIGlmIChmaC5zeW5jSGFuZGxlKSB7XG4gICAgICBsb2coJ0Nsb3Npbmcgc3luYyBoYW5kbGUgZm9yJywgZmguZmlsZW5hbWVBYnMpO1xuICAgICAgY29uc3QgaCA9IGZoLnN5bmNIYW5kbGU7XG4gICAgICBkZWxldGUgZmguc3luY0hhbmRsZTtcbiAgICAgIGRlbGV0ZSBmaC54TG9jaztcbiAgICAgIF9faW1wbGljaXRMb2Nrcy5kZWxldGUoZmguZmlkKTtcbiAgICAgIHJldHVybiBoLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHByb3h5IGZvciBjbG9zZVN5bmNIYW5kbGUoKSB3aGljaCBpcyBndWFyYW50ZWVkIHRvIG5vdCB0aHJvdy5cbiAgICpcbiAgICogICAgICBUaGlzIGZ1bmN0aW9uIGlzIHBhcnQgb2YgYSBsb2NrL3VubG9jayBzdGVwIGluIGZ1bmN0aW9ucyB3aGljaFxuICAgKiAgICAgIHJlcXVpcmUgYSBzeW5jIGFjY2VzcyBoYW5kbGUgYnV0IG1heSBiZSBjYWxsZWQgd2l0aG91dCB4TG9jaygpXG4gICAqICAgICAgaGF2aW5nIGJlZW4gY2FsbGVkIGZpcnN0LiBTdWNoIGNhbGxzIG5lZWQgdG8gcmVsZWFzZSB0aGF0XG4gICAqICAgICAgaGFuZGxlIHRvIGF2b2lkIGxvY2tpbmcgdGhlIGZpbGUgZm9yIGFsbCBvZiB0aW1lLiBUaGlzIGlzIGFuXG4gICAqICAgICAgX2F0dGVtcHRfIGF0IHJlZHVjaW5nIGNyb3NzLXRhYiBjb250ZW50aW9uIGJ1dCBpdCBtYXkgcHJvdmVcbiAgICogICAgICB0byBiZSBtb3JlIG9mIGEgcHJvYmxlbSB0aGFuIGEgc29sdXRpb24gYW5kIG1heSBuZWVkIHRvIGJlXG4gICAqICAgICAgcmVtb3ZlZC5cbiAgICovXG4gIGNvbnN0IGNsb3NlU3luY0hhbmRsZU5vVGhyb3cgPSBhc3luYyAoZmgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2xvc2VTeW5jSGFuZGxlKGZoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdjbG9zZVN5bmNIYW5kbGVOb1Rocm93KCkgaWdub3Jpbmc6JywgZSwgZmgpO1xuICAgIH1cbiAgfTtcblxuICAvKiBSZWxlYXNlIGFsbCBhdXRvLWxvY2tzLiAqL1xuICBjb25zdCByZWxlYXNlSW1wbGljaXRMb2NrcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoX19pbXBsaWNpdExvY2tzLnNpemUpIHtcbiAgICAgIC8qIFJlbGVhc2UgYWxsIGF1dG8tbG9ja3MuICovXG4gICAgICBmb3IgKGNvbnN0IGZpZCBvZiBfX2ltcGxpY2l0TG9ja3MpIHtcbiAgICAgICAgY29uc3QgZmggPSBfX29wZW5GaWxlc1tmaWRdO1xuICAgICAgICBhd2FpdCBjbG9zZVN5bmNIYW5kbGVOb1Rocm93KGZoKTtcbiAgICAgICAgbG9nKCdBdXRvLXVubG9ja2VkJywgZmlkLCBmaC5maWxlbmFtZUFicyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBbiBleHBlcmltZW50IGluIGltcHJvdmluZyBjb25jdXJyZW5jeSBieSBmcmVlaW5nIHVwIGltcGxpY2l0IGxvY2tzXG4gICAqICAgICAgc29vbmVyLiBUaGlzIGlzIGtub3duIHRvIGltcGFjdCBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnV0IGl0IGhhc1xuICAgKiAgICAgIGFsc28gc2hvd24gdG8gaW1wcm92ZSBjb25jdXJyZW5jeSBjb25zaWRlcmFibHkuXG4gICAqXG4gICAqICAgICAgSWYgZmgucmVsZWFzZUltcGxpY2l0TG9ja3MgaXMgdHJ1dGh5IGFuZCBmaCBpcyBpbiBfX2ltcGxpY2l0TG9ja3MsXG4gICAqICAgICAgdGhpcyByb3V0aW5lIHJldHVybnMgY2xvc2VTeW5jSGFuZGxlTm9UaHJvdygpLCBlbHNlIGl0IGlzIGEgbm8tb3AuXG4gICAqL1xuICBjb25zdCByZWxlYXNlSW1wbGljaXRMb2NrID0gYXN5bmMgKGZoKSA9PiB7XG4gICAgaWYgKGZoLnJlbGVhc2VJbXBsaWNpdExvY2tzICYmIF9faW1wbGljaXRMb2Nrcy5oYXMoZmguZmlkKSkge1xuICAgICAgcmV0dXJuIGNsb3NlU3luY0hhbmRsZU5vVGhyb3coZmgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQW4gZXJyb3IgY2xhc3Mgc3BlY2lmaWNhbGx5IGZvciB1c2Ugd2l0aCBnZXRTeW5jSGFuZGxlKCksIHRoZSBnb2FsXG4gICAqICAgICAgb2Ygd2hpY2ggaXMgdG8gZXZlbnR1YWxseSBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIHVuYW1iaWd1b3VzbHlcbiAgICogICAgICBiZXR3ZWVuIGxvY2tpbmctcmVsYXRlZCBmYWlsdXJlcyBhbmQgb3RoZXIgdHlwZXMsIG5vdGluZyB0aGF0IHdlXG4gICAqICAgICAgY2Fubm90IGN1cnJlbnRseSBkbyBzbyBiZWNhdXNlIGNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKSBkb2VzIG5vdFxuICAgKiAgICAgIGRlZmluZSBpdHMgZXhjZXB0aW9ucyBpbiB0aGUgcmVxdWlyZWQgbGV2ZWwgb2YgZGV0YWlsLlxuICAgKlxuICAgKiAgICAgIDIwMjItMTEtMjk6IGFjY29yZGluZyB0bzpcbiAgICpcbiAgICogICAgICBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZzL3B1bGwvMjFcbiAgICpcbiAgICogICAgICBOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciB3aWxsIGJlIHRoZSBzdGFuZGFyZCBleGNlcHRpb24gdGhyb3duXG4gICAqICAgICAgd2hlbiBhY3F1aXNpdGlvbiBvZiBhIHN5bmMgYWNjZXNzIGhhbmRsZSBmYWlscyBkdWUgdG8gYSBsb2NraW5nXG4gICAqICAgICAgZXJyb3IuIEFzIG9mIHRoaXMgd3JpdGluZywgdGhhdCBlcnJvciB0eXBlIGlzIG5vdCB2aXNpYmxlIGluIHRoZVxuICAgKiAgICAgIGRldiBjb25zb2xlIGluIENocm9tZSB2MTA5LCBub3IgaXMgaXQgZG9jdW1lbnRlZCBpbiBNRE4sIGJ1dCBhblxuICAgKiAgICAgIGVycm9yIHdpdGggdGhhdCBcIm5hbWVcIiBwcm9wZXJ0eSBpcyBiZWluZyB0aHJvd24gZnJvbSB0aGUgT1BGU1xuICAgKiAgICAgIGxheWVyLlxuICAgKi9cbiAgY2xhc3MgR2V0U3luY0hhbmRsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9yT2JqZWN0LCAuLi5tc2cpIHtcbiAgICAgIHN1cGVyKFxuICAgICAgICBbLi4ubXNnLCAnOiAnICsgZXJyb3JPYmplY3QubmFtZSArICc6JywgZXJyb3JPYmplY3QubWVzc2FnZV0uam9pbignICcpLFxuICAgICAgICB7XG4gICAgICAgICAgY2F1c2U6IGVycm9yT2JqZWN0LFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIHRoaXMubmFtZSA9ICdHZXRTeW5jSGFuZGxlRXJyb3InO1xuICAgIH1cbiAgfVxuICBHZXRTeW5jSGFuZGxlRXJyb3IuY29udmVydFJjID0gKGUsIHJjKSA9PiB7XG4gICAgaWYgKDEpIHtcbiAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgR2V0U3luY0hhbmRsZUVycm9yICYmXG4gICAgICAgIChlLmNhdXNlLm5hbWUgPT09ICdOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvcicgfHxcbiAgICAgICAgICAvKiBJbmNvbnNpc3RlbnQgZXhjZXB0aW9uLm5hbWUgZnJvbSBDaHJvbWUvaXVtIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgIHNhbWUgZXhjZXB0aW9uLm1lc3NhZ2UgdGV4dDogKi9cbiAgICAgICAgICAoZS5jYXVzZS5uYW1lID09PSAnRE9NRXhjZXB0aW9uJyAmJlxuICAgICAgICAgICAgMCA9PT0gZS5jYXVzZS5tZXNzYWdlLmluZGV4T2YoJ0FjY2VzcyBIYW5kbGVzIGNhbm5vdCcpKSlcbiAgICAgICAgPyAvKmNvbnNvbGUud2FybihcIlNRTElURV9CVVNZXCIsZSksKi9cbiAgICAgICAgICBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfQlVTWVxuICAgICAgICA6IHJjO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3luYyBhY2Nlc3MgaGFuZGxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZmlsZVxuICAgKiAgICAgIGhhbmRsZSBvYmplY3QgKHdoaWNoIG11c3QgYmUgYSB2YWxpZCBoYW5kbGUgb2JqZWN0LCBhcyBjcmVhdGVkIGJ5XG4gICAqICAgICAgeE9wZW4oKSksIGxhemlseSBvcGVuaW5nIGl0IGlmIG5lZWRlZC5cbiAgICpcbiAgICogICAgICBJbiBvcmRlciB0byBoZWxwIGFsbGV2aWF0ZSBjcm9zcy10YWIgY29udGVudGlvbiBmb3IgYSBkYWJhc2UsIGlmXG4gICAqICAgICAgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBhY3F1aXJpbmcgdGhlIGhhbmRsZSwgdGhpcyByb3V0aW5lXG4gICAqICAgICAgd2lsbCB3YWl0IGJyaWVmbHkgYW5kIHRyeSBhZ2FpbiwgdXAgdG8gc29tZSBmaXhlZCBudW1iZXIgb2ZcbiAgICogICAgICB0aW1lcy4gSWYgYWNxdWlzaXRpb24gc3RpbGwgZmFpbHMgYXQgdGhhdCBwb2ludCBpdCB3aWxsIGdpdmUgdXBcbiAgICogICAgICBhbmQgcHJvcGFnYXRlIHRoZSBleGNlcHRpb24uIENsaWVudC1sZXZlbCBjb2RlIHdpbGwgc2VlIHRoYXQgYXNcbiAgICogICAgICBhbiBJL08gZXJyb3IuXG4gICAqL1xuICBjb25zdCBnZXRTeW5jSGFuZGxlID0gYXN5bmMgKGZoLCBvcE5hbWUpID0+IHtcbiAgICBpZiAoIWZoLnN5bmNIYW5kbGUpIHtcbiAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGxvZygnQWNxdWlyaW5nIHN5bmMgaGFuZGxlIGZvcicsIGZoLmZpbGVuYW1lQWJzKTtcbiAgICAgIGNvbnN0IG1heFRyaWVzID0gNixcbiAgICAgICAgbXNCYXNlID0gc3RhdGUuYXN5bmNJZGxlV2FpdFRpbWUgKiAyO1xuICAgICAgbGV0IGkgPSAxLFxuICAgICAgICBtcyA9IG1zQmFzZTtcbiAgICAgIGZvciAoOyB0cnVlOyBtcyA9IG1zQmFzZSAqICsraSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vaWYoaTwzKSB0b3NzKFwiSnVzdCB0ZXN0aW5nIGdldFN5bmNIYW5kbGUoKSB3YWl0LWFuZC1yZXRyeS5cIik7XG4gICAgICAgICAgLy9UT0RPPyBBIGNvbmZpZyBvcHRpb24gd2hpY2ggdGVsbHMgaXQgdG8gdGhyb3cgaGVyZVxuICAgICAgICAgIC8vcmFuZG9tbHkgZXZlcnkgbm93IGFuZCB0aGVuLCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgICAgICBmaC5zeW5jSGFuZGxlID0gYXdhaXQgZmguZmlsZUhhbmRsZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gbWF4VHJpZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHZXRTeW5jSGFuZGxlRXJyb3IoXG4gICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICdFcnJvciBnZXR0aW5nIHN5bmMgaGFuZGxlIGZvcicsXG4gICAgICAgICAgICAgIG9wTmFtZSArICcoKS4nLFxuICAgICAgICAgICAgICBtYXhUcmllcyxcbiAgICAgICAgICAgICAgJ2F0dGVtcHRzIGZhaWxlZC4nLFxuICAgICAgICAgICAgICBmaC5maWxlbmFtZUFicyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnRXJyb3IgZ2V0dGluZyBzeW5jIGhhbmRsZSBmb3InLFxuICAgICAgICAgICAgb3BOYW1lICsgJygpLiBXYWl0aW5nJyxcbiAgICAgICAgICAgIG1zLFxuICAgICAgICAgICAgJ21zIGFuZCB0cnlpbmcgYWdhaW4uJyxcbiAgICAgICAgICAgIGZoLmZpbGVuYW1lQWJzLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIEF0b21pY3Mud2FpdChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJldHJ5LCAwLCBtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxvZyhcbiAgICAgICAgJ0dvdCcsXG4gICAgICAgIG9wTmFtZSArICcoKSBzeW5jIGhhbmRsZSBmb3InLFxuICAgICAgICBmaC5maWxlbmFtZUFicyxcbiAgICAgICAgJ2luJyxcbiAgICAgICAgcGVyZm9ybWFuY2Uubm93KCkgLSB0LFxuICAgICAgICAnbXMnLFxuICAgICAgKTtcbiAgICAgIGlmICghZmgueExvY2spIHtcbiAgICAgICAgX19pbXBsaWNpdExvY2tzLmFkZChmaC5maWQpO1xuICAgICAgICBsb2coXG4gICAgICAgICAgJ0FjcXVpcmVkIGltcGxpY2l0IGxvY2sgZm9yJyxcbiAgICAgICAgICBvcE5hbWUgKyAnKCknLFxuICAgICAgICAgIGZoLmZpZCxcbiAgICAgICAgICBmaC5maWxlbmFtZUFicyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZoLnN5bmNIYW5kbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gdmFsdWUgYXQgc3RhdGUuc2FiT1BWaWV3W3N0YXRlLm9wSWRzLnJjXSBhbmQgdGhlblxuICAgKiAgICAgIEF0b21pY3Mubm90aWZ5KCkncyBpdC5cbiAgICovXG4gIGNvbnN0IHN0b3JlQW5kTm90aWZ5ID0gKG9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICBsb2cob3BOYW1lICsgJygpID0+IG5vdGlmeSgnLCB2YWx1ZSwgJyknKTtcbiAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIHZhbHVlKTtcbiAgICBBdG9taWNzLm5vdGlmeShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJjKTtcbiAgfTtcblxuICAvKiogVGhyb3dzIGlmIGZoIGlzIGEgZmlsZS1ob2xkaW5nIG9iamVjdCB3aGljaCBpcyBmbGFnZ2VkIGFzIHJlYWQtb25seS4gKi9cbiAgY29uc3QgYWZmaXJtTm90Uk8gPSBmdW5jdGlvbiAob3BOYW1lLCBmaCkge1xuICAgIGlmIChmaC5yZWFkT25seSkgdG9zcyhvcE5hbWUgKyAnKCk6IEZpbGUgaXMgcmVhZC1vbmx5OiAnICsgZmguZmlsZW5hbWVBYnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXZSB0cmFjayAyIGRpZmZlcmVudCB0aW1lcnM6IHRoZSBcIm1ldHJpY3NcIiB0aW1lciByZWNvcmRzIGhvdyBtdWNoXG4gICAqICAgICAgdGltZSB3ZSBzcGVuZCBwZXJmb3JtaW5nIHdvcmsuIFRoZSBcIndhaXRcIiB0aW1lciByZWNvcmRzIGhvdyBtdWNoXG4gICAqICAgICAgdGltZSB3ZSBzcGVuZCB3YWl0aW5nIG9uIHRoZSB1bmRlcmx5aW5nIE9QRlMgdGltZXIuIFNlZSB0aGUgY2FsbHNcbiAgICogICAgICB0byBtVGltZVN0YXJ0KCksIG1UaW1lRW5kKCksIHdUaW1lU3RhcnQoKSwgYW5kIHdUaW1lRW5kKClcbiAgICogICAgICB0aHJvdWdob3V0IHRoaXMgZmlsZSB0byBzZWUgaG93IHRoZXkncmUgdXNlZC5cbiAgICovXG4gIGNvbnN0IF9fbVRpbWVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX19tVGltZXIub3AgPSB1bmRlZmluZWQ7XG4gIF9fbVRpbWVyLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICBjb25zdCBtVGltZVN0YXJ0ID0gKG9wKSA9PiB7XG4gICAgX19tVGltZXIuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBfX21UaW1lci5vcCA9IG9wO1xuICAgIC8vbWV0cmljc1tvcF0gfHwgdG9zcyhcIk1haW50ZW5hbmNlIHJlcXVpcmVkOiBtaXNzaW5nIG1ldHJpY3MgZm9yXCIsb3ApO1xuICAgICsrbWV0cmljc1tvcF0uY291bnQ7XG4gIH07XG4gIGNvbnN0IG1UaW1lRW5kID0gKCkgPT5cbiAgICAobWV0cmljc1tfX21UaW1lci5vcF0udGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIF9fbVRpbWVyLnN0YXJ0KTtcbiAgY29uc3QgX193VGltZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBfX3dUaW1lci5vcCA9IHVuZGVmaW5lZDtcbiAgX193VGltZXIuc3RhcnQgPSB1bmRlZmluZWQ7XG4gIGNvbnN0IHdUaW1lU3RhcnQgPSAob3ApID0+IHtcbiAgICBfX3dUaW1lci5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIF9fd1RpbWVyLm9wID0gb3A7XG4gICAgLy9tZXRyaWNzW29wXSB8fCB0b3NzKFwiTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IG1pc3NpbmcgbWV0cmljcyBmb3JcIixvcCk7XG4gIH07XG4gIGNvbnN0IHdUaW1lRW5kID0gKCkgPT5cbiAgICAobWV0cmljc1tfX3dUaW1lci5vcF0ud2FpdCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIF9fd1RpbWVyLnN0YXJ0KTtcblxuICAvKipcbiAgICogR2V0cyBzZXQgdG8gdHJ1ZSBieSB0aGUgJ29wZnMtYXN5bmMtc2h1dGRvd24nIGNvbW1hbmQgdG8gcXVpdCB0aGVcbiAgICogICAgICB3YWl0IGxvb3AuIFRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzOiB3ZSBjYW5ub3RcbiAgICogICAgICBpbnNwZWN0IHRoaXMgZmlsZSdzIHN0YXRlIHdoaWxlIHRoZSB0aWdodCB3YWl0TG9vcCgpIGlzIHJ1bm5pbmcgYW5kXG4gICAqICAgICAgbmVlZCBhIHdheSB0byBzdG9wIHRoYXQgbG9vcCBmb3IgaW50cm9zcGVjdGlvbiBwdXJwb3Nlcy5cbiAgICovXG4gIGxldCBmbGFnQXN5bmNTaHV0ZG93biA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgd3JhcHBlcnMgZm9yIHNxbGl0ZTNfdmZzIGFuZCBzcWxpdGUzX2lvX21ldGhvZHNcbiAgICogICAgICBtZXRob2RzLCBhcyB3ZWxsIGFzIGhlbHBlcnMgbGlrZSBta2RpcigpLiBNYWludGVuYW5jZSByZW1pbmRlcjpcbiAgICogICAgICBtZW1iZXJzIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXIgdG8gc2ltcGxpZnkgZmluZGluZyB0aGVtLlxuICAgKi9cbiAgY29uc3QgdmZzQXN5bmNJbXBscyA9IHtcbiAgICAnb3Bmcy1hc3luYy1tZXRyaWNzJzogYXN5bmMgKCkgPT4ge1xuICAgICAgbVRpbWVTdGFydCgnb3Bmcy1hc3luYy1tZXRyaWNzJyk7XG4gICAgICBtZXRyaWNzLmR1bXAoKTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KCdvcGZzLWFzeW5jLW1ldHJpY3MnLCAwKTtcbiAgICAgIG1UaW1lRW5kKCk7XG4gICAgfSxcbiAgICAnb3Bmcy1hc3luYy1zaHV0ZG93bic6IGFzeW5jICgpID0+IHtcbiAgICAgIGZsYWdBc3luY1NodXRkb3duID0gdHJ1ZTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KCdvcGZzLWFzeW5jLXNodXRkb3duJywgMCk7XG4gICAgfSxcbiAgICBta2RpcjogYXN5bmMgKGRpcm5hbWUpID0+IHtcbiAgICAgIG1UaW1lU3RhcnQoJ21rZGlyJyk7XG4gICAgICBsZXQgcmMgPSAwO1xuICAgICAgd1RpbWVTdGFydCgnbWtkaXInKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdldERpckZvckZpbGVuYW1lKGRpcm5hbWUgKyAnL2ZpbGVwYXJ0JywgdHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMiwgZSk7XG4gICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd1RpbWVFbmQoKTtcbiAgICAgIH1cbiAgICAgIHN0b3JlQW5kTm90aWZ5KCdta2RpcicsIHJjKTtcbiAgICAgIG1UaW1lRW5kKCk7XG4gICAgfSxcbiAgICB4QWNjZXNzOiBhc3luYyAoZmlsZW5hbWUpID0+IHtcbiAgICAgIG1UaW1lU3RhcnQoJ3hBY2Nlc3MnKTtcbiAgICAgIC8qIE9QRlMgY2Fubm90IHN1cHBvcnQgdGhlIGZ1bGwgcmFuZ2Ugb2YgeEFjY2VzcygpIHF1ZXJpZXNcbiAgICAgICAgIHNxbGl0ZTMgY2FsbHMgZm9yLiBXZSBjYW4gZXNzZW50aWFsbHkganVzdCB0ZWxsIGlmIHRoZSBmaWxlXG4gICAgICAgICBpcyBhY2Nlc3NpYmxlLCBidXQgaWYgaXQgaXMgdGhlbiBpdCdzIGF1dG9tYXRpY2FsbHkgd3JpdGFibGVcbiAgICAgICAgICh1bmxlc3MgaXQncyBsb2NrZWQsIHdoaWNoIHdlIGNhbm5vdCg/KSBrbm93IHdpdGhvdXQgdHJ5aW5nXG4gICAgICAgICB0byBvcGVuIGl0KS4gT1BGUyBkb2VzIG5vdCBoYXZlIHRoZSBub3Rpb24gb2YgcmVhZC1vbmx5LlxuXG4gICAgICAgICBUaGUgcmV0dXJuIHNlbWFudGljcyBvZiB0aGlzIGZ1bmN0aW9uIGRpZmZlciBmcm9tIHNxbGl0ZTMnc1xuICAgICAgICAgeEFjY2VzcyBzZW1hbnRpY3MgYmVjYXVzZSB3ZSBhcmUgbGltaXRlZCBpbiB3aGF0IHdlIGNhblxuICAgICAgICAgY29tbXVuaWNhdGUgYmFjayB0byBvdXIgc3luY2hyb25vdXMgY29tbXVuaWNhdGlvbiBwYXJ0bmVyOiAwID1cbiAgICAgICAgIGFjY2Vzc2libGUsIG5vbi0wIG1lYW5zIG5vdCBhY2Nlc3NpYmxlLlxuICAgICAgKi9cbiAgICAgIGxldCByYyA9IDA7XG4gICAgICB3VGltZVN0YXJ0KCd4QWNjZXNzJyk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbZGgsIGZuXSA9IGF3YWl0IGdldERpckZvckZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMiwgZSk7XG4gICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd1RpbWVFbmQoKTtcbiAgICAgIH1cbiAgICAgIHN0b3JlQW5kTm90aWZ5KCd4QWNjZXNzJywgcmMpO1xuICAgICAgbVRpbWVFbmQoKTtcbiAgICB9LFxuICAgIHhDbG9zZTogYXN5bmMgZnVuY3Rpb24gKGZpZCAvKnNxbGl0ZTNfZmlsZSBwb2ludGVyKi8pIHtcbiAgICAgIGNvbnN0IG9wTmFtZSA9ICd4Q2xvc2UnO1xuICAgICAgbVRpbWVTdGFydChvcE5hbWUpO1xuICAgICAgX19pbXBsaWNpdExvY2tzLmRlbGV0ZShmaWQpO1xuICAgICAgY29uc3QgZmggPSBfX29wZW5GaWxlc1tmaWRdO1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIHdUaW1lU3RhcnQob3BOYW1lKTtcbiAgICAgIGlmIChmaCkge1xuICAgICAgICBkZWxldGUgX19vcGVuRmlsZXNbZmlkXTtcbiAgICAgICAgYXdhaXQgY2xvc2VTeW5jSGFuZGxlKGZoKTtcbiAgICAgICAgaWYgKGZoLmRlbGV0ZU9uQ2xvc2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZmguZGlySGFuZGxlLnJlbW92ZUVudHJ5KGZoLmZpbGVuYW1lUGFydCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgd2FybignSWdub3JpbmcgZGlySGFuZGxlLnJlbW92ZUVudHJ5KCkgZmFpbHVyZSBvZicsIGZoLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKCk7XG4gICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX05PVEZPVU5EO1xuICAgICAgfVxuICAgICAgd1RpbWVFbmQoKTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KG9wTmFtZSwgcmMpO1xuICAgICAgbVRpbWVFbmQoKTtcbiAgICB9LFxuICAgIHhEZWxldGU6IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBtVGltZVN0YXJ0KCd4RGVsZXRlJyk7XG4gICAgICBjb25zdCByYyA9IGF3YWl0IHZmc0FzeW5jSW1wbHMueERlbGV0ZU5vV2FpdCguLi5hcmdzKTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KCd4RGVsZXRlJywgcmMpO1xuICAgICAgbVRpbWVFbmQoKTtcbiAgICB9LFxuICAgIHhEZWxldGVOb1dhaXQ6IGFzeW5jIGZ1bmN0aW9uIChmaWxlbmFtZSwgc3luY0RpciA9IDAsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgICAvKiBUaGUgc3luY0RpciBmbGFnIGlzLCBmb3IgcHVycG9zZXMgb2YgdGhlIFZGUyBBUEkncyBzZW1hbnRpY3MsXG4gICAgICAgICBpZ25vcmVkIGhlcmUuIEhvd2V2ZXIsIGlmIGl0IGhhcyB0aGUgdmFsdWUgMHgxMjM0IHRoZW46IGFmdGVyXG4gICAgICAgICBkZWxldGluZyB0aGUgZ2l2ZW4gZmlsZSwgcmVjdXJzaXZlbHkgdHJ5IHRvIGRlbGV0ZSBhbnkgZW1wdHlcbiAgICAgICAgIGRpcmVjdG9yaWVzIGxlZnQgYmVoaW5kIGluIGl0cyB3YWtlIChpZ25vcmluZyBhbnkgZXJyb3JzIGFuZFxuICAgICAgICAgc3RvcHBpbmcgYXQgdGhlIGZpcnN0IGZhaWx1cmUpLlxuXG4gICAgICAgICBUaGF0IHNhaWQ6IHdlIGRvbid0IGtub3cgZm9yIHN1cmUgdGhhdCByZW1vdmVFbnRyeSgpIGZhaWxzIGlmXG4gICAgICAgICB0aGUgZGlyIGlzIG5vdCBlbXB0eSBiZWNhdXNlIHRoZSBBUEkgaXMgbm90IGRvY3VtZW50ZWQuIEl0IGhhcyxcbiAgICAgICAgIGhvd2V2ZXIsIGEgXCJyZWN1cnNpdmVcIiBmbGFnIHdoaWNoIGRlZmF1bHRzIHRvIGZhbHNlLCBzb1xuICAgICAgICAgcHJlc3VtYWJseSBpdCB3aWxsIGZhaWwgaWYgdGhlIGRpciBpcyBub3QgZW1wdHkgYW5kIHRoYXQgZmxhZ1xuICAgICAgICAgaXMgZmFsc2UuXG4gICAgICAqL1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIHdUaW1lU3RhcnQoJ3hEZWxldGUnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlIChmaWxlbmFtZSkge1xuICAgICAgICAgIGNvbnN0IFtoRGlyLCBmaWxlbmFtZVBhcnRdID0gYXdhaXQgZ2V0RGlyRm9yRmlsZW5hbWUoZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoIWZpbGVuYW1lUGFydCkgYnJlYWs7XG4gICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmaWxlbmFtZVBhcnQsIHsgcmVjdXJzaXZlIH0pO1xuICAgICAgICAgIGlmICgweDEyMzQgIT09IHN5bmNEaXIpIGJyZWFrO1xuICAgICAgICAgIHJlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgIGZpbGVuYW1lID0gZ2V0UmVzb2x2ZWRQYXRoKGZpbGVuYW1lLCB0cnVlKTtcbiAgICAgICAgICBmaWxlbmFtZS5wb3AoKTtcbiAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGF0ZS5zMTFuLnN0b3JlRXhjZXB0aW9uKDIsIGUpO1xuICAgICAgICByYyA9IHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUl9ERUxFVEU7XG4gICAgICB9XG4gICAgICB3VGltZUVuZCgpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH0sXG4gICAgeEZpbGVTaXplOiBhc3luYyBmdW5jdGlvbiAoZmlkIC8qc3FsaXRlM19maWxlIHBvaW50ZXIqLykge1xuICAgICAgbVRpbWVTdGFydCgneEZpbGVTaXplJyk7XG4gICAgICBjb25zdCBmaCA9IF9fb3BlbkZpbGVzW2ZpZF07XG4gICAgICBsZXQgcmMgPSAwO1xuICAgICAgd1RpbWVTdGFydCgneEZpbGVTaXplJyk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzeiA9IGF3YWl0IChhd2FpdCBnZXRTeW5jSGFuZGxlKGZoLCAneEZpbGVTaXplJykpLmdldFNpemUoKTtcbiAgICAgICAgc3RhdGUuczExbi5zZXJpYWxpemUoTnVtYmVyKHN6KSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgIHJjID0gR2V0U3luY0hhbmRsZUVycm9yLmNvbnZlcnRSYyhlLCBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlIpO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVsZWFzZUltcGxpY2l0TG9jayhmaCk7XG4gICAgICB3VGltZUVuZCgpO1xuICAgICAgc3RvcmVBbmROb3RpZnkoJ3hGaWxlU2l6ZScsIHJjKTtcbiAgICAgIG1UaW1lRW5kKCk7XG4gICAgfSxcbiAgICB4TG9jazogYXN5bmMgZnVuY3Rpb24gKFxuICAgICAgZmlkIC8qc3FsaXRlM19maWxlIHBvaW50ZXIqLyxcbiAgICAgIGxvY2tUeXBlIC8qU1FMSVRFX0xPQ0tfLi4uKi8sXG4gICAgKSB7XG4gICAgICBtVGltZVN0YXJ0KCd4TG9jaycpO1xuICAgICAgY29uc3QgZmggPSBfX29wZW5GaWxlc1tmaWRdO1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIGNvbnN0IG9sZExvY2tUeXBlID0gZmgueExvY2s7XG4gICAgICBmaC54TG9jayA9IGxvY2tUeXBlO1xuICAgICAgaWYgKCFmaC5zeW5jSGFuZGxlKSB7XG4gICAgICAgIHdUaW1lU3RhcnQoJ3hMb2NrJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZ2V0U3luY0hhbmRsZShmaCwgJ3hMb2NrJyk7XG4gICAgICAgICAgX19pbXBsaWNpdExvY2tzLmRlbGV0ZShmaWQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc3RhdGUuczExbi5zdG9yZUV4Y2VwdGlvbigxLCBlKTtcbiAgICAgICAgICByYyA9IEdldFN5bmNIYW5kbGVFcnJvci5jb252ZXJ0UmMoXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX0xPQ0ssXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmaC54TG9jayA9IG9sZExvY2tUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHdUaW1lRW5kKCk7XG4gICAgICB9XG4gICAgICBzdG9yZUFuZE5vdGlmeSgneExvY2snLCByYyk7XG4gICAgICBtVGltZUVuZCgpO1xuICAgIH0sXG4gICAgeE9wZW46IGFzeW5jIGZ1bmN0aW9uIChcbiAgICAgIGZpZCAvKnNxbGl0ZTNfZmlsZSBwb2ludGVyKi8sXG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGZsYWdzIC8qU1FMSVRFX09QRU5fLi4uKi8sXG4gICAgICBvcGZzRmxhZ3MgLypPUEZTXy4uLiovLFxuICAgICkge1xuICAgICAgY29uc3Qgb3BOYW1lID0gJ3hPcGVuJztcbiAgICAgIG1UaW1lU3RhcnQob3BOYW1lKTtcbiAgICAgIGNvbnN0IGNyZWF0ZSA9IHN0YXRlLnNxM0NvZGVzLlNRTElURV9PUEVOX0NSRUFURSAmIGZsYWdzO1xuICAgICAgd1RpbWVTdGFydCgneE9wZW4nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBoRGlyLCBmaWxlbmFtZVBhcnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgW2hEaXIsIGZpbGVuYW1lUGFydF0gPSBhd2FpdCBnZXREaXJGb3JGaWxlbmFtZShmaWxlbmFtZSwgISFjcmVhdGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc3RhdGUuczExbi5zdG9yZUV4Y2VwdGlvbigxLCBlKTtcbiAgICAgICAgICBzdG9yZUFuZE5vdGlmeShvcE5hbWUsIHN0YXRlLnNxM0NvZGVzLlNRTElURV9OT1RGT1VORCk7XG4gICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICB3VGltZUVuZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoRmlsZSA9IGF3YWl0IGhEaXIuZ2V0RmlsZUhhbmRsZShmaWxlbmFtZVBhcnQsIHsgY3JlYXRlIH0pO1xuICAgICAgICB3VGltZUVuZCgpO1xuICAgICAgICBjb25zdCBmaCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgIGZpZDogZmlkLFxuICAgICAgICAgIGZpbGVuYW1lQWJzOiBmaWxlbmFtZSxcbiAgICAgICAgICBmaWxlbmFtZVBhcnQ6IGZpbGVuYW1lUGFydCxcbiAgICAgICAgICBkaXJIYW5kbGU6IGhEaXIsXG4gICAgICAgICAgZmlsZUhhbmRsZTogaEZpbGUsXG4gICAgICAgICAgc2FiVmlldzogc3RhdGUuc2FiRmlsZUJ1ZlZpZXcsXG4gICAgICAgICAgcmVhZE9ubHk6IGNyZWF0ZVxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfT1BFTl9SRUFET05MWSAmIGZsYWdzLFxuICAgICAgICAgIGRlbGV0ZU9uQ2xvc2U6ICEhKHN0YXRlLnNxM0NvZGVzLlNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UgJiBmbGFncyksXG4gICAgICAgIH0pO1xuICAgICAgICBmaC5yZWxlYXNlSW1wbGljaXRMb2NrcyA9XG4gICAgICAgICAgb3Bmc0ZsYWdzICYgc3RhdGUub3Bmc0ZsYWdzLk9QRlNfVU5MT0NLX0FTQVAgfHxcbiAgICAgICAgICBzdGF0ZS5vcGZzRmxhZ3MuZGVmYXVsdFVubG9ja0FzYXA7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAwIC8qIHRoaXMgYmxvY2sgaXMgbW9kZWxsZWQgYWZ0ZXIgc29tZXRoaW5nIHdhLXNxbGl0ZVxuICAgICAgICAgICAgICAgIGRvZXMgYnV0IGl0IGxlYWRzIHRvIGltbWVkaWF0ZSBjb250ZW50aW9uIG9uIGpvdXJuYWwgZmlsZXMuXG4gICAgICAgICAgICAgICAgVXBkYXRlOiB0aGlzIGFwcHJvYWNoIHJlcG9ydGVkbHkgb25seSB3b3JrcyBmb3IgREVMRVRFIGpvdXJuYWxcbiAgICAgICAgICAgICAgICBtb2RlLiAqLyAmJlxuICAgICAgICAgIDAgPT09IChmbGFncyAmIHN0YXRlLnNxM0NvZGVzLlNRTElURV9PUEVOX01BSU5fREIpXG4gICAgICAgICkge1xuICAgICAgICAgIC8qIHNxbGl0ZSBkb2VzIG5vdCBsb2NrIHRoZXNlIGZpbGVzLCBzbyBnbyBhaGVhZCBhbmQgZ3JhYiBhbiBPUEZTXG4gICAgICAgICAgICAgbG9jay4gKi9cbiAgICAgICAgICBmaC54TG9jayA9ICd4T3BlbicgLyogVHJ1dGh5IHZhbHVlIHRvIGtlZXAgZW50cnkgZnJvbSBnZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ2dlZCBhcyBhdXRvLWxvY2tlZC4gU3RyaW5nIHZhbHVlIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB3ZSBjYW4gZWFzaWx5IGRpc3Rpbmd1aXNoIGlzIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbmVlZGVkLiAqLztcbiAgICAgICAgICBhd2FpdCBnZXRTeW5jSGFuZGxlKGZoLCAneE9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBfX29wZW5GaWxlc1tmaWRdID0gZmg7XG4gICAgICAgIHN0b3JlQW5kTm90aWZ5KG9wTmFtZSwgMCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdUaW1lRW5kKCk7XG4gICAgICAgIGVycm9yKG9wTmFtZSwgZSk7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgIHN0b3JlQW5kTm90aWZ5KG9wTmFtZSwgc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSKTtcbiAgICAgIH1cbiAgICAgIG1UaW1lRW5kKCk7XG4gICAgfSxcbiAgICB4UmVhZDogYXN5bmMgZnVuY3Rpb24gKGZpZCAvKnNxbGl0ZTNfZmlsZSBwb2ludGVyKi8sIG4sIG9mZnNldDY0KSB7XG4gICAgICBtVGltZVN0YXJ0KCd4UmVhZCcpO1xuICAgICAgbGV0IHJjID0gMCxcbiAgICAgICAgblJlYWQ7XG4gICAgICBjb25zdCBmaCA9IF9fb3BlbkZpbGVzW2ZpZF07XG4gICAgICB0cnkge1xuICAgICAgICB3VGltZVN0YXJ0KCd4UmVhZCcpO1xuICAgICAgICBuUmVhZCA9IChhd2FpdCBnZXRTeW5jSGFuZGxlKGZoLCAneFJlYWQnKSkucmVhZChcbiAgICAgICAgICBmaC5zYWJWaWV3LnN1YmFycmF5KDAsIG4pLFxuICAgICAgICAgIHsgYXQ6IE51bWJlcihvZmZzZXQ2NCkgfSxcbiAgICAgICAgKTtcbiAgICAgICAgd1RpbWVFbmQoKTtcbiAgICAgICAgaWYgKG5SZWFkIDwgbikge1xuICAgICAgICAgIC8qIFplcm8tZmlsbCByZW1haW5pbmcgYnl0ZXMgKi9cbiAgICAgICAgICBmaC5zYWJWaWV3LmZpbGwoMCwgblJlYWQsIG4pO1xuICAgICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX1NIT1JUX1JFQUQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gblJlYWQpIHdUaW1lRW5kKCk7XG4gICAgICAgIGVycm9yKCd4UmVhZCgpIGZhaWxlZCcsIGUsIGZoKTtcbiAgICAgICAgc3RhdGUuczExbi5zdG9yZUV4Y2VwdGlvbigxLCBlKTtcbiAgICAgICAgcmMgPSBHZXRTeW5jSGFuZGxlRXJyb3IuY29udmVydFJjKGUsIHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUl9SRUFEKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlbGVhc2VJbXBsaWNpdExvY2soZmgpO1xuICAgICAgc3RvcmVBbmROb3RpZnkoJ3hSZWFkJywgcmMpO1xuICAgICAgbVRpbWVFbmQoKTtcbiAgICB9LFxuICAgIHhTeW5jOiBhc3luYyBmdW5jdGlvbiAoZmlkIC8qc3FsaXRlM19maWxlIHBvaW50ZXIqLywgZmxhZ3MgLyppZ25vcmVkKi8pIHtcbiAgICAgIG1UaW1lU3RhcnQoJ3hTeW5jJyk7XG4gICAgICBjb25zdCBmaCA9IF9fb3BlbkZpbGVzW2ZpZF07XG4gICAgICBsZXQgcmMgPSAwO1xuICAgICAgaWYgKCFmaC5yZWFkT25seSAmJiBmaC5zeW5jSGFuZGxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd1RpbWVTdGFydCgneFN5bmMnKTtcbiAgICAgICAgICBhd2FpdCBmaC5zeW5jSGFuZGxlLmZsdXNoKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdGF0ZS5zMTFuLnN0b3JlRXhjZXB0aW9uKDIsIGUpO1xuICAgICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX0ZTWU5DO1xuICAgICAgICB9XG4gICAgICAgIHdUaW1lRW5kKCk7XG4gICAgICB9XG4gICAgICBzdG9yZUFuZE5vdGlmeSgneFN5bmMnLCByYyk7XG4gICAgICBtVGltZUVuZCgpO1xuICAgIH0sXG4gICAgeFRydW5jYXRlOiBhc3luYyBmdW5jdGlvbiAoZmlkIC8qc3FsaXRlM19maWxlIHBvaW50ZXIqLywgc2l6ZSkge1xuICAgICAgbVRpbWVTdGFydCgneFRydW5jYXRlJyk7XG4gICAgICBsZXQgcmMgPSAwO1xuICAgICAgY29uc3QgZmggPSBfX29wZW5GaWxlc1tmaWRdO1xuICAgICAgd1RpbWVTdGFydCgneFRydW5jYXRlJyk7XG4gICAgICB0cnkge1xuICAgICAgICBhZmZpcm1Ob3RSTygneFRydW5jYXRlJywgZmgpO1xuICAgICAgICBhd2FpdCAoYXdhaXQgZ2V0U3luY0hhbmRsZShmaCwgJ3hUcnVuY2F0ZScpKS50cnVuY2F0ZShzaXplKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoJ3hUcnVuY2F0ZSgpOicsIGUsIGZoKTtcbiAgICAgICAgc3RhdGUuczExbi5zdG9yZUV4Y2VwdGlvbigyLCBlKTtcbiAgICAgICAgcmMgPSBHZXRTeW5jSGFuZGxlRXJyb3IuY29udmVydFJjKFxuICAgICAgICAgIGUsXG4gICAgICAgICAgc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX1RSVU5DQVRFLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVsZWFzZUltcGxpY2l0TG9jayhmaCk7XG4gICAgICB3VGltZUVuZCgpO1xuICAgICAgc3RvcmVBbmROb3RpZnkoJ3hUcnVuY2F0ZScsIHJjKTtcbiAgICAgIG1UaW1lRW5kKCk7XG4gICAgfSxcbiAgICB4VW5sb2NrOiBhc3luYyBmdW5jdGlvbiAoXG4gICAgICBmaWQgLypzcWxpdGUzX2ZpbGUgcG9pbnRlciovLFxuICAgICAgbG9ja1R5cGUgLypTUUxJVEVfTE9DS18uLi4qLyxcbiAgICApIHtcbiAgICAgIG1UaW1lU3RhcnQoJ3hVbmxvY2snKTtcbiAgICAgIGxldCByYyA9IDA7XG4gICAgICBjb25zdCBmaCA9IF9fb3BlbkZpbGVzW2ZpZF07XG4gICAgICBpZiAoc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0xPQ0tfTk9ORSA9PT0gbG9ja1R5cGUgJiYgZmguc3luY0hhbmRsZSkge1xuICAgICAgICB3VGltZVN0YXJ0KCd4VW5sb2NrJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgY2xvc2VTeW5jSGFuZGxlKGZoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgICAgcmMgPSBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlJfVU5MT0NLO1xuICAgICAgICB9XG4gICAgICAgIHdUaW1lRW5kKCk7XG4gICAgICB9XG4gICAgICBzdG9yZUFuZE5vdGlmeSgneFVubG9jaycsIHJjKTtcbiAgICAgIG1UaW1lRW5kKCk7XG4gICAgfSxcbiAgICB4V3JpdGU6IGFzeW5jIGZ1bmN0aW9uIChmaWQgLypzcWxpdGUzX2ZpbGUgcG9pbnRlciovLCBuLCBvZmZzZXQ2NCkge1xuICAgICAgbVRpbWVTdGFydCgneFdyaXRlJyk7XG4gICAgICBsZXQgcmM7XG4gICAgICBjb25zdCBmaCA9IF9fb3BlbkZpbGVzW2ZpZF07XG4gICAgICB3VGltZVN0YXJ0KCd4V3JpdGUnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFmZmlybU5vdFJPKCd4V3JpdGUnLCBmaCk7XG4gICAgICAgIHJjID1cbiAgICAgICAgICBuID09PVxuICAgICAgICAgIChhd2FpdCBnZXRTeW5jSGFuZGxlKGZoLCAneFdyaXRlJykpLndyaXRlKGZoLnNhYlZpZXcuc3ViYXJyYXkoMCwgbiksIHtcbiAgICAgICAgICAgIGF0OiBOdW1iZXIob2Zmc2V0NjQpLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX1dSSVRFO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcigneFdyaXRlKCk6JywgZSwgZmgpO1xuICAgICAgICBzdGF0ZS5zMTFuLnN0b3JlRXhjZXB0aW9uKDEsIGUpO1xuICAgICAgICByYyA9IEdldFN5bmNIYW5kbGVFcnJvci5jb252ZXJ0UmMoZSwgc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX1dSSVRFKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlbGVhc2VJbXBsaWNpdExvY2soZmgpO1xuICAgICAgd1RpbWVFbmQoKTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KCd4V3JpdGUnLCByYyk7XG4gICAgICBtVGltZUVuZCgpO1xuICAgIH0sXG4gIH07IC8qdmZzQXN5bmNJbXBscyovXG5cbiAgY29uc3QgaW5pdFMxMW4gPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogQUNIVFVORzogdGhpcyBjb2RlIGlzIDEwMCUgZHVwbGljYXRlZCBpbiB0aGUgb3RoZXIgaGFsZiBvZiB0aGlzXG4gICAgICogICAgICAgIHByb3h5ISBUaGUgZG9jdW1lbnRhdGlvbiBpcyBtYWludGFpbmVkIGluIHRoZSBcInN5bmNocm9ub3VzIGhhbGZcIi5cbiAgICAgKi9cbiAgICBpZiAoc3RhdGUuczExbikgcmV0dXJuIHN0YXRlLnMxMW47XG4gICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKSxcbiAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLFxuICAgICAgdmlld1U4ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIHN0YXRlLnNhYklPLFxuICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICBzdGF0ZS5zYWJTMTFuU2l6ZSxcbiAgICAgICksXG4gICAgICB2aWV3RFYgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgIHN0YXRlLnNhYklPLFxuICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICBzdGF0ZS5zYWJTMTFuU2l6ZSxcbiAgICAgICk7XG4gICAgc3RhdGUuczExbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgVHlwZUlkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgVHlwZUlkcy5udW1iZXIgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIHNpemU6IDgsXG4gICAgICBnZXR0ZXI6ICdnZXRGbG9hdDY0JyxcbiAgICAgIHNldHRlcjogJ3NldEZsb2F0NjQnLFxuICAgIH07XG4gICAgVHlwZUlkcy5iaWdpbnQgPSB7XG4gICAgICBpZDogMixcbiAgICAgIHNpemU6IDgsXG4gICAgICBnZXR0ZXI6ICdnZXRCaWdJbnQ2NCcsXG4gICAgICBzZXR0ZXI6ICdzZXRCaWdJbnQ2NCcsXG4gICAgfTtcbiAgICBUeXBlSWRzLmJvb2xlYW4gPSB7XG4gICAgICBpZDogMyxcbiAgICAgIHNpemU6IDQsXG4gICAgICBnZXR0ZXI6ICdnZXRJbnQzMicsXG4gICAgICBzZXR0ZXI6ICdzZXRJbnQzMicsXG4gICAgfTtcbiAgICBUeXBlSWRzLnN0cmluZyA9IHsgaWQ6IDQgfTtcbiAgICBjb25zdCBnZXRUeXBlSWQgPSAodikgPT5cbiAgICAgIFR5cGVJZHNbdHlwZW9mIHZdIHx8XG4gICAgICB0b3NzKCdNYWludGVuYW5jZSByZXF1aXJlZDogdGhpcyB2YWx1ZSB0eXBlIGNhbm5vdCBiZSBzZXJpYWxpemVkLicsIHYpO1xuICAgIGNvbnN0IGdldFR5cGVJZEJ5SWQgPSAodGlkKSA9PiB7XG4gICAgICBzd2l0Y2ggKHRpZCkge1xuICAgICAgICBjYXNlIFR5cGVJZHMubnVtYmVyLmlkOlxuICAgICAgICAgIHJldHVybiBUeXBlSWRzLm51bWJlcjtcbiAgICAgICAgY2FzZSBUeXBlSWRzLmJpZ2ludC5pZDpcbiAgICAgICAgICByZXR1cm4gVHlwZUlkcy5iaWdpbnQ7XG4gICAgICAgIGNhc2UgVHlwZUlkcy5ib29sZWFuLmlkOlxuICAgICAgICAgIHJldHVybiBUeXBlSWRzLmJvb2xlYW47XG4gICAgICAgIGNhc2UgVHlwZUlkcy5zdHJpbmcuaWQ6XG4gICAgICAgICAgcmV0dXJuIFR5cGVJZHMuc3RyaW5nO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdHlwZSBJRDonLCB0aWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgc3RhdGUuczExbi5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChjbGVhciA9IGZhbHNlKSB7XG4gICAgICArK21ldHJpY3MuczExbi5kZXNlcmlhbGl6ZS5jb3VudDtcbiAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGFyZ2MgPSB2aWV3VThbMF07XG4gICAgICBjb25zdCByYyA9IGFyZ2MgPyBbXSA6IG51bGw7XG4gICAgICBpZiAoYXJnYykge1xuICAgICAgICBjb25zdCB0eXBlSWRzID0gW107XG4gICAgICAgIGxldCBvZmZzZXQgPSAxLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbixcbiAgICAgICAgICB2O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgKytpLCArK29mZnNldCkge1xuICAgICAgICAgIHR5cGVJZHMucHVzaChnZXRUeXBlSWRCeUlkKHZpZXdVOFtvZmZzZXRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHQgPSB0eXBlSWRzW2ldO1xuICAgICAgICAgIGlmICh0LmdldHRlcikge1xuICAgICAgICAgICAgdiA9IHZpZXdEVlt0LmdldHRlcl0ob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHQuc2l6ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLypTdHJpbmcqL1xuICAgICAgICAgICAgbiA9IHZpZXdEVi5nZXRJbnQzMihvZmZzZXQsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHYgPSB0ZXh0RGVjb2Rlci5kZWNvZGUodmlld1U4LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJjLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjbGVhcikgdmlld1U4WzBdID0gMDtcbiAgICAgIC8vbG9nKFwiZGVzZXJpYWxpemU6XCIsYXJnYywgcmMpO1xuICAgICAgbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH07XG4gICAgc3RhdGUuczExbi5zZXJpYWxpemUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgKyttZXRyaWNzLnMxMW4uc2VyaWFsaXplLmNvdW50O1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIC8vbG9nKFwic2VyaWFsaXplKCk6XCIsYXJncyk7XG4gICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgIHZpZXdVOFswXSA9IGFyZ3MubGVuZ3RoICYgMHhmZiAvKiBoZWFkZXIgPSAjIG9mIGFyZ3MgKi87XG4gICAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7ICsraSwgKytvZmZzZXQpIHtcbiAgICAgICAgICAvKiBXcml0ZSB0aGUgVHlwZUlkcy5pZCB2YWx1ZSBpbnRvIHRoZSBuZXh0IGFyZ3MubGVuZ3RoXG4gICAgICAgICAgICAgYnl0ZXMuICovXG4gICAgICAgICAgdHlwZUlkcy5wdXNoKGdldFR5cGVJZChhcmdzW2ldKSk7XG4gICAgICAgICAgdmlld1U4W29mZnNldF0gPSB0eXBlSWRzW2ldLmlkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgLyogRGVzZXJpYWxpemUgdGhlIGZvbGxvd2luZyBieXRlcyBiYXNlZCBvbiB0aGVpclxuICAgICAgICAgICAgIGNvcnJlc3BvbmRpbmcgVHlwZUlkcy5pZCBmcm9tIHRoZSBoZWFkZXIuICovXG4gICAgICAgICAgY29uc3QgdCA9IHR5cGVJZHNbaV07XG4gICAgICAgICAgaWYgKHQuc2V0dGVyKSB7XG4gICAgICAgICAgICB2aWV3RFZbdC5zZXR0ZXJdKG9mZnNldCwgYXJnc1tpXSwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0LnNpemU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qU3RyaW5nKi9cbiAgICAgICAgICAgIGNvbnN0IHMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYXJnc1tpXSk7XG4gICAgICAgICAgICB2aWV3RFYuc2V0SW50MzIob2Zmc2V0LCBzLmJ5dGVMZW5ndGgsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZpZXdVOC5zZXQocywgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vbG9nKFwic2VyaWFsaXplKCkgcmVzdWx0OlwiLHZpZXdVOC5zbGljZSgwLG9mZnNldCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld1U4WzBdID0gMDtcbiAgICAgIH1cbiAgICAgIG1ldHJpY3MuczExbi5zZXJpYWxpemUudGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgfTtcblxuICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24gPSBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zXG4gICAgICA/IChwcmlvcml0eSwgZSkgPT4ge1xuICAgICAgICAgIGlmIChwcmlvcml0eSA8PSBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZShbZS5uYW1lLCAnOiAnLCBlLm1lc3NhZ2VdLmpvaW4oJycpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogKCkgPT4ge307XG5cbiAgICByZXR1cm4gc3RhdGUuczExbjtcbiAgfTsgLyppbml0UzExbigpKi9cblxuICBjb25zdCB3YWl0TG9vcCA9IGFzeW5jIGZ1bmN0aW9uIGYoKSB7XG4gICAgY29uc3Qgb3BIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgayBvZiBPYmplY3Qua2V5cyhzdGF0ZS5vcElkcykpIHtcbiAgICAgIGNvbnN0IHZpID0gdmZzQXN5bmNJbXBsc1trXTtcbiAgICAgIGlmICghdmkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcEhhbmRsZXJzW3N0YXRlLm9wSWRzW2tdXSA9IG87XG4gICAgICBvLmtleSA9IGs7XG4gICAgICBvLmYgPSB2aTtcbiAgICB9XG4gICAgd2hpbGUgKCFmbGFnQXN5bmNTaHV0ZG93bikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICdub3QtZXF1YWwnICE9PVxuICAgICAgICAgIEF0b21pY3Mud2FpdChcbiAgICAgICAgICAgIHN0YXRlLnNhYk9QVmlldyxcbiAgICAgICAgICAgIHN0YXRlLm9wSWRzLndoaWNoT3AsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgc3RhdGUuYXN5bmNJZGxlV2FpdFRpbWUsXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAvKiBNYWludGVuYW5jZSBub3RlOiB3ZSBjb21wYXJlIGFnYWluc3QgJ25vdC1lcXVhbCcgYmVjYXVzZVxuXG4gICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3RvbWF5YWMvc3FsaXRlLXdhc20vaXNzdWVzLzEyXG5cbiAgICAgICAgICAgICBpcyByZXBvcnRpbmcgdGhhdCB0aGlzIG9jY2Fzc2lvbmFsbHksIHVuZGVyIGhpZ2ggbG9hZHMsXG4gICAgICAgICAgICAgcmV0dXJucyAnb2snLCB3aGljaCBsZWFkcyB0byB0aGUgd2hpY2hPcCBiZWluZyAwICh3aGljaFxuICAgICAgICAgICAgIGlzbid0IGEgdmFsaWQgb3BlcmF0aW9uIElEIGFuZCBsZWFkcyB0byBhbiBleGNlcHRpb24sXG4gICAgICAgICAgICAgYWxvbmcgd2l0aCBhIGNvcnJlc3BvbmRpbmcgdWdseSBjb25zb2xlIGxvZ1xuICAgICAgICAgICAgIG1lc3NhZ2UpLiBVbmZvcnR1bmF0ZWx5LCB0aGUgY29uZGl0aW9ucyBmb3IgdGhhdCBjYW5ub3RcbiAgICAgICAgICAgICBiZSByZWxpYWJseSByZXByb2R1Y2VkLiBUaGUgb25seSBwbGFjZSBpbiBvdXIgY29kZSB3aGljaFxuICAgICAgICAgICAgIHdyaXRlcyBhIDAgdG8gdGhlIHN0YXRlLm9wSWRzLndoaWNoT3AgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICAgICBpbmRleCBpcyBhIGZldyBsaW5lcyBkb3duIGZyb20gaGVyZSwgYW5kIHRoYXQgaW5zdGFuY2VcbiAgICAgICAgICAgICBpcyByZXF1aXJlZCBpbiBvcmRlciBmb3IgY2xlYXIgY29tbXVuaWNhdGlvbiBiZXR3ZWVuXG4gICAgICAgICAgICAgdGhlIHN5bmMgaGFsZiBvZiB0aGlzIHByb3h5IGFuZCB0aGlzIGhhbGYuXG4gICAgICAgICAgKi9cbiAgICAgICAgICBhd2FpdCByZWxlYXNlSW1wbGljaXRMb2NrcygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wSWQgPSBBdG9taWNzLmxvYWQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy53aGljaE9wKTtcbiAgICAgICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3AsIDApO1xuICAgICAgICBjb25zdCBobmQgPVxuICAgICAgICAgIG9wSGFuZGxlcnNbb3BJZF0gPz8gdG9zcygnTm8gd2FpdExvb3AgaGFuZGxlciBmb3Igd2hpY2hPcCAjJywgb3BJZCk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPVxuICAgICAgICAgIHN0YXRlLnMxMW4uZGVzZXJpYWxpemUoXG4gICAgICAgICAgICB0cnVlIC8qIGNsZWFyIHMxMW4gdG8ga2VlcCB0aGUgY2FsbGVyIGZyb20gY29uZnVzaW5nIHRoaXMgd2l0aFxuICAgICAgICAgICAgICAgICAgYW4gZXhjZXB0aW9uIHN0cmluZyB3cml0dGVuIGJ5IHRoZSB1cGNvbWluZ1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uICovLFxuICAgICAgICAgICkgfHwgW107XG4gICAgICAgIC8vd2FybihcIndhaXRMb29wKCkgd2hpY2hPcCA9XCIsb3BJZCwgaG5kLCBhcmdzKTtcbiAgICAgICAgaWYgKGhuZC5mKSBhd2FpdCBobmQuZiguLi5hcmdzKTtcbiAgICAgICAgZWxzZSBlcnJvcignTWlzc2luZyBjYWxsYmFjayBmb3Igb3BJZCcsIG9wSWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignaW4gd2FpdExvb3AoKTonLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbmF2aWdhdG9yLnN0b3JhZ2VcbiAgICAuZ2V0RGlyZWN0b3J5KClcbiAgICAudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgc3RhdGUucm9vdERpciA9IGQ7XG4gICAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICh7IGRhdGEgfSkge1xuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtaW5pdCc6IHtcbiAgICAgICAgICAgIC8qIFJlY2VpdmUgc2hhcmVkIHN0YXRlIGZyb20gc3luY2hyb25vdXMgcGFydG5lciAqL1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gZGF0YS5hcmdzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIG9wdCkgc3RhdGVba10gPSBvcHRba107XG4gICAgICAgICAgICBzdGF0ZS52ZXJib3NlID0gb3B0LnZlcmJvc2UgPz8gMTtcbiAgICAgICAgICAgIHN0YXRlLnNhYk9QVmlldyA9IG5ldyBJbnQzMkFycmF5KHN0YXRlLnNhYk9QKTtcbiAgICAgICAgICAgIHN0YXRlLnNhYkZpbGVCdWZWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgIHN0YXRlLnNhYklPLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdGF0ZS5zYWJTMTFuVmlldyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgc3RhdGUuc2FiUzExbk9mZnNldCxcbiAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblNpemUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmZzQXN5bmNJbXBscykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGF0ZS5vcElkc1trXSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzKCdNYWludGVuYW5jZSByZXF1aXJlZDogbWlzc2luZyBzdGF0ZS5vcElkc1snLCBrLCAnXScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluaXRTMTFuKCk7XG4gICAgICAgICAgICBtZXRyaWNzLnJlc2V0KCk7XG4gICAgICAgICAgICBsb2coJ2luaXQgc3RhdGUnLCBzdGF0ZSk7XG4gICAgICAgICAgICB3UG9zdCgnb3Bmcy1hc3luYy1pbml0ZWQnKTtcbiAgICAgICAgICAgIHdhaXRMb29wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnb3Bmcy1hc3luYy1yZXN0YXJ0JzpcbiAgICAgICAgICAgIGlmIChmbGFnQXN5bmNTaHV0ZG93bikge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdSZXN0YXJ0aW5nIGFmdGVyIG9wZnMtYXN5bmMtc2h1dGRvd24uIE1pZ2h0IG9yIG1pZ2h0IG5vdCB3b3JrLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdBc3luY1NodXRkb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgIHdhaXRMb29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvcGZzLWFzeW5jLW1ldHJpY3MnOlxuICAgICAgICAgICAgbWV0cmljcy5kdW1wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdQb3N0KCdvcGZzLWFzeW5jLWxvYWRlZCcpO1xuICAgIH0pXG4gICAgLmNhdGNoKChlKSA9PiBlcnJvcignZXJyb3IgaW5pdGlhbGl6aW5nIE9QRlMgYXN5bmNlcjonLCBlKSk7XG59OyAvKmluc3RhbGxBc3luY1Byb3h5KCkqL1xuaWYgKCFnbG9iYWxUaGlzLlNoYXJlZEFycmF5QnVmZmVyKSB7XG4gIHdQb3N0KFxuICAgICdvcGZzLXVuYXZhaWxhYmxlJyxcbiAgICAnTWlzc2luZyBTaGFyZWRBcnJheUJ1ZmZlciBBUEkuJyxcbiAgICAnVGhlIHNlcnZlciBtdXN0IGVtaXQgdGhlIENPT1AvQ09FUCByZXNwb25zZSBoZWFkZXJzIHRvIGVuYWJsZSB0aGF0LicsXG4gICk7XG59IGVsc2UgaWYgKCFnbG9iYWxUaGlzLkF0b21pY3MpIHtcbiAgd1Bvc3QoXG4gICAgJ29wZnMtdW5hdmFpbGFibGUnLFxuICAgICdNaXNzaW5nIEF0b21pY3MgQVBJLicsXG4gICAgJ1RoZSBzZXJ2ZXIgbXVzdCBlbWl0IHRoZSBDT09QL0NPRVAgcmVzcG9uc2UgaGVhZGVycyB0byBlbmFibGUgdGhhdC4nLFxuICApO1xufSBlbHNlIGlmIChcbiAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSB8fFxuICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlIHx8XG4gICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlIHx8XG4gICFuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeVxuKSB7XG4gIHdQb3N0KCdvcGZzLXVuYXZhaWxhYmxlJywgJ01pc3NpbmcgcmVxdWlyZWQgT1BGUyBBUElzLicpO1xufSBlbHNlIHtcbiAgaW5zdGFsbEFzeW5jUHJveHkoc2VsZik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=